/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 232);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/graphql/polyfills/objectEntries.mjs
var objectEntries = __webpack_require__(37);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/inspect.mjs
var inspect = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/keyMap.mjs
var keyMap = __webpack_require__(22);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/mapValue.mjs
var mapValue = __webpack_require__(43);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/toObjMap.mjs
var toObjMap = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/devAssert.mjs
var devAssert = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/keyValMap.mjs
var keyValMap = __webpack_require__(20);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf = __webpack_require__(40);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/isObjectLike.mjs
var isObjectLike = __webpack_require__(18);

// CONCATENATED MODULE: ./node_modules/graphql/jsutils/identityFunc.mjs
/**
 * Returns the first argument it receives.
 */
function identityFunc(x) {
  return x;
}

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/defineToJSON.mjs
var defineToJSON = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/defineToStringTag.mjs
var defineToStringTag = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/graphql/language/kinds.mjs
var kinds = __webpack_require__(2);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/valueFromASTUntyped.mjs
var valueFromASTUntyped = __webpack_require__(72);

// CONCATENATED MODULE: ./node_modules/graphql/type/definition.mjs
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "S", function() { return isType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return assertType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "R", function() { return isScalarType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return assertScalarType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "N", function() { return isObjectType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return assertObjectType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return isInterfaceType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return assertInterfaceType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "T", function() { return isUnionType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return assertUnionType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return isEnumType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return assertEnumType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return isInputObjectType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return assertInputObjectType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "J", function() { return isListType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return assertListType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "L", function() { return isNonNullType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return assertNonNullType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return isInputType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return assertInputType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "O", function() { return isOutputType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return assertOutputType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return isLeafType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return assertLeafType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return isCompositeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return assertCompositeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return isAbstractType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return assertAbstractType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return GraphQLList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return GraphQLNonNull; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "U", function() { return isWrappingType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return assertWrappingType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "M", function() { return isNullableType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return assertNullableType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return getNullableType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "K", function() { return isNamedType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return assertNamedType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return getNamedType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return definition_GraphQLScalarType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return definition_GraphQLObjectType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return argsToArgsConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "P", function() { return isRequiredArgument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return definition_GraphQLInterfaceType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return definition_GraphQLUnionType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return definition_GraphQLEnumType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return definition_GraphQLInputObjectType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Q", function() { return isRequiredInputField; });
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }















function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function assertType(type) {
  if (!isType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL type."));
  }

  return type;
}
/**
 * There are predicates for each kind of GraphQL type.
 */

// eslint-disable-next-line no-redeclare
function isScalarType(type) {
  return Object(instanceOf["a" /* default */])(type, definition_GraphQLScalarType);
}
function assertScalarType(type) {
  if (!isScalarType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL Scalar type."));
  }

  return type;
}
// eslint-disable-next-line no-redeclare
function isObjectType(type) {
  return Object(instanceOf["a" /* default */])(type, definition_GraphQLObjectType);
}
function assertObjectType(type) {
  if (!isObjectType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL Object type."));
  }

  return type;
}
// eslint-disable-next-line no-redeclare
function isInterfaceType(type) {
  return Object(instanceOf["a" /* default */])(type, definition_GraphQLInterfaceType);
}
function assertInterfaceType(type) {
  if (!isInterfaceType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL Interface type."));
  }

  return type;
}
// eslint-disable-next-line no-redeclare
function isUnionType(type) {
  return Object(instanceOf["a" /* default */])(type, definition_GraphQLUnionType);
}
function assertUnionType(type) {
  if (!isUnionType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL Union type."));
  }

  return type;
}
// eslint-disable-next-line no-redeclare
function isEnumType(type) {
  return Object(instanceOf["a" /* default */])(type, definition_GraphQLEnumType);
}
function assertEnumType(type) {
  if (!isEnumType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL Enum type."));
  }

  return type;
}
// eslint-disable-next-line no-redeclare
function isInputObjectType(type) {
  return Object(instanceOf["a" /* default */])(type, definition_GraphQLInputObjectType);
}
function assertInputObjectType(type) {
  if (!isInputObjectType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL Input Object type."));
  }

  return type;
}
// eslint-disable-next-line no-redeclare
function isListType(type) {
  return Object(instanceOf["a" /* default */])(type, GraphQLList);
}
function assertListType(type) {
  if (!isListType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL List type."));
  }

  return type;
}
// eslint-disable-next-line no-redeclare
function isNonNullType(type) {
  return Object(instanceOf["a" /* default */])(type, GraphQLNonNull);
}
function assertNonNullType(type) {
  if (!isNonNullType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL Non-Null type."));
  }

  return type;
}
/**
 * These types may be used as input types for arguments and directives.
 */

function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function assertInputType(type) {
  if (!isInputType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL input type."));
  }

  return type;
}
/**
 * These types may be used as output types as the result of fields.
 */

function isOutputType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
}
function assertOutputType(type) {
  if (!isOutputType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL output type."));
  }

  return type;
}
/**
 * These types may describe types which may be leaf values.
 */

function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function assertLeafType(type) {
  if (!isLeafType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL leaf type."));
  }

  return type;
}
/**
 * These types may describe the parent context of a selection set.
 */

function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function assertCompositeType(type) {
  if (!isCompositeType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL composite type."));
  }

  return type;
}
/**
 * These types may describe the parent context of a selection set.
 */

function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
function assertAbstractType(type) {
  if (!isAbstractType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL abstract type."));
  }

  return type;
}
/**
 * List Type Wrapper
 *
 * A list is a wrapping type which points to another type.
 * Lists are often created within the context of defining the fields of
 * an object type.
 *
 * Example:
 *
 *     const PersonType = new GraphQLObjectType({
 *       name: 'Person',
 *       fields: () => ({
 *         parents: { type: GraphQLList(PersonType) },
 *         children: { type: GraphQLList(PersonType) },
 *       })
 *     })
 *
 */

// eslint-disable-next-line no-redeclare
function GraphQLList(ofType) {
  if (this instanceof GraphQLList) {
    this.ofType = assertType(ofType);
  } else {
    return new GraphQLList(ofType);
  }
} // Need to cast through any to alter the prototype.

GraphQLList.prototype.toString = function toString() {
  return '[' + String(this.ofType) + ']';
}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported


Object(defineToStringTag["a" /* default */])(GraphQLList);
Object(defineToJSON["a" /* default */])(GraphQLList);
/**
 * Non-Null Type Wrapper
 *
 * A non-null is a wrapping type which points to another type.
 * Non-null types enforce that their values are never null and can ensure
 * an error is raised if this ever occurs during a request. It is useful for
 * fields which you can make a strong guarantee on non-nullability, for example
 * usually the id field of a database row will never be null.
 *
 * Example:
 *
 *     const RowType = new GraphQLObjectType({
 *       name: 'Row',
 *       fields: () => ({
 *         id: { type: GraphQLNonNull(GraphQLString) },
 *       })
 *     })
 *
 * Note: the enforcement of non-nullability occurs within the executor.
 */

// eslint-disable-next-line no-redeclare
function GraphQLNonNull(ofType) {
  if (this instanceof GraphQLNonNull) {
    this.ofType = assertNullableType(ofType);
  } else {
    return new GraphQLNonNull(ofType);
  }
} // Need to cast through any to alter the prototype.

GraphQLNonNull.prototype.toString = function toString() {
  return String(this.ofType) + '!';
}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported


Object(defineToStringTag["a" /* default */])(GraphQLNonNull);
Object(defineToJSON["a" /* default */])(GraphQLNonNull);
/**
 * These types wrap and modify other types
 */

function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function assertWrappingType(type) {
  if (!isWrappingType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL wrapping type."));
  }

  return type;
}
/**
 * These types can all accept null as a value.
 */

function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function assertNullableType(type) {
  if (!isNullableType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL nullable type."));
  }

  return type;
}
/* eslint-disable no-redeclare */

function getNullableType(type) {
  /* eslint-enable no-redeclare */
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
/**
 * These named types do not include modifiers like List or NonNull.
 */

function isNamedType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
}
function assertNamedType(type) {
  if (!isNamedType(type)) {
    throw new Error("Expected ".concat(Object(inspect["a" /* default */])(type), " to be a GraphQL named type."));
  }

  return type;
}
/* eslint-disable no-redeclare */

function getNamedType(type) {
  /* eslint-enable no-redeclare */
  if (type) {
    var unwrappedType = type;

    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }

    return unwrappedType;
  }
}
/**
 * Used while defining GraphQL types to allow for circular references in
 * otherwise immutable type definitions.
 */

function resolveThunk(thunk) {
  // $FlowFixMe(>=0.90.0)
  return typeof thunk === 'function' ? thunk() : thunk;
}

function undefineIfEmpty(arr) {
  return arr && arr.length > 0 ? arr : undefined;
}
/**
 * Scalar Type Definition
 *
 * The leaf values of any request and input values to arguments are
 * Scalars (or Enums) and are defined with a name and a series of functions
 * used to parse input from ast or variables and to ensure validity.
 *
 * If a type's serialize function does not return a value (i.e. it returns
 * `undefined`) then an error will be raised and a `null` value will be returned
 * in the response. If the serialize function returns `null`, then no error will
 * be included in the response.
 *
 * Example:
 *
 *     const OddType = new GraphQLScalarType({
 *       name: 'Odd',
 *       serialize(value) {
 *         if (value % 2 === 1) {
 *           return value;
 *         }
 *       }
 *     });
 *
 */


var definition_GraphQLScalarType =
/*#__PURE__*/
function () {
  function GraphQLScalarType(config) {
    var parseValue = config.parseValue || identityFunc;
    this.name = config.name;
    this.description = config.description;
    this.serialize = config.serialize || identityFunc;
    this.parseValue = parseValue;

    this.parseLiteral = config.parseLiteral || function (node) {
      return parseValue(Object(valueFromASTUntyped["a" /* valueFromASTUntyped */])(node));
    };

    this.extensions = config.extensions && Object(toObjMap["a" /* default */])(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
    typeof config.name === 'string' || Object(devAssert["a" /* default */])(0, 'Must provide name.');
    config.serialize == null || typeof config.serialize === 'function' || Object(devAssert["a" /* default */])(0, "".concat(this.name, " must provide \"serialize\" function. If this custom Scalar is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" functions are also provided."));

    if (config.parseLiteral) {
      typeof config.parseValue === 'function' && typeof config.parseLiteral === 'function' || Object(devAssert["a" /* default */])(0, "".concat(this.name, " must provide both \"parseValue\" and \"parseLiteral\" functions."));
    }
  }

  var _proto = GraphQLScalarType.prototype;

  _proto.toConfig = function toConfig() {
    return {
      name: this.name,
      description: this.description,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes || []
    };
  };

  _proto.toString = function toString() {
    return this.name;
  };

  return GraphQLScalarType;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

Object(defineToStringTag["a" /* default */])(definition_GraphQLScalarType);
Object(defineToJSON["a" /* default */])(definition_GraphQLScalarType);

/**
 * Object Type Definition
 *
 * Almost all of the GraphQL types you define will be object types. Object types
 * have a name, but most importantly describe their fields.
 *
 * Example:
 *
 *     const AddressType = new GraphQLObjectType({
 *       name: 'Address',
 *       fields: {
 *         street: { type: GraphQLString },
 *         number: { type: GraphQLInt },
 *         formatted: {
 *           type: GraphQLString,
 *           resolve(obj) {
 *             return obj.number + ' ' + obj.street
 *           }
 *         }
 *       }
 *     });
 *
 * When two types need to refer to each other, or a type needs to refer to
 * itself in a field, you can use a function expression (aka a closure or a
 * thunk) to supply the fields lazily.
 *
 * Example:
 *
 *     const PersonType = new GraphQLObjectType({
 *       name: 'Person',
 *       fields: () => ({
 *         name: { type: GraphQLString },
 *         bestFriend: { type: PersonType },
 *       })
 *     });
 *
 */
var definition_GraphQLObjectType =
/*#__PURE__*/
function () {
  function GraphQLObjectType(config) {
    this.name = config.name;
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = config.extensions && Object(toObjMap["a" /* default */])(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
    this._fields = defineFieldMap.bind(undefined, config);
    this._interfaces = defineInterfaces.bind(undefined, config);
    typeof config.name === 'string' || Object(devAssert["a" /* default */])(0, 'Must provide name.');
    config.isTypeOf == null || typeof config.isTypeOf === 'function' || Object(devAssert["a" /* default */])(0, "".concat(this.name, " must provide \"isTypeOf\" as a function, ") + "but got: ".concat(Object(inspect["a" /* default */])(config.isTypeOf), "."));
  }

  var _proto2 = GraphQLObjectType.prototype;

  _proto2.getFields = function getFields() {
    if (typeof this._fields === 'function') {
      this._fields = this._fields();
    }

    return this._fields;
  };

  _proto2.getInterfaces = function getInterfaces() {
    if (typeof this._interfaces === 'function') {
      this._interfaces = this._interfaces();
    }

    return this._interfaces;
  };

  _proto2.toConfig = function toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes || []
    };
  };

  _proto2.toString = function toString() {
    return this.name;
  };

  return GraphQLObjectType;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

Object(defineToStringTag["a" /* default */])(definition_GraphQLObjectType);
Object(defineToJSON["a" /* default */])(definition_GraphQLObjectType);

function defineInterfaces(config) {
  var interfaces = resolveThunk(config.interfaces) || [];
  Array.isArray(interfaces) || Object(devAssert["a" /* default */])(0, "".concat(config.name, " interfaces must be an Array or a function which returns an Array."));
  return interfaces;
}

function defineFieldMap(config) {
  var fieldMap = resolveThunk(config.fields) || {};
  isPlainObj(fieldMap) || Object(devAssert["a" /* default */])(0, "".concat(config.name, " fields must be an object with field names as keys or a function which returns such an object."));
  return Object(mapValue["a" /* default */])(fieldMap, function (fieldConfig, fieldName) {
    isPlainObj(fieldConfig) || Object(devAssert["a" /* default */])(0, "".concat(config.name, ".").concat(fieldName, " field config must be an object"));
    !('isDeprecated' in fieldConfig) || Object(devAssert["a" /* default */])(0, "".concat(config.name, ".").concat(fieldName, " should provide \"deprecationReason\" instead of \"isDeprecated\"."));
    fieldConfig.resolve == null || typeof fieldConfig.resolve === 'function' || Object(devAssert["a" /* default */])(0, "".concat(config.name, ".").concat(fieldName, " field resolver must be a function if ") + "provided, but got: ".concat(Object(inspect["a" /* default */])(fieldConfig.resolve), "."));
    var argsConfig = fieldConfig.args || {};
    isPlainObj(argsConfig) || Object(devAssert["a" /* default */])(0, "".concat(config.name, ".").concat(fieldName, " args must be an object with argument names as keys."));
    var args = Object(objectEntries["a" /* default */])(argsConfig).map(function (_ref) {
      var argName = _ref[0],
          arg = _ref[1];
      return {
        name: argName,
        description: arg.description === undefined ? null : arg.description,
        type: arg.type,
        defaultValue: arg.defaultValue,
        extensions: arg.extensions && Object(toObjMap["a" /* default */])(arg.extensions),
        astNode: arg.astNode
      };
    });
    return _objectSpread({}, fieldConfig, {
      name: fieldName,
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: args,
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      isDeprecated: Boolean(fieldConfig.deprecationReason),
      deprecationReason: fieldConfig.deprecationReason,
      extensions: fieldConfig.extensions && Object(toObjMap["a" /* default */])(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    });
  });
}

function isPlainObj(obj) {
  return Object(isObjectLike["a" /* default */])(obj) && !Array.isArray(obj);
}

function fieldsToFieldsConfig(fields) {
  return Object(mapValue["a" /* default */])(fields, function (field) {
    return {
      description: field.description,
      type: field.type,
      args: argsToArgsConfig(field.args),
      resolve: field.resolve,
      subscribe: field.subscribe,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    };
  });
}

function argsToArgsConfig(args) {
  return Object(keyValMap["a" /* default */])(args, function (arg) {
    return arg.name;
  }, function (arg) {
    return {
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      extensions: arg.extensions,
      astNode: arg.astNode
    };
  });
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === undefined;
}

/**
 * Interface Type Definition
 *
 * When a field can return one of a heterogeneous set of types, a Interface type
 * is used to describe what types are possible, what fields are in common across
 * all types, as well as a function to determine which type is actually used
 * when the field is resolved.
 *
 * Example:
 *
 *     const EntityType = new GraphQLInterfaceType({
 *       name: 'Entity',
 *       fields: {
 *         name: { type: GraphQLString }
 *       }
 *     });
 *
 */
var definition_GraphQLInterfaceType =
/*#__PURE__*/
function () {
  function GraphQLInterfaceType(config) {
    this.name = config.name;
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = config.extensions && Object(toObjMap["a" /* default */])(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
    this._fields = defineFieldMap.bind(undefined, config);
    typeof config.name === 'string' || Object(devAssert["a" /* default */])(0, 'Must provide name.');
    config.resolveType == null || typeof config.resolveType === 'function' || Object(devAssert["a" /* default */])(0, "".concat(this.name, " must provide \"resolveType\" as a function, ") + "but got: ".concat(Object(inspect["a" /* default */])(config.resolveType), "."));
  }

  var _proto3 = GraphQLInterfaceType.prototype;

  _proto3.getFields = function getFields() {
    if (typeof this._fields === 'function') {
      this._fields = this._fields();
    }

    return this._fields;
  };

  _proto3.toConfig = function toConfig() {
    return {
      name: this.name,
      description: this.description,
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes || []
    };
  };

  _proto3.toString = function toString() {
    return this.name;
  };

  return GraphQLInterfaceType;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

Object(defineToStringTag["a" /* default */])(definition_GraphQLInterfaceType);
Object(defineToJSON["a" /* default */])(definition_GraphQLInterfaceType);

/**
 * Union Type Definition
 *
 * When a field can return one of a heterogeneous set of types, a Union type
 * is used to describe what types are possible as well as providing a function
 * to determine which type is actually used when the field is resolved.
 *
 * Example:
 *
 *     const PetType = new GraphQLUnionType({
 *       name: 'Pet',
 *       types: [ DogType, CatType ],
 *       resolveType(value) {
 *         if (value instanceof Dog) {
 *           return DogType;
 *         }
 *         if (value instanceof Cat) {
 *           return CatType;
 *         }
 *       }
 *     });
 *
 */
var definition_GraphQLUnionType =
/*#__PURE__*/
function () {
  function GraphQLUnionType(config) {
    this.name = config.name;
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = config.extensions && Object(toObjMap["a" /* default */])(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
    this._types = defineTypes.bind(undefined, config);
    typeof config.name === 'string' || Object(devAssert["a" /* default */])(0, 'Must provide name.');
    config.resolveType == null || typeof config.resolveType === 'function' || Object(devAssert["a" /* default */])(0, "".concat(this.name, " must provide \"resolveType\" as a function, ") + "but got: ".concat(Object(inspect["a" /* default */])(config.resolveType), "."));
  }

  var _proto4 = GraphQLUnionType.prototype;

  _proto4.getTypes = function getTypes() {
    if (typeof this._types === 'function') {
      this._types = this._types();
    }

    return this._types;
  };

  _proto4.toConfig = function toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes || []
    };
  };

  _proto4.toString = function toString() {
    return this.name;
  };

  return GraphQLUnionType;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

Object(defineToStringTag["a" /* default */])(definition_GraphQLUnionType);
Object(defineToJSON["a" /* default */])(definition_GraphQLUnionType);

function defineTypes(config) {
  var types = resolveThunk(config.types) || [];
  Array.isArray(types) || Object(devAssert["a" /* default */])(0, "Must provide Array of types or a function which returns such an array for Union ".concat(config.name, "."));
  return types;
}

/**
 * Enum Type Definition
 *
 * Some leaf values of requests and input values are Enums. GraphQL serializes
 * Enum values as strings, however internally Enums can be represented by any
 * kind of type, often integers.
 *
 * Example:
 *
 *     const RGBType = new GraphQLEnumType({
 *       name: 'RGB',
 *       values: {
 *         RED: { value: 0 },
 *         GREEN: { value: 1 },
 *         BLUE: { value: 2 }
 *       }
 *     });
 *
 * Note: If a value is not provided in a definition, the name of the enum value
 * will be used as its internal value.
 */
var definition_GraphQLEnumType
/* <T> */
=
/*#__PURE__*/
function () {
  function GraphQLEnumType(config) {
    this.name = config.name;
    this.description = config.description;
    this.extensions = config.extensions && Object(toObjMap["a" /* default */])(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
    this._values = defineEnumValues(this.name, config.values);
    this._valueLookup = new Map(this._values.map(function (enumValue) {
      return [enumValue.value, enumValue];
    }));
    this._nameLookup = Object(keyMap["a" /* default */])(this._values, function (value) {
      return value.name;
    });
    typeof config.name === 'string' || Object(devAssert["a" /* default */])(0, 'Must provide name.');
  }

  var _proto5 = GraphQLEnumType.prototype;

  _proto5.getValues = function getValues() {
    return this._values;
  };

  _proto5.getValue = function getValue(name) {
    return this._nameLookup[name];
  };

  _proto5.serialize = function serialize(value) {
    var enumValue = this._valueLookup.get(value);

    if (enumValue) {
      return enumValue.name;
    }
  };

  _proto5.parseValue = function parseValue(value)
  /* T */
  {
    if (typeof value === 'string') {
      var enumValue = this.getValue(value);

      if (enumValue) {
        return enumValue.value;
      }
    }
  };

  _proto5.parseLiteral = function parseLiteral(valueNode, _variables)
  /* T */
  {
    // Note: variables will be resolved to a value before calling this function.
    if (valueNode.kind === kinds["a" /* Kind */].ENUM) {
      var enumValue = this.getValue(valueNode.value);

      if (enumValue) {
        return enumValue.value;
      }
    }
  };

  _proto5.toConfig = function toConfig() {
    var values = Object(keyValMap["a" /* default */])(this.getValues(), function (value) {
      return value.name;
    }, function (value) {
      return {
        description: value.description,
        value: value.value,
        deprecationReason: value.deprecationReason,
        extensions: value.extensions,
        astNode: value.astNode
      };
    });
    return {
      name: this.name,
      description: this.description,
      values: values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes || []
    };
  };

  _proto5.toString = function toString() {
    return this.name;
  };

  return GraphQLEnumType;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

Object(defineToStringTag["a" /* default */])(definition_GraphQLEnumType);
Object(defineToJSON["a" /* default */])(definition_GraphQLEnumType);

function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || Object(devAssert["a" /* default */])(0, "".concat(typeName, " values must be an object with value names as keys."));
  return Object(objectEntries["a" /* default */])(valueMap).map(function (_ref2) {
    var valueName = _ref2[0],
        value = _ref2[1];
    isPlainObj(value) || Object(devAssert["a" /* default */])(0, "".concat(typeName, ".").concat(valueName, " must refer to an object with a \"value\" key ") + "representing an internal value but got: ".concat(Object(inspect["a" /* default */])(value), "."));
    !('isDeprecated' in value) || Object(devAssert["a" /* default */])(0, "".concat(typeName, ".").concat(valueName, " should provide \"deprecationReason\" instead of \"isDeprecated\"."));
    return {
      name: valueName,
      description: value.description,
      value: 'value' in value ? value.value : valueName,
      isDeprecated: Boolean(value.deprecationReason),
      deprecationReason: value.deprecationReason,
      extensions: value.extensions && Object(toObjMap["a" /* default */])(value.extensions),
      astNode: value.astNode
    };
  });
}

/**
 * Input Object Type Definition
 *
 * An input object defines a structured collection of fields which may be
 * supplied to a field argument.
 *
 * Using `NonNull` will ensure that a value must be provided by the query
 *
 * Example:
 *
 *     const GeoPoint = new GraphQLInputObjectType({
 *       name: 'GeoPoint',
 *       fields: {
 *         lat: { type: GraphQLNonNull(GraphQLFloat) },
 *         lon: { type: GraphQLNonNull(GraphQLFloat) },
 *         alt: { type: GraphQLFloat, defaultValue: 0 },
 *       }
 *     });
 *
 */
var definition_GraphQLInputObjectType =
/*#__PURE__*/
function () {
  function GraphQLInputObjectType(config) {
    this.name = config.name;
    this.description = config.description;
    this.extensions = config.extensions && Object(toObjMap["a" /* default */])(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
    this._fields = defineInputFieldMap.bind(undefined, config);
    typeof config.name === 'string' || Object(devAssert["a" /* default */])(0, 'Must provide name.');
  }

  var _proto6 = GraphQLInputObjectType.prototype;

  _proto6.getFields = function getFields() {
    if (typeof this._fields === 'function') {
      this._fields = this._fields();
    }

    return this._fields;
  };

  _proto6.toConfig = function toConfig() {
    var fields = Object(mapValue["a" /* default */])(this.getFields(), function (field) {
      return {
        description: field.description,
        type: field.type,
        defaultValue: field.defaultValue,
        extensions: field.extensions,
        astNode: field.astNode
      };
    });
    return {
      name: this.name,
      description: this.description,
      fields: fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes || []
    };
  };

  _proto6.toString = function toString() {
    return this.name;
  };

  return GraphQLInputObjectType;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

Object(defineToStringTag["a" /* default */])(definition_GraphQLInputObjectType);
Object(defineToJSON["a" /* default */])(definition_GraphQLInputObjectType);

function defineInputFieldMap(config) {
  var fieldMap = resolveThunk(config.fields) || {};
  isPlainObj(fieldMap) || Object(devAssert["a" /* default */])(0, "".concat(config.name, " fields must be an object with field names as keys or a function which returns such an object."));
  return Object(mapValue["a" /* default */])(fieldMap, function (fieldConfig, fieldName) {
    !('resolve' in fieldConfig) || Object(devAssert["a" /* default */])(0, "".concat(config.name, ".").concat(fieldName, " field has a resolve property, but Input Types cannot define resolvers."));
    return _objectSpread({}, fieldConfig, {
      name: fieldName,
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      extensions: fieldConfig.extensions && Object(toObjMap["a" /* default */])(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    });
  });
}

function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === undefined;
}


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _assign; });
/* unused harmony export __rest */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __decorate; });
/* unused harmony export __param */
/* unused harmony export __metadata */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __generator; });
/* unused harmony export __exportStar */
/* unused harmony export __values */
/* unused harmony export __read */
/* unused harmony export __spread */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __spreadArrays; });
/* unused harmony export __await */
/* unused harmony export __asyncGenerator */
/* unused harmony export __asyncDelegator */
/* unused harmony export __asyncValues */
/* unused harmony export __makeTemplateObject */
/* unused harmony export __importStar */
/* unused harmony export __importDefault */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var _extendStatics = function extendStatics(d, b) {
  _extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return _extendStatics(d, b);
};

function __extends(d, b) {
  _extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var _assign = function __assign() {
  _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return _assign.apply(this, arguments);
};


function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __exportStar(m, exports) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
function __values(o) {
  var m = typeof Symbol === "function" && o[Symbol.iterator],
      i = 0;
  if (m) return m.call(o);
  return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}
;
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;

  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}
;
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}

/***/ }),
/* 2 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Kind; });
/**
 * The set of allowed kind values for AST nodes.
 */
var Kind = Object.freeze({
  // Name
  NAME: 'Name',
  // Document
  DOCUMENT: 'Document',
  OPERATION_DEFINITION: 'OperationDefinition',
  VARIABLE_DEFINITION: 'VariableDefinition',
  SELECTION_SET: 'SelectionSet',
  FIELD: 'Field',
  ARGUMENT: 'Argument',
  // Fragments
  FRAGMENT_SPREAD: 'FragmentSpread',
  INLINE_FRAGMENT: 'InlineFragment',
  FRAGMENT_DEFINITION: 'FragmentDefinition',
  // Values
  VARIABLE: 'Variable',
  INT: 'IntValue',
  FLOAT: 'FloatValue',
  STRING: 'StringValue',
  BOOLEAN: 'BooleanValue',
  NULL: 'NullValue',
  ENUM: 'EnumValue',
  LIST: 'ListValue',
  OBJECT: 'ObjectValue',
  OBJECT_FIELD: 'ObjectField',
  // Directives
  DIRECTIVE: 'Directive',
  // Types
  NAMED_TYPE: 'NamedType',
  LIST_TYPE: 'ListType',
  NON_NULL_TYPE: 'NonNullType',
  // Type System Definitions
  SCHEMA_DEFINITION: 'SchemaDefinition',
  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',
  // Type Definitions
  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',
  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',
  FIELD_DEFINITION: 'FieldDefinition',
  INPUT_VALUE_DEFINITION: 'InputValueDefinition',
  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',
  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',
  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',
  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',
  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',
  // Directive Definitions
  DIRECTIVE_DEFINITION: 'DirectiveDefinition',
  // Type System Extensions
  SCHEMA_EXTENSION: 'SchemaExtension',
  // Type Extensions
  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',
  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',
  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',
  UNION_TYPE_EXTENSION: 'UnionTypeExtension',
  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',
  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'
});
/**
 * The enum type representing the possible kind values of AST nodes.
 */


/***/ }),
/* 3 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return inspect; });
/* harmony import */ var _nodejsCustomInspectSymbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }


var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
/**
 * Used to print values in error messages.
 */

function inspect(value) {
  return formatValue(value, []);
}

function formatValue(value, seenValues) {
  switch (_typeof(value)) {
    case 'string':
      return JSON.stringify(value);

    case 'function':
      return value.name ? "[function ".concat(value.name, "]") : '[function]';

    case 'object':
      if (value === null) {
        return 'null';
      }

      return formatObjectValue(value, seenValues);

    default:
      return String(value);
  }
}

function formatObjectValue(value, previouslySeenValues) {
  if (previouslySeenValues.indexOf(value) !== -1) {
    return '[Circular]';
  }

  var seenValues = [].concat(previouslySeenValues, [value]);
  var customInspectFn = getCustomFn(value);

  if (customInspectFn !== undefined) {
    // $FlowFixMe(>=0.90.0)
    var customValue = customInspectFn.call(value); // check for infinite recursion

    if (customValue !== value) {
      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }

  return formatObject(value, seenValues);
}

function formatObject(object, seenValues) {
  var keys = Object.keys(object);

  if (keys.length === 0) {
    return '{}';
  }

  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return '[' + getObjectTag(object) + ']';
  }

  var properties = keys.map(function (key) {
    var value = formatValue(object[key], seenValues);
    return key + ': ' + value;
  });
  return '{ ' + properties.join(', ') + ' }';
}

function formatArray(array, seenValues) {
  if (array.length === 0) {
    return '[]';
  }

  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return '[Array]';
  }

  var len = Math.min(MAX_ARRAY_LENGTH, array.length);
  var remaining = array.length - len;
  var items = [];

  for (var i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }

  if (remaining === 1) {
    items.push('... 1 more item');
  } else if (remaining > 1) {
    items.push("... ".concat(remaining, " more items"));
  }

  return '[' + items.join(', ') + ']';
}

function getCustomFn(object) {
  var customInspectFn = object[String(_nodejsCustomInspectSymbol__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])];

  if (typeof customInspectFn === 'function') {
    return customInspectFn;
  }

  if (typeof object.inspect === 'function') {
    return object.inspect;
  }
}

function getObjectTag(object) {
  var tag = Object.prototype.toString.call(object).replace(/^\[object /, '').replace(/]$/, '');

  if (tag === 'Object' && typeof object.constructor === 'function') {
    var name = object.constructor.name;

    if (typeof name === 'string' && name !== '') {
      return name;
    }
  }

  return tag;
}


/***/ }),
/* 4 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GraphQLError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return printError; });
/* harmony import */ var _jsutils_isObjectLike__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);
/* harmony import */ var _language_location__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66);
/* harmony import */ var _language_printLocation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87);



/**
 * A GraphQLError describes an Error found during the parse, validate, or
 * execute phases of performing a GraphQL operation. In addition to a message
 * and stack trace, it also includes information about the locations in a
 * GraphQL document and/or execution result that correspond to the Error.
 */

function GraphQLError( // eslint-disable-line no-redeclare
message, nodes, source, positions, path, originalError, extensions) {
  // Compute list of blame nodes.
  var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.


  var _source = source;

  if (!_source && _nodes) {
    var node = _nodes[0];
    _source = node && node.loc && node.loc.source;
  }

  var _positions = positions;

  if (!_positions && _nodes) {
    _positions = _nodes.reduce(function (list, node) {
      if (node.loc) {
        list.push(node.loc.start);
      }

      return list;
    }, []);
  }

  if (_positions && _positions.length === 0) {
    _positions = undefined;
  }

  var _locations;

  if (positions && source) {
    _locations = positions.map(function (pos) {
      return Object(_language_location__WEBPACK_IMPORTED_MODULE_1__[/* getLocation */ "a"])(source, pos);
    });
  } else if (_nodes) {
    _locations = _nodes.reduce(function (list, node) {
      if (node.loc) {
        list.push(Object(_language_location__WEBPACK_IMPORTED_MODULE_1__[/* getLocation */ "a"])(node.loc.source, node.loc.start));
      }

      return list;
    }, []);
  }

  var _extensions = extensions;

  if (_extensions == null && originalError != null) {
    var originalExtensions = originalError.extensions;

    if (Object(_jsutils_isObjectLike__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(originalExtensions)) {
      _extensions = originalExtensions;
    }
  }

  Object.defineProperties(this, {
    message: {
      value: message,
      // By being enumerable, JSON.stringify will include `message` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: true,
      writable: true
    },
    locations: {
      // Coercing falsey values to undefined ensures they will not be included
      // in JSON.stringify() when not provided.
      value: _locations || undefined,
      // By being enumerable, JSON.stringify will include `locations` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: Boolean(_locations)
    },
    path: {
      // Coercing falsey values to undefined ensures they will not be included
      // in JSON.stringify() when not provided.
      value: path || undefined,
      // By being enumerable, JSON.stringify will include `path` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: Boolean(path)
    },
    nodes: {
      value: _nodes || undefined
    },
    source: {
      value: _source || undefined
    },
    positions: {
      value: _positions || undefined
    },
    originalError: {
      value: originalError
    },
    extensions: {
      // Coercing falsey values to undefined ensures they will not be included
      // in JSON.stringify() when not provided.
      value: _extensions || undefined,
      // By being enumerable, JSON.stringify will include `path` in the
      // resulting output. This ensures that the simplest possible GraphQL
      // service adheres to the spec.
      enumerable: Boolean(_extensions)
    }
  }); // Include (non-enumerable) stack trace.

  if (originalError && originalError.stack) {
    Object.defineProperty(this, 'stack', {
      value: originalError.stack,
      writable: true,
      configurable: true
    });
  } else if (Error.captureStackTrace) {
    Error.captureStackTrace(this, GraphQLError);
  } else {
    Object.defineProperty(this, 'stack', {
      value: Error().stack,
      writable: true,
      configurable: true
    });
  }
}
GraphQLError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: GraphQLError
  },
  name: {
    value: 'GraphQLError'
  },
  toString: {
    value: function toString() {
      return printError(this);
    }
  }
});
/**
 * Prints a GraphQLError to a string, representing useful location information
 * about the error's position in the source.
 */

function printError(error) {
  var output = error.message;

  if (error.nodes) {
    for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {
      var node = _error$nodes2[_i2];

      if (node.loc) {
        output += '\n\n' + Object(_language_printLocation__WEBPACK_IMPORTED_MODULE_2__[/* printLocation */ "a"])(node.loc);
      }
    }
  } else if (error.source && error.locations) {
    for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {
      var location = _error$locations2[_i4];
      output += '\n\n' + Object(_language_printLocation__WEBPACK_IMPORTED_MODULE_2__[/* printSourceLocation */ "b"])(error.source, location);
    }
  }

  return output;
}


/***/ }),
/* 5 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TokenKind; });
/**
 * An exported enum describing the different kinds of tokens that the
 * lexer emits.
 */
var TokenKind = Object.freeze({
  SOF: '<SOF>',
  EOF: '<EOF>',
  BANG: '!',
  DOLLAR: '$',
  AMP: '&',
  PAREN_L: '(',
  PAREN_R: ')',
  SPREAD: '...',
  COLON: ':',
  EQUALS: '=',
  AT: '@',
  BRACKET_L: '[',
  BRACKET_R: ']',
  BRACE_L: '{',
  PIPE: '|',
  BRACE_R: '}',
  NAME: 'Name',
  INT: 'Int',
  FLOAT: 'Float',
  STRING: 'String',
  BLOCK_STRING: 'BlockString',
  COMMENT: 'Comment'
});
/**
 * The enum type representing the token kinds values.
 */


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addTypenameToDocument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return argumentsObjectFromField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return buildQueryFromSelectionSet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return canUseWeakMap; });
/* unused harmony export checkDocument */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return cloneDeep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return createFragmentMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return getDefaultValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return getDirectiveInfoFromField; });
/* unused harmony export getDirectiveNames */
/* unused harmony export getDirectivesFromDocument */
/* unused harmony export getEnv */
/* unused harmony export getFragmentDefinition */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return getFragmentDefinitions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return getFragmentQueryDocument; });
/* unused harmony export getInclusionDirectives */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return getMainDefinition; });
/* unused harmony export getMutationDefinition */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return getOperationDefinition; });
/* unused harmony export getOperationDefinitionOrDie */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return getOperationName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return getQueryDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return getStoreKeyName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return graphQLResultHasError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return hasClientExports; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return hasDirectives; });
/* unused harmony export isDevelopment */
/* unused harmony export isEnv */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return isField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return isIdValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return isInlineFragment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return isJsonValue; });
/* unused harmony export isNumberValue */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return isProduction; });
/* unused harmony export isScalarValue */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return isTest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return maybeDeepFreeze; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return mergeDeep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return mergeDeepArray; });
/* unused harmony export removeArgumentsFromDocument */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return removeClientSetsFromDocument; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return removeConnectionDirectiveFromDocument; });
/* unused harmony export removeDirectivesFromDocument */
/* unused harmony export removeFragmentSpreadFromDocument */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return resultKeyNameFromField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return shouldInclude; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return storeKeyNameFromField; });
/* unused harmony export stripSymbols */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return toIdValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return tryFunctionOrLogError; });
/* unused harmony export valueFromNode */
/* unused harmony export valueToObjectRepresentation */
/* unused harmony export variablesInOperation */
/* unused harmony export warnOnceInDevelopment */
/* harmony import */ var graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(163);
/* harmony import */ var fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _wry_equality__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(114);






function isScalarValue(value) {
  return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;
}

function isNumberValue(value) {
  return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;
}

function isStringValue(value) {
  return value.kind === 'StringValue';
}

function isBooleanValue(value) {
  return value.kind === 'BooleanValue';
}

function isIntValue(value) {
  return value.kind === 'IntValue';
}

function isFloatValue(value) {
  return value.kind === 'FloatValue';
}

function isVariable(value) {
  return value.kind === 'Variable';
}

function isObjectValue(value) {
  return value.kind === 'ObjectValue';
}

function isListValue(value) {
  return value.kind === 'ListValue';
}

function isEnumValue(value) {
  return value.kind === 'EnumValue';
}

function isNullValue(value) {
  return value.kind === 'NullValue';
}

function valueToObjectRepresentation(argObj, name, value, variables) {
  if (isIntValue(value) || isFloatValue(value)) {
    argObj[name.value] = Number(value.value);
  } else if (isBooleanValue(value) || isStringValue(value)) {
    argObj[name.value] = value.value;
  } else if (isObjectValue(value)) {
    var nestedArgObj_1 = {};
    value.fields.map(function (obj) {
      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
    });
    argObj[name.value] = nestedArgObj_1;
  } else if (isVariable(value)) {
    var variableValue = (variables || {})[value.name.value];
    argObj[name.value] = variableValue;
  } else if (isListValue(value)) {
    argObj[name.value] = value.values.map(function (listValue) {
      var nestedArgArrayObj = {};
      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
      return nestedArgArrayObj[name.value];
    });
  } else if (isEnumValue(value)) {
    argObj[name.value] = value.value;
  } else if (isNullValue(value)) {
    argObj[name.value] = null;
  } else {
    throw  true ? new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* InvariantError */ "a"](17) : undefined;
  }
}

function storeKeyNameFromField(field, variables) {
  var directivesObj = null;

  if (field.directives) {
    directivesObj = {};
    field.directives.forEach(function (directive) {
      directivesObj[directive.name.value] = {};

      if (directive.arguments) {
        directive.arguments.forEach(function (_a) {
          var name = _a.name,
              value = _a.value;
          return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
        });
      }
    });
  }

  var argObj = null;

  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(function (_a) {
      var name = _a.name,
          value = _a.value;
      return valueToObjectRepresentation(argObj, name, value, variables);
    });
  }

  return getStoreKeyName(field.name.value, argObj, directivesObj);
}

var KNOWN_DIRECTIVES = ['connection', 'include', 'skip', 'client', 'rest', 'export'];

function getStoreKeyName(fieldName, args, directives) {
  if (directives && directives['connection'] && directives['connection']['key']) {
    if (directives['connection']['filter'] && directives['connection']['filter'].length > 0) {
      var filterKeys = directives['connection']['filter'] ? directives['connection']['filter'] : [];
      filterKeys.sort();
      var queryArgs_1 = args;
      var filteredArgs_1 = {};
      filterKeys.forEach(function (key) {
        filteredArgs_1[key] = queryArgs_1[key];
      });
      return directives['connection']['key'] + "(" + JSON.stringify(filteredArgs_1) + ")";
    } else {
      return directives['connection']['key'];
    }
  }

  var completeFieldName = fieldName;

  if (args) {
    var stringifiedArgs = fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_3___default()(args);
    completeFieldName += "(" + stringifiedArgs + ")";
  }

  if (directives) {
    Object.keys(directives).forEach(function (key) {
      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;

      if (directives[key] && Object.keys(directives[key]).length) {
        completeFieldName += "@" + key + "(" + JSON.stringify(directives[key]) + ")";
      } else {
        completeFieldName += "@" + key;
      }
    });
  }

  return completeFieldName;
}

function argumentsObjectFromField(field, variables) {
  if (field.arguments && field.arguments.length) {
    var argObj_1 = {};
    field.arguments.forEach(function (_a) {
      var name = _a.name,
          value = _a.value;
      return valueToObjectRepresentation(argObj_1, name, value, variables);
    });
    return argObj_1;
  }

  return null;
}

function resultKeyNameFromField(field) {
  return field.alias ? field.alias.value : field.name.value;
}

function isField(selection) {
  return selection.kind === 'Field';
}

function isInlineFragment(selection) {
  return selection.kind === 'InlineFragment';
}

function isIdValue(idObject) {
  return idObject && idObject.type === 'id' && typeof idObject.generated === 'boolean';
}

function toIdValue(idConfig, generated) {
  if (generated === void 0) {
    generated = false;
  }

  return Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])({
    type: 'id',
    generated: generated
  }, typeof idConfig === 'string' ? {
    id: idConfig,
    typename: undefined
  } : idConfig);
}

function isJsonValue(jsonObject) {
  return jsonObject != null && typeof jsonObject === 'object' && jsonObject.type === 'json';
}

function defaultValueFromVariable(node) {
  throw  true ? new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* InvariantError */ "a"](18) : undefined;
}

function valueFromNode(node, onVariable) {
  if (onVariable === void 0) {
    onVariable = defaultValueFromVariable;
  }

  switch (node.kind) {
    case 'Variable':
      return onVariable(node);

    case 'NullValue':
      return null;

    case 'IntValue':
      return parseInt(node.value, 10);

    case 'FloatValue':
      return parseFloat(node.value);

    case 'ListValue':
      return node.values.map(function (v) {
        return valueFromNode(v, onVariable);
      });

    case 'ObjectValue':
      {
        var value = {};

        for (var _i = 0, _a = node.fields; _i < _a.length; _i++) {
          var field = _a[_i];
          value[field.name.value] = valueFromNode(field.value, onVariable);
        }

        return value;
      }

    default:
      return node.value;
  }
}

function getDirectiveInfoFromField(field, variables) {
  if (field.directives && field.directives.length) {
    var directiveObj_1 = {};
    field.directives.forEach(function (directive) {
      directiveObj_1[directive.name.value] = argumentsObjectFromField(directive, variables);
    });
    return directiveObj_1;
  }

  return null;
}

function shouldInclude(selection, variables) {
  if (variables === void 0) {
    variables = {};
  }

  return getInclusionDirectives(selection.directives).every(function (_a) {
    var directive = _a.directive,
        ifArgument = _a.ifArgument;
    var evaledValue = false;

    if (ifArgument.value.kind === 'Variable') {
      evaledValue = variables[ifArgument.value.name.value];
       true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ "b"])(evaledValue !== void 0, 1) : undefined;
    } else {
      evaledValue = ifArgument.value.value;
    }

    return directive.name.value === 'skip' ? !evaledValue : evaledValue;
  });
}

function getDirectiveNames(doc) {
  var names = [];
  Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ "c"])(doc, {
    Directive: function Directive(node) {
      names.push(node.name.value);
    }
  });
  return names;
}

function hasDirectives(names, doc) {
  return getDirectiveNames(doc).some(function (name) {
    return names.indexOf(name) > -1;
  });
}

function hasClientExports(document) {
  return document && hasDirectives(['client'], document) && hasDirectives(['export'], document);
}

function isInclusionDirective(_a) {
  var value = _a.name.value;
  return value === 'skip' || value === 'include';
}

function getInclusionDirectives(directives) {
  return directives ? directives.filter(isInclusionDirective).map(function (directive) {
    var directiveArguments = directive.arguments;
    var directiveName = directive.name.value;
     true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ "b"])(directiveArguments && directiveArguments.length === 1, 2) : undefined;
    var ifArgument = directiveArguments[0];
     true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ "b"])(ifArgument.name && ifArgument.name.value === 'if', 3) : undefined;
    var ifValue = ifArgument.value;
     true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ "b"])(ifValue && (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), 4) : undefined;
    return {
      directive: directive,
      ifArgument: ifArgument
    };
  }) : [];
}

function getFragmentQueryDocument(document, fragmentName) {
  var actualFragmentName = fragmentName;
  var fragments = [];
  document.definitions.forEach(function (definition) {
    if (definition.kind === 'OperationDefinition') {
      throw  true ? new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* InvariantError */ "a"](5) : undefined;
    }

    if (definition.kind === 'FragmentDefinition') {
      fragments.push(definition);
    }
  });

  if (typeof actualFragmentName === 'undefined') {
     true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ "b"])(fragments.length === 1, 6) : undefined;
    actualFragmentName = fragments[0].name.value;
  }

  var query = Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])({}, document), {
    definitions: Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __spreadArrays */ "f"])([{
      kind: 'OperationDefinition',
      operation: 'query',
      selectionSet: {
        kind: 'SelectionSet',
        selections: [{
          kind: 'FragmentSpread',
          name: {
            kind: 'Name',
            value: actualFragmentName
          }
        }]
      }
    }], document.definitions)
  });

  return query;
}

function assign(target) {
  var sources = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    sources[_i - 1] = arguments[_i];
  }

  sources.forEach(function (source) {
    if (typeof source === 'undefined' || source === null) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      target[key] = source[key];
    });
  });
  return target;
}

function getMutationDefinition(doc) {
  checkDocument(doc);
  var mutationDef = doc.definitions.filter(function (definition) {
    return definition.kind === 'OperationDefinition' && definition.operation === 'mutation';
  })[0];
   true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ "b"])(mutationDef, 7) : undefined;
  return mutationDef;
}

function checkDocument(doc) {
   true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ "b"])(doc && doc.kind === 'Document', 8) : undefined;
  var operations = doc.definitions.filter(function (d) {
    return d.kind !== 'FragmentDefinition';
  }).map(function (definition) {
    if (definition.kind !== 'OperationDefinition') {
      throw  true ? new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* InvariantError */ "a"](9) : undefined;
    }

    return definition;
  });
   true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ "b"])(operations.length <= 1, 10) : undefined;
  return doc;
}

function getOperationDefinition(doc) {
  checkDocument(doc);
  return doc.definitions.filter(function (definition) {
    return definition.kind === 'OperationDefinition';
  })[0];
}

function getOperationDefinitionOrDie(document) {
  var def = getOperationDefinition(document);
   true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ "b"])(def, 11) : undefined;
  return def;
}

function getOperationName(doc) {
  return doc.definitions.filter(function (definition) {
    return definition.kind === 'OperationDefinition' && definition.name;
  }).map(function (x) {
    return x.name.value;
  })[0] || null;
}

function getFragmentDefinitions(doc) {
  return doc.definitions.filter(function (definition) {
    return definition.kind === 'FragmentDefinition';
  });
}

function getQueryDefinition(doc) {
  var queryDef = getOperationDefinition(doc);
   true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ "b"])(queryDef && queryDef.operation === 'query', 12) : undefined;
  return queryDef;
}

function getFragmentDefinition(doc) {
   true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ "b"])(doc.kind === 'Document', 13) : undefined;
   true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ "b"])(doc.definitions.length <= 1, 14) : undefined;
  var fragmentDef = doc.definitions[0];
   true ? Object(ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* invariant */ "b"])(fragmentDef.kind === 'FragmentDefinition', 15) : undefined;
  return fragmentDef;
}

function getMainDefinition(queryDoc) {
  checkDocument(queryDoc);
  var fragmentDefinition;

  for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {
    var definition = _a[_i];

    if (definition.kind === 'OperationDefinition') {
      var operation = definition.operation;

      if (operation === 'query' || operation === 'mutation' || operation === 'subscription') {
        return definition;
      }
    }

    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {
      fragmentDefinition = definition;
    }
  }

  if (fragmentDefinition) {
    return fragmentDefinition;
  }

  throw  true ? new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* InvariantError */ "a"](16) : undefined;
}

function createFragmentMap(fragments) {
  if (fragments === void 0) {
    fragments = [];
  }

  var symTable = {};
  fragments.forEach(function (fragment) {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}

function getDefaultValues(definition) {
  if (definition && definition.variableDefinitions && definition.variableDefinitions.length) {
    var defaultValues = definition.variableDefinitions.filter(function (_a) {
      var defaultValue = _a.defaultValue;
      return defaultValue;
    }).map(function (_a) {
      var variable = _a.variable,
          defaultValue = _a.defaultValue;
      var defaultValueObj = {};
      valueToObjectRepresentation(defaultValueObj, variable.name, defaultValue);
      return defaultValueObj;
    });
    return assign.apply(void 0, Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __spreadArrays */ "f"])([{}], defaultValues));
  }

  return {};
}

function variablesInOperation(operation) {
  var names = new Set();

  if (operation.variableDefinitions) {
    for (var _i = 0, _a = operation.variableDefinitions; _i < _a.length; _i++) {
      var definition = _a[_i];
      names.add(definition.variable.name.value);
    }
  }

  return names;
}

function filterInPlace(array, test, context) {
  var target = 0;
  array.forEach(function (elem, i) {
    if (test.call(this, elem, i, array)) {
      array[target++] = elem;
    }
  }, context);
  array.length = target;
  return array;
}

var TYPENAME_FIELD = {
  kind: 'Field',
  name: {
    kind: 'Name',
    value: '__typename'
  }
};

function isEmpty(op, fragments) {
  return op.selectionSet.selections.every(function (selection) {
    return selection.kind === 'FragmentSpread' && isEmpty(fragments[selection.name.value], fragments);
  });
}

function nullIfDocIsEmpty(doc) {
  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
}

function getDirectiveMatcher(directives) {
  return function directiveMatcher(directive) {
    return directives.some(function (dir) {
      return dir.name && dir.name === directive.name.value || dir.test && dir.test(directive);
    });
  };
}

function removeDirectivesFromDocument(directives, doc) {
  var variablesInUse = Object.create(null);
  var variablesToRemove = [];
  var fragmentSpreadsInUse = Object.create(null);
  var fragmentSpreadsToRemove = [];
  var modifiedDoc = nullIfDocIsEmpty(Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ "c"])(doc, {
    Variable: {
      enter: function enter(node, _key, parent) {
        if (parent.kind !== 'VariableDefinition') {
          variablesInUse[node.name.value] = true;
        }
      }
    },
    Field: {
      enter: function enter(node) {
        if (directives && node.directives) {
          var shouldRemoveField = directives.some(function (directive) {
            return directive.remove;
          });

          if (shouldRemoveField && node.directives && node.directives.some(getDirectiveMatcher(directives))) {
            if (node.arguments) {
              node.arguments.forEach(function (arg) {
                if (arg.value.kind === 'Variable') {
                  variablesToRemove.push({
                    name: arg.value.name.value
                  });
                }
              });
            }

            if (node.selectionSet) {
              getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function (frag) {
                fragmentSpreadsToRemove.push({
                  name: frag.name.value
                });
              });
            }

            return null;
          }
        }
      }
    },
    FragmentSpread: {
      enter: function enter(node) {
        fragmentSpreadsInUse[node.name.value] = true;
      }
    },
    Directive: {
      enter: function enter(node) {
        if (getDirectiveMatcher(directives)(node)) {
          return null;
        }
      }
    }
  }));

  if (modifiedDoc && filterInPlace(variablesToRemove, function (v) {
    return !variablesInUse[v.name];
  }).length) {
    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);
  }

  if (modifiedDoc && filterInPlace(fragmentSpreadsToRemove, function (fs) {
    return !fragmentSpreadsInUse[fs.name];
  }).length) {
    modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);
  }

  return modifiedDoc;
}

function addTypenameToDocument(doc) {
  return Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ "c"])(checkDocument(doc), {
    SelectionSet: {
      enter: function enter(node, _key, parent) {
        if (parent && parent.kind === 'OperationDefinition') {
          return;
        }

        var selections = node.selections;

        if (!selections) {
          return;
        }

        var skip = selections.some(function (selection) {
          return isField(selection) && (selection.name.value === '__typename' || selection.name.value.lastIndexOf('__', 0) === 0);
        });

        if (skip) {
          return;
        }

        var field = parent;

        if (isField(field) && field.directives && field.directives.some(function (d) {
          return d.name.value === 'export';
        })) {
          return;
        }

        return Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])({}, node), {
          selections: Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __spreadArrays */ "f"])(selections, [TYPENAME_FIELD])
        });
      }
    }
  });
}

var connectionRemoveConfig = {
  test: function test(directive) {
    var willRemove = directive.name.value === 'connection';

    if (willRemove) {
      if (!directive.arguments || !directive.arguments.some(function (arg) {
        return arg.name.value === 'key';
      })) {
         true || false;
      }
    }

    return willRemove;
  }
};

function removeConnectionDirectiveFromDocument(doc) {
  return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
}

function hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {
  if (nestedCheck === void 0) {
    nestedCheck = true;
  }

  return selectionSet && selectionSet.selections && selectionSet.selections.some(function (selection) {
    return hasDirectivesInSelection(directives, selection, nestedCheck);
  });
}

function hasDirectivesInSelection(directives, selection, nestedCheck) {
  if (nestedCheck === void 0) {
    nestedCheck = true;
  }

  if (!isField(selection)) {
    return true;
  }

  if (!selection.directives) {
    return false;
  }

  return selection.directives.some(getDirectiveMatcher(directives)) || nestedCheck && hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck);
}

function getDirectivesFromDocument(directives, doc) {
  checkDocument(doc);
  var parentPath;
  return nullIfDocIsEmpty(Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ "c"])(doc, {
    SelectionSet: {
      enter: function enter(node, _key, _parent, path) {
        var currentPath = path.join('-');

        if (!parentPath || currentPath === parentPath || !currentPath.startsWith(parentPath)) {
          if (node.selections) {
            var selectionsWithDirectives = node.selections.filter(function (selection) {
              return hasDirectivesInSelection(directives, selection);
            });

            if (hasDirectivesInSelectionSet(directives, node, false)) {
              parentPath = currentPath;
            }

            return Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])({}, node), {
              selections: selectionsWithDirectives
            });
          } else {
            return null;
          }
        }
      }
    }
  }));
}

function getArgumentMatcher(config) {
  return function argumentMatcher(argument) {
    return config.some(function (aConfig) {
      return argument.value && argument.value.kind === 'Variable' && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
    });
  };
}

function removeArgumentsFromDocument(config, doc) {
  var argMatcher = getArgumentMatcher(config);
  return nullIfDocIsEmpty(Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ "c"])(doc, {
    OperationDefinition: {
      enter: function enter(node) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])({}, node), {
          variableDefinitions: node.variableDefinitions.filter(function (varDef) {
            return !config.some(function (arg) {
              return arg.name === varDef.variable.name.value;
            });
          })
        });
      }
    },
    Field: {
      enter: function enter(node) {
        var shouldRemoveField = config.some(function (argConfig) {
          return argConfig.remove;
        });

        if (shouldRemoveField) {
          var argMatchCount_1 = 0;
          node.arguments.forEach(function (arg) {
            if (argMatcher(arg)) {
              argMatchCount_1 += 1;
            }
          });

          if (argMatchCount_1 === 1) {
            return null;
          }
        }
      }
    },
    Argument: {
      enter: function enter(node) {
        if (argMatcher(node)) {
          return null;
        }
      }
    }
  }));
}

function removeFragmentSpreadFromDocument(config, doc) {
  function enter(node) {
    if (config.some(function (def) {
      return def.name === node.name.value;
    })) {
      return null;
    }
  }

  return nullIfDocIsEmpty(Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ "c"])(doc, {
    FragmentSpread: {
      enter: enter
    },
    FragmentDefinition: {
      enter: enter
    }
  }));
}

function getAllFragmentSpreadsFromSelectionSet(selectionSet) {
  var allFragments = [];
  selectionSet.selections.forEach(function (selection) {
    if ((isField(selection) || isInlineFragment(selection)) && selection.selectionSet) {
      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function (frag) {
        return allFragments.push(frag);
      });
    } else if (selection.kind === 'FragmentSpread') {
      allFragments.push(selection);
    }
  });
  return allFragments;
}

function buildQueryFromSelectionSet(document) {
  var definition = getMainDefinition(document);
  var definitionOperation = definition.operation;

  if (definitionOperation === 'query') {
    return document;
  }

  var modifiedDoc = Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ "c"])(document, {
    OperationDefinition: {
      enter: function enter(node) {
        return Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])(Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])({}, node), {
          operation: 'query'
        });
      }
    }
  });
  return modifiedDoc;
}

function removeClientSetsFromDocument(document) {
  checkDocument(document);
  var modifiedDoc = removeDirectivesFromDocument([{
    test: function test(directive) {
      return directive.name.value === 'client';
    },
    remove: true
  }], document);

  if (modifiedDoc) {
    modifiedDoc = Object(graphql_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ "c"])(modifiedDoc, {
      FragmentDefinition: {
        enter: function enter(node) {
          if (node.selectionSet) {
            var isTypenameOnly = node.selectionSet.selections.every(function (selection) {
              return isField(selection) && selection.name.value === '__typename';
            });

            if (isTypenameOnly) {
              return null;
            }
          }
        }
      }
    });
  }

  return modifiedDoc;
}

var canUseWeakMap = typeof WeakMap === 'function' && !(typeof navigator === 'object' && navigator.product === 'ReactNative');
var toString = Object.prototype.toString;

function cloneDeep(value) {
  return cloneDeepHelper(value, new Map());
}

function cloneDeepHelper(val, seen) {
  switch (toString.call(val)) {
    case "[object Array]":
      {
        if (seen.has(val)) return seen.get(val);
        var copy_1 = val.slice(0);
        seen.set(val, copy_1);
        copy_1.forEach(function (child, i) {
          copy_1[i] = cloneDeepHelper(child, seen);
        });
        return copy_1;
      }

    case "[object Object]":
      {
        if (seen.has(val)) return seen.get(val);
        var copy_2 = Object.create(Object.getPrototypeOf(val));
        seen.set(val, copy_2);
        Object.keys(val).forEach(function (key) {
          copy_2[key] = cloneDeepHelper(val[key], seen);
        });
        return copy_2;
      }

    default:
      return val;
  }
}

function getEnv() {
  if (typeof process !== 'undefined' && "production") {
    return "production";
  }

  return 'development';
}

function isEnv(env) {
  return getEnv() === env;
}

function isProduction() {
  return isEnv('production') === true;
}

function isDevelopment() {
  return isEnv('development') === true;
}

function isTest() {
  return isEnv('test') === true;
}

function tryFunctionOrLogError(f) {
  try {
    return f();
  } catch (e) {
    if (console.error) {
      console.error(e);
    }
  }
}

function graphQLResultHasError(result) {
  return result.errors && result.errors.length;
}

function deepFreeze(o) {
  Object.freeze(o);
  Object.getOwnPropertyNames(o).forEach(function (prop) {
    if (o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  return o;
}

function maybeDeepFreeze(obj) {
  if (isDevelopment() || isTest()) {
    var symbolIsPolyfilled = typeof Symbol === 'function' && typeof Symbol('') === 'string';

    if (!symbolIsPolyfilled) {
      return deepFreeze(obj);
    }
  }

  return obj;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;

function mergeDeep() {
  var sources = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }

  return mergeDeepArray(sources);
}

function mergeDeepArray(sources) {
  var target = sources[0] || {};
  var count = sources.length;

  if (count > 1) {
    var pastCopies = [];
    target = shallowCopyForMerge(target, pastCopies);

    for (var i = 1; i < count; ++i) {
      target = mergeHelper(target, sources[i], pastCopies);
    }
  }

  return target;
}

function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

function mergeHelper(target, source, pastCopies) {
  if (isObject(source) && isObject(target)) {
    if (Object.isExtensible && !Object.isExtensible(target)) {
      target = shallowCopyForMerge(target, pastCopies);
    }

    Object.keys(source).forEach(function (sourceKey) {
      var sourceValue = source[sourceKey];

      if (hasOwnProperty.call(target, sourceKey)) {
        var targetValue = target[sourceKey];

        if (sourceValue !== targetValue) {
          target[sourceKey] = mergeHelper(shallowCopyForMerge(targetValue, pastCopies), sourceValue, pastCopies);
        }
      } else {
        target[sourceKey] = sourceValue;
      }
    });
    return target;
  }

  return source;
}

function shallowCopyForMerge(value, pastCopies) {
  if (value !== null && typeof value === 'object' && pastCopies.indexOf(value) < 0) {
    if (Array.isArray(value)) {
      value = value.slice(0);
    } else {
      value = Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])({
        __proto__: Object.getPrototypeOf(value)
      }, value);
    }

    pastCopies.push(value);
  }

  return value;
}

var haveWarned = Object.create({});

function warnOnceInDevelopment(msg, type) {
  if (type === void 0) {
    type = 'warn';
  }

  if (!isProduction() && !haveWarned[msg]) {
    if (!isTest()) {
      haveWarned[msg] = true;
    }

    if (type === 'error') {
      console.error(msg);
    } else {
      console.warn(msg);
    }
  }
}

function stripSymbols(data) {
  return JSON.parse(JSON.stringify(data));
}



/***/ }),
/* 7 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return devAssert; });
function devAssert(condition, message) {
  var booleanCondition = Boolean(condition);

  if (!booleanCondition) {
    throw new Error(message);
  }
}


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InvariantError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return invariant; });
/* unused harmony export process */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

var genericMessage = "Invariant Violation";
var _a = Object.setPrototypeOf,
    setPrototypeOf = _a === void 0 ? function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
} : _a;

var InvariantError =
/** @class */
function (_super) {
  Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "d"])(InvariantError, _super);

  function InvariantError(message) {
    if (message === void 0) {
      message = genericMessage;
    }

    var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;

    _this.framesToPop = 1;
    _this.name = genericMessage;
    setPrototypeOf(_this, InvariantError.prototype);
    return _this;
  }

  return InvariantError;
}(Error);

function invariant(condition, message) {
  if (!condition) {
    throw new InvariantError(message);
  }
}

function wrapConsoleMethod(method) {
  return function () {
    return console[method].apply(console, arguments);
  };
}

(function (invariant) {
  invariant.warn = wrapConsoleMethod("warn");
  invariant.error = wrapConsoleMethod("error");
})(invariant || (invariant = {})); // Code that uses ts-invariant with rollup-plugin-invariant may want to
// import this process stub to avoid errors evaluating process.env.NODE_ENV.
// However, because most ESM-to-CJS compilers will rewrite the process import
// as tsInvariant.process, which prevents proper replacement by minifiers, we
// also attempt to define the stub globally when it is not already defined.


var processStub = {
  env: {}
};

if (typeof process === "object") {
  processStub = process;
} else try {
  // Using Function to evaluate this assignment in global scope also escapes
  // the strict mode of the current module, thereby allowing the assignment.
  // Inspired by https://github.com/facebook/regenerator/pull/369.
  Function("stub", "process = stub")(processStub);
} catch (atLeastWeTried) {// The assignment can fail if a Content Security Policy heavy-handedly
  // forbids Function usage. In those environments, developers should take
  // extra care to replace process.env.NODE_ENV in their production builds,
  // or define an appropriate global.process polyfill.
}

var invariant$1 = invariant;
/* unused harmony default export */ var _unused_webpack_default_export = (invariant$1);


/***/ }),
/* 9 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DirectiveLocation; });
/**
 * The set of allowed directive location values.
 */
var DirectiveLocation = Object.freeze({
  // Request Definitions
  QUERY: 'QUERY',
  MUTATION: 'MUTATION',
  SUBSCRIPTION: 'SUBSCRIPTION',
  FIELD: 'FIELD',
  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',
  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',
  INLINE_FRAGMENT: 'INLINE_FRAGMENT',
  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',
  // Type System Definitions
  SCHEMA: 'SCHEMA',
  SCALAR: 'SCALAR',
  OBJECT: 'OBJECT',
  FIELD_DEFINITION: 'FIELD_DEFINITION',
  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',
  INTERFACE: 'INTERFACE',
  UNION: 'UNION',
  ENUM: 'ENUM',
  ENUM_VALUE: 'ENUM_VALUE',
  INPUT_OBJECT: 'INPUT_OBJECT',
  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'
});
/**
 * The enum type representing the directive location values.
 */


/***/ }),
/* 10 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* eslint-disable no-redeclare */
// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/2221
var objectValues = Object.values || function (obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
};

/* harmony default export */ __webpack_exports__["a"] = (objectValues);


/***/ }),
/* 11 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/graphql/version.mjs
/**
 * Note: This file is autogenerated using "resources/gen-version.js" script and
 * automatically updated by "yarn version" command.
 */

/**
 * A string containing the version of the GraphQL.js library
 */
var version = '14.6.0';
/**
 * An object containing the components of the GraphQL.js version string
 */

var versionInfo = Object.freeze({
  major: 14,
  minor: 6,
  patch: 0,
  preReleaseTag: null
});

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/isPromise.mjs
var isPromise = __webpack_require__(23);

// EXTERNAL MODULE: ./node_modules/graphql/language/parser.mjs
var parser = __webpack_require__(48);

// EXTERNAL MODULE: ./node_modules/graphql/validation/validate.mjs
var validate = __webpack_require__(56);

// EXTERNAL MODULE: ./node_modules/graphql/type/validate.mjs
var type_validate = __webpack_require__(55);

// EXTERNAL MODULE: ./node_modules/graphql/execution/execute.mjs + 3 modules
var execute = __webpack_require__(33);

// CONCATENATED MODULE: ./node_modules/graphql/graphql.mjs





/**
 * This is the primary entry point function for fulfilling GraphQL operations
 * by parsing, validating, and executing a GraphQL document along side a
 * GraphQL schema.
 *
 * More sophisticated GraphQL servers, such as those which persist queries,
 * may wish to separate the validation and execution phases to a static time
 * tooling step, and a server runtime step.
 *
 * Accepts either an object with named arguments, or individual arguments:
 *
 * schema:
 *    The GraphQL type system to use when validating and executing a query.
 * source:
 *    A GraphQL language formatted string representing the requested operation.
 * rootValue:
 *    The value provided as the first argument to resolver functions on the top
 *    level type (e.g. the query object type).
 * contextValue:
 *    The context value is provided as an argument to resolver functions after
 *    field arguments. It is used to pass shared information useful at any point
 *    during executing this query, for example the currently logged in user and
 *    connections to databases or other services.
 * variableValues:
 *    A mapping of variable name to runtime value to use for all variables
 *    defined in the requestString.
 * operationName:
 *    The name of the operation to use if requestString contains multiple
 *    possible operations. Can be omitted if requestString contains only
 *    one operation.
 * fieldResolver:
 *    A resolver function to use when one is not provided by the schema.
 *    If not provided, the default field resolver is used (which looks for a
 *    value or method on the source value with the field's name).
 * typeResolver:
 *    A type resolver function to use when none is provided by the schema.
 *    If not provided, the default type resolver is used (which looks for a
 *    `__typename` field or alternatively calls the `isTypeOf` method).
 */

function graphql(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
  var _arguments = arguments;

  /* eslint-enable no-redeclare */
  // Always return a Promise for a consistent API.
  return new Promise(function (resolve) {
    return resolve( // Extract arguments from object args if provided.
    _arguments.length === 1 ? graphqlImpl(argsOrSchema) : graphqlImpl({
      schema: argsOrSchema,
      source: source,
      rootValue: rootValue,
      contextValue: contextValue,
      variableValues: variableValues,
      operationName: operationName,
      fieldResolver: fieldResolver,
      typeResolver: typeResolver
    }));
  });
}
/**
 * The graphqlSync function also fulfills GraphQL operations by parsing,
 * validating, and executing a GraphQL document along side a GraphQL schema.
 * However, it guarantees to complete synchronously (or throw an error) assuming
 * that all field resolvers are also synchronous.
 */

function graphqlSync(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
  /* eslint-enable no-redeclare */
  // Extract arguments from object args if provided.
  var result = arguments.length === 1 ? graphqlImpl(argsOrSchema) : graphqlImpl({
    schema: argsOrSchema,
    source: source,
    rootValue: rootValue,
    contextValue: contextValue,
    variableValues: variableValues,
    operationName: operationName,
    fieldResolver: fieldResolver,
    typeResolver: typeResolver
  }); // Assert that the execution was synchronous.

  if (Object(isPromise["a" /* default */])(result)) {
    throw new Error('GraphQL execution failed to complete synchronously.');
  }

  return result;
}

function graphqlImpl(args) {
  var schema = args.schema,
      source = args.source,
      rootValue = args.rootValue,
      contextValue = args.contextValue,
      variableValues = args.variableValues,
      operationName = args.operationName,
      fieldResolver = args.fieldResolver,
      typeResolver = args.typeResolver; // Validate Schema

  var schemaValidationErrors = Object(type_validate["b" /* validateSchema */])(schema);

  if (schemaValidationErrors.length > 0) {
    return {
      errors: schemaValidationErrors
    };
  } // Parse


  var document;

  try {
    document = Object(parser["parse"])(source);
  } catch (syntaxError) {
    return {
      errors: [syntaxError]
    };
  } // Validate


  var validationErrors = Object(validate["c" /* validate */])(schema, document);

  if (validationErrors.length > 0) {
    return {
      errors: validationErrors
    };
  } // Execute


  return Object(execute["g" /* execute */])({
    schema: schema,
    document: document,
    rootValue: rootValue,
    contextValue: contextValue,
    variableValues: variableValues,
    operationName: operationName,
    fieldResolver: fieldResolver,
    typeResolver: typeResolver
  });
}

// EXTERNAL MODULE: ./node_modules/graphql/type/schema.mjs
var type_schema = __webpack_require__(36);

// EXTERNAL MODULE: ./node_modules/graphql/type/directives.mjs
var directives = __webpack_require__(15);

// EXTERNAL MODULE: ./node_modules/graphql/type/definition.mjs + 1 modules
var definition = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/graphql/type/scalars.mjs + 2 modules
var scalars = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/graphql/type/introspection.mjs
var introspection = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/graphql/language/source.mjs
var language_source = __webpack_require__(58);

// EXTERNAL MODULE: ./node_modules/graphql/language/location.mjs
var language_location = __webpack_require__(66);

// EXTERNAL MODULE: ./node_modules/graphql/language/printLocation.mjs
var printLocation = __webpack_require__(87);

// EXTERNAL MODULE: ./node_modules/graphql/language/lexer.mjs
var lexer = __webpack_require__(67);

// EXTERNAL MODULE: ./node_modules/graphql/language/tokenKind.mjs
var tokenKind = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/graphql/language/printer.mjs
var printer = __webpack_require__(16);

// EXTERNAL MODULE: ./node_modules/graphql/language/visitor.mjs
var visitor = __webpack_require__(14);

// EXTERNAL MODULE: ./node_modules/graphql/language/kinds.mjs
var kinds = __webpack_require__(2);

// EXTERNAL MODULE: ./node_modules/graphql/language/directiveLocation.mjs
var directiveLocation = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/graphql/language/predicates.mjs
var predicates = __webpack_require__(38);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/Path.mjs
var Path = __webpack_require__(21);

// EXTERNAL MODULE: ./node_modules/graphql/execution/values.mjs
var values = __webpack_require__(50);

// EXTERNAL MODULE: ./node_modules/iterall/index.mjs
var iterall = __webpack_require__(24);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/inspect.mjs
var inspect = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/graphql/error/GraphQLError.mjs
var GraphQLError = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/graphql/error/locatedError.mjs
var locatedError = __webpack_require__(54);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/getOperationRootType.mjs
var getOperationRootType = __webpack_require__(53);

// CONCATENATED MODULE: ./node_modules/graphql/subscription/mapAsyncIterator.mjs
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



/**
 * Given an AsyncIterable and a callback function, return an AsyncIterator
 * which produces values mapped via calling the callback function.
 */
function mapAsyncIterator(iterable, callback, rejectCallback) {
  var iterator = Object(iterall["getAsyncIterator"])(iterable);
  var $return;
  var abruptClose; // $FlowFixMe(>=0.68.0)

  if (typeof iterator.return === 'function') {
    $return = iterator.return;

    abruptClose = function abruptClose(error) {
      var rethrow = function rethrow() {
        return Promise.reject(error);
      };

      return $return.call(iterator).then(rethrow, rethrow);
    };
  }

  function mapResult(result) {
    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
  }

  var mapReject;

  if (rejectCallback) {
    // Capture rejectCallback to ensure it cannot be null.
    var reject = rejectCallback;

    mapReject = function mapReject(error) {
      return asyncMapValue(error, reject).then(iteratorResult, abruptClose);
    };
  }
  /* TODO: Flow doesn't support symbols as keys:
     https://github.com/facebook/flow/issues/3258 */


  return _defineProperty({
    next: function next() {
      return iterator.next().then(mapResult, mapReject);
    },
    return: function _return() {
      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({
        value: undefined,
        done: true
      });
    },
    throw: function _throw(error) {
      // $FlowFixMe(>=0.68.0)
      if (typeof iterator.throw === 'function') {
        return iterator.throw(error).then(mapResult, mapReject);
      }

      return Promise.reject(error).catch(abruptClose);
    }
  }, iterall["$$asyncIterator"], function () {
    return this;
  });
}

function asyncMapValue(value, callback) {
  return new Promise(function (resolve) {
    return resolve(callback(value));
  });
}

function iteratorResult(value) {
  return {
    value: value,
    done: false
  };
}

// CONCATENATED MODULE: ./node_modules/graphql/subscription/subscribe.mjs








function subscribe(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {
  /* eslint-enable no-redeclare */
  // Extract arguments from object args if provided.
  return arguments.length === 1 ? subscribeImpl(argsOrSchema) : subscribeImpl({
    schema: argsOrSchema,
    document: document,
    rootValue: rootValue,
    contextValue: contextValue,
    variableValues: variableValues,
    operationName: operationName,
    fieldResolver: fieldResolver,
    subscribeFieldResolver: subscribeFieldResolver
  });
}
/**
 * This function checks if the error is a GraphQLError. If it is, report it as
 * an ExecutionResult, containing only errors and no data. Otherwise treat the
 * error as a system-class error and re-throw it.
 */

function reportGraphQLError(error) {
  if (error instanceof GraphQLError["a" /* GraphQLError */]) {
    return {
      errors: [error]
    };
  }

  throw error;
}

function subscribeImpl(args) {
  var schema = args.schema,
      document = args.document,
      rootValue = args.rootValue,
      contextValue = args.contextValue,
      variableValues = args.variableValues,
      operationName = args.operationName,
      fieldResolver = args.fieldResolver,
      subscribeFieldResolver = args.subscribeFieldResolver;
  var sourcePromise = createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver); // For each payload yielded from a subscription, map it over the normal
  // GraphQL `execute` function, with `payload` as the rootValue.
  // This implements the "MapSourceToResponseEvent" algorithm described in
  // the GraphQL specification. The `execute` function provides the
  // "ExecuteSubscriptionEvent" algorithm, as it is nearly identical to the
  // "ExecuteQuery" algorithm, for which `execute` is also used.

  var mapSourceToResponse = function mapSourceToResponse(payload) {
    return Object(execute["g" /* execute */])(schema, document, payload, contextValue, variableValues, operationName, fieldResolver);
  }; // Resolve the Source Stream, then map every source value to a
  // ExecutionResult value as described above.


  return sourcePromise.then(function (resultOrStream) {
    return (// Note: Flow can't refine isAsyncIterable, so explicit casts are used.
      Object(iterall["isAsyncIterable"])(resultOrStream) ? mapAsyncIterator(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream
    );
  });
}
/**
 * Implements the "CreateSourceEventStream" algorithm described in the
 * GraphQL specification, resolving the subscription source event stream.
 *
 * Returns a Promise which resolves to either an AsyncIterable (if successful)
 * or an ExecutionResult (error). The promise will be rejected if the schema or
 * other arguments to this function are invalid, or if the resolved event stream
 * is not an async iterable.
 *
 * If the client-provided arguments to this function do not result in a
 * compliant subscription, a GraphQL Response (ExecutionResult) with
 * descriptive errors and no data will be returned.
 *
 * If the the source stream could not be created due to faulty subscription
 * resolver logic or underlying systems, the promise will resolve to a single
 * ExecutionResult containing `errors` and no `data`.
 *
 * If the operation succeeded, the promise resolves to the AsyncIterable for the
 * event stream returned by the resolver.
 *
 * A Source Event Stream represents a sequence of events, each of which triggers
 * a GraphQL execution for that event.
 *
 * This may be useful when hosting the stateful subscription service in a
 * different process or machine than the stateless GraphQL execution engine,
 * or otherwise separating these two steps. For more on this, see the
 * "Supporting Subscriptions at Scale" information in the GraphQL specification.
 */


function createSourceEventStream(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver) {
  // If arguments are missing or incorrectly typed, this is an internal
  // developer mistake which should throw an early error.
  Object(execute["a" /* assertValidExecutionArguments */])(schema, document, variableValues);

  try {
    // If a valid context cannot be created due to incorrect arguments,
    // this will throw an error.
    var exeContext = Object(execute["b" /* buildExecutionContext */])(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver); // Return early errors if execution context failed.

    if (Array.isArray(exeContext)) {
      return Promise.resolve({
        errors: exeContext
      });
    }

    var type = Object(getOperationRootType["a" /* getOperationRootType */])(schema, exeContext.operation);
    var fields = Object(execute["d" /* collectFields */])(exeContext, type, exeContext.operation.selectionSet, Object.create(null), Object.create(null));
    var responseNames = Object.keys(fields);
    var responseName = responseNames[0];
    var fieldNodes = fields[responseName];
    var fieldNode = fieldNodes[0];
    var fieldName = fieldNode.name.value;
    var fieldDef = Object(execute["h" /* getFieldDef */])(schema, type, fieldName);

    if (!fieldDef) {
      throw new GraphQLError["a" /* GraphQLError */]("The subscription field \"".concat(fieldName, "\" is not defined."), fieldNodes);
    } // Call the `subscribe()` resolver or the default resolver to produce an
    // AsyncIterable yielding raw payloads.


    var resolveFn = fieldDef.subscribe || exeContext.fieldResolver;
    var path = Object(Path["a" /* addPath */])(undefined, responseName);
    var info = Object(execute["c" /* buildResolveInfo */])(exeContext, fieldDef, fieldNodes, type, path); // resolveFieldValueOrError implements the "ResolveFieldEventStream"
    // algorithm from GraphQL specification. It differs from
    // "ResolveFieldValue" due to providing a different `resolveFn`.

    var result = Object(execute["i" /* resolveFieldValueOrError */])(exeContext, fieldDef, fieldNodes, resolveFn, rootValue, info); // Coerce to Promise for easier error handling and consistent return type.

    return Promise.resolve(result).then(function (eventStream) {
      // If eventStream is an Error, rethrow a located error.
      if (eventStream instanceof Error) {
        return {
          errors: [Object(locatedError["a" /* locatedError */])(eventStream, fieldNodes, Object(Path["b" /* pathToArray */])(path))]
        };
      } // Assert field returned an event stream, otherwise yield an error.


      if (Object(iterall["isAsyncIterable"])(eventStream)) {
        // Note: isAsyncIterable above ensures this will be correct.
        return eventStream;
      }

      throw new Error('Subscription field must return Async Iterable. Received: ' + Object(inspect["a" /* default */])(eventStream));
    });
  } catch (error) {
    // As with reportGraphQLError above, if the error is a GraphQLError, report
    // it as an ExecutionResult; otherwise treat it as a system-class error and
    // re-throw it.
    return error instanceof GraphQLError["a" /* GraphQLError */] ? Promise.resolve({
      errors: [error]
    }) : Promise.reject(error);
  }
}

// EXTERNAL MODULE: ./node_modules/graphql/validation/ValidationContext.mjs
var ValidationContext = __webpack_require__(68);

// EXTERNAL MODULE: ./node_modules/graphql/validation/specifiedRules.mjs
var specifiedRules = __webpack_require__(88);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/ExecutableDefinitions.mjs
var ExecutableDefinitions = __webpack_require__(137);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/FieldsOnCorrectType.mjs
var FieldsOnCorrectType = __webpack_require__(144);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/FragmentsOnCompositeTypes.mjs
var FragmentsOnCompositeTypes = __webpack_require__(141);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/KnownArgumentNames.mjs
var KnownArgumentNames = __webpack_require__(92);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/KnownDirectives.mjs
var KnownDirectives = __webpack_require__(90);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/KnownFragmentNames.mjs
var KnownFragmentNames = __webpack_require__(146);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/KnownTypeNames.mjs
var KnownTypeNames = __webpack_require__(89);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/LoneAnonymousOperation.mjs
var LoneAnonymousOperation = __webpack_require__(139);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/NoFragmentCycles.mjs
var NoFragmentCycles = __webpack_require__(149);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/NoUndefinedVariables.mjs
var NoUndefinedVariables = __webpack_require__(151);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/NoUnusedFragments.mjs
var NoUnusedFragments = __webpack_require__(147);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/NoUnusedVariables.mjs
var NoUnusedVariables = __webpack_require__(152);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/OverlappingFieldsCanBeMerged.mjs
var OverlappingFieldsCanBeMerged = __webpack_require__(154);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/PossibleFragmentSpreads.mjs
var PossibleFragmentSpreads = __webpack_require__(148);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/ProvidedRequiredArguments.mjs
var ProvidedRequiredArguments = __webpack_require__(94);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/ScalarLeafs.mjs
var ScalarLeafs = __webpack_require__(143);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/SingleFieldSubscriptions.mjs
var SingleFieldSubscriptions = __webpack_require__(140);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/UniqueArgumentNames.mjs
var UniqueArgumentNames = __webpack_require__(93);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/UniqueDirectivesPerLocation.mjs
var UniqueDirectivesPerLocation = __webpack_require__(91);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/UniqueFragmentNames.mjs
var UniqueFragmentNames = __webpack_require__(145);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/UniqueInputFieldNames.mjs
var UniqueInputFieldNames = __webpack_require__(95);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/UniqueOperationNames.mjs
var UniqueOperationNames = __webpack_require__(138);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/UniqueVariableNames.mjs
var UniqueVariableNames = __webpack_require__(150);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/ValuesOfCorrectType.mjs
var ValuesOfCorrectType = __webpack_require__(76);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/VariablesAreInputTypes.mjs
var VariablesAreInputTypes = __webpack_require__(142);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/VariablesInAllowedPosition.mjs
var VariablesInAllowedPosition = __webpack_require__(153);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/LoneSchemaDefinition.mjs
var LoneSchemaDefinition = __webpack_require__(155);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/UniqueOperationTypes.mjs
var UniqueOperationTypes = __webpack_require__(156);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/UniqueTypeNames.mjs
var UniqueTypeNames = __webpack_require__(157);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/UniqueEnumValueNames.mjs
var UniqueEnumValueNames = __webpack_require__(158);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/UniqueFieldDefinitionNames.mjs
var UniqueFieldDefinitionNames = __webpack_require__(159);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/UniqueDirectiveNames.mjs
var UniqueDirectiveNames = __webpack_require__(160);

// EXTERNAL MODULE: ./node_modules/graphql/validation/rules/PossibleTypeExtensions.mjs
var PossibleTypeExtensions = __webpack_require__(161);

// EXTERNAL MODULE: ./node_modules/graphql/error/syntaxError.mjs
var syntaxError = __webpack_require__(25);

// EXTERNAL MODULE: ./node_modules/graphql/error/formatError.mjs
var formatError = __webpack_require__(96);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/introspectionQuery.mjs
var introspectionQuery = __webpack_require__(64);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/getOperationAST.mjs
var getOperationAST = __webpack_require__(97);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/introspectionFromSchema.mjs
var introspectionFromSchema = __webpack_require__(98);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/buildClientSchema.mjs
var buildClientSchema = __webpack_require__(99);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/buildASTSchema.mjs
var buildASTSchema = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/extendSchema.mjs
var extendSchema = __webpack_require__(100);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/lexicographicSortSchema.mjs
var lexicographicSortSchema = __webpack_require__(101);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/schemaPrinter.mjs
var schemaPrinter = __webpack_require__(69);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/typeFromAST.mjs
var typeFromAST = __webpack_require__(19);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/valueFromAST.mjs
var valueFromAST = __webpack_require__(45);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/valueFromASTUntyped.mjs
var valueFromASTUntyped = __webpack_require__(72);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/astFromValue.mjs
var astFromValue = __webpack_require__(47);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/TypeInfo.mjs
var TypeInfo = __webpack_require__(44);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/coerceInputValue.mjs
var coerceInputValue = __webpack_require__(52);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/coerceValue.mjs
var coerceValue = __webpack_require__(73);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/isValidJSValue.mjs
var isValidJSValue = __webpack_require__(102);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/isValidLiteralValue.mjs
var isValidLiteralValue = __webpack_require__(103);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/concatAST.mjs
var concatAST = __webpack_require__(104);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/separateOperations.mjs
var separateOperations = __webpack_require__(105);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/stripIgnoredCharacters.mjs
var stripIgnoredCharacters = __webpack_require__(106);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/typeComparators.mjs
var typeComparators = __webpack_require__(35);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/assertValidName.mjs
var assertValidName = __webpack_require__(63);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/findBreakingChanges.mjs
var findBreakingChanges = __webpack_require__(60);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/findDeprecatedUsages.mjs
var findDeprecatedUsages = __webpack_require__(107);

// CONCATENATED MODULE: ./node_modules/graphql/index.mjs
/* concated harmony reexport version */__webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/* concated harmony reexport versionInfo */__webpack_require__.d(__webpack_exports__, "versionInfo", function() { return versionInfo; });
/* concated harmony reexport graphql */__webpack_require__.d(__webpack_exports__, "graphql", function() { return graphql; });
/* concated harmony reexport graphqlSync */__webpack_require__.d(__webpack_exports__, "graphqlSync", function() { return graphqlSync; });
/* concated harmony reexport GraphQLSchema */__webpack_require__.d(__webpack_exports__, "GraphQLSchema", function() { return type_schema["a" /* GraphQLSchema */]; });
/* concated harmony reexport GraphQLDirective */__webpack_require__.d(__webpack_exports__, "GraphQLDirective", function() { return directives["c" /* GraphQLDirective */]; });
/* concated harmony reexport GraphQLScalarType */__webpack_require__.d(__webpack_exports__, "GraphQLScalarType", function() { return definition["g" /* GraphQLScalarType */]; });
/* concated harmony reexport GraphQLObjectType */__webpack_require__.d(__webpack_exports__, "GraphQLObjectType", function() { return definition["f" /* GraphQLObjectType */]; });
/* concated harmony reexport GraphQLInterfaceType */__webpack_require__.d(__webpack_exports__, "GraphQLInterfaceType", function() { return definition["c" /* GraphQLInterfaceType */]; });
/* concated harmony reexport GraphQLUnionType */__webpack_require__.d(__webpack_exports__, "GraphQLUnionType", function() { return definition["h" /* GraphQLUnionType */]; });
/* concated harmony reexport GraphQLEnumType */__webpack_require__.d(__webpack_exports__, "GraphQLEnumType", function() { return definition["a" /* GraphQLEnumType */]; });
/* concated harmony reexport GraphQLInputObjectType */__webpack_require__.d(__webpack_exports__, "GraphQLInputObjectType", function() { return definition["b" /* GraphQLInputObjectType */]; });
/* concated harmony reexport GraphQLList */__webpack_require__.d(__webpack_exports__, "GraphQLList", function() { return definition["d" /* GraphQLList */]; });
/* concated harmony reexport GraphQLNonNull */__webpack_require__.d(__webpack_exports__, "GraphQLNonNull", function() { return definition["e" /* GraphQLNonNull */]; });
/* concated harmony reexport specifiedScalarTypes */__webpack_require__.d(__webpack_exports__, "specifiedScalarTypes", function() { return scalars["g" /* specifiedScalarTypes */]; });
/* concated harmony reexport GraphQLInt */__webpack_require__.d(__webpack_exports__, "GraphQLInt", function() { return scalars["d" /* GraphQLInt */]; });
/* concated harmony reexport GraphQLFloat */__webpack_require__.d(__webpack_exports__, "GraphQLFloat", function() { return scalars["b" /* GraphQLFloat */]; });
/* concated harmony reexport GraphQLString */__webpack_require__.d(__webpack_exports__, "GraphQLString", function() { return scalars["e" /* GraphQLString */]; });
/* concated harmony reexport GraphQLBoolean */__webpack_require__.d(__webpack_exports__, "GraphQLBoolean", function() { return scalars["a" /* GraphQLBoolean */]; });
/* concated harmony reexport GraphQLID */__webpack_require__.d(__webpack_exports__, "GraphQLID", function() { return scalars["c" /* GraphQLID */]; });
/* concated harmony reexport specifiedDirectives */__webpack_require__.d(__webpack_exports__, "specifiedDirectives", function() { return directives["i" /* specifiedDirectives */]; });
/* concated harmony reexport GraphQLIncludeDirective */__webpack_require__.d(__webpack_exports__, "GraphQLIncludeDirective", function() { return directives["d" /* GraphQLIncludeDirective */]; });
/* concated harmony reexport GraphQLSkipDirective */__webpack_require__.d(__webpack_exports__, "GraphQLSkipDirective", function() { return directives["e" /* GraphQLSkipDirective */]; });
/* concated harmony reexport GraphQLDeprecatedDirective */__webpack_require__.d(__webpack_exports__, "GraphQLDeprecatedDirective", function() { return directives["b" /* GraphQLDeprecatedDirective */]; });
/* concated harmony reexport TypeKind */__webpack_require__.d(__webpack_exports__, "TypeKind", function() { return introspection["b" /* TypeKind */]; });
/* concated harmony reexport DEFAULT_DEPRECATION_REASON */__webpack_require__.d(__webpack_exports__, "DEFAULT_DEPRECATION_REASON", function() { return directives["a" /* DEFAULT_DEPRECATION_REASON */]; });
/* concated harmony reexport introspectionTypes */__webpack_require__.d(__webpack_exports__, "introspectionTypes", function() { return introspection["m" /* introspectionTypes */]; });
/* concated harmony reexport __Schema */__webpack_require__.d(__webpack_exports__, "__Schema", function() { return introspection["j" /* __Schema */]; });
/* concated harmony reexport __Directive */__webpack_require__.d(__webpack_exports__, "__Directive", function() { return introspection["e" /* __Directive */]; });
/* concated harmony reexport __DirectiveLocation */__webpack_require__.d(__webpack_exports__, "__DirectiveLocation", function() { return introspection["f" /* __DirectiveLocation */]; });
/* concated harmony reexport __Type */__webpack_require__.d(__webpack_exports__, "__Type", function() { return introspection["k" /* __Type */]; });
/* concated harmony reexport __Field */__webpack_require__.d(__webpack_exports__, "__Field", function() { return introspection["h" /* __Field */]; });
/* concated harmony reexport __InputValue */__webpack_require__.d(__webpack_exports__, "__InputValue", function() { return introspection["i" /* __InputValue */]; });
/* concated harmony reexport __EnumValue */__webpack_require__.d(__webpack_exports__, "__EnumValue", function() { return introspection["g" /* __EnumValue */]; });
/* concated harmony reexport __TypeKind */__webpack_require__.d(__webpack_exports__, "__TypeKind", function() { return introspection["l" /* __TypeKind */]; });
/* concated harmony reexport SchemaMetaFieldDef */__webpack_require__.d(__webpack_exports__, "SchemaMetaFieldDef", function() { return introspection["a" /* SchemaMetaFieldDef */]; });
/* concated harmony reexport TypeMetaFieldDef */__webpack_require__.d(__webpack_exports__, "TypeMetaFieldDef", function() { return introspection["c" /* TypeMetaFieldDef */]; });
/* concated harmony reexport TypeNameMetaFieldDef */__webpack_require__.d(__webpack_exports__, "TypeNameMetaFieldDef", function() { return introspection["d" /* TypeNameMetaFieldDef */]; });
/* concated harmony reexport isSchema */__webpack_require__.d(__webpack_exports__, "isSchema", function() { return type_schema["c" /* isSchema */]; });
/* concated harmony reexport isDirective */__webpack_require__.d(__webpack_exports__, "isDirective", function() { return directives["g" /* isDirective */]; });
/* concated harmony reexport isType */__webpack_require__.d(__webpack_exports__, "isType", function() { return definition["S" /* isType */]; });
/* concated harmony reexport isScalarType */__webpack_require__.d(__webpack_exports__, "isScalarType", function() { return definition["R" /* isScalarType */]; });
/* concated harmony reexport isObjectType */__webpack_require__.d(__webpack_exports__, "isObjectType", function() { return definition["N" /* isObjectType */]; });
/* concated harmony reexport isInterfaceType */__webpack_require__.d(__webpack_exports__, "isInterfaceType", function() { return definition["H" /* isInterfaceType */]; });
/* concated harmony reexport isUnionType */__webpack_require__.d(__webpack_exports__, "isUnionType", function() { return definition["T" /* isUnionType */]; });
/* concated harmony reexport isEnumType */__webpack_require__.d(__webpack_exports__, "isEnumType", function() { return definition["E" /* isEnumType */]; });
/* concated harmony reexport isInputObjectType */__webpack_require__.d(__webpack_exports__, "isInputObjectType", function() { return definition["F" /* isInputObjectType */]; });
/* concated harmony reexport isListType */__webpack_require__.d(__webpack_exports__, "isListType", function() { return definition["J" /* isListType */]; });
/* concated harmony reexport isNonNullType */__webpack_require__.d(__webpack_exports__, "isNonNullType", function() { return definition["L" /* isNonNullType */]; });
/* concated harmony reexport isInputType */__webpack_require__.d(__webpack_exports__, "isInputType", function() { return definition["G" /* isInputType */]; });
/* concated harmony reexport isOutputType */__webpack_require__.d(__webpack_exports__, "isOutputType", function() { return definition["O" /* isOutputType */]; });
/* concated harmony reexport isLeafType */__webpack_require__.d(__webpack_exports__, "isLeafType", function() { return definition["I" /* isLeafType */]; });
/* concated harmony reexport isCompositeType */__webpack_require__.d(__webpack_exports__, "isCompositeType", function() { return definition["D" /* isCompositeType */]; });
/* concated harmony reexport isAbstractType */__webpack_require__.d(__webpack_exports__, "isAbstractType", function() { return definition["C" /* isAbstractType */]; });
/* concated harmony reexport isWrappingType */__webpack_require__.d(__webpack_exports__, "isWrappingType", function() { return definition["U" /* isWrappingType */]; });
/* concated harmony reexport isNullableType */__webpack_require__.d(__webpack_exports__, "isNullableType", function() { return definition["M" /* isNullableType */]; });
/* concated harmony reexport isNamedType */__webpack_require__.d(__webpack_exports__, "isNamedType", function() { return definition["K" /* isNamedType */]; });
/* concated harmony reexport isRequiredArgument */__webpack_require__.d(__webpack_exports__, "isRequiredArgument", function() { return definition["P" /* isRequiredArgument */]; });
/* concated harmony reexport isRequiredInputField */__webpack_require__.d(__webpack_exports__, "isRequiredInputField", function() { return definition["Q" /* isRequiredInputField */]; });
/* concated harmony reexport isSpecifiedScalarType */__webpack_require__.d(__webpack_exports__, "isSpecifiedScalarType", function() { return scalars["f" /* isSpecifiedScalarType */]; });
/* concated harmony reexport isIntrospectionType */__webpack_require__.d(__webpack_exports__, "isIntrospectionType", function() { return introspection["n" /* isIntrospectionType */]; });
/* concated harmony reexport isSpecifiedDirective */__webpack_require__.d(__webpack_exports__, "isSpecifiedDirective", function() { return directives["h" /* isSpecifiedDirective */]; });
/* concated harmony reexport assertSchema */__webpack_require__.d(__webpack_exports__, "assertSchema", function() { return type_schema["b" /* assertSchema */]; });
/* concated harmony reexport assertDirective */__webpack_require__.d(__webpack_exports__, "assertDirective", function() { return directives["f" /* assertDirective */]; });
/* concated harmony reexport assertType */__webpack_require__.d(__webpack_exports__, "assertType", function() { return definition["x" /* assertType */]; });
/* concated harmony reexport assertScalarType */__webpack_require__.d(__webpack_exports__, "assertScalarType", function() { return definition["w" /* assertScalarType */]; });
/* concated harmony reexport assertObjectType */__webpack_require__.d(__webpack_exports__, "assertObjectType", function() { return definition["u" /* assertObjectType */]; });
/* concated harmony reexport assertInterfaceType */__webpack_require__.d(__webpack_exports__, "assertInterfaceType", function() { return definition["o" /* assertInterfaceType */]; });
/* concated harmony reexport assertUnionType */__webpack_require__.d(__webpack_exports__, "assertUnionType", function() { return definition["y" /* assertUnionType */]; });
/* concated harmony reexport assertEnumType */__webpack_require__.d(__webpack_exports__, "assertEnumType", function() { return definition["l" /* assertEnumType */]; });
/* concated harmony reexport assertInputObjectType */__webpack_require__.d(__webpack_exports__, "assertInputObjectType", function() { return definition["m" /* assertInputObjectType */]; });
/* concated harmony reexport assertListType */__webpack_require__.d(__webpack_exports__, "assertListType", function() { return definition["q" /* assertListType */]; });
/* concated harmony reexport assertNonNullType */__webpack_require__.d(__webpack_exports__, "assertNonNullType", function() { return definition["s" /* assertNonNullType */]; });
/* concated harmony reexport assertInputType */__webpack_require__.d(__webpack_exports__, "assertInputType", function() { return definition["n" /* assertInputType */]; });
/* concated harmony reexport assertOutputType */__webpack_require__.d(__webpack_exports__, "assertOutputType", function() { return definition["v" /* assertOutputType */]; });
/* concated harmony reexport assertLeafType */__webpack_require__.d(__webpack_exports__, "assertLeafType", function() { return definition["p" /* assertLeafType */]; });
/* concated harmony reexport assertCompositeType */__webpack_require__.d(__webpack_exports__, "assertCompositeType", function() { return definition["k" /* assertCompositeType */]; });
/* concated harmony reexport assertAbstractType */__webpack_require__.d(__webpack_exports__, "assertAbstractType", function() { return definition["j" /* assertAbstractType */]; });
/* concated harmony reexport assertWrappingType */__webpack_require__.d(__webpack_exports__, "assertWrappingType", function() { return definition["z" /* assertWrappingType */]; });
/* concated harmony reexport assertNullableType */__webpack_require__.d(__webpack_exports__, "assertNullableType", function() { return definition["t" /* assertNullableType */]; });
/* concated harmony reexport assertNamedType */__webpack_require__.d(__webpack_exports__, "assertNamedType", function() { return definition["r" /* assertNamedType */]; });
/* concated harmony reexport getNullableType */__webpack_require__.d(__webpack_exports__, "getNullableType", function() { return definition["B" /* getNullableType */]; });
/* concated harmony reexport getNamedType */__webpack_require__.d(__webpack_exports__, "getNamedType", function() { return definition["A" /* getNamedType */]; });
/* concated harmony reexport validateSchema */__webpack_require__.d(__webpack_exports__, "validateSchema", function() { return type_validate["b" /* validateSchema */]; });
/* concated harmony reexport assertValidSchema */__webpack_require__.d(__webpack_exports__, "assertValidSchema", function() { return type_validate["a" /* assertValidSchema */]; });
/* concated harmony reexport Source */__webpack_require__.d(__webpack_exports__, "Source", function() { return language_source["a" /* Source */]; });
/* concated harmony reexport getLocation */__webpack_require__.d(__webpack_exports__, "getLocation", function() { return language_location["a" /* getLocation */]; });
/* concated harmony reexport printLocation */__webpack_require__.d(__webpack_exports__, "printLocation", function() { return printLocation["a" /* printLocation */]; });
/* concated harmony reexport printSourceLocation */__webpack_require__.d(__webpack_exports__, "printSourceLocation", function() { return printLocation["b" /* printSourceLocation */]; });
/* concated harmony reexport createLexer */__webpack_require__.d(__webpack_exports__, "createLexer", function() { return lexer["a" /* createLexer */]; });
/* concated harmony reexport TokenKind */__webpack_require__.d(__webpack_exports__, "TokenKind", function() { return tokenKind["a" /* TokenKind */]; });
/* concated harmony reexport parse */__webpack_require__.d(__webpack_exports__, "parse", function() { return parser["parse"]; });
/* concated harmony reexport parseValue */__webpack_require__.d(__webpack_exports__, "parseValue", function() { return parser["parseValue"]; });
/* concated harmony reexport parseType */__webpack_require__.d(__webpack_exports__, "parseType", function() { return parser["parseType"]; });
/* concated harmony reexport print */__webpack_require__.d(__webpack_exports__, "print", function() { return printer["a" /* print */]; });
/* concated harmony reexport visit */__webpack_require__.d(__webpack_exports__, "visit", function() { return visitor["c" /* visit */]; });
/* concated harmony reexport visitInParallel */__webpack_require__.d(__webpack_exports__, "visitInParallel", function() { return visitor["d" /* visitInParallel */]; });
/* concated harmony reexport visitWithTypeInfo */__webpack_require__.d(__webpack_exports__, "visitWithTypeInfo", function() { return visitor["e" /* visitWithTypeInfo */]; });
/* concated harmony reexport getVisitFn */__webpack_require__.d(__webpack_exports__, "getVisitFn", function() { return visitor["b" /* getVisitFn */]; });
/* concated harmony reexport BREAK */__webpack_require__.d(__webpack_exports__, "BREAK", function() { return visitor["a" /* BREAK */]; });
/* concated harmony reexport Kind */__webpack_require__.d(__webpack_exports__, "Kind", function() { return kinds["a" /* Kind */]; });
/* concated harmony reexport DirectiveLocation */__webpack_require__.d(__webpack_exports__, "DirectiveLocation", function() { return directiveLocation["a" /* DirectiveLocation */]; });
/* concated harmony reexport isDefinitionNode */__webpack_require__.d(__webpack_exports__, "isDefinitionNode", function() { return predicates["a" /* isDefinitionNode */]; });
/* concated harmony reexport isExecutableDefinitionNode */__webpack_require__.d(__webpack_exports__, "isExecutableDefinitionNode", function() { return predicates["b" /* isExecutableDefinitionNode */]; });
/* concated harmony reexport isSelectionNode */__webpack_require__.d(__webpack_exports__, "isSelectionNode", function() { return predicates["c" /* isSelectionNode */]; });
/* concated harmony reexport isValueNode */__webpack_require__.d(__webpack_exports__, "isValueNode", function() { return predicates["i" /* isValueNode */]; });
/* concated harmony reexport isTypeNode */__webpack_require__.d(__webpack_exports__, "isTypeNode", function() { return predicates["f" /* isTypeNode */]; });
/* concated harmony reexport isTypeSystemDefinitionNode */__webpack_require__.d(__webpack_exports__, "isTypeSystemDefinitionNode", function() { return predicates["g" /* isTypeSystemDefinitionNode */]; });
/* concated harmony reexport isTypeDefinitionNode */__webpack_require__.d(__webpack_exports__, "isTypeDefinitionNode", function() { return predicates["d" /* isTypeDefinitionNode */]; });
/* concated harmony reexport isTypeSystemExtensionNode */__webpack_require__.d(__webpack_exports__, "isTypeSystemExtensionNode", function() { return predicates["h" /* isTypeSystemExtensionNode */]; });
/* concated harmony reexport isTypeExtensionNode */__webpack_require__.d(__webpack_exports__, "isTypeExtensionNode", function() { return predicates["e" /* isTypeExtensionNode */]; });
/* concated harmony reexport execute */__webpack_require__.d(__webpack_exports__, "execute", function() { return execute["g" /* execute */]; });
/* concated harmony reexport defaultFieldResolver */__webpack_require__.d(__webpack_exports__, "defaultFieldResolver", function() { return execute["e" /* defaultFieldResolver */]; });
/* concated harmony reexport defaultTypeResolver */__webpack_require__.d(__webpack_exports__, "defaultTypeResolver", function() { return execute["f" /* defaultTypeResolver */]; });
/* concated harmony reexport responsePathAsArray */__webpack_require__.d(__webpack_exports__, "responsePathAsArray", function() { return Path["b" /* pathToArray */]; });
/* concated harmony reexport getDirectiveValues */__webpack_require__.d(__webpack_exports__, "getDirectiveValues", function() { return values["getDirectiveValues"]; });
/* concated harmony reexport subscribe */__webpack_require__.d(__webpack_exports__, "subscribe", function() { return subscribe; });
/* concated harmony reexport createSourceEventStream */__webpack_require__.d(__webpack_exports__, "createSourceEventStream", function() { return createSourceEventStream; });
/* concated harmony reexport validate */__webpack_require__.d(__webpack_exports__, "validate", function() { return validate["c" /* validate */]; });
/* concated harmony reexport ValidationContext */__webpack_require__.d(__webpack_exports__, "ValidationContext", function() { return ValidationContext["b" /* ValidationContext */]; });
/* concated harmony reexport specifiedRules */__webpack_require__.d(__webpack_exports__, "specifiedRules", function() { return specifiedRules["a" /* specifiedRules */]; });
/* concated harmony reexport ExecutableDefinitionsRule */__webpack_require__.d(__webpack_exports__, "ExecutableDefinitionsRule", function() { return ExecutableDefinitions["a" /* ExecutableDefinitions */]; });
/* concated harmony reexport FieldsOnCorrectTypeRule */__webpack_require__.d(__webpack_exports__, "FieldsOnCorrectTypeRule", function() { return FieldsOnCorrectType["a" /* FieldsOnCorrectType */]; });
/* concated harmony reexport FragmentsOnCompositeTypesRule */__webpack_require__.d(__webpack_exports__, "FragmentsOnCompositeTypesRule", function() { return FragmentsOnCompositeTypes["a" /* FragmentsOnCompositeTypes */]; });
/* concated harmony reexport KnownArgumentNamesRule */__webpack_require__.d(__webpack_exports__, "KnownArgumentNamesRule", function() { return KnownArgumentNames["a" /* KnownArgumentNames */]; });
/* concated harmony reexport KnownDirectivesRule */__webpack_require__.d(__webpack_exports__, "KnownDirectivesRule", function() { return KnownDirectives["a" /* KnownDirectives */]; });
/* concated harmony reexport KnownFragmentNamesRule */__webpack_require__.d(__webpack_exports__, "KnownFragmentNamesRule", function() { return KnownFragmentNames["a" /* KnownFragmentNames */]; });
/* concated harmony reexport KnownTypeNamesRule */__webpack_require__.d(__webpack_exports__, "KnownTypeNamesRule", function() { return KnownTypeNames["a" /* KnownTypeNames */]; });
/* concated harmony reexport LoneAnonymousOperationRule */__webpack_require__.d(__webpack_exports__, "LoneAnonymousOperationRule", function() { return LoneAnonymousOperation["a" /* LoneAnonymousOperation */]; });
/* concated harmony reexport NoFragmentCyclesRule */__webpack_require__.d(__webpack_exports__, "NoFragmentCyclesRule", function() { return NoFragmentCycles["a" /* NoFragmentCycles */]; });
/* concated harmony reexport NoUndefinedVariablesRule */__webpack_require__.d(__webpack_exports__, "NoUndefinedVariablesRule", function() { return NoUndefinedVariables["a" /* NoUndefinedVariables */]; });
/* concated harmony reexport NoUnusedFragmentsRule */__webpack_require__.d(__webpack_exports__, "NoUnusedFragmentsRule", function() { return NoUnusedFragments["a" /* NoUnusedFragments */]; });
/* concated harmony reexport NoUnusedVariablesRule */__webpack_require__.d(__webpack_exports__, "NoUnusedVariablesRule", function() { return NoUnusedVariables["a" /* NoUnusedVariables */]; });
/* concated harmony reexport OverlappingFieldsCanBeMergedRule */__webpack_require__.d(__webpack_exports__, "OverlappingFieldsCanBeMergedRule", function() { return OverlappingFieldsCanBeMerged["a" /* OverlappingFieldsCanBeMerged */]; });
/* concated harmony reexport PossibleFragmentSpreadsRule */__webpack_require__.d(__webpack_exports__, "PossibleFragmentSpreadsRule", function() { return PossibleFragmentSpreads["a" /* PossibleFragmentSpreads */]; });
/* concated harmony reexport ProvidedRequiredArgumentsRule */__webpack_require__.d(__webpack_exports__, "ProvidedRequiredArgumentsRule", function() { return ProvidedRequiredArguments["a" /* ProvidedRequiredArguments */]; });
/* concated harmony reexport ScalarLeafsRule */__webpack_require__.d(__webpack_exports__, "ScalarLeafsRule", function() { return ScalarLeafs["a" /* ScalarLeafs */]; });
/* concated harmony reexport SingleFieldSubscriptionsRule */__webpack_require__.d(__webpack_exports__, "SingleFieldSubscriptionsRule", function() { return SingleFieldSubscriptions["a" /* SingleFieldSubscriptions */]; });
/* concated harmony reexport UniqueArgumentNamesRule */__webpack_require__.d(__webpack_exports__, "UniqueArgumentNamesRule", function() { return UniqueArgumentNames["a" /* UniqueArgumentNames */]; });
/* concated harmony reexport UniqueDirectivesPerLocationRule */__webpack_require__.d(__webpack_exports__, "UniqueDirectivesPerLocationRule", function() { return UniqueDirectivesPerLocation["a" /* UniqueDirectivesPerLocation */]; });
/* concated harmony reexport UniqueFragmentNamesRule */__webpack_require__.d(__webpack_exports__, "UniqueFragmentNamesRule", function() { return UniqueFragmentNames["a" /* UniqueFragmentNames */]; });
/* concated harmony reexport UniqueInputFieldNamesRule */__webpack_require__.d(__webpack_exports__, "UniqueInputFieldNamesRule", function() { return UniqueInputFieldNames["a" /* UniqueInputFieldNames */]; });
/* concated harmony reexport UniqueOperationNamesRule */__webpack_require__.d(__webpack_exports__, "UniqueOperationNamesRule", function() { return UniqueOperationNames["a" /* UniqueOperationNames */]; });
/* concated harmony reexport UniqueVariableNamesRule */__webpack_require__.d(__webpack_exports__, "UniqueVariableNamesRule", function() { return UniqueVariableNames["a" /* UniqueVariableNames */]; });
/* concated harmony reexport ValuesOfCorrectTypeRule */__webpack_require__.d(__webpack_exports__, "ValuesOfCorrectTypeRule", function() { return ValuesOfCorrectType["a" /* ValuesOfCorrectType */]; });
/* concated harmony reexport VariablesAreInputTypesRule */__webpack_require__.d(__webpack_exports__, "VariablesAreInputTypesRule", function() { return VariablesAreInputTypes["a" /* VariablesAreInputTypes */]; });
/* concated harmony reexport VariablesInAllowedPositionRule */__webpack_require__.d(__webpack_exports__, "VariablesInAllowedPositionRule", function() { return VariablesInAllowedPosition["a" /* VariablesInAllowedPosition */]; });
/* concated harmony reexport LoneSchemaDefinitionRule */__webpack_require__.d(__webpack_exports__, "LoneSchemaDefinitionRule", function() { return LoneSchemaDefinition["a" /* LoneSchemaDefinition */]; });
/* concated harmony reexport UniqueOperationTypesRule */__webpack_require__.d(__webpack_exports__, "UniqueOperationTypesRule", function() { return UniqueOperationTypes["a" /* UniqueOperationTypes */]; });
/* concated harmony reexport UniqueTypeNamesRule */__webpack_require__.d(__webpack_exports__, "UniqueTypeNamesRule", function() { return UniqueTypeNames["a" /* UniqueTypeNames */]; });
/* concated harmony reexport UniqueEnumValueNamesRule */__webpack_require__.d(__webpack_exports__, "UniqueEnumValueNamesRule", function() { return UniqueEnumValueNames["a" /* UniqueEnumValueNames */]; });
/* concated harmony reexport UniqueFieldDefinitionNamesRule */__webpack_require__.d(__webpack_exports__, "UniqueFieldDefinitionNamesRule", function() { return UniqueFieldDefinitionNames["a" /* UniqueFieldDefinitionNames */]; });
/* concated harmony reexport UniqueDirectiveNamesRule */__webpack_require__.d(__webpack_exports__, "UniqueDirectiveNamesRule", function() { return UniqueDirectiveNames["a" /* UniqueDirectiveNames */]; });
/* concated harmony reexport PossibleTypeExtensionsRule */__webpack_require__.d(__webpack_exports__, "PossibleTypeExtensionsRule", function() { return PossibleTypeExtensions["a" /* PossibleTypeExtensions */]; });
/* concated harmony reexport GraphQLError */__webpack_require__.d(__webpack_exports__, "GraphQLError", function() { return GraphQLError["a" /* GraphQLError */]; });
/* concated harmony reexport syntaxError */__webpack_require__.d(__webpack_exports__, "syntaxError", function() { return syntaxError["a" /* syntaxError */]; });
/* concated harmony reexport locatedError */__webpack_require__.d(__webpack_exports__, "locatedError", function() { return locatedError["a" /* locatedError */]; });
/* concated harmony reexport printError */__webpack_require__.d(__webpack_exports__, "printError", function() { return GraphQLError["b" /* printError */]; });
/* concated harmony reexport formatError */__webpack_require__.d(__webpack_exports__, "formatError", function() { return formatError["a" /* formatError */]; });
/* concated harmony reexport getIntrospectionQuery */__webpack_require__.d(__webpack_exports__, "getIntrospectionQuery", function() { return introspectionQuery["a" /* getIntrospectionQuery */]; });
/* concated harmony reexport introspectionQuery */__webpack_require__.d(__webpack_exports__, "introspectionQuery", function() { return introspectionQuery["b" /* introspectionQuery */]; });
/* concated harmony reexport getOperationAST */__webpack_require__.d(__webpack_exports__, "getOperationAST", function() { return getOperationAST["a" /* getOperationAST */]; });
/* concated harmony reexport getOperationRootType */__webpack_require__.d(__webpack_exports__, "getOperationRootType", function() { return getOperationRootType["a" /* getOperationRootType */]; });
/* concated harmony reexport introspectionFromSchema */__webpack_require__.d(__webpack_exports__, "introspectionFromSchema", function() { return introspectionFromSchema["a" /* introspectionFromSchema */]; });
/* concated harmony reexport buildClientSchema */__webpack_require__.d(__webpack_exports__, "buildClientSchema", function() { return buildClientSchema["a" /* buildClientSchema */]; });
/* concated harmony reexport buildASTSchema */__webpack_require__.d(__webpack_exports__, "buildASTSchema", function() { return buildASTSchema["b" /* buildASTSchema */]; });
/* concated harmony reexport buildSchema */__webpack_require__.d(__webpack_exports__, "buildSchema", function() { return buildASTSchema["c" /* buildSchema */]; });
/* concated harmony reexport getDescription */__webpack_require__.d(__webpack_exports__, "getDescription", function() { return buildASTSchema["d" /* getDescription */]; });
/* concated harmony reexport extendSchema */__webpack_require__.d(__webpack_exports__, "extendSchema", function() { return extendSchema["a" /* extendSchema */]; });
/* concated harmony reexport lexicographicSortSchema */__webpack_require__.d(__webpack_exports__, "lexicographicSortSchema", function() { return lexicographicSortSchema["a" /* lexicographicSortSchema */]; });
/* concated harmony reexport printSchema */__webpack_require__.d(__webpack_exports__, "printSchema", function() { return schemaPrinter["b" /* printSchema */]; });
/* concated harmony reexport printType */__webpack_require__.d(__webpack_exports__, "printType", function() { return schemaPrinter["c" /* printType */]; });
/* concated harmony reexport printIntrospectionSchema */__webpack_require__.d(__webpack_exports__, "printIntrospectionSchema", function() { return schemaPrinter["a" /* printIntrospectionSchema */]; });
/* concated harmony reexport typeFromAST */__webpack_require__.d(__webpack_exports__, "typeFromAST", function() { return typeFromAST["a" /* typeFromAST */]; });
/* concated harmony reexport valueFromAST */__webpack_require__.d(__webpack_exports__, "valueFromAST", function() { return valueFromAST["a" /* valueFromAST */]; });
/* concated harmony reexport valueFromASTUntyped */__webpack_require__.d(__webpack_exports__, "valueFromASTUntyped", function() { return valueFromASTUntyped["a" /* valueFromASTUntyped */]; });
/* concated harmony reexport astFromValue */__webpack_require__.d(__webpack_exports__, "astFromValue", function() { return astFromValue["a" /* astFromValue */]; });
/* concated harmony reexport TypeInfo */__webpack_require__.d(__webpack_exports__, "TypeInfo", function() { return TypeInfo["a" /* TypeInfo */]; });
/* concated harmony reexport coerceInputValue */__webpack_require__.d(__webpack_exports__, "coerceInputValue", function() { return coerceInputValue["a" /* coerceInputValue */]; });
/* concated harmony reexport coerceValue */__webpack_require__.d(__webpack_exports__, "coerceValue", function() { return coerceValue["a" /* coerceValue */]; });
/* concated harmony reexport isValidJSValue */__webpack_require__.d(__webpack_exports__, "isValidJSValue", function() { return isValidJSValue["a" /* isValidJSValue */]; });
/* concated harmony reexport isValidLiteralValue */__webpack_require__.d(__webpack_exports__, "isValidLiteralValue", function() { return isValidLiteralValue["a" /* isValidLiteralValue */]; });
/* concated harmony reexport concatAST */__webpack_require__.d(__webpack_exports__, "concatAST", function() { return concatAST["a" /* concatAST */]; });
/* concated harmony reexport separateOperations */__webpack_require__.d(__webpack_exports__, "separateOperations", function() { return separateOperations["a" /* separateOperations */]; });
/* concated harmony reexport stripIgnoredCharacters */__webpack_require__.d(__webpack_exports__, "stripIgnoredCharacters", function() { return stripIgnoredCharacters["a" /* stripIgnoredCharacters */]; });
/* concated harmony reexport isEqualType */__webpack_require__.d(__webpack_exports__, "isEqualType", function() { return typeComparators["b" /* isEqualType */]; });
/* concated harmony reexport isTypeSubTypeOf */__webpack_require__.d(__webpack_exports__, "isTypeSubTypeOf", function() { return typeComparators["c" /* isTypeSubTypeOf */]; });
/* concated harmony reexport doTypesOverlap */__webpack_require__.d(__webpack_exports__, "doTypesOverlap", function() { return typeComparators["a" /* doTypesOverlap */]; });
/* concated harmony reexport assertValidName */__webpack_require__.d(__webpack_exports__, "assertValidName", function() { return assertValidName["a" /* assertValidName */]; });
/* concated harmony reexport isValidNameError */__webpack_require__.d(__webpack_exports__, "isValidNameError", function() { return assertValidName["b" /* isValidNameError */]; });
/* concated harmony reexport BreakingChangeType */__webpack_require__.d(__webpack_exports__, "BreakingChangeType", function() { return findBreakingChanges["a" /* BreakingChangeType */]; });
/* concated harmony reexport DangerousChangeType */__webpack_require__.d(__webpack_exports__, "DangerousChangeType", function() { return findBreakingChanges["b" /* DangerousChangeType */]; });
/* concated harmony reexport findBreakingChanges */__webpack_require__.d(__webpack_exports__, "findBreakingChanges", function() { return findBreakingChanges["c" /* findBreakingChanges */]; });
/* concated harmony reexport findDangerousChanges */__webpack_require__.d(__webpack_exports__, "findDangerousChanges", function() { return findBreakingChanges["d" /* findDangerousChanges */]; });
/* concated harmony reexport findDeprecatedUsages */__webpack_require__.d(__webpack_exports__, "findDeprecatedUsages", function() { return findDeprecatedUsages["a" /* findDeprecatedUsages */]; });
/**
 * GraphQL.js provides a reference implementation for the GraphQL specification
 * but is also a useful utility for operating on GraphQL files and building
 * sophisticated tools.
 *
 * This primary module exports a general purpose function for fulfilling all
 * steps of the GraphQL specification in a single operation, but also includes
 * utilities for every part of the GraphQL specification:
 *
 *   - Parsing the GraphQL language.
 *   - Building a GraphQL type schema.
 *   - Validating a GraphQL request against a type schema.
 *   - Executing a GraphQL request against a type schema.
 *
 * This also includes utility functions for operating on GraphQL types and
 * GraphQL documents to facilitate building tools.
 *
 * You may also import from each sub-directory directly. For example, the
 * following two import statements are equivalent:
 *
 *     import { parse } from 'graphql';
 *     import { parse } from 'graphql/language';
 */
// The GraphQL.js version info.
 // The primary entry point into fulfilling a GraphQL request.

 // Create and operate on GraphQL type definitions and schema.


// Parse and operate on GraphQL language source files.

// Execute GraphQL queries.


// Validate GraphQL documents.

// Create, format, and print GraphQL errors.

// Utilities for operating on GraphQL type schema and parsed sources.



/***/ }),
/* 12 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __Schema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __Directive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __DirectiveLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __Field; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __InputValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __EnumValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return TypeKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __TypeKind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SchemaMetaFieldDef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return TypeMetaFieldDef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return TypeNameMetaFieldDef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return introspectionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return isIntrospectionType; });
/* harmony import */ var _polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _jsutils_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var _language_printer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16);
/* harmony import */ var _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9);
/* harmony import */ var _utilities_astFromValue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(47);
/* harmony import */ var _scalars__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(13);
/* harmony import */ var _definition__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);








var __Schema = new _definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLObjectType */ "f"]({
  name: '__Schema',
  description: 'A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.',
  fields: function fields() {
    return {
      types: {
        description: 'A list of all types supported by this server.',
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLList */ "d"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__Type))),
        resolve: function resolve(schema) {
          return Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(schema.getTypeMap());
        }
      },
      queryType: {
        description: 'The type that query operations will be rooted at.',
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__Type),
        resolve: function resolve(schema) {
          return schema.getQueryType();
        }
      },
      mutationType: {
        description: 'If this server supports mutation, the type that mutation operations will be rooted at.',
        type: __Type,
        resolve: function resolve(schema) {
          return schema.getMutationType();
        }
      },
      subscriptionType: {
        description: 'If this server support subscription, the type that subscription operations will be rooted at.',
        type: __Type,
        resolve: function resolve(schema) {
          return schema.getSubscriptionType();
        }
      },
      directives: {
        description: 'A list of all directives supported by this server.',
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLList */ "d"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__Directive))),
        resolve: function resolve(schema) {
          return schema.getDirectives();
        }
      }
    };
  }
});
var __Directive = new _definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLObjectType */ "f"]({
  name: '__Directive',
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: function fields() {
    return {
      name: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(_scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"]),
        resolve: function resolve(obj) {
          return obj.name;
        }
      },
      description: {
        type: _scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"],
        resolve: function resolve(obj) {
          return obj.description;
        }
      },
      locations: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLList */ "d"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__DirectiveLocation))),
        resolve: function resolve(obj) {
          return obj.locations;
        }
      },
      args: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLList */ "d"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__InputValue))),
        resolve: function resolve(directive) {
          return directive.args;
        }
      }
    };
  }
});
var __DirectiveLocation = new _definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLEnumType */ "a"]({
  name: '__DirectiveLocation',
  description: 'A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.',
  values: {
    QUERY: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].QUERY,
      description: 'Location adjacent to a query operation.'
    },
    MUTATION: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].MUTATION,
      description: 'Location adjacent to a mutation operation.'
    },
    SUBSCRIPTION: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].SUBSCRIPTION,
      description: 'Location adjacent to a subscription operation.'
    },
    FIELD: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].FIELD,
      description: 'Location adjacent to a field.'
    },
    FRAGMENT_DEFINITION: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].FRAGMENT_DEFINITION,
      description: 'Location adjacent to a fragment definition.'
    },
    FRAGMENT_SPREAD: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].FRAGMENT_SPREAD,
      description: 'Location adjacent to a fragment spread.'
    },
    INLINE_FRAGMENT: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].INLINE_FRAGMENT,
      description: 'Location adjacent to an inline fragment.'
    },
    VARIABLE_DEFINITION: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].VARIABLE_DEFINITION,
      description: 'Location adjacent to a variable definition.'
    },
    SCHEMA: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].SCHEMA,
      description: 'Location adjacent to a schema definition.'
    },
    SCALAR: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].SCALAR,
      description: 'Location adjacent to a scalar definition.'
    },
    OBJECT: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].OBJECT,
      description: 'Location adjacent to an object type definition.'
    },
    FIELD_DEFINITION: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].FIELD_DEFINITION,
      description: 'Location adjacent to a field definition.'
    },
    ARGUMENT_DEFINITION: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].ARGUMENT_DEFINITION,
      description: 'Location adjacent to an argument definition.'
    },
    INTERFACE: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].INTERFACE,
      description: 'Location adjacent to an interface definition.'
    },
    UNION: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].UNION,
      description: 'Location adjacent to a union definition.'
    },
    ENUM: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].ENUM,
      description: 'Location adjacent to an enum definition.'
    },
    ENUM_VALUE: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].ENUM_VALUE,
      description: 'Location adjacent to an enum value definition.'
    },
    INPUT_OBJECT: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].INPUT_OBJECT,
      description: 'Location adjacent to an input object type definition.'
    },
    INPUT_FIELD_DEFINITION: {
      value: _language_directiveLocation__WEBPACK_IMPORTED_MODULE_4__[/* DirectiveLocation */ "a"].INPUT_FIELD_DEFINITION,
      description: 'Location adjacent to an input object field definition.'
    }
  }
});
var __Type = new _definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLObjectType */ "f"]({
  name: '__Type',
  description: 'The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name and description, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.',
  fields: function fields() {
    return {
      kind: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__TypeKind),
        resolve: function resolve(type) {
          if (Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isScalarType */ "R"])(type)) {
            return TypeKind.SCALAR;
          } else if (Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isObjectType */ "N"])(type)) {
            return TypeKind.OBJECT;
          } else if (Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isInterfaceType */ "H"])(type)) {
            return TypeKind.INTERFACE;
          } else if (Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isUnionType */ "T"])(type)) {
            return TypeKind.UNION;
          } else if (Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isEnumType */ "E"])(type)) {
            return TypeKind.ENUM;
          } else if (Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isInputObjectType */ "F"])(type)) {
            return TypeKind.INPUT_OBJECT;
          } else if (Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isListType */ "J"])(type)) {
            return TypeKind.LIST;
          } else if (Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isNonNullType */ "L"])(type)) {
            return TypeKind.NON_NULL;
          } // Not reachable. All possible types have been considered.


          /* istanbul ignore next */
          Object(_jsutils_invariant__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(false, "Unexpected type: \"".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(type), "\"."));
        }
      },
      name: {
        type: _scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"],
        resolve: function resolve(obj) {
          return obj.name !== undefined ? obj.name : undefined;
        }
      },
      description: {
        type: _scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"],
        resolve: function resolve(obj) {
          return obj.description !== undefined ? obj.description : undefined;
        }
      },
      fields: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLList */ "d"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__Field)),
        args: {
          includeDeprecated: {
            type: _scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLBoolean */ "a"],
            defaultValue: false
          }
        },
        resolve: function resolve(type, _ref) {
          var includeDeprecated = _ref.includeDeprecated;

          if (Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isObjectType */ "N"])(type) || Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isInterfaceType */ "H"])(type)) {
            var fields = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(type.getFields());

            if (!includeDeprecated) {
              fields = fields.filter(function (field) {
                return !field.deprecationReason;
              });
            }

            return fields;
          }

          return null;
        }
      },
      interfaces: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLList */ "d"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__Type)),
        resolve: function resolve(type) {
          if (Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isObjectType */ "N"])(type)) {
            return type.getInterfaces();
          }
        }
      },
      possibleTypes: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLList */ "d"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__Type)),
        resolve: function resolve(type, args, context, _ref2) {
          var schema = _ref2.schema;

          if (Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isAbstractType */ "C"])(type)) {
            return schema.getPossibleTypes(type);
          }
        }
      },
      enumValues: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLList */ "d"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__EnumValue)),
        args: {
          includeDeprecated: {
            type: _scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLBoolean */ "a"],
            defaultValue: false
          }
        },
        resolve: function resolve(type, _ref3) {
          var includeDeprecated = _ref3.includeDeprecated;

          if (Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isEnumType */ "E"])(type)) {
            var values = type.getValues();

            if (!includeDeprecated) {
              values = values.filter(function (value) {
                return !value.deprecationReason;
              });
            }

            return values;
          }
        }
      },
      inputFields: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLList */ "d"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__InputValue)),
        resolve: function resolve(type) {
          if (Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isInputObjectType */ "F"])(type)) {
            return Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(type.getFields());
          }
        }
      },
      ofType: {
        type: __Type,
        resolve: function resolve(obj) {
          return obj.ofType !== undefined ? obj.ofType : undefined;
        }
      }
    };
  }
});
var __Field = new _definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLObjectType */ "f"]({
  name: '__Field',
  description: 'Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.',
  fields: function fields() {
    return {
      name: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(_scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"]),
        resolve: function resolve(obj) {
          return obj.name;
        }
      },
      description: {
        type: _scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"],
        resolve: function resolve(obj) {
          return obj.description;
        }
      },
      args: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLList */ "d"])(Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__InputValue))),
        resolve: function resolve(field) {
          return field.args;
        }
      },
      type: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__Type),
        resolve: function resolve(obj) {
          return obj.type;
        }
      },
      isDeprecated: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(_scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLBoolean */ "a"]),
        resolve: function resolve(obj) {
          return obj.isDeprecated;
        }
      },
      deprecationReason: {
        type: _scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"],
        resolve: function resolve(obj) {
          return obj.deprecationReason;
        }
      }
    };
  }
});
var __InputValue = new _definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLObjectType */ "f"]({
  name: '__InputValue',
  description: 'Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.',
  fields: function fields() {
    return {
      name: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(_scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"]),
        resolve: function resolve(obj) {
          return obj.name;
        }
      },
      description: {
        type: _scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"],
        resolve: function resolve(obj) {
          return obj.description;
        }
      },
      type: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__Type),
        resolve: function resolve(obj) {
          return obj.type;
        }
      },
      defaultValue: {
        type: _scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"],
        description: 'A GraphQL-formatted string representing the default value for this input value.',
        resolve: function resolve(inputVal) {
          var valueAST = Object(_utilities_astFromValue__WEBPACK_IMPORTED_MODULE_5__[/* astFromValue */ "a"])(inputVal.defaultValue, inputVal.type);
          return valueAST ? Object(_language_printer__WEBPACK_IMPORTED_MODULE_3__[/* print */ "a"])(valueAST) : null;
        }
      }
    };
  }
});
var __EnumValue = new _definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLObjectType */ "f"]({
  name: '__EnumValue',
  description: 'One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.',
  fields: function fields() {
    return {
      name: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(_scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"]),
        resolve: function resolve(obj) {
          return obj.name;
        }
      },
      description: {
        type: _scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"],
        resolve: function resolve(obj) {
          return obj.description;
        }
      },
      isDeprecated: {
        type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(_scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLBoolean */ "a"]),
        resolve: function resolve(obj) {
          return obj.isDeprecated;
        }
      },
      deprecationReason: {
        type: _scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"],
        resolve: function resolve(obj) {
          return obj.deprecationReason;
        }
      }
    };
  }
});
var TypeKind = Object.freeze({
  SCALAR: 'SCALAR',
  OBJECT: 'OBJECT',
  INTERFACE: 'INTERFACE',
  UNION: 'UNION',
  ENUM: 'ENUM',
  INPUT_OBJECT: 'INPUT_OBJECT',
  LIST: 'LIST',
  NON_NULL: 'NON_NULL'
});
var __TypeKind = new _definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLEnumType */ "a"]({
  name: '__TypeKind',
  description: 'An enum describing what kind of type a given `__Type` is.',
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: 'Indicates this type is a scalar.'
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: 'Indicates this type is an object. `fields` and `interfaces` are valid fields.'
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: 'Indicates this type is an interface. `fields` and `possibleTypes` are valid fields.'
    },
    UNION: {
      value: TypeKind.UNION,
      description: 'Indicates this type is a union. `possibleTypes` is a valid field.'
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: 'Indicates this type is an enum. `enumValues` is a valid field.'
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: 'Indicates this type is an input object. `inputFields` is a valid field.'
    },
    LIST: {
      value: TypeKind.LIST,
      description: 'Indicates this type is a list. `ofType` is a valid field.'
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: 'Indicates this type is a non-null. `ofType` is a valid field.'
    }
  }
});
/**
 * Note that these are GraphQLField and not GraphQLFieldConfig,
 * so the format for args is different.
 */

var SchemaMetaFieldDef = {
  name: '__schema',
  type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(__Schema),
  description: 'Access the current type schema of this server.',
  args: [],
  resolve: function resolve(source, args, context, _ref4) {
    var schema = _ref4.schema;
    return schema;
  },
  deprecationReason: undefined,
  extensions: undefined,
  astNode: undefined
};
var TypeMetaFieldDef = {
  name: '__type',
  type: __Type,
  description: 'Request the type information of a single type.',
  args: [{
    name: 'name',
    description: undefined,
    type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(_scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"]),
    defaultValue: undefined,
    extensions: undefined,
    astNode: undefined
  }],
  resolve: function resolve(source, _ref5, context, _ref6) {
    var name = _ref5.name;
    var schema = _ref6.schema;
    return schema.getType(name);
  },
  deprecationReason: undefined,
  extensions: undefined,
  astNode: undefined
};
var TypeNameMetaFieldDef = {
  name: '__typename',
  type: Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"])(_scalars__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLString */ "e"]),
  description: 'The name of the current Object type at runtime.',
  args: [],
  resolve: function resolve(source, args, context, _ref7) {
    var parentType = _ref7.parentType;
    return parentType.name;
  },
  deprecationReason: undefined,
  extensions: undefined,
  astNode: undefined
};
var introspectionTypes = Object.freeze([__Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, __TypeKind]);
function isIntrospectionType(type) {
  return Object(_definition__WEBPACK_IMPORTED_MODULE_7__[/* isNamedType */ "K"])(type) && introspectionTypes.some(function (_ref8) {
    var name = _ref8.name;
    return type.name === name;
  });
}


/***/ }),
/* 13 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/graphql/polyfills/isFinite.mjs
/* eslint-disable no-redeclare */
// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/4441
var isFinitePolyfill = Number.isFinite || function (value) {
  return typeof value === 'number' && isFinite(value);
};

/* harmony default export */ var polyfills_isFinite = (isFinitePolyfill);

// CONCATENATED MODULE: ./node_modules/graphql/polyfills/isInteger.mjs
/* eslint-disable no-redeclare */
// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/4441
var isInteger = Number.isInteger || function (value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};

/* harmony default export */ var polyfills_isInteger = (isInteger);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/inspect.mjs
var inspect = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/isObjectLike.mjs
var isObjectLike = __webpack_require__(18);

// EXTERNAL MODULE: ./node_modules/graphql/language/kinds.mjs
var kinds = __webpack_require__(2);

// EXTERNAL MODULE: ./node_modules/graphql/type/definition.mjs + 1 modules
var definition = __webpack_require__(0);

// CONCATENATED MODULE: ./node_modules/graphql/type/scalars.mjs
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return GraphQLInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return GraphQLFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return GraphQLString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GraphQLBoolean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return GraphQLID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return specifiedScalarTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return isSpecifiedScalarType; });





 // As per the GraphQL Spec, Integers are only treated as valid when a valid
// 32-bit signed integer, providing the broadest support across platforms.
//
// n.b. JavaScript's integers are safe between -(2^53 - 1) and 2^53 - 1 because
// they are internally represented as IEEE 754 doubles.

var MAX_INT = 2147483647;
var MIN_INT = -2147483648;

function serializeInt(value) {
  if (typeof value === 'boolean') {
    return value ? 1 : 0;
  }

  var num = value;

  if (typeof value === 'string' && value !== '') {
    num = Number(value);
  }

  if (!polyfills_isInteger(num)) {
    throw new TypeError("Int cannot represent non-integer value: ".concat(Object(inspect["a" /* default */])(value)));
  }

  if (num > MAX_INT || num < MIN_INT) {
    throw new TypeError("Int cannot represent non 32-bit signed integer value: ".concat(Object(inspect["a" /* default */])(value)));
  }

  return num;
}

function coerceInt(value) {
  if (!polyfills_isInteger(value)) {
    throw new TypeError("Int cannot represent non-integer value: ".concat(Object(inspect["a" /* default */])(value)));
  }

  if (value > MAX_INT || value < MIN_INT) {
    throw new TypeError("Int cannot represent non 32-bit signed integer value: ".concat(Object(inspect["a" /* default */])(value)));
  }

  return value;
}

var GraphQLInt = new definition["g" /* GraphQLScalarType */]({
  name: 'Int',
  description: 'The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.',
  serialize: serializeInt,
  parseValue: coerceInt,
  parseLiteral: function parseLiteral(ast) {
    if (ast.kind === kinds["a" /* Kind */].INT) {
      var num = parseInt(ast.value, 10);

      if (num <= MAX_INT && num >= MIN_INT) {
        return num;
      }
    }

    return undefined;
  }
});

function serializeFloat(value) {
  if (typeof value === 'boolean') {
    return value ? 1 : 0;
  }

  var num = value;

  if (typeof value === 'string' && value !== '') {
    num = Number(value);
  }

  if (!polyfills_isFinite(num)) {
    throw new TypeError("Float cannot represent non numeric value: ".concat(Object(inspect["a" /* default */])(value)));
  }

  return num;
}

function coerceFloat(value) {
  if (!polyfills_isFinite(value)) {
    throw new TypeError("Float cannot represent non numeric value: ".concat(Object(inspect["a" /* default */])(value)));
  }

  return value;
}

var GraphQLFloat = new definition["g" /* GraphQLScalarType */]({
  name: 'Float',
  description: 'The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).',
  serialize: serializeFloat,
  parseValue: coerceFloat,
  parseLiteral: function parseLiteral(ast) {
    return ast.kind === kinds["a" /* Kind */].FLOAT || ast.kind === kinds["a" /* Kind */].INT ? parseFloat(ast.value) : undefined;
  }
}); // Support serializing objects with custom valueOf() or toJSON() functions -
// a common way to represent a complex value which can be represented as
// a string (ex: MongoDB id objects).

function serializeObject(value) {
  if (Object(isObjectLike["a" /* default */])(value)) {
    if (typeof value.valueOf === 'function') {
      var valueOfResult = value.valueOf();

      if (!Object(isObjectLike["a" /* default */])(valueOfResult)) {
        return valueOfResult;
      }
    }

    if (typeof value.toJSON === 'function') {
      // $FlowFixMe(>=0.90.0)
      return value.toJSON();
    }
  }

  return value;
}

function serializeString(rawValue) {
  var value = serializeObject(rawValue); // Serialize string, boolean and number values to a string, but do not
  // attempt to coerce object, function, symbol, or other types as strings.

  if (typeof value === 'string') {
    return value;
  }

  if (typeof value === 'boolean') {
    return value ? 'true' : 'false';
  }

  if (polyfills_isFinite(value)) {
    return value.toString();
  }

  throw new TypeError("String cannot represent value: ".concat(Object(inspect["a" /* default */])(rawValue)));
}

function coerceString(value) {
  if (typeof value !== 'string') {
    throw new TypeError("String cannot represent a non string value: ".concat(Object(inspect["a" /* default */])(value)));
  }

  return value;
}

var GraphQLString = new definition["g" /* GraphQLScalarType */]({
  name: 'String',
  description: 'The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.',
  serialize: serializeString,
  parseValue: coerceString,
  parseLiteral: function parseLiteral(ast) {
    return ast.kind === kinds["a" /* Kind */].STRING ? ast.value : undefined;
  }
});

function serializeBoolean(value) {
  if (typeof value === 'boolean') {
    return value;
  }

  if (polyfills_isFinite(value)) {
    return value !== 0;
  }

  throw new TypeError("Boolean cannot represent a non boolean value: ".concat(Object(inspect["a" /* default */])(value)));
}

function coerceBoolean(value) {
  if (typeof value !== 'boolean') {
    throw new TypeError("Boolean cannot represent a non boolean value: ".concat(Object(inspect["a" /* default */])(value)));
  }

  return value;
}

var GraphQLBoolean = new definition["g" /* GraphQLScalarType */]({
  name: 'Boolean',
  description: 'The `Boolean` scalar type represents `true` or `false`.',
  serialize: serializeBoolean,
  parseValue: coerceBoolean,
  parseLiteral: function parseLiteral(ast) {
    return ast.kind === kinds["a" /* Kind */].BOOLEAN ? ast.value : undefined;
  }
});

function serializeID(rawValue) {
  var value = serializeObject(rawValue);

  if (typeof value === 'string') {
    return value;
  }

  if (polyfills_isInteger(value)) {
    return String(value);
  }

  throw new TypeError("ID cannot represent value: ".concat(Object(inspect["a" /* default */])(rawValue)));
}

function coerceID(value) {
  if (typeof value === 'string') {
    return value;
  }

  if (polyfills_isInteger(value)) {
    return value.toString();
  }

  throw new TypeError("ID cannot represent value: ".concat(Object(inspect["a" /* default */])(value)));
}

var GraphQLID = new definition["g" /* GraphQLScalarType */]({
  name: 'ID',
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize: serializeID,
  parseValue: coerceID,
  parseLiteral: function parseLiteral(ast) {
    return ast.kind === kinds["a" /* Kind */].STRING || ast.kind === kinds["a" /* Kind */].INT ? ast.value : undefined;
  }
});
var specifiedScalarTypes = Object.freeze([GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID]);
function isSpecifiedScalarType(type) {
  return Object(definition["R" /* isScalarType */])(type) && specifiedScalarTypes.some(function (_ref) {
    var name = _ref.name;
    return type.name === name;
  });
}


/***/ }),
/* 14 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export QueryDocumentKeys */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BREAK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return visit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return visitInParallel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return visitWithTypeInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getVisitFn; });
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);

var QueryDocumentKeys = {
  Name: [],
  Document: ['definitions'],
  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],
  Variable: ['name'],
  SelectionSet: ['selections'],
  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
  Argument: ['name', 'value'],
  FragmentSpread: ['name', 'directives'],
  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed
  // or removed in the future.
  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ['values'],
  ObjectValue: ['fields'],
  ObjectField: ['name', 'value'],
  Directive: ['name', 'arguments'],
  NamedType: ['name'],
  ListType: ['type'],
  NonNullType: ['type'],
  SchemaDefinition: ['directives', 'operationTypes'],
  OperationTypeDefinition: ['type'],
  ScalarTypeDefinition: ['description', 'name', 'directives'],
  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],
  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
  EnumValueDefinition: ['description', 'name', 'directives'],
  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
  SchemaExtension: ['directives', 'operationTypes'],
  ScalarTypeExtension: ['name', 'directives'],
  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
  InterfaceTypeExtension: ['name', 'directives', 'fields'],
  UnionTypeExtension: ['name', 'directives', 'types'],
  EnumTypeExtension: ['name', 'directives', 'values'],
  InputObjectTypeExtension: ['name', 'directives', 'fields']
};
var BREAK = Object.freeze({});
/**
 * visit() will walk through an AST using a depth first traversal, calling
 * the visitor's enter function at each node in the traversal, and calling the
 * leave function after visiting that node and all of its child nodes.
 *
 * By returning different values from the enter and leave functions, the
 * behavior of the visitor can be altered, including skipping over a sub-tree of
 * the AST (by returning false), editing the AST by returning a value or null
 * to remove the value, or to stop the whole traversal by returning BREAK.
 *
 * When using visit() to edit an AST, the original AST will not be modified, and
 * a new version of the AST with the changes applied will be returned from the
 * visit function.
 *
 *     const editedAST = visit(ast, {
 *       enter(node, key, parent, path, ancestors) {
 *         // @return
 *         //   undefined: no action
 *         //   false: skip visiting this node
 *         //   visitor.BREAK: stop visiting altogether
 *         //   null: delete this node
 *         //   any value: replace this node with the returned value
 *       },
 *       leave(node, key, parent, path, ancestors) {
 *         // @return
 *         //   undefined: no action
 *         //   false: no action
 *         //   visitor.BREAK: stop visiting altogether
 *         //   null: delete this node
 *         //   any value: replace this node with the returned value
 *       }
 *     });
 *
 * Alternatively to providing enter() and leave() functions, a visitor can
 * instead provide functions named the same as the kinds of AST nodes, or
 * enter/leave visitors at a named key, leading to four permutations of
 * visitor API:
 *
 * 1) Named visitors triggered when entering a node a specific kind.
 *
 *     visit(ast, {
 *       Kind(node) {
 *         // enter the "Kind" node
 *       }
 *     })
 *
 * 2) Named visitors that trigger upon entering and leaving a node of
 *    a specific kind.
 *
 *     visit(ast, {
 *       Kind: {
 *         enter(node) {
 *           // enter the "Kind" node
 *         }
 *         leave(node) {
 *           // leave the "Kind" node
 *         }
 *       }
 *     })
 *
 * 3) Generic visitors that trigger upon entering and leaving any node.
 *
 *     visit(ast, {
 *       enter(node) {
 *         // enter any node
 *       },
 *       leave(node) {
 *         // leave any node
 *       }
 *     })
 *
 * 4) Parallel visitors for entering and leaving nodes of a specific kind.
 *
 *     visit(ast, {
 *       enter: {
 *         Kind(node) {
 *           // enter the "Kind" node
 *         }
 *       },
 *       leave: {
 *         Kind(node) {
 *           // leave the "Kind" node
 *         }
 *       }
 *     })
 */

function visit(root, visitor) {
  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;

  /* eslint-disable no-undef-init */
  var stack = undefined;
  var inArray = Array.isArray(root);
  var keys = [root];
  var index = -1;
  var edits = [];
  var node = undefined;
  var key = undefined;
  var parent = undefined;
  var path = [];
  var ancestors = [];
  var newRoot = root;
  /* eslint-enable no-undef-init */

  do {
    index++;
    var isLeaving = index === keys.length;
    var isEdited = isLeaving && edits.length !== 0;

    if (isLeaving) {
      key = ancestors.length === 0 ? undefined : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();

      if (isEdited) {
        if (inArray) {
          node = node.slice();
        } else {
          var clone = {};

          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {
            var k = _Object$keys2[_i2];
            clone[k] = node[k];
          }

          node = clone;
        }

        var editOffset = 0;

        for (var ii = 0; ii < edits.length; ii++) {
          var editKey = edits[ii][0];
          var editValue = edits[ii][1];

          if (inArray) {
            editKey -= editOffset;
          }

          if (inArray && editValue === null) {
            node.splice(editKey, 1);
            editOffset++;
          } else {
            node[editKey] = editValue;
          }
        }
      }

      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else {
      key = parent ? inArray ? index : keys[index] : undefined;
      node = parent ? parent[key] : newRoot;

      if (node === null || node === undefined) {
        continue;
      }

      if (parent) {
        path.push(key);
      }
    }

    var result = void 0;

    if (!Array.isArray(node)) {
      if (!isNode(node)) {
        throw new Error('Invalid AST Node: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(node));
      }

      var visitFn = getVisitFn(visitor, node.kind, isLeaving);

      if (visitFn) {
        result = visitFn.call(visitor, node, key, parent, path, ancestors);

        if (result === BREAK) {
          break;
        }

        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== undefined) {
          edits.push([key, result]);

          if (!isLeaving) {
            if (isNode(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
    }

    if (result === undefined && isEdited) {
      edits.push([key, node]);
    }

    if (isLeaving) {
      path.pop();
    } else {
      stack = {
        inArray: inArray,
        index: index,
        keys: keys,
        edits: edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : visitorKeys[node.kind] || [];
      index = -1;
      edits = [];

      if (parent) {
        ancestors.push(parent);
      }

      parent = node;
    }
  } while (stack !== undefined);

  if (edits.length !== 0) {
    newRoot = edits[edits.length - 1][1];
  }

  return newRoot;
}

function isNode(maybeNode) {
  return Boolean(maybeNode && typeof maybeNode.kind === 'string');
}
/**
 * Creates a new visitor instance which delegates to many visitors to run in
 * parallel. Each visitor will be visited for each node before moving on.
 *
 * If a prior visitor edits a node, no following visitors will see that node.
 */


function visitInParallel(visitors) {
  var skipping = new Array(visitors.length);
  return {
    enter: function enter(node) {
      for (var i = 0; i < visitors.length; i++) {
        if (!skipping[i]) {
          var fn = getVisitFn(visitors[i], node.kind,
          /* isLeaving */
          false);

          if (fn) {
            var result = fn.apply(visitors[i], arguments);

            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined) {
              return result;
            }
          }
        }
      }
    },
    leave: function leave(node) {
      for (var i = 0; i < visitors.length; i++) {
        if (!skipping[i]) {
          var fn = getVisitFn(visitors[i], node.kind,
          /* isLeaving */
          true);

          if (fn) {
            var result = fn.apply(visitors[i], arguments);

            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined && result !== false) {
              return result;
            }
          }
        } else if (skipping[i] === node) {
          skipping[i] = null;
        }
      }
    }
  };
}
/**
 * Creates a new visitor instance which maintains a provided TypeInfo instance
 * along with visiting visitor.
 */

function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter: function enter(node) {
      typeInfo.enter(node);
      var fn = getVisitFn(visitor, node.kind,
      /* isLeaving */
      false);

      if (fn) {
        var result = fn.apply(visitor, arguments);

        if (result !== undefined) {
          typeInfo.leave(node);

          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }

        return result;
      }
    },
    leave: function leave(node) {
      var fn = getVisitFn(visitor, node.kind,
      /* isLeaving */
      true);
      var result;

      if (fn) {
        result = fn.apply(visitor, arguments);
      }

      typeInfo.leave(node);
      return result;
    }
  };
}
/**
 * Given a visitor instance, if it is leaving or not, and a node kind, return
 * the function the visitor runtime should call.
 */

function getVisitFn(visitor, kind, isLeaving) {
  var kindVisitor = visitor[kind];

  if (kindVisitor) {
    if (!isLeaving && typeof kindVisitor === 'function') {
      // { Kind() {} }
      return kindVisitor;
    }

    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;

    if (typeof kindSpecificVisitor === 'function') {
      // { Kind: { enter() {}, leave() {} } }
      return kindSpecificVisitor;
    }
  } else {
    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;

    if (specificVisitor) {
      if (typeof specificVisitor === 'function') {
        // { enter() {}, leave() {} }
        return specificVisitor;
      }

      var specificKindVisitor = specificVisitor[kind];

      if (typeof specificKindVisitor === 'function') {
        // { enter: { Kind() {} }, leave: { Kind() {} } }
        return specificKindVisitor;
      }
    }
  }
}


/***/ }),
/* 15 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return isDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return assertDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return GraphQLDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return GraphQLIncludeDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return GraphQLSkipDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DEFAULT_DEPRECATION_REASON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return GraphQLDeprecatedDirective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return specifiedDirectives; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return isSpecifiedDirective; });
/* harmony import */ var _polyfills_objectEntries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _jsutils_toObjMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);
/* harmony import */ var _jsutils_devAssert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var _jsutils_instanceOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);
/* harmony import */ var _jsutils_defineToJSON__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(32);
/* harmony import */ var _jsutils_isObjectLike__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(18);
/* harmony import */ var _jsutils_defineToStringTag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(31);
/* harmony import */ var _language_directiveLocation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9);
/* harmony import */ var _scalars__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(13);
/* harmony import */ var _definition__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(0);











/**
 * Test if the given value is a GraphQL directive.
 */

// eslint-disable-next-line no-redeclare
function isDirective(directive) {
  return Object(_jsutils_instanceOf__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(directive, GraphQLDirective);
}
function assertDirective(directive) {
  if (!isDirective(directive)) {
    throw new Error("Expected ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(directive), " to be a GraphQL directive."));
  }

  return directive;
}
/**
 * Directives are used by the GraphQL runtime as a way of modifying execution
 * behavior. Type system creators will usually not create these directly.
 */

var GraphQLDirective =
/*#__PURE__*/
function () {
  function GraphQLDirective(config) {
    this.name = config.name;
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = config.isRepeatable != null && config.isRepeatable;
    this.extensions = config.extensions && Object(_jsutils_toObjMap__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(config.extensions);
    this.astNode = config.astNode;
    config.name || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(0, 'Directive must be named.');
    Array.isArray(config.locations) || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(0, "@".concat(config.name, " locations must be an Array."));
    var args = config.args || {};
    Object(_jsutils_isObjectLike__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(args) && !Array.isArray(args) || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(0, "@".concat(config.name, " args must be an object with argument names as keys."));
    this.args = Object(_polyfills_objectEntries__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(args).map(function (_ref) {
      var argName = _ref[0],
          arg = _ref[1];
      return {
        name: argName,
        description: arg.description === undefined ? null : arg.description,
        type: arg.type,
        defaultValue: arg.defaultValue,
        extensions: arg.extensions && Object(_jsutils_toObjMap__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(arg.extensions),
        astNode: arg.astNode
      };
    });
  }

  var _proto = GraphQLDirective.prototype;

  _proto.toString = function toString() {
    return '@' + this.name;
  };

  _proto.toConfig = function toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: Object(_definition__WEBPACK_IMPORTED_MODULE_10__[/* argsToArgsConfig */ "i"])(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  };

  return GraphQLDirective;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

Object(_jsutils_defineToStringTag__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(GraphQLDirective);
Object(_jsutils_defineToJSON__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(GraphQLDirective);

/**
 * Used to conditionally include fields or fragments.
 */
var GraphQLIncludeDirective = new GraphQLDirective({
  name: 'include',
  description: 'Directs the executor to include this field or fragment only when the `if` argument is true.',
  locations: [_language_directiveLocation__WEBPACK_IMPORTED_MODULE_8__[/* DirectiveLocation */ "a"].FIELD, _language_directiveLocation__WEBPACK_IMPORTED_MODULE_8__[/* DirectiveLocation */ "a"].FRAGMENT_SPREAD, _language_directiveLocation__WEBPACK_IMPORTED_MODULE_8__[/* DirectiveLocation */ "a"].INLINE_FRAGMENT],
  args: {
    if: {
      type: Object(_definition__WEBPACK_IMPORTED_MODULE_10__[/* GraphQLNonNull */ "e"])(_scalars__WEBPACK_IMPORTED_MODULE_9__[/* GraphQLBoolean */ "a"]),
      description: 'Included when true.'
    }
  }
});
/**
 * Used to conditionally skip (exclude) fields or fragments.
 */

var GraphQLSkipDirective = new GraphQLDirective({
  name: 'skip',
  description: 'Directs the executor to skip this field or fragment when the `if` argument is true.',
  locations: [_language_directiveLocation__WEBPACK_IMPORTED_MODULE_8__[/* DirectiveLocation */ "a"].FIELD, _language_directiveLocation__WEBPACK_IMPORTED_MODULE_8__[/* DirectiveLocation */ "a"].FRAGMENT_SPREAD, _language_directiveLocation__WEBPACK_IMPORTED_MODULE_8__[/* DirectiveLocation */ "a"].INLINE_FRAGMENT],
  args: {
    if: {
      type: Object(_definition__WEBPACK_IMPORTED_MODULE_10__[/* GraphQLNonNull */ "e"])(_scalars__WEBPACK_IMPORTED_MODULE_9__[/* GraphQLBoolean */ "a"]),
      description: 'Skipped when true.'
    }
  }
});
/**
 * Constant string used for default reason for a deprecation.
 */

var DEFAULT_DEPRECATION_REASON = 'No longer supported';
/**
 * Used to declare element of a GraphQL schema as deprecated.
 */

var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: 'deprecated',
  description: 'Marks an element of a GraphQL schema as no longer supported.',
  locations: [_language_directiveLocation__WEBPACK_IMPORTED_MODULE_8__[/* DirectiveLocation */ "a"].FIELD_DEFINITION, _language_directiveLocation__WEBPACK_IMPORTED_MODULE_8__[/* DirectiveLocation */ "a"].ENUM_VALUE],
  args: {
    reason: {
      type: _scalars__WEBPACK_IMPORTED_MODULE_9__[/* GraphQLString */ "e"],
      description: 'Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax (as specified by [CommonMark](https://commonmark.org/).',
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
/**
 * The full list of specified directives.
 */

var specifiedDirectives = Object.freeze([GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective]);
function isSpecifiedDirective(directive) {
  return isDirective(directive) && specifiedDirectives.some(function (_ref2) {
    var name = _ref2.name;
    return name === directive.name;
  });
}


/***/ }),
/* 16 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return print; });
/* harmony import */ var _visitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _blockString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);


/**
 * Converts an AST into a string, using one set of reasonable
 * formatting rules.
 */

function print(ast) {
  return Object(_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ "c"])(ast, {
    leave: printDocASTReducer
  });
} // TODO: provide better type coverage in future

var printDocASTReducer = {
  Name: function Name(node) {
    return node.value;
  },
  Variable: function Variable(node) {
    return '$' + node.name;
  },
  // Document
  Document: function Document(node) {
    return join(node.definitions, '\n\n') + '\n';
  },
  OperationDefinition: function OperationDefinition(node) {
    var op = node.operation;
    var name = node.name;
    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');
    var directives = join(node.directives, ' ');
    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use
    // the query short form.

    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');
  },
  VariableDefinition: function VariableDefinition(_ref) {
    var variable = _ref.variable,
        type = _ref.type,
        defaultValue = _ref.defaultValue,
        directives = _ref.directives;
    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));
  },
  SelectionSet: function SelectionSet(_ref2) {
    var selections = _ref2.selections;
    return block(selections);
  },
  Field: function Field(_ref3) {
    var alias = _ref3.alias,
        name = _ref3.name,
        args = _ref3.arguments,
        directives = _ref3.directives,
        selectionSet = _ref3.selectionSet;
    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');
  },
  Argument: function Argument(_ref4) {
    var name = _ref4.name,
        value = _ref4.value;
    return name + ': ' + value;
  },
  // Fragments
  FragmentSpread: function FragmentSpread(_ref5) {
    var name = _ref5.name,
        directives = _ref5.directives;
    return '...' + name + wrap(' ', join(directives, ' '));
  },
  InlineFragment: function InlineFragment(_ref6) {
    var typeCondition = _ref6.typeCondition,
        directives = _ref6.directives,
        selectionSet = _ref6.selectionSet;
    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');
  },
  FragmentDefinition: function FragmentDefinition(_ref7) {
    var name = _ref7.name,
        typeCondition = _ref7.typeCondition,
        variableDefinitions = _ref7.variableDefinitions,
        directives = _ref7.directives,
        selectionSet = _ref7.selectionSet;
    return (// Note: fragment variable definitions are experimental and may be changed
      // or removed in the future.
      "fragment ".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), " ") + "on ".concat(typeCondition, " ").concat(wrap('', join(directives, ' '), ' ')) + selectionSet
    );
  },
  // Value
  IntValue: function IntValue(_ref8) {
    var value = _ref8.value;
    return value;
  },
  FloatValue: function FloatValue(_ref9) {
    var value = _ref9.value;
    return value;
  },
  StringValue: function StringValue(_ref10, key) {
    var value = _ref10.value,
        isBlockString = _ref10.block;
    return isBlockString ? Object(_blockString__WEBPACK_IMPORTED_MODULE_1__[/* printBlockString */ "c"])(value, key === 'description' ? '' : '  ') : JSON.stringify(value);
  },
  BooleanValue: function BooleanValue(_ref11) {
    var value = _ref11.value;
    return value ? 'true' : 'false';
  },
  NullValue: function NullValue() {
    return 'null';
  },
  EnumValue: function EnumValue(_ref12) {
    var value = _ref12.value;
    return value;
  },
  ListValue: function ListValue(_ref13) {
    var values = _ref13.values;
    return '[' + join(values, ', ') + ']';
  },
  ObjectValue: function ObjectValue(_ref14) {
    var fields = _ref14.fields;
    return '{' + join(fields, ', ') + '}';
  },
  ObjectField: function ObjectField(_ref15) {
    var name = _ref15.name,
        value = _ref15.value;
    return name + ': ' + value;
  },
  // Directive
  Directive: function Directive(_ref16) {
    var name = _ref16.name,
        args = _ref16.arguments;
    return '@' + name + wrap('(', join(args, ', '), ')');
  },
  // Type
  NamedType: function NamedType(_ref17) {
    var name = _ref17.name;
    return name;
  },
  ListType: function ListType(_ref18) {
    var type = _ref18.type;
    return '[' + type + ']';
  },
  NonNullType: function NonNullType(_ref19) {
    var type = _ref19.type;
    return type + '!';
  },
  // Type System Definitions
  SchemaDefinition: function SchemaDefinition(_ref20) {
    var directives = _ref20.directives,
        operationTypes = _ref20.operationTypes;
    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');
  },
  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
    var operation = _ref21.operation,
        type = _ref21.type;
    return operation + ': ' + type;
  },
  ScalarTypeDefinition: addDescription(function (_ref22) {
    var name = _ref22.name,
        directives = _ref22.directives;
    return join(['scalar', name, join(directives, ' ')], ' ');
  }),
  ObjectTypeDefinition: addDescription(function (_ref23) {
    var name = _ref23.name,
        interfaces = _ref23.interfaces,
        directives = _ref23.directives,
        fields = _ref23.fields;
    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  }),
  FieldDefinition: addDescription(function (_ref24) {
    var name = _ref24.name,
        args = _ref24.arguments,
        type = _ref24.type,
        directives = _ref24.directives;
    return name + (hasMultilineItems(args) ? wrap('(\n', indent(join(args, '\n')), '\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));
  }),
  InputValueDefinition: addDescription(function (_ref25) {
    var name = _ref25.name,
        type = _ref25.type,
        defaultValue = _ref25.defaultValue,
        directives = _ref25.directives;
    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');
  }),
  InterfaceTypeDefinition: addDescription(function (_ref26) {
    var name = _ref26.name,
        directives = _ref26.directives,
        fields = _ref26.fields;
    return join(['interface', name, join(directives, ' '), block(fields)], ' ');
  }),
  UnionTypeDefinition: addDescription(function (_ref27) {
    var name = _ref27.name,
        directives = _ref27.directives,
        types = _ref27.types;
    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
  }),
  EnumTypeDefinition: addDescription(function (_ref28) {
    var name = _ref28.name,
        directives = _ref28.directives,
        values = _ref28.values;
    return join(['enum', name, join(directives, ' '), block(values)], ' ');
  }),
  EnumValueDefinition: addDescription(function (_ref29) {
    var name = _ref29.name,
        directives = _ref29.directives;
    return join([name, join(directives, ' ')], ' ');
  }),
  InputObjectTypeDefinition: addDescription(function (_ref30) {
    var name = _ref30.name,
        directives = _ref30.directives,
        fields = _ref30.fields;
    return join(['input', name, join(directives, ' '), block(fields)], ' ');
  }),
  DirectiveDefinition: addDescription(function (_ref31) {
    var name = _ref31.name,
        args = _ref31.arguments,
        repeatable = _ref31.repeatable,
        locations = _ref31.locations;
    return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\n', indent(join(args, '\n')), '\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');
  }),
  SchemaExtension: function SchemaExtension(_ref32) {
    var directives = _ref32.directives,
        operationTypes = _ref32.operationTypes;
    return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');
  },
  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
    var name = _ref33.name,
        directives = _ref33.directives;
    return join(['extend scalar', name, join(directives, ' ')], ' ');
  },
  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
    var name = _ref34.name,
        interfaces = _ref34.interfaces,
        directives = _ref34.directives,
        fields = _ref34.fields;
    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');
  },
  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
    var name = _ref35.name,
        directives = _ref35.directives,
        fields = _ref35.fields;
    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');
  },
  UnionTypeExtension: function UnionTypeExtension(_ref36) {
    var name = _ref36.name,
        directives = _ref36.directives,
        types = _ref36.types;
    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');
  },
  EnumTypeExtension: function EnumTypeExtension(_ref37) {
    var name = _ref37.name,
        directives = _ref37.directives,
        values = _ref37.values;
    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');
  },
  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
    var name = _ref38.name,
        directives = _ref38.directives,
        fields = _ref38.fields;
    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');
  }
};

function addDescription(cb) {
  return function (node) {
    return join([node.description, cb(node)], '\n');
  };
}
/**
 * Given maybeArray, print an empty string if it is null or empty, otherwise
 * print all items together separated by separator if provided
 */


function join(maybeArray, separator) {
  return maybeArray ? maybeArray.filter(function (x) {
    return x;
  }).join(separator || '') : '';
}
/**
 * Given array, print each item on its own line, wrapped in an
 * indented "{ }" block.
 */


function block(array) {
  return array && array.length !== 0 ? '{\n' + indent(join(array, '\n')) + '\n}' : '';
}
/**
 * If maybeString is not null or empty, then wrap with start and end, otherwise
 * print an empty string.
 */


function wrap(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || '') : '';
}

function indent(maybeString) {
  return maybeString && '  ' + maybeString.replace(/\n/g, '\n  ');
}

function isMultiline(string) {
  return string.indexOf('\n') !== -1;
}

function hasMultilineItems(maybeArray) {
  return maybeArray && maybeArray.some(isMultiline);
}


/***/ }),
/* 17 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return invariant; });
function invariant(condition, message) {
  var booleanCondition = Boolean(condition);

  if (!booleanCondition) {
    throw new Error(message || 'Unexpected invariant triggered');
  }
}


/***/ }),
/* 18 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isObjectLike; });
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Return true if `value` is object-like. A value is object-like if it's not
 * `null` and has a `typeof` result of "object".
 */
function isObjectLike(value) {
  return _typeof(value) == 'object' && value !== null;
}


/***/ }),
/* 19 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return typeFromAST; });
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _jsutils_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);




/**
 * Given a Schema and an AST node describing a type, return a GraphQLType
 * definition which applies to that type. For example, if provided the parsed
 * AST node for `[User]`, a GraphQLList instance will be returned, containing
 * the type called "User" found in the schema. If a type called "User" is not
 * found in the schema, then undefined will be returned.
 */

/* eslint-disable no-redeclare */

function typeFromAST(schema, typeNode) {
  /* eslint-enable no-redeclare */
  var innerType;

  if (typeNode.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_2__[/* Kind */ "a"].LIST_TYPE) {
    innerType = typeFromAST(schema, typeNode.type);
    return innerType && Object(_type_definition__WEBPACK_IMPORTED_MODULE_3__[/* GraphQLList */ "d"])(innerType);
  }

  if (typeNode.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_2__[/* Kind */ "a"].NON_NULL_TYPE) {
    innerType = typeFromAST(schema, typeNode.type);
    return innerType && Object(_type_definition__WEBPACK_IMPORTED_MODULE_3__[/* GraphQLNonNull */ "e"])(innerType);
  }

  /* istanbul ignore else */
  if (typeNode.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_2__[/* Kind */ "a"].NAMED_TYPE) {
    return schema.getType(typeNode.name.value);
  } // Not reachable. All possible type nodes have been considered.


  /* istanbul ignore next */
  Object(_jsutils_invariant__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(false, 'Unexpected type node: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(typeNode));
}


/***/ }),
/* 20 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return keyValMap; });
/**
 * Creates a keyed JS object from an array, given a function to produce the keys
 * and a function to produce the values from each item in the array.
 *
 *     const phoneBook = [
 *       { name: 'Jon', num: '555-1234' },
 *       { name: 'Jenny', num: '867-5309' }
 *     ]
 *
 *     // { Jon: '555-1234', Jenny: '867-5309' }
 *     const phonesByName = keyValMap(
 *       phoneBook,
 *       entry => entry.name,
 *       entry => entry.num
 *     )
 *
 */
function keyValMap(list, keyFn, valFn) {
  return list.reduce(function (map, item) {
    map[keyFn(item)] = valFn(item);
    return map;
  }, Object.create(null));
}


/***/ }),
/* 21 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return pathToArray; });
/**
 * Given a Path and a key, return a new Path containing the new key.
 */
function addPath(prev, key) {
  return {
    prev: prev,
    key: key
  };
}
/**
 * Given a Path, return an Array of the path keys.
 */

function pathToArray(path) {
  var flattened = [];
  var curr = path;

  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }

  return flattened.reverse();
}


/***/ }),
/* 22 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return keyMap; });
/**
 * Creates a keyed JS object from an array, given a function to produce the keys
 * for each value in the array.
 *
 * This provides a convenient lookup for the array items if the key function
 * produces unique results.
 *
 *     const phoneBook = [
 *       { name: 'Jon', num: '555-1234' },
 *       { name: 'Jenny', num: '867-5309' }
 *     ]
 *
 *     // { Jon: { name: 'Jon', num: '555-1234' },
 *     //   Jenny: { name: 'Jenny', num: '867-5309' } }
 *     const entriesByName = keyMap(
 *       phoneBook,
 *       entry => entry.name
 *     )
 *
 *     // { name: 'Jenny', num: '857-6309' }
 *     const jennyEntry = entriesByName['Jenny']
 *
 */
function keyMap(list, keyFn) {
  return list.reduce(function (map, item) {
    map[keyFn(item)] = item;
    return map;
  }, Object.create(null));
}


/***/ }),
/* 23 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isPromise; });
/**
 * Returns true if the value acts like a Promise, i.e. has a "then" function,
 * otherwise returns false.
 */
// eslint-disable-next-line no-redeclare
function isPromise(value) {
  return Boolean(value && typeof value.then === 'function');
}


/***/ }),
/* 24 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$$iterator", function() { return $$iterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIterable", function() { return isIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArrayLike", function() { return isArrayLike; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCollection", function() { return isCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIterator", function() { return getIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIteratorMethod", function() { return getIteratorMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createIterator", function() { return createIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$$asyncIterator", function() { return $$asyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAsyncIterable", function() { return isAsyncIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAsyncIterator", function() { return getAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAsyncIteratorMethod", function() { return getAsyncIteratorMethod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createAsyncIterator", function() { return createAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forAwaitEach", function() { return forAwaitEach; });
/**
 * Copyright (c) 2016, Lee Byron
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 * @ignore
 */

/**
 * [Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator)
 * is a *protocol* which describes a standard way to produce a sequence of
 * values, typically the values of the Iterable represented by this Iterator.
 *
 * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterator-interface)
 * it can be utilized by any version of JavaScript.
 *
 * @external Iterator
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterator|MDN Iteration protocols}
 */

/**
 * [Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
 * is a *protocol* which when implemented allows a JavaScript object to define
 * their iteration behavior, such as what values are looped over in a
 * [`for...of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)
 * loop or `iterall`'s `forEach` function. Many [built-in types](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#Builtin_iterables)
 * implement the Iterable protocol, including `Array` and `Map`.
 *
 * While described by the [ES2015 version of JavaScript](http://www.ecma-international.org/ecma-262/6.0/#sec-iterable-interface)
 * it can be utilized by any version of JavaScript.
 *
 * @external Iterable
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable|MDN Iteration protocols}
 */

// In ES2015 environments, Symbol exists
var SYMBOL /*: any */ = typeof Symbol === 'function' ? Symbol : void 0

// In ES2015 (or a polyfilled) environment, this will be Symbol.iterator
var SYMBOL_ITERATOR = SYMBOL && SYMBOL.iterator

/**
 * A property name to be used as the name of an Iterable's method responsible
 * for producing an Iterator, referred to as `@@iterator`. Typically represents
 * the value `Symbol.iterator` but falls back to the string `"@@iterator"` when
 * `Symbol.iterator` is not defined.
 *
 * Use `$$iterator` for defining new Iterables instead of `Symbol.iterator`,
 * but do not use it for accessing existing Iterables, instead use
 * {@link getIterator} or {@link isIterable}.
 *
 * @example
 *
 * var $$iterator = require('iterall').$$iterator
 *
 * function Counter (to) {
 *   this.to = to
 * }
 *
 * Counter.prototype[$$iterator] = function () {
 *   return {
 *     to: this.to,
 *     num: 0,
 *     next () {
 *       if (this.num >= this.to) {
 *         return { value: undefined, done: true }
 *       }
 *       return { value: this.num++, done: false }
 *     }
 *   }
 * }
 *
 * var counter = new Counter(3)
 * for (var number of counter) {
 *   console.log(number) // 0 ... 1 ... 2
 * }
 *
 * @type {Symbol|string}
 */
/*:: declare export var $$iterator: '@@iterator'; */
var $$iterator = SYMBOL_ITERATOR || '@@iterator'

/**
 * Returns true if the provided object implements the Iterator protocol via
 * either implementing a `Symbol.iterator` or `"@@iterator"` method.
 *
 * @example
 *
 * var isIterable = require('iterall').isIterable
 * isIterable([ 1, 2, 3 ]) // true
 * isIterable('ABC') // true
 * isIterable({ length: 1, 0: 'Alpha' }) // false
 * isIterable({ key: 'value' }) // false
 * isIterable(new Map()) // true
 *
 * @param obj
 *   A value which might implement the Iterable protocol.
 * @return {boolean} true if Iterable.
 */
/*:: declare export function isIterable(obj: any): boolean; */
function isIterable(obj) {
  return !!getIteratorMethod(obj)
}

/**
 * Returns true if the provided object implements the Array-like protocol via
 * defining a positive-integer `length` property.
 *
 * @example
 *
 * var isArrayLike = require('iterall').isArrayLike
 * isArrayLike([ 1, 2, 3 ]) // true
 * isArrayLike('ABC') // true
 * isArrayLike({ length: 1, 0: 'Alpha' }) // true
 * isArrayLike({ key: 'value' }) // false
 * isArrayLike(new Map()) // false
 *
 * @param obj
 *   A value which might implement the Array-like protocol.
 * @return {boolean} true if Array-like.
 */
/*:: declare export function isArrayLike(obj: any): boolean; */
function isArrayLike(obj) {
  var length = obj != null && obj.length
  return typeof length === 'number' && length >= 0 && length % 1 === 0
}

/**
 * Returns true if the provided object is an Object (i.e. not a string literal)
 * and is either Iterable or Array-like.
 *
 * This may be used in place of [Array.isArray()][isArray] to determine if an
 * object should be iterated-over. It always excludes string literals and
 * includes Arrays (regardless of if it is Iterable). It also includes other
 * Array-like objects such as NodeList, TypedArray, and Buffer.
 *
 * @example
 *
 * var isCollection = require('iterall').isCollection
 * isCollection([ 1, 2, 3 ]) // true
 * isCollection('ABC') // false
 * isCollection({ length: 1, 0: 'Alpha' }) // true
 * isCollection({ key: 'value' }) // false
 * isCollection(new Map()) // true
 *
 * @example
 *
 * var forEach = require('iterall').forEach
 * if (isCollection(obj)) {
 *   forEach(obj, function (value) {
 *     console.log(value)
 *   })
 * }
 *
 * @param obj
 *   An Object value which might implement the Iterable or Array-like protocols.
 * @return {boolean} true if Iterable or Array-like Object.
 */
/*:: declare export function isCollection(obj: any): boolean; */
function isCollection(obj) {
  return Object(obj) === obj && (isArrayLike(obj) || isIterable(obj))
}

/**
 * If the provided object implements the Iterator protocol, its Iterator object
 * is returned. Otherwise returns undefined.
 *
 * @example
 *
 * var getIterator = require('iterall').getIterator
 * var iterator = getIterator([ 1, 2, 3 ])
 * iterator.next() // { value: 1, done: false }
 * iterator.next() // { value: 2, done: false }
 * iterator.next() // { value: 3, done: false }
 * iterator.next() // { value: undefined, done: true }
 *
 * @template T the type of each iterated value
 * @param {Iterable<T>} iterable
 *   An Iterable object which is the source of an Iterator.
 * @return {Iterator<T>} new Iterator instance.
 */
/*:: declare export var getIterator:
  & (<+TValue>(iterable: Iterable<TValue>) => Iterator<TValue>)
  & ((iterable: mixed) => void | Iterator<mixed>); */
function getIterator(iterable) {
  var method = getIteratorMethod(iterable)
  if (method) {
    return method.call(iterable)
  }
}

/**
 * If the provided object implements the Iterator protocol, the method
 * responsible for producing its Iterator object is returned.
 *
 * This is used in rare cases for performance tuning. This method must be called
 * with obj as the contextual this-argument.
 *
 * @example
 *
 * var getIteratorMethod = require('iterall').getIteratorMethod
 * var myArray = [ 1, 2, 3 ]
 * var method = getIteratorMethod(myArray)
 * if (method) {
 *   var iterator = method.call(myArray)
 * }
 *
 * @template T the type of each iterated value
 * @param {Iterable<T>} iterable
 *   An Iterable object which defines an `@@iterator` method.
 * @return {function(): Iterator<T>} `@@iterator` method.
 */
/*:: declare export var getIteratorMethod:
  & (<+TValue>(iterable: Iterable<TValue>) => (() => Iterator<TValue>))
  & ((iterable: mixed) => (void | (() => Iterator<mixed>))); */
function getIteratorMethod(iterable) {
  if (iterable != null) {
    var method =
      (SYMBOL_ITERATOR && iterable[SYMBOL_ITERATOR]) || iterable['@@iterator']
    if (typeof method === 'function') {
      return method
    }
  }
}

/**
 * Similar to {@link getIterator}, this method returns a new Iterator given an
 * Iterable. However it will also create an Iterator for a non-Iterable
 * Array-like collection, such as Array in a non-ES2015 environment.
 *
 * `createIterator` is complimentary to `forEach`, but allows a "pull"-based
 * iteration as opposed to `forEach`'s "push"-based iteration.
 *
 * `createIterator` produces an Iterator for Array-likes with the same behavior
 * as ArrayIteratorPrototype described in the ECMAScript specification, and
 * does *not* skip over "holes".
 *
 * @example
 *
 * var createIterator = require('iterall').createIterator
 *
 * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }
 * var iterator = createIterator(myArraylike)
 * iterator.next() // { value: 'Alpha', done: false }
 * iterator.next() // { value: 'Bravo', done: false }
 * iterator.next() // { value: 'Charlie', done: false }
 * iterator.next() // { value: undefined, done: true }
 *
 * @template T the type of each iterated value
 * @param {Iterable<T>|{ length: number }} collection
 *   An Iterable or Array-like object to produce an Iterator.
 * @return {Iterator<T>} new Iterator instance.
 */
/*:: declare export var createIterator:
  & (<+TValue>(collection: Iterable<TValue>) => Iterator<TValue>)
  & ((collection: {length: number}) => Iterator<mixed>)
  & ((collection: mixed) => (void | Iterator<mixed>)); */
function createIterator(collection) {
  if (collection != null) {
    var iterator = getIterator(collection)
    if (iterator) {
      return iterator
    }
    if (isArrayLike(collection)) {
      return new ArrayLikeIterator(collection)
    }
  }
}

// When the object provided to `createIterator` is not Iterable but is
// Array-like, this simple Iterator is created.
function ArrayLikeIterator(obj) {
  this._o = obj
  this._i = 0
}

// Note: all Iterators are themselves Iterable.
ArrayLikeIterator.prototype[$$iterator] = function() {
  return this
}

// A simple state-machine determines the IteratorResult returned, yielding
// each value in the Array-like object in order of their indicies.
ArrayLikeIterator.prototype.next = function() {
  if (this._o === void 0 || this._i >= this._o.length) {
    this._o = void 0
    return { value: void 0, done: true }
  }
  return { value: this._o[this._i++], done: false }
}

/**
 * Given an object which either implements the Iterable protocol or is
 * Array-like, iterate over it, calling the `callback` at each iteration.
 *
 * Use `forEach` where you would expect to use a `for ... of` loop in ES6.
 * However `forEach` adheres to the behavior of [Array#forEach][] described in
 * the ECMAScript specification, skipping over "holes" in Array-likes. It will
 * also delegate to a `forEach` method on `collection` if one is defined,
 * ensuring native performance for `Arrays`.
 *
 * Similar to [Array#forEach][], the `callback` function accepts three
 * arguments, and is provided with `thisArg` as the calling context.
 *
 * Note: providing an infinite Iterator to forEach will produce an error.
 *
 * [Array#forEach]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
 *
 * @example
 *
 * var forEach = require('iterall').forEach
 *
 * forEach(myIterable, function (value, index, iterable) {
 *   console.log(value, index, iterable === myIterable)
 * })
 *
 * @example
 *
 * // ES6:
 * for (let value of myIterable) {
 *   console.log(value)
 * }
 *
 * // Any JavaScript environment:
 * forEach(myIterable, function (value) {
 *   console.log(value)
 * })
 *
 * @template T the type of each iterated value
 * @param {Iterable<T>|{ length: number }} collection
 *   The Iterable or array to iterate over.
 * @param {function(T, number, object)} callback
 *   Function to execute for each iteration, taking up to three arguments
 * @param [thisArg]
 *   Optional. Value to use as `this` when executing `callback`.
 */
/*:: declare export var forEach:
  & (<+TValue, TCollection: Iterable<TValue>>(
      collection: TCollection,
      callbackFn: (value: TValue, index: number, collection: TCollection) => any,
      thisArg?: any
    ) => void)
  & (<TCollection: {length: number}>(
      collection: TCollection,
      callbackFn: (value: mixed, index: number, collection: TCollection) => any,
      thisArg?: any
    ) => void); */
function forEach(collection, callback, thisArg) {
  if (collection != null) {
    if (typeof collection.forEach === 'function') {
      return collection.forEach(callback, thisArg)
    }
    var i = 0
    var iterator = getIterator(collection)
    if (iterator) {
      var step
      while (!(step = iterator.next()).done) {
        callback.call(thisArg, step.value, i++, collection)
        // Infinite Iterators could cause forEach to run forever.
        // After a very large number of iterations, produce an error.
        /* istanbul ignore if */
        if (i > 9999999) {
          throw new TypeError('Near-infinite iteration.')
        }
      }
    } else if (isArrayLike(collection)) {
      for (; i < collection.length; i++) {
        if (collection.hasOwnProperty(i)) {
          callback.call(thisArg, collection[i], i, collection)
        }
      }
    }
  }
}

/////////////////////////////////////////////////////
//                                                 //
//                 ASYNC ITERATORS                 //
//                                                 //
/////////////////////////////////////////////////////

/**
 * [AsyncIterable](https://tc39.github.io/proposal-async-iteration/#sec-asynciterable-interface)
 * is a *protocol* which when implemented allows a JavaScript object to define
 * an asynchronous iteration behavior, such as what values are looped over in
 * a [`for-await-of`](https://tc39.github.io/proposal-async-iteration/#sec-for-in-and-for-of-statements)
 * loop or `iterall`'s {@link forAwaitEach} function.
 *
 * While described as a proposed addition to the [ES2017 version of JavaScript](https://tc39.github.io/proposal-async-iteration/)
 * it can be utilized by any version of JavaScript.
 *
 * @external AsyncIterable
 * @see {@link https://tc39.github.io/proposal-async-iteration/#sec-asynciterable-interface|Async Iteration Proposal}
 * @template T The type of each iterated value
 * @property {function (): AsyncIterator<T>} Symbol.asyncIterator
 *   A method which produces an AsyncIterator for this AsyncIterable.
 */

/**
 * [AsyncIterator](https://tc39.github.io/proposal-async-iteration/#sec-asynciterator-interface)
 * is a *protocol* which describes a standard way to produce and consume an
 * asynchronous sequence of values, typically the values of the
 * {@link AsyncIterable} represented by this {@link AsyncIterator}.
 *
 * AsyncIterator is similar to Observable or Stream. Like an {@link Iterator} it
 * also as a `next()` method, however instead of an IteratorResult,
 * calling this method returns a {@link Promise} for a IteratorResult.
 *
 * While described as a proposed addition to the [ES2017 version of JavaScript](https://tc39.github.io/proposal-async-iteration/)
 * it can be utilized by any version of JavaScript.
 *
 * @external AsyncIterator
 * @see {@link https://tc39.github.io/proposal-async-iteration/#sec-asynciterator-interface|Async Iteration Proposal}
 */

// In ES2017 (or a polyfilled) environment, this will be Symbol.asyncIterator
var SYMBOL_ASYNC_ITERATOR = SYMBOL && SYMBOL.asyncIterator

/**
 * A property name to be used as the name of an AsyncIterable's method
 * responsible for producing an Iterator, referred to as `@@asyncIterator`.
 * Typically represents the value `Symbol.asyncIterator` but falls back to the
 * string `"@@asyncIterator"` when `Symbol.asyncIterator` is not defined.
 *
 * Use `$$asyncIterator` for defining new AsyncIterables instead of
 * `Symbol.asyncIterator`, but do not use it for accessing existing Iterables,
 * instead use {@link getAsyncIterator} or {@link isAsyncIterable}.
 *
 * @example
 *
 * var $$asyncIterator = require('iterall').$$asyncIterator
 *
 * function Chirper (to) {
 *   this.to = to
 * }
 *
 * Chirper.prototype[$$asyncIterator] = function () {
 *   return {
 *     to: this.to,
 *     num: 0,
 *     next () {
 *       return new Promise(resolve => {
 *         if (this.num >= this.to) {
 *           resolve({ value: undefined, done: true })
 *         } else {
 *           setTimeout(() => {
 *             resolve({ value: this.num++, done: false })
 *           }, 1000)
 *         }
 *       })
 *     }
 *   }
 * }
 *
 * var chirper = new Chirper(3)
 * for await (var number of chirper) {
 *   console.log(number) // 0 ...wait... 1 ...wait... 2
 * }
 *
 * @type {Symbol|string}
 */
/*:: declare export var $$asyncIterator: '@@asyncIterator'; */
var $$asyncIterator = SYMBOL_ASYNC_ITERATOR || '@@asyncIterator'

/**
 * Returns true if the provided object implements the AsyncIterator protocol via
 * either implementing a `Symbol.asyncIterator` or `"@@asyncIterator"` method.
 *
 * @example
 *
 * var isAsyncIterable = require('iterall').isAsyncIterable
 * isAsyncIterable(myStream) // true
 * isAsyncIterable('ABC') // false
 *
 * @param obj
 *   A value which might implement the AsyncIterable protocol.
 * @return {boolean} true if AsyncIterable.
 */
/*:: declare export function isAsyncIterable(obj: any): boolean; */
function isAsyncIterable(obj) {
  return !!getAsyncIteratorMethod(obj)
}

/**
 * If the provided object implements the AsyncIterator protocol, its
 * AsyncIterator object is returned. Otherwise returns undefined.
 *
 * @example
 *
 * var getAsyncIterator = require('iterall').getAsyncIterator
 * var asyncIterator = getAsyncIterator(myStream)
 * asyncIterator.next().then(console.log) // { value: 1, done: false }
 * asyncIterator.next().then(console.log) // { value: 2, done: false }
 * asyncIterator.next().then(console.log) // { value: 3, done: false }
 * asyncIterator.next().then(console.log) // { value: undefined, done: true }
 *
 * @template T the type of each iterated value
 * @param {AsyncIterable<T>} asyncIterable
 *   An AsyncIterable object which is the source of an AsyncIterator.
 * @return {AsyncIterator<T>} new AsyncIterator instance.
 */
/*:: declare export var getAsyncIterator:
  & (<+TValue>(asyncIterable: AsyncIterable<TValue>) => AsyncIterator<TValue>)
  & ((asyncIterable: mixed) => (void | AsyncIterator<mixed>)); */
function getAsyncIterator(asyncIterable) {
  var method = getAsyncIteratorMethod(asyncIterable)
  if (method) {
    return method.call(asyncIterable)
  }
}

/**
 * If the provided object implements the AsyncIterator protocol, the method
 * responsible for producing its AsyncIterator object is returned.
 *
 * This is used in rare cases for performance tuning. This method must be called
 * with obj as the contextual this-argument.
 *
 * @example
 *
 * var getAsyncIteratorMethod = require('iterall').getAsyncIteratorMethod
 * var method = getAsyncIteratorMethod(myStream)
 * if (method) {
 *   var asyncIterator = method.call(myStream)
 * }
 *
 * @template T the type of each iterated value
 * @param {AsyncIterable<T>} asyncIterable
 *   An AsyncIterable object which defines an `@@asyncIterator` method.
 * @return {function(): AsyncIterator<T>} `@@asyncIterator` method.
 */
/*:: declare export var getAsyncIteratorMethod:
  & (<+TValue>(asyncIterable: AsyncIterable<TValue>) => (() => AsyncIterator<TValue>))
  & ((asyncIterable: mixed) => (void | (() => AsyncIterator<mixed>))); */
function getAsyncIteratorMethod(asyncIterable) {
  if (asyncIterable != null) {
    var method =
      (SYMBOL_ASYNC_ITERATOR && asyncIterable[SYMBOL_ASYNC_ITERATOR]) ||
      asyncIterable['@@asyncIterator']
    if (typeof method === 'function') {
      return method
    }
  }
}

/**
 * Similar to {@link getAsyncIterator}, this method returns a new AsyncIterator
 * given an AsyncIterable. However it will also create an AsyncIterator for a
 * non-async Iterable as well as non-Iterable Array-like collection, such as
 * Array in a pre-ES2015 environment.
 *
 * `createAsyncIterator` is complimentary to `forAwaitEach`, but allows a
 * buffering "pull"-based iteration as opposed to `forAwaitEach`'s
 * "push"-based iteration.
 *
 * `createAsyncIterator` produces an AsyncIterator for non-async Iterables as
 * described in the ECMAScript proposal [Async-from-Sync Iterator Objects](https://tc39.github.io/proposal-async-iteration/#sec-async-from-sync-iterator-objects).
 *
 * > Note: Creating `AsyncIterator`s requires the existence of `Promise`.
 * > While `Promise` has been available in modern browsers for a number of
 * > years, legacy browsers (like IE 11) may require a polyfill.
 *
 * @example
 *
 * var createAsyncIterator = require('iterall').createAsyncIterator
 *
 * var myArraylike = { length: 3, 0: 'Alpha', 1: 'Bravo', 2: 'Charlie' }
 * var iterator = createAsyncIterator(myArraylike)
 * iterator.next().then(console.log) // { value: 'Alpha', done: false }
 * iterator.next().then(console.log) // { value: 'Bravo', done: false }
 * iterator.next().then(console.log) // { value: 'Charlie', done: false }
 * iterator.next().then(console.log) // { value: undefined, done: true }
 *
 * @template T the type of each iterated value
 * @param {AsyncIterable<T>|Iterable<T>|{ length: number }} source
 *   An AsyncIterable, Iterable, or Array-like object to produce an Iterator.
 * @return {AsyncIterator<T>} new AsyncIterator instance.
 */
/*:: declare export var createAsyncIterator:
  & (<+TValue>(
      collection: Iterable<Promise<TValue> | TValue> | AsyncIterable<TValue>
    ) => AsyncIterator<TValue>)
  & ((collection: {length: number}) => AsyncIterator<mixed>)
  & ((collection: mixed) => (void | AsyncIterator<mixed>)); */
function createAsyncIterator(source) {
  if (source != null) {
    var asyncIterator = getAsyncIterator(source)
    if (asyncIterator) {
      return asyncIterator
    }
    var iterator = createIterator(source)
    if (iterator) {
      return new AsyncFromSyncIterator(iterator)
    }
  }
}

// When the object provided to `createAsyncIterator` is not AsyncIterable but is
// sync Iterable, this simple wrapper is created.
function AsyncFromSyncIterator(iterator) {
  this._i = iterator
}

// Note: all AsyncIterators are themselves AsyncIterable.
AsyncFromSyncIterator.prototype[$$asyncIterator] = function() {
  return this
}

// A simple state-machine determines the IteratorResult returned, yielding
// each value in the Array-like object in order of their indicies.
AsyncFromSyncIterator.prototype.next = function(value) {
  return unwrapAsyncFromSync(this._i, 'next', value)
}

AsyncFromSyncIterator.prototype.return = function(value) {
  return this._i.return
    ? unwrapAsyncFromSync(this._i, 'return', value)
    : Promise.resolve({ value: value, done: true })
}

AsyncFromSyncIterator.prototype.throw = function(value) {
  return this._i.throw
    ? unwrapAsyncFromSync(this._i, 'throw', value)
    : Promise.reject(value)
}

function unwrapAsyncFromSync(iterator, fn, value) {
  var step
  return new Promise(function(resolve) {
    step = iterator[fn](value)
    resolve(step.value)
  }).then(function(value) {
    return { value: value, done: step.done }
  })
}

/**
 * Given an object which either implements the AsyncIterable protocol or is
 * Array-like, iterate over it, calling the `callback` at each iteration.
 *
 * Use `forAwaitEach` where you would expect to use a [for-await-of](https://tc39.github.io/proposal-async-iteration/#sec-for-in-and-for-of-statements) loop.
 *
 * Similar to [Array#forEach][], the `callback` function accepts three
 * arguments, and is provided with `thisArg` as the calling context.
 *
 * > Note: Using `forAwaitEach` requires the existence of `Promise`.
 * > While `Promise` has been available in modern browsers for a number of
 * > years, legacy browsers (like IE 11) may require a polyfill.
 *
 * @example
 *
 * var forAwaitEach = require('iterall').forAwaitEach
 *
 * forAwaitEach(myIterable, function (value, index, iterable) {
 *   console.log(value, index, iterable === myIterable)
 * })
 *
 * @example
 *
 * // ES2017:
 * for await (let value of myAsyncIterable) {
 *   console.log(await doSomethingAsync(value))
 * }
 * console.log('done')
 *
 * // Any JavaScript environment:
 * forAwaitEach(myAsyncIterable, function (value) {
 *   return doSomethingAsync(value).then(console.log)
 * }).then(function () {
 *   console.log('done')
 * })
 *
 * @template T the type of each iterated value
 * @param {AsyncIterable<T>|Iterable<Promise<T> | T>|{ length: number }} source
 *   The AsyncIterable or array to iterate over.
 * @param {function(T, number, object)} callback
 *   Function to execute for each iteration, taking up to three arguments
 * @param [thisArg]
 *   Optional. Value to use as `this` when executing `callback`.
 */
/*:: declare export var forAwaitEach:
  & (<+TValue, TCollection: Iterable<Promise<TValue> | TValue> | AsyncIterable<TValue>>(
      collection: TCollection,
      callbackFn: (value: TValue, index: number, collection: TCollection) => any,
      thisArg?: any
    ) => Promise<void>)
  & (<TCollection: { length: number }>(
      collection: TCollection,
      callbackFn: (value: mixed, index: number, collection: TCollection) => any,
      thisArg?: any
    ) => Promise<void>); */
function forAwaitEach(source, callback, thisArg) {
  var asyncIterator = createAsyncIterator(source)
  if (asyncIterator) {
    var i = 0
    return new Promise(function(resolve, reject) {
      function next() {
        asyncIterator
          .next()
          .then(function(step) {
            if (!step.done) {
              Promise.resolve(callback.call(thisArg, step.value, i++, source))
                .then(next)
                .catch(reject)
            } else {
              resolve()
            }
            // Explicitly return null, silencing bluebird-style warnings.
            return null
          })
          .catch(reject)
        // Explicitly return null, silencing bluebird-style warnings.
        return null
      }
      next()
    })
  }
}


/***/ }),
/* 25 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return syntaxError; });
/* harmony import */ var _GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

/**
 * Produces a GraphQLError representing a syntax error, containing useful
 * descriptive information about the syntax error's position in the source.
 */

function syntaxError(source, position, description) {
  return new _GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"]("Syntax Error: ".concat(description), undefined, source, [position]);
}


/***/ }),
/* 26 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return didYouMean; });
var MAX_SUGGESTIONS = 5;
/**
 * Given [ A, B, C ] return ' Did you mean A, B, or C?'.
 */

// eslint-disable-next-line no-redeclare
function didYouMean(firstArg, secondArg) {
  var _ref = typeof firstArg === 'string' ? [firstArg, secondArg] : [undefined, firstArg],
      subMessage = _ref[0],
      suggestions = _ref[1];

  var message = ' Did you mean ';

  if (subMessage) {
    message += subMessage + ' ';
  }

  switch (suggestions.length) {
    case 0:
      return '';

    case 1:
      return message + suggestions[0] + '?';

    case 2:
      return message + suggestions[0] + ' or ' + suggestions[1] + '?';
  }

  var selected = suggestions.slice(0, MAX_SUGGESTIONS);
  var lastItem = selected.pop();
  return message + selected.join(', ') + ', or ' + lastItem + '?';
}


/***/ }),
/* 27 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return toObjMap; });
/* harmony import */ var _polyfills_objectEntries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);

function toObjMap(obj) {
  /* eslint-enable no-redeclare */
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }

  var map = Object.create(null);

  for (var _i2 = 0, _objectEntries2 = Object(_polyfills_objectEntries__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(obj); _i2 < _objectEntries2.length; _i2++) {
    var _ref2 = _objectEntries2[_i2];
    var key = _ref2[0];
    var value = _ref2[1];
    map[key] = value;
  }

  return map;
}


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Observable */
/* harmony import */ var zen_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(162);
/* harmony import */ var zen_observable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(zen_observable__WEBPACK_IMPORTED_MODULE_0__);

var Observable = zen_observable__WEBPACK_IMPORTED_MODULE_0___default.a;
/* harmony default export */ __webpack_exports__["a"] = (Observable);


/***/ }),
/* 29 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return suggestionList; });
/**
 * Given an invalid input string and a list of valid options, returns a filtered
 * list of valid options sorted based on their similarity with the input.
 */
function suggestionList(input, options) {
  var optionsByDistance = Object.create(null);
  var inputThreshold = input.length / 2;

  for (var _i2 = 0; _i2 < options.length; _i2++) {
    var option = options[_i2];
    var distance = lexicalDistance(input, option);
    var threshold = Math.max(inputThreshold, option.length / 2, 1);

    if (distance <= threshold) {
      optionsByDistance[option] = distance;
    }
  }

  return Object.keys(optionsByDistance).sort(function (a, b) {
    return optionsByDistance[a] - optionsByDistance[b];
  });
}
/**
 * Computes the lexical distance between strings A and B.
 *
 * The "distance" between two strings is given by counting the minimum number
 * of edits needed to transform string A into string B. An edit can be an
 * insertion, deletion, or substitution of a single character, or a swap of two
 * adjacent characters.
 *
 * Includes a custom alteration from Damerau-Levenshtein to treat case changes
 * as a single edit which helps identify mis-cased values with an edit distance
 * of 1.
 *
 * This distance can be useful for detecting typos in input or sorting
 *
 * @param {string} a
 * @param {string} b
 * @return {int} distance in number of edits
 */

function lexicalDistance(aStr, bStr) {
  if (aStr === bStr) {
    return 0;
  }

  var d = [];
  var a = aStr.toLowerCase();
  var b = bStr.toLowerCase();
  var aLength = a.length;
  var bLength = b.length; // Any case change counts as a single edit

  if (a === b) {
    return 1;
  }

  for (var i = 0; i <= aLength; i++) {
    d[i] = [i];
  }

  for (var j = 1; j <= bLength; j++) {
    d[0][j] = j;
  }

  for (var _i3 = 1; _i3 <= aLength; _i3++) {
    for (var _j = 1; _j <= bLength; _j++) {
      var cost = a[_i3 - 1] === b[_j - 1] ? 0 : 1;
      d[_i3][_j] = Math.min(d[_i3 - 1][_j] + 1, d[_i3][_j - 1] + 1, d[_i3 - 1][_j - 1] + cost);

      if (_i3 > 1 && _j > 1 && a[_i3 - 1] === b[_j - 2] && a[_i3 - 2] === b[_j - 1]) {
        d[_i3][_j] = Math.min(d[_i3][_j], d[_i3 - 2][_j - 2] + cost);
      }
    }
  }

  return d[aLength][bLength];
}


/***/ }),
/* 30 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isInvalid; });
/**
 * Returns true if a value is undefined, or NaN.
 */
function isInvalid(value) {
  return value === undefined || value !== value;
}


/***/ }),
/* 31 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return defineToStringTag; });
/**
 * The `defineToStringTag()` function checks first to see if the runtime
 * supports the `Symbol` class and then if the `Symbol.toStringTag` constant
 * is defined as a `Symbol` instance. If both conditions are met, the
 * Symbol.toStringTag property is defined as a getter that returns the
 * supplied class constructor's name.
 *
 * @method defineToStringTag
 *
 * @param {Class<any>} classObject a class such as Object, String, Number but
 * typically one of your own creation through the class keyword; `class A {}`,
 * for example.
 */
function defineToStringTag(classObject) {
  if (typeof Symbol === 'function' && Symbol.toStringTag) {
    Object.defineProperty(classObject.prototype, Symbol.toStringTag, {
      get: function get() {
        return this.constructor.name;
      }
    });
  }
}


/***/ }),
/* 32 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return defineToJSON; });
/* harmony import */ var _nodejsCustomInspectSymbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);

/**
 * The `defineToJSON()` function defines toJSON() and inspect() prototype
 * methods, if no function provided they become aliases for toString().
 */

function defineToJSON(classObject) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : classObject.prototype.toString;
  classObject.prototype.toJSON = fn;
  classObject.prototype.inspect = fn;

  if (_nodejsCustomInspectSymbol__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]) {
    classObject.prototype[_nodejsCustomInspectSymbol__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]] = fn;
  }
}


/***/ }),
/* 33 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/iterall/index.mjs
var iterall = __webpack_require__(24);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/inspect.mjs
var inspect = __webpack_require__(3);

// CONCATENATED MODULE: ./node_modules/graphql/jsutils/memoize3.mjs
/**
 * Memoizes the provided three-argument function.
 */
function memoize3(fn) {
  var cache0;

  function memoized(a1, a2, a3) {
    if (!cache0) {
      cache0 = new WeakMap();
    }

    var cache1 = cache0.get(a1);
    var cache2;

    if (cache1) {
      cache2 = cache1.get(a2);

      if (cache2) {
        var cachedValue = cache2.get(a3);

        if (cachedValue !== undefined) {
          return cachedValue;
        }
      }
    } else {
      cache1 = new WeakMap();
      cache0.set(a1, cache1);
    }

    if (!cache2) {
      cache2 = new WeakMap();
      cache1.set(a2, cache2);
    }

    var newValue = fn(a1, a2, a3);
    cache2.set(a3, newValue);
    return newValue;
  }

  return memoized;
}

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/invariant.mjs
var invariant = __webpack_require__(17);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/devAssert.mjs
var devAssert = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/isInvalid.mjs
var isInvalid = __webpack_require__(30);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/isNullish.mjs
var isNullish = __webpack_require__(75);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/isPromise.mjs
var isPromise = __webpack_require__(23);

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/isObjectLike.mjs
var isObjectLike = __webpack_require__(18);

// CONCATENATED MODULE: ./node_modules/graphql/jsutils/promiseReduce.mjs


/**
 * Similar to Array.prototype.reduce(), however the reducing callback may return
 * a Promise, in which case reduction will continue after each promise resolves.
 *
 * If the callback does not return a Promise, then this function will also not
 * return a Promise.
 */
function promiseReduce(values, callback, initialValue) {
  return values.reduce(function (previous, value) {
    return Object(isPromise["a" /* default */])(previous) ? previous.then(function (resolved) {
      return callback(resolved, value);
    }) : callback(previous, value);
  }, initialValue);
}

// CONCATENATED MODULE: ./node_modules/graphql/jsutils/promiseForObject.mjs
/**
 * This function transforms a JS object `ObjMap<Promise<T>>` into
 * a `Promise<ObjMap<T>>`
 *
 * This is akin to bluebird's `Promise.props`, but implemented only using
 * `Promise.all` so it will work with any implementation of ES6 promises.
 */
function promiseForObject(object) {
  var keys = Object.keys(object);
  var valuesAndPromises = keys.map(function (name) {
    return object[name];
  });
  return Promise.all(valuesAndPromises).then(function (values) {
    return values.reduce(function (resolvedObject, value, i) {
      resolvedObject[keys[i]] = value;
      return resolvedObject;
    }, Object.create(null));
  });
}

// EXTERNAL MODULE: ./node_modules/graphql/jsutils/Path.mjs
var Path = __webpack_require__(21);

// EXTERNAL MODULE: ./node_modules/graphql/error/GraphQLError.mjs
var GraphQLError = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/graphql/error/locatedError.mjs
var locatedError = __webpack_require__(54);

// EXTERNAL MODULE: ./node_modules/graphql/language/kinds.mjs
var kinds = __webpack_require__(2);

// EXTERNAL MODULE: ./node_modules/graphql/type/validate.mjs
var validate = __webpack_require__(55);

// EXTERNAL MODULE: ./node_modules/graphql/type/introspection.mjs
var introspection = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/graphql/type/directives.mjs
var directives = __webpack_require__(15);

// EXTERNAL MODULE: ./node_modules/graphql/type/definition.mjs + 1 modules
var type_definition = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/typeFromAST.mjs
var typeFromAST = __webpack_require__(19);

// EXTERNAL MODULE: ./node_modules/graphql/utilities/getOperationRootType.mjs
var getOperationRootType = __webpack_require__(53);

// EXTERNAL MODULE: ./node_modules/graphql/execution/values.mjs
var execution_values = __webpack_require__(50);

// CONCATENATED MODULE: ./node_modules/graphql/execution/execute.mjs
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return execute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return assertValidExecutionArguments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return buildExecutionContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return collectFields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return buildResolveInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return resolveFieldValueOrError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return execute_defaultTypeResolver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return execute_defaultFieldResolver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return getFieldDef; });






















/**
 * Terminology
 *
 * "Definitions" are the generic name for top-level statements in the document.
 * Examples of this include:
 * 1) Operations (such as a query)
 * 2) Fragments
 *
 * "Operations" are a generic name for requests in the document.
 * Examples of this include:
 * 1) query,
 * 2) mutation
 *
 * "Selections" are the definitions that can appear legally and at
 * single level of the query. These include:
 * 1) field references e.g "a"
 * 2) fragment "spreads" e.g. "...c"
 * 3) inline fragment "spreads" e.g. "...on Type { a }"
 */

/**
 * Data that must be available at all points during query execution.
 *
 * Namely, schema of the type system that is currently executing,
 * and the fragments defined in the query document
 */

function execute(argsOrSchema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
  /* eslint-enable no-redeclare */
  // Extract arguments from object args if provided.
  return arguments.length === 1 ? executeImpl(argsOrSchema) : executeImpl({
    schema: argsOrSchema,
    document: document,
    rootValue: rootValue,
    contextValue: contextValue,
    variableValues: variableValues,
    operationName: operationName,
    fieldResolver: fieldResolver,
    typeResolver: typeResolver
  });
}

function executeImpl(args) {
  var schema = args.schema,
      document = args.document,
      rootValue = args.rootValue,
      contextValue = args.contextValue,
      variableValues = args.variableValues,
      operationName = args.operationName,
      fieldResolver = args.fieldResolver,
      typeResolver = args.typeResolver; // If arguments are missing or incorrect, throw an error.

  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,
  // a "Response" with only errors is returned.

  var exeContext = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver); // Return early errors if execution context failed.

  if (Array.isArray(exeContext)) {
    return {
      errors: exeContext
    };
  } // Return a Promise that will eventually resolve to the data described by
  // The "Response" section of the GraphQL specification.
  //
  // If errors are encountered while executing a GraphQL field, only that
  // field and its descendants will be omitted, and sibling fields will still
  // be executed. An execution which encounters errors will still result in a
  // resolved Promise.


  var data = executeOperation(exeContext, exeContext.operation, rootValue);
  return buildResponse(exeContext, data);
}
/**
 * Given a completed execution context and data, build the { errors, data }
 * response defined by the "Response" section of the GraphQL specification.
 */


function buildResponse(exeContext, data) {
  if (Object(isPromise["a" /* default */])(data)) {
    return data.then(function (resolved) {
      return buildResponse(exeContext, resolved);
    });
  }

  return exeContext.errors.length === 0 ? {
    data: data
  } : {
    errors: exeContext.errors,
    data: data
  };
}
/**
 * Essential assertions before executing to provide developer feedback for
 * improper use of the GraphQL library.
 */


function assertValidExecutionArguments(schema, document, rawVariableValues) {
  document || Object(devAssert["a" /* default */])(0, 'Must provide document'); // If the schema used for execution is invalid, throw an error.

  Object(validate["a" /* assertValidSchema */])(schema); // Variables, if provided, must be an object.

  rawVariableValues == null || Object(isObjectLike["a" /* default */])(rawVariableValues) || Object(devAssert["a" /* default */])(0, 'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.');
}
/**
 * Constructs a ExecutionContext object from the arguments passed to
 * execute, which we will pass throughout the other execution methods.
 *
 * Throws a GraphQLError if a valid execution context cannot be created.
 */

function buildExecutionContext(schema, document, rootValue, contextValue, rawVariableValues, operationName, fieldResolver, typeResolver) {
  var operation;
  var hasMultipleAssumedOperations = false;
  var fragments = Object.create(null);

  for (var _i2 = 0, _document$definitions2 = document.definitions; _i2 < _document$definitions2.length; _i2++) {
    var definition = _document$definitions2[_i2];

    switch (definition.kind) {
      case kinds["a" /* Kind */].OPERATION_DEFINITION:
        if (!operationName && operation) {
          hasMultipleAssumedOperations = true;
        } else if (!operationName || definition.name && definition.name.value === operationName) {
          operation = definition;
        }

        break;

      case kinds["a" /* Kind */].FRAGMENT_DEFINITION:
        fragments[definition.name.value] = definition;
        break;
    }
  }

  if (!operation) {
    if (operationName) {
      return [new GraphQLError["a" /* GraphQLError */]("Unknown operation named \"".concat(operationName, "\"."))];
    }

    return [new GraphQLError["a" /* GraphQLError */]('Must provide an operation.')];
  }

  if (hasMultipleAssumedOperations) {
    return [new GraphQLError["a" /* GraphQLError */]('Must provide operation name if query contains multiple operations.')];
  }

  var coercedVariableValues = Object(execution_values["getVariableValues"])(schema, operation.variableDefinitions || [], rawVariableValues || {}, {
    maxErrors: 50
  });

  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }

  return {
    schema: schema,
    fragments: fragments,
    rootValue: rootValue,
    contextValue: contextValue,
    operation: operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver || execute_defaultFieldResolver,
    typeResolver: typeResolver || execute_defaultTypeResolver,
    errors: []
  };
}
/**
 * Implements the "Evaluating operations" section of the spec.
 */

function executeOperation(exeContext, operation, rootValue) {
  var type = Object(getOperationRootType["a" /* getOperationRootType */])(exeContext.schema, operation);
  var fields = collectFields(exeContext, type, operation.selectionSet, Object.create(null), Object.create(null));
  var path = undefined; // Errors from sub-fields of a NonNull type may propagate to the top level,
  // at which point we still log the error and null the parent field, which
  // in this case is the entire response.
  //
  // Similar to completeValueCatchingError.

  try {
    var result = operation.operation === 'mutation' ? executeFieldsSerially(exeContext, type, rootValue, path, fields) : executeFields(exeContext, type, rootValue, path, fields);

    if (Object(isPromise["a" /* default */])(result)) {
      return result.then(undefined, function (error) {
        exeContext.errors.push(error);
        return Promise.resolve(null);
      });
    }

    return result;
  } catch (error) {
    exeContext.errors.push(error);
    return null;
  }
}
/**
 * Implements the "Evaluating selection sets" section of the spec
 * for "write" mode.
 */


function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
  return promiseReduce(Object.keys(fields), function (results, responseName) {
    var fieldNodes = fields[responseName];
    var fieldPath = Object(Path["a" /* addPath */])(path, responseName);
    var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);

    if (result === undefined) {
      return results;
    }

    if (Object(isPromise["a" /* default */])(result)) {
      return result.then(function (resolvedResult) {
        results[responseName] = resolvedResult;
        return results;
      });
    }

    results[responseName] = result;
    return results;
  }, Object.create(null));
}
/**
 * Implements the "Evaluating selection sets" section of the spec
 * for "read" mode.
 */


function executeFields(exeContext, parentType, sourceValue, path, fields) {
  var results = Object.create(null);
  var containsPromise = false;

  for (var _i4 = 0, _Object$keys2 = Object.keys(fields); _i4 < _Object$keys2.length; _i4++) {
    var responseName = _Object$keys2[_i4];
    var fieldNodes = fields[responseName];
    var fieldPath = Object(Path["a" /* addPath */])(path, responseName);
    var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);

    if (result !== undefined) {
      results[responseName] = result;

      if (!containsPromise && Object(isPromise["a" /* default */])(result)) {
        containsPromise = true;
      }
    }
  } // If there are no promises, we can just return the object


  if (!containsPromise) {
    return results;
  } // Otherwise, results is a map from field name to the result of resolving that
  // field, which is possibly a promise. Return a promise that will return this
  // same map, but with any promises replaced with the values they resolved to.


  return promiseForObject(results);
}
/**
 * Given a selectionSet, adds all of the fields in that selection to
 * the passed in map of fields, and returns it at the end.
 *
 * CollectFields requires the "runtime type" of an object. For a field which
 * returns an Interface or Union type, the "runtime type" will be the actual
 * Object type returned by that field.
 */


function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (var _i6 = 0, _selectionSet$selecti2 = selectionSet.selections; _i6 < _selectionSet$selecti2.length; _i6++) {
    var selection = _selectionSet$selecti2[_i6];

    switch (selection.kind) {
      case kinds["a" /* Kind */].FIELD:
        {
          if (!shouldIncludeNode(exeContext, selection)) {
            continue;
          }

          var name = getFieldEntryKey(selection);

          if (!fields[name]) {
            fields[name] = [];
          }

          fields[name].push(selection);
          break;
        }

      case kinds["a" /* Kind */].INLINE_FRAGMENT:
        {
          if (!shouldIncludeNode(exeContext, selection) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {
            continue;
          }

          collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
          break;
        }

      case kinds["a" /* Kind */].FRAGMENT_SPREAD:
        {
          var fragName = selection.name.value;

          if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {
            continue;
          }

          visitedFragmentNames[fragName] = true;
          var fragment = exeContext.fragments[fragName];

          if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {
            continue;
          }

          collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
          break;
        }
    }
  }

  return fields;
}
/**
 * Determines if a field should be included based on the @include and @skip
 * directives, where @skip has higher precedence than @include.
 */

function shouldIncludeNode(exeContext, node) {
  var skip = Object(execution_values["getDirectiveValues"])(directives["e" /* GraphQLSkipDirective */], node, exeContext.variableValues);

  if (skip && skip.if === true) {
    return false;
  }

  var include = Object(execution_values["getDirectiveValues"])(directives["d" /* GraphQLIncludeDirective */], node, exeContext.variableValues);

  if (include && include.if === false) {
    return false;
  }

  return true;
}
/**
 * Determines if a fragment is applicable to the given type.
 */


function doesFragmentConditionMatch(exeContext, fragment, type) {
  var typeConditionNode = fragment.typeCondition;

  if (!typeConditionNode) {
    return true;
  }

  var conditionalType = Object(typeFromAST["a" /* typeFromAST */])(exeContext.schema, typeConditionNode);

  if (conditionalType === type) {
    return true;
  }

  if (Object(type_definition["C" /* isAbstractType */])(conditionalType)) {
    return exeContext.schema.isPossibleType(conditionalType, type);
  }

  return false;
}
/**
 * Implements the logic to compute the key of a given field's entry
 */


function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}
/**
 * Resolves the field on the given source object. In particular, this
 * figures out the value that the field returns by calling its resolve function,
 * then calls completeValue to complete promises, serialize scalars, or execute
 * the sub-selection-set for objects.
 */


function resolveField(exeContext, parentType, source, fieldNodes, path) {
  var fieldNode = fieldNodes[0];
  var fieldName = fieldNode.name.value;
  var fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);

  if (!fieldDef) {
    return;
  }

  var resolveFn = fieldDef.resolve || exeContext.fieldResolver;
  var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path); // Get the resolve function, regardless of if its result is normal
  // or abrupt (error).

  var result = resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, source, info);
  return completeValueCatchingError(exeContext, fieldDef.type, fieldNodes, info, path, result);
}

function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  // The resolve function's optional fourth argument is a collection of
  // information about the current execution state.
  return {
    fieldName: fieldDef.name,
    fieldNodes: fieldNodes,
    returnType: fieldDef.type,
    parentType: parentType,
    path: path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
} // Isolates the "ReturnOrAbrupt" behavior to not de-opt the `resolveField`
// function. Returns the result of resolveFn or the abrupt-return Error object.

function resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, source, info) {
  try {
    // Build a JS object of arguments from the field.arguments AST, using the
    // variables scope to fulfill any variable references.
    // TODO: find a way to memoize, in case this field is within a List type.
    var args = Object(execution_values["getArgumentValues"])(fieldDef, fieldNodes[0], exeContext.variableValues); // The resolve function's optional third argument is a context value that
    // is provided to every resolve function within an execution. It is commonly
    // used to represent an authenticated user, or request-specific caches.

    var _contextValue = exeContext.contextValue;
    var result = resolveFn(source, args, _contextValue, info);
    return Object(isPromise["a" /* default */])(result) ? result.then(undefined, asErrorInstance) : result;
  } catch (error) {
    return asErrorInstance(error);
  }
} // Sometimes a non-error is thrown, wrap it as an Error instance to ensure a
// consistent Error interface.

function asErrorInstance(error) {
  if (error instanceof Error) {
    return error;
  }

  return new Error('Unexpected error value: ' + Object(inspect["a" /* default */])(error));
} // This is a small wrapper around completeValue which detects and logs errors
// in the execution context.


function completeValueCatchingError(exeContext, returnType, fieldNodes, info, path, result) {
  try {
    var completed;

    if (Object(isPromise["a" /* default */])(result)) {
      completed = result.then(function (resolved) {
        return completeValue(exeContext, returnType, fieldNodes, info, path, resolved);
      });
    } else {
      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
    }

    if (Object(isPromise["a" /* default */])(completed)) {
      // Note: we don't rely on a `catch` method, but we do expect "thenable"
      // to take a second callback for the error case.
      return completed.then(undefined, function (error) {
        return handleFieldError(error, fieldNodes, path, returnType, exeContext);
      });
    }

    return completed;
  } catch (error) {
    return handleFieldError(error, fieldNodes, path, returnType, exeContext);
  }
}

function handleFieldError(rawError, fieldNodes, path, returnType, exeContext) {
  var error = Object(locatedError["a" /* locatedError */])(asErrorInstance(rawError), fieldNodes, Object(Path["b" /* pathToArray */])(path)); // If the field type is non-nullable, then it is resolved without any
  // protection from errors, however it still properly locates the error.

  if (Object(type_definition["L" /* isNonNullType */])(returnType)) {
    throw error;
  } // Otherwise, error protection is applied, logging the error and resolving
  // a null value for this field if one is encountered.


  exeContext.errors.push(error);
  return null;
}
/**
 * Implements the instructions for completeValue as defined in the
 * "Field entries" section of the spec.
 *
 * If the field type is Non-Null, then this recursively completes the value
 * for the inner type. It throws a field error if that completion returns null,
 * as per the "Nullability" section of the spec.
 *
 * If the field type is a List, then this recursively completes the value
 * for the inner type on each item in the list.
 *
 * If the field type is a Scalar or Enum, ensures the completed value is a legal
 * value of the type by calling the `serialize` method of GraphQL type
 * definition.
 *
 * If the field is an abstract type, determine the runtime type of the value
 * and then complete based on that type
 *
 * Otherwise, the field type expects a sub-selection set, and will complete the
 * value by evaluating all sub-selections.
 */


function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
  // If result is an Error, throw a located error.
  if (result instanceof Error) {
    throw result;
  } // If field type is NonNull, complete for inner type, and throw field error
  // if result is null.


  if (Object(type_definition["L" /* isNonNullType */])(returnType)) {
    var completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);

    if (completed === null) {
      throw new Error("Cannot return null for non-nullable field ".concat(info.parentType.name, ".").concat(info.fieldName, "."));
    }

    return completed;
  } // If result value is null-ish (null, undefined, or NaN) then return null.


  if (Object(isNullish["a" /* default */])(result)) {
    return null;
  } // If field type is List, complete each item in the list with the inner type


  if (Object(type_definition["J" /* isListType */])(returnType)) {
    return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,
  // returning null if serialization is not possible.


  if (Object(type_definition["I" /* isLeafType */])(returnType)) {
    return completeLeafValue(returnType, result);
  } // If field type is an abstract type, Interface or Union, determine the
  // runtime Object type and complete for that type.


  if (Object(type_definition["C" /* isAbstractType */])(returnType)) {
    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
  } // If field type is Object, execute and complete all sub-selections.


  /* istanbul ignore else */
  if (Object(type_definition["N" /* isObjectType */])(returnType)) {
    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
  } // Not reachable. All possible output types have been considered.


  /* istanbul ignore next */
  Object(invariant["a" /* default */])(false, 'Cannot complete value of unexpected output type: ' + Object(inspect["a" /* default */])(returnType));
}
/**
 * Complete a list value by completing each item in the list with the
 * inner type
 */


function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
  if (!Object(iterall["isCollection"])(result)) {
    throw new GraphQLError["a" /* GraphQLError */]("Expected Iterable, but did not find one for field ".concat(info.parentType.name, ".").concat(info.fieldName, "."));
  } // This is specified as a simple map, however we're optimizing the path
  // where the list contains no Promises by avoiding creating another Promise.


  var itemType = returnType.ofType;
  var containsPromise = false;
  var completedResults = [];
  Object(iterall["forEach"])(result, function (item, index) {
    // No need to modify the info object containing the path,
    // since from here on it is not ever accessed by resolver functions.
    var fieldPath = Object(Path["a" /* addPath */])(path, index);
    var completedItem = completeValueCatchingError(exeContext, itemType, fieldNodes, info, fieldPath, item);

    if (!containsPromise && Object(isPromise["a" /* default */])(completedItem)) {
      containsPromise = true;
    }

    completedResults.push(completedItem);
  });
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
/**
 * Complete a Scalar or Enum by serializing to a valid value, returning
 * null if serialization is not possible.
 */


function completeLeafValue(returnType, result) {
  var serializedResult = returnType.serialize(result);

  if (Object(isInvalid["a" /* default */])(serializedResult)) {
    throw new Error("Expected a value of type \"".concat(Object(inspect["a" /* default */])(returnType), "\" but ") + "received: ".concat(Object(inspect["a" /* default */])(result)));
  }

  return serializedResult;
}
/**
 * Complete a value of an abstract type by determining the runtime object type
 * of that value, then complete the value for that type.
 */


function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
  var resolveTypeFn = returnType.resolveType || exeContext.typeResolver;
  var contextValue = exeContext.contextValue;
  var runtimeType = resolveTypeFn(result, contextValue, info, returnType);

  if (Object(isPromise["a" /* default */])(runtimeType)) {
    return runtimeType.then(function (resolvedRuntimeType) {
      return completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
    });
  }

  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
}

function ensureValidRuntimeType(runtimeTypeOrName, exeContext, returnType, fieldNodes, info, result) {
  var runtimeType = typeof runtimeTypeOrName === 'string' ? exeContext.schema.getType(runtimeTypeOrName) : runtimeTypeOrName;

  if (!Object(type_definition["N" /* isObjectType */])(runtimeType)) {
    throw new GraphQLError["a" /* GraphQLError */]("Abstract type ".concat(returnType.name, " must resolve to an Object type at runtime for field ").concat(info.parentType.name, ".").concat(info.fieldName, " with ") + "value ".concat(Object(inspect["a" /* default */])(result), ", received \"").concat(Object(inspect["a" /* default */])(runtimeType), "\". ") + "Either the ".concat(returnType.name, " type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function."), fieldNodes);
  }

  if (!exeContext.schema.isPossibleType(returnType, runtimeType)) {
    throw new GraphQLError["a" /* GraphQLError */]("Runtime Object type \"".concat(runtimeType.name, "\" is not a possible type for \"").concat(returnType.name, "\"."), fieldNodes);
  }

  return runtimeType;
}
/**
 * Complete an Object value by executing all sub-selections.
 */


function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
  // If there is an isTypeOf predicate function, call it with the
  // current result. If isTypeOf returns false, then raise an error rather
  // than continuing execution.
  if (returnType.isTypeOf) {
    var isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);

    if (Object(isPromise["a" /* default */])(isTypeOf)) {
      return isTypeOf.then(function (resolvedIsTypeOf) {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }

        return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);
      });
    }

    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result, fieldNodes);
    }
  }

  return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);
}

function invalidReturnTypeError(returnType, result, fieldNodes) {
  return new GraphQLError["a" /* GraphQLError */]("Expected value of type \"".concat(returnType.name, "\" but got: ").concat(Object(inspect["a" /* default */])(result), "."), fieldNodes);
}

function collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result) {
  // Collect sub-fields to execute to complete this value.
  var subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
  return executeFields(exeContext, returnType, result, path, subFieldNodes);
}
/**
 * A memoized collection of relevant subfields with regard to the return
 * type. Memoizing ensures the subfields are not repeatedly calculated, which
 * saves overhead when resolving lists of values.
 */


var collectSubfields = memoize3(_collectSubfields);

function _collectSubfields(exeContext, returnType, fieldNodes) {
  var subFieldNodes = Object.create(null);
  var visitedFragmentNames = Object.create(null);

  for (var _i8 = 0; _i8 < fieldNodes.length; _i8++) {
    var node = fieldNodes[_i8];

    if (node.selectionSet) {
      subFieldNodes = collectFields(exeContext, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
    }
  }

  return subFieldNodes;
}
/**
 * If a resolveType function is not given, then a default resolve behavior is
 * used which attempts two strategies:
 *
 * First, See if the provided value has a `__typename` field defined, if so, use
 * that value as name of the resolved type.
 *
 * Otherwise, test each possible type for the abstract type by calling
 * isTypeOf for the object being coerced, returning the first type that matches.
 */


var execute_defaultTypeResolver = function defaultTypeResolver(value, contextValue, info, abstractType) {
  // First, look for `__typename`.
  if (Object(isObjectLike["a" /* default */])(value) && typeof value.__typename === 'string') {
    return value.__typename;
  } // Otherwise, test each possible type.


  var possibleTypes = info.schema.getPossibleTypes(abstractType);
  var promisedIsTypeOfResults = [];

  for (var i = 0; i < possibleTypes.length; i++) {
    var type = possibleTypes[i];

    if (type.isTypeOf) {
      var isTypeOfResult = type.isTypeOf(value, contextValue, info);

      if (Object(isPromise["a" /* default */])(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type;
      }
    }
  }

  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then(function (isTypeOfResults) {
      for (var _i9 = 0; _i9 < isTypeOfResults.length; _i9++) {
        if (isTypeOfResults[_i9]) {
          return possibleTypes[_i9];
        }
      }
    });
  }
};
/**
 * If a resolve function is not given, then a default resolve behavior is used
 * which takes the property of the source object of the same name as the field
 * and returns it as the result, or if it's a function, returns the result
 * of calling that function while passing along args and context value.
 */

var execute_defaultFieldResolver = function defaultFieldResolver(source, args, contextValue, info) {
  // ensure source is a value for which property access is acceptable.
  if (Object(isObjectLike["a" /* default */])(source) || typeof source === 'function') {
    var property = source[info.fieldName];

    if (typeof property === 'function') {
      return source[info.fieldName](args, contextValue, info);
    }

    return property;
  }
};
/**
 * This method looks up the field on the given type definition.
 * It has special casing for the two introspection fields, __schema
 * and __typename. __typename is special because it can always be
 * queried as a field, even in situations where no other fields
 * are allowed, like on a Union. __schema could get automatically
 * added to the query type, but that would require mutating type
 * definitions, which would cause issues.
 */

function getFieldDef(schema, parentType, fieldName) {
  if (fieldName === introspection["a" /* SchemaMetaFieldDef */].name && schema.getQueryType() === parentType) {
    return introspection["a" /* SchemaMetaFieldDef */];
  } else if (fieldName === introspection["c" /* TypeMetaFieldDef */].name && schema.getQueryType() === parentType) {
    return introspection["c" /* TypeMetaFieldDef */];
  } else if (fieldName === introspection["d" /* TypeNameMetaFieldDef */].name) {
    return introspection["d" /* TypeNameMetaFieldDef */];
  }

  return parentType.getFields()[fieldName];
}


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var parser = __webpack_require__(48);

var parse = parser.parse; // Strip insignificant whitespace
// Note that this could do a lot more, such as reorder fields etc.

function normalize(string) {
  return string.replace(/[\s,]+/g, ' ').trim();
} // A map docString -> graphql document


var docCache = {}; // A map fragmentName -> [normalized source]

var fragmentSourceMap = {};

function cacheKeyFromLoc(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
} // For testing.


function resetCaches() {
  docCache = {};
  fragmentSourceMap = {};
} // Take a unstripped parsed document (query/mutation or even fragment), and
// check all fragment definitions, checking for name->source uniqueness.
// We also want to make sure only unique fragments exist in the document.


var printFragmentWarnings = true;

function processFragments(ast) {
  var astFragmentMap = {};
  var definitions = [];

  for (var i = 0; i < ast.definitions.length; i++) {
    var fragmentDefinition = ast.definitions[i];

    if (fragmentDefinition.kind === 'FragmentDefinition') {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc); // We know something about this fragment

      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {
        // this is a problem because the app developer is trying to register another fragment with
        // the same name as one previously registered. So, we tell them about it.
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\n" + "graphql-tag enforces all fragment names across your application to be unique; read more about\n" + "this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }

        fragmentSourceMap[fragmentName][sourceKey] = true;
      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {
        fragmentSourceMap[fragmentName] = {};
        fragmentSourceMap[fragmentName][sourceKey] = true;
      }

      if (!astFragmentMap[sourceKey]) {
        astFragmentMap[sourceKey] = true;
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  }

  ast.definitions = definitions;
  return ast;
}

function disableFragmentWarnings() {
  printFragmentWarnings = false;
}

function stripLoc(doc, removeLocAtThisLevel) {
  var docType = Object.prototype.toString.call(doc);

  if (docType === '[object Array]') {
    return doc.map(function (d) {
      return stripLoc(d, removeLocAtThisLevel);
    });
  }

  if (docType !== '[object Object]') {
    throw new Error('Unexpected input.');
  } // We don't want to remove the root loc field so we can use it
  // for fragment substitution (see below)


  if (removeLocAtThisLevel && doc.loc) {
    delete doc.loc;
  } // https://github.com/apollographql/graphql-tag/issues/40


  if (doc.loc) {
    delete doc.loc.startToken;
    delete doc.loc.endToken;
  }

  var keys = Object.keys(doc);
  var key;
  var value;
  var valueType;

  for (key in keys) {
    if (keys.hasOwnProperty(key)) {
      value = doc[keys[key]];
      valueType = Object.prototype.toString.call(value);

      if (valueType === '[object Object]' || valueType === '[object Array]') {
        doc[keys[key]] = stripLoc(value, true);
      }
    }
  }

  return doc;
}

var experimentalFragmentVariables = false;

function parseDocument(doc) {
  var cacheKey = normalize(doc);

  if (docCache[cacheKey]) {
    return docCache[cacheKey];
  }

  var parsed = parse(doc, {
    experimentalFragmentVariables: experimentalFragmentVariables
  });

  if (!parsed || parsed.kind !== 'Document') {
    throw new Error('Not a valid GraphQL document.');
  } // check that all "new" fragments inside the documents are consistent with
  // existing fragments of the same name


  parsed = processFragments(parsed);
  parsed = stripLoc(parsed, false);
  docCache[cacheKey] = parsed;
  return parsed;
}

function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}

function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
} // XXX This should eventually disallow arbitrary string interpolation, like Relay does


function gql()
/* arguments */
{
  var args = Array.prototype.slice.call(arguments);
  var literals = args[0]; // We always get literals[0] and then matching post literals for each arg given

  var result = typeof literals === "string" ? literals : literals[0];

  for (var i = 1; i < args.length; i++) {
    if (args[i] && args[i].kind && args[i].kind === 'Document') {
      result += args[i].loc.source.body;
    } else {
      result += args[i];
    }

    result += literals[i];
  }

  return parseDocument(result);
} // Support typescript, which isn't as nice as Babel about default exports


gql.default = gql;
gql.resetCaches = resetCaches;
gql.disableFragmentWarnings = disableFragmentWarnings;
gql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
gql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;
module.exports = gql;

/***/ }),
/* 35 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isEqualType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isTypeSubTypeOf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return doTypesOverlap; });
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);

/**
 * Provided two types, return true if the types are equal (invariant).
 */

function isEqualType(typeA, typeB) {
  // Equivalent types are equal.
  if (typeA === typeB) {
    return true;
  } // If either type is non-null, the other must also be non-null.


  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isNonNullType */ "L"])(typeA) && Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isNonNullType */ "L"])(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  } // If either type is a list, the other must also be a list.


  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isListType */ "J"])(typeA) && Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isListType */ "J"])(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  } // Otherwise the types are not equal.


  return false;
}
/**
 * Provided a type and a super type, return true if the first type is either
 * equal or a subset of the second super type (covariant).
 */

function isTypeSubTypeOf(schema, maybeSubType, superType) {
  // Equivalent type is a valid subtype
  if (maybeSubType === superType) {
    return true;
  } // If superType is non-null, maybeSubType must also be non-null.


  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isNonNullType */ "L"])(superType)) {
    if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isNonNullType */ "L"])(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }

    return false;
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isNonNullType */ "L"])(maybeSubType)) {
    // If superType is nullable, maybeSubType may be non-null or nullable.
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  } // If superType type is a list, maybeSubType type must also be a list.


  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isListType */ "J"])(superType)) {
    if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isListType */ "J"])(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }

    return false;
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isListType */ "J"])(maybeSubType)) {
    // If superType is not a list, maybeSubType must also be not a list.
    return false;
  } // If superType type is an abstract type, maybeSubType type may be a currently
  // possible object type.


  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isAbstractType */ "C"])(superType) && Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isObjectType */ "N"])(maybeSubType) && schema.isPossibleType(superType, maybeSubType)) {
    return true;
  } // Otherwise, the child type is not a valid subtype of the parent type.


  return false;
}
/**
 * Provided two composite types, determine if they "overlap". Two composite
 * types overlap when the Sets of possible concrete types for each intersect.
 *
 * This is often used to determine if a fragment of a given type could possibly
 * be visited in a context of another type.
 *
 * This function is commutative.
 */

function doTypesOverlap(schema, typeA, typeB) {
  // Equivalent types overlap
  if (typeA === typeB) {
    return true;
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isAbstractType */ "C"])(typeA)) {
    if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isAbstractType */ "C"])(typeB)) {
      // If both types are abstract, then determine if there is any intersection
      // between possible concrete types of each.
      return schema.getPossibleTypes(typeA).some(function (type) {
        return schema.isPossibleType(typeB, type);
      });
    } // Determine if the latter type is a possible concrete type of the former.


    return schema.isPossibleType(typeA, typeB);
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_0__[/* isAbstractType */ "C"])(typeB)) {
    // Determine if the former type is a possible concrete type of the latter.
    return schema.isPossibleType(typeB, typeA);
  } // Otherwise the types do not overlap.


  return false;
}


/***/ }),
/* 36 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isSchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return assertSchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GraphQLSchema; });
/* harmony import */ var _polyfills_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var _polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _jsutils_toObjMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
/* harmony import */ var _jsutils_devAssert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);
/* harmony import */ var _jsutils_instanceOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(40);
/* harmony import */ var _jsutils_isObjectLike__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(18);
/* harmony import */ var _jsutils_defineToStringTag__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(31);
/* harmony import */ var _introspection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(12);
/* harmony import */ var _directives__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(15);
/* harmony import */ var _definition__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(0);











/**
 * Test if the given value is a GraphQL schema.
 */

// eslint-disable-next-line no-redeclare
function isSchema(schema) {
  return Object(_jsutils_instanceOf__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(schema, GraphQLSchema);
}
function assertSchema(schema) {
  if (!isSchema(schema)) {
    throw new Error("Expected ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(schema), " to be a GraphQL schema."));
  }

  return schema;
}
/**
 * Schema Definition
 *
 * A Schema is created by supplying the root types of each type of operation,
 * query and mutation (optional). A schema definition is then supplied to the
 * validator and executor.
 *
 * Example:
 *
 *     const MyAppSchema = new GraphQLSchema({
 *       query: MyAppQueryRootType,
 *       mutation: MyAppMutationRootType,
 *     })
 *
 * Note: When the schema is constructed, by default only the types that are
 * reachable by traversing the root types are included, other types must be
 * explicitly referenced.
 *
 * Example:
 *
 *     const characterInterface = new GraphQLInterfaceType({
 *       name: 'Character',
 *       ...
 *     });
 *
 *     const humanType = new GraphQLObjectType({
 *       name: 'Human',
 *       interfaces: [characterInterface],
 *       ...
 *     });
 *
 *     const droidType = new GraphQLObjectType({
 *       name: 'Droid',
 *       interfaces: [characterInterface],
 *       ...
 *     });
 *
 *     const schema = new GraphQLSchema({
 *       query: new GraphQLObjectType({
 *         name: 'Query',
 *         fields: {
 *           hero: { type: characterInterface, ... },
 *         }
 *       }),
 *       ...
 *       // Since this schema references only the `Character` interface it's
 *       // necessary to explicitly list the types that implement it if
 *       // you want them to be included in the final schema.
 *       types: [humanType, droidType],
 *     })
 *
 * Note: If an array of `directives` are provided to GraphQLSchema, that will be
 * the exact list of directives represented and allowed. If `directives` is not
 * provided then a default set of the specified directives (e.g. @include and
 * @skip) will be used. If you wish to provide *additional* directives to these
 * specified directives, you must explicitly declare them. Example:
 *
 *     const MyAppSchema = new GraphQLSchema({
 *       ...
 *       directives: specifiedDirectives.concat([ myCustomDirective ]),
 *     })
 *
 */

var GraphQLSchema =
/*#__PURE__*/
function () {
  // Used as a cache for validateSchema().
  // Referenced by validateSchema().
  function GraphQLSchema(config) {
    // If this schema was built from a source known to be valid, then it may be
    // marked with assumeValid to avoid an additional type system validation.
    if (config && config.assumeValid) {
      this.__validationErrors = [];
    } else {
      this.__validationErrors = undefined; // Otherwise check for common mistakes during construction to produce
      // clear and early error messages.

      Object(_jsutils_isObjectLike__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(config) || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(0, 'Must provide configuration object.');
      !config.types || Array.isArray(config.types) || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(0, "\"types\" must be Array if provided but got: ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(config.types), "."));
      !config.directives || Array.isArray(config.directives) || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(0, '"directives" must be Array if provided but got: ' + "".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(config.directives), "."));
      !config.allowedLegacyNames || Array.isArray(config.allowedLegacyNames) || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(0, '"allowedLegacyNames" must be Array if provided but got: ' + "".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(config.allowedLegacyNames), "."));
    }

    this.extensions = config.extensions && Object(_jsutils_toObjMap__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = config.extensionASTNodes;
    this.__allowedLegacyNames = config.allowedLegacyNames || [];
    this._queryType = config.query;
    this._mutationType = config.mutation;
    this._subscriptionType = config.subscription; // Provide specified directives (e.g. @include and @skip) by default.

    this._directives = config.directives || _directives__WEBPACK_IMPORTED_MODULE_9__[/* specifiedDirectives */ "i"]; // Build type map now to detect any errors within this schema.

    var initialTypes = [this._queryType, this._mutationType, this._subscriptionType, _introspection__WEBPACK_IMPORTED_MODULE_8__[/* __Schema */ "j"]].concat(config.types); // Keep track of all types referenced within the schema.

    var typeMap = Object.create(null); // First by deeply visiting all initial types.

    typeMap = initialTypes.reduce(typeMapReducer, typeMap); // Then by deeply visiting all directive types.

    typeMap = this._directives.reduce(typeMapDirectiveReducer, typeMap); // Storing the resulting map for reference by the schema.

    this._typeMap = typeMap;
    this._possibleTypeMap = Object.create(null); // Keep track of all implementations by interface name.

    this._implementations = Object.create(null);

    for (var _i2 = 0, _objectValues2 = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this._typeMap); _i2 < _objectValues2.length; _i2++) {
      var type = _objectValues2[_i2];

      if (Object(_definition__WEBPACK_IMPORTED_MODULE_10__[/* isObjectType */ "N"])(type)) {
        for (var _i4 = 0, _type$getInterfaces2 = type.getInterfaces(); _i4 < _type$getInterfaces2.length; _i4++) {
          var iface = _type$getInterfaces2[_i4];

          if (Object(_definition__WEBPACK_IMPORTED_MODULE_10__[/* isInterfaceType */ "H"])(iface)) {
            var impls = this._implementations[iface.name];

            if (impls) {
              impls.push(type);
            } else {
              this._implementations[iface.name] = [type];
            }
          }
        }
      }
    }
  }

  var _proto = GraphQLSchema.prototype;

  _proto.getQueryType = function getQueryType() {
    return this._queryType;
  };

  _proto.getMutationType = function getMutationType() {
    return this._mutationType;
  };

  _proto.getSubscriptionType = function getSubscriptionType() {
    return this._subscriptionType;
  };

  _proto.getTypeMap = function getTypeMap() {
    return this._typeMap;
  };

  _proto.getType = function getType(name) {
    return this.getTypeMap()[name];
  };

  _proto.getPossibleTypes = function getPossibleTypes(abstractType) {
    if (Object(_definition__WEBPACK_IMPORTED_MODULE_10__[/* isUnionType */ "T"])(abstractType)) {
      return abstractType.getTypes();
    }

    return this._implementations[abstractType.name] || [];
  };

  _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {
    if (this._possibleTypeMap[abstractType.name] == null) {
      var map = Object.create(null);

      for (var _i6 = 0, _this$getPossibleType2 = this.getPossibleTypes(abstractType); _i6 < _this$getPossibleType2.length; _i6++) {
        var type = _this$getPossibleType2[_i6];
        map[type.name] = true;
      }

      this._possibleTypeMap[abstractType.name] = map;
    }

    return Boolean(this._possibleTypeMap[abstractType.name][possibleType.name]);
  };

  _proto.getDirectives = function getDirectives() {
    return this._directives;
  };

  _proto.getDirective = function getDirective(name) {
    return Object(_polyfills_find__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this.getDirectives(), function (directive) {
      return directive.name === name;
    });
  };

  _proto.toConfig = function toConfig() {
    return {
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this.getTypeMap()),
      directives: this.getDirectives().slice(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes || [],
      assumeValid: this.__validationErrors !== undefined,
      allowedLegacyNames: this.__allowedLegacyNames
    };
  };

  return GraphQLSchema;
}(); // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

Object(_jsutils_defineToStringTag__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(GraphQLSchema);

function typeMapReducer(map, type) {
  if (!type) {
    return map;
  }

  var namedType = Object(_definition__WEBPACK_IMPORTED_MODULE_10__[/* getNamedType */ "A"])(type);
  var seenType = map[namedType.name];

  if (seenType) {
    if (seenType !== namedType) {
      throw new Error("Schema must contain uniquely named types but contains multiple types named \"".concat(namedType.name, "\"."));
    }

    return map;
  }

  map[namedType.name] = namedType;
  var reducedMap = map;

  if (Object(_definition__WEBPACK_IMPORTED_MODULE_10__[/* isUnionType */ "T"])(namedType)) {
    reducedMap = namedType.getTypes().reduce(typeMapReducer, reducedMap);
  }

  if (Object(_definition__WEBPACK_IMPORTED_MODULE_10__[/* isObjectType */ "N"])(namedType)) {
    reducedMap = namedType.getInterfaces().reduce(typeMapReducer, reducedMap);
  }

  if (Object(_definition__WEBPACK_IMPORTED_MODULE_10__[/* isObjectType */ "N"])(namedType) || Object(_definition__WEBPACK_IMPORTED_MODULE_10__[/* isInterfaceType */ "H"])(namedType)) {
    for (var _i8 = 0, _objectValues4 = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(namedType.getFields()); _i8 < _objectValues4.length; _i8++) {
      var field = _objectValues4[_i8];
      var fieldArgTypes = field.args.map(function (arg) {
        return arg.type;
      });
      reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);
      reducedMap = typeMapReducer(reducedMap, field.type);
    }
  }

  if (Object(_definition__WEBPACK_IMPORTED_MODULE_10__[/* isInputObjectType */ "F"])(namedType)) {
    for (var _i10 = 0, _objectValues6 = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(namedType.getFields()); _i10 < _objectValues6.length; _i10++) {
      var _field = _objectValues6[_i10];
      reducedMap = typeMapReducer(reducedMap, _field.type);
    }
  }

  return reducedMap;
}

function typeMapDirectiveReducer(map, directive) {
  // Directives are not validated until validateSchema() is called.
  if (!Object(_directives__WEBPACK_IMPORTED_MODULE_9__[/* isDirective */ "g"])(directive)) {
    return map;
  }

  return directive.args.reduce(function (_map, arg) {
    return typeMapReducer(_map, arg.type);
  }, map);
}


/***/ }),
/* 37 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* eslint-disable no-redeclare */
// $FlowFixMe workaround for: https://github.com/facebook/flow/issues/5838
var objectEntries = Object.entries || function (obj) {
  return Object.keys(obj).map(function (key) {
    return [key, obj[key]];
  });
};

/* harmony default export */ __webpack_exports__["a"] = (objectEntries);


/***/ }),
/* 38 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isDefinitionNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isExecutableDefinitionNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isSelectionNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return isValueNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return isTypeNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return isTypeSystemDefinitionNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isTypeDefinitionNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return isTypeSystemExtensionNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isTypeExtensionNode; });
/* harmony import */ var _kinds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

function isDefinitionNode(node) {
  return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
}
function isExecutableDefinitionNode(node) {
  return node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].OPERATION_DEFINITION || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].FRAGMENT_DEFINITION;
}
function isSelectionNode(node) {
  return node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].FIELD || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].FRAGMENT_SPREAD || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].INLINE_FRAGMENT;
}
function isValueNode(node) {
  return node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].VARIABLE || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].INT || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].FLOAT || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].STRING || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].BOOLEAN || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].NULL || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].ENUM || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].LIST || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].OBJECT;
}
function isTypeNode(node) {
  return node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].NAMED_TYPE || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].LIST_TYPE || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].NON_NULL_TYPE;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].SCALAR_TYPE_DEFINITION || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].OBJECT_TYPE_DEFINITION || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].INTERFACE_TYPE_DEFINITION || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].UNION_TYPE_DEFINITION || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].ENUM_TYPE_DEFINITION || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].SCALAR_TYPE_EXTENSION || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].OBJECT_TYPE_EXTENSION || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].INTERFACE_TYPE_EXTENSION || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].UNION_TYPE_EXTENSION || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].ENUM_TYPE_EXTENSION || node.kind === _kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].INPUT_OBJECT_TYPE_EXTENSION;
}


/***/ }),
/* 39 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
// Workaround to make older Flow versions happy
var flatMapMethod = Array.prototype.flatMap;
/* eslint-disable no-redeclare */
// $FlowFixMe

var flatMap = flatMapMethod ? function (list, fn) {
  return flatMapMethod.call(list, fn);
} : function (list, fn) {
  var result = [];

  for (var _i2 = 0; _i2 < list.length; _i2++) {
    var _item = list[_i2];
    var value = fn(_item);

    if (Array.isArray(value)) {
      result = result.concat(value);
    } else {
      result.push(value);
    }
  }

  return result;
};
/* harmony default export */ __webpack_exports__["a"] = (flatMap);


/***/ }),
/* 40 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A replacement for instanceof which includes an error warning when multi-realm
 * constructors are detected.
 */
// See: https://expressjs.com/en/advanced/best-practice-performance.html#set-node_env-to-production
// See: https://webpack.js.org/guides/production/
/* harmony default export */ __webpack_exports__["a"] = ( true ? // eslint-disable-next-line no-shadow
function instanceOf(value, constructor) {
  return value instanceof constructor;
} : // eslint-disable-next-line no-shadow
undefined);


/***/ }),
/* 41 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return dedentBlockStringValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getBlockStringIndentation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return printBlockString; });
/**
 * Produces the value of a block string from its parsed raw value, similar to
 * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.
 *
 * This implements the GraphQL spec's BlockStringValue() static algorithm.
 */
function dedentBlockStringValue(rawString) {
  // Expand a block string's raw value into independent lines.
  var lines = rawString.split(/\r\n|[\n\r]/g); // Remove common indentation from all lines but first.

  var commonIndent = getBlockStringIndentation(lines);

  if (commonIndent !== 0) {
    for (var i = 1; i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  } // Remove leading and trailing blank lines.


  while (lines.length > 0 && isBlank(lines[0])) {
    lines.shift();
  }

  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
    lines.pop();
  } // Return a string of the lines joined with U+000A.


  return lines.join('\n');
} // @internal

function getBlockStringIndentation(lines) {
  var commonIndent = null;

  for (var i = 1; i < lines.length; i++) {
    var line = lines[i];
    var indent = leadingWhitespace(line);

    if (indent === line.length) {
      continue; // skip empty lines
    }

    if (commonIndent === null || indent < commonIndent) {
      commonIndent = indent;

      if (commonIndent === 0) {
        break;
      }
    }
  }

  return commonIndent === null ? 0 : commonIndent;
}

function leadingWhitespace(str) {
  var i = 0;

  while (i < str.length && (str[i] === ' ' || str[i] === '\t')) {
    i++;
  }

  return i;
}

function isBlank(str) {
  return leadingWhitespace(str) === str.length;
}
/**
 * Print a block string in the indented block form by adding a leading and
 * trailing blank line. However, if a block string starts with whitespace and is
 * a single-line, adding a leading blank line would strip that whitespace.
 */


function printBlockString(value) {
  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isSingleLine = value.indexOf('\n') === -1;
  var hasLeadingSpace = value[0] === ' ' || value[0] === '\t';
  var hasTrailingQuote = value[value.length - 1] === '"';
  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || preferMultipleLines;
  var result = ''; // Format a multi-line block quote to account for leading space.

  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
    result += '\n' + indentation;
  }

  result += indentation ? value.replace(/\n/g, '\n' + indentation) : value;

  if (printAsMultipleLines) {
    result += '\n';
  }

  return '"""' + result.replace(/"""/g, '\\"""') + '"""';
}


/***/ }),
/* 42 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* eslint-disable no-redeclare */
// $FlowFixMe
var find = Array.prototype.find ? function (list, predicate) {
  return Array.prototype.find.call(list, predicate);
} : function (list, predicate) {
  for (var _i2 = 0; _i2 < list.length; _i2++) {
    var value = list[_i2];

    if (predicate(value)) {
      return value;
    }
  }
};
/* harmony default export */ __webpack_exports__["a"] = (find);


/***/ }),
/* 43 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return mapValue; });
/* harmony import */ var _polyfills_objectEntries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);


/**
 * Creates an object map with the same keys as `map` and values generated by
 * running each value of `map` thru `fn`.
 */
function mapValue(map, fn) {
  var result = Object.create(null);

  for (var _i2 = 0, _objectEntries2 = Object(_polyfills_objectEntries__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(map); _i2 < _objectEntries2.length; _i2++) {
    var _ref2 = _objectEntries2[_i2];
    var _key = _ref2[0];
    var _value = _ref2[1];
    result[_key] = fn(_value, _key);
  }

  return result;
}


/***/ }),
/* 44 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TypeInfo; });
/* harmony import */ var _polyfills_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var _type_introspection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12);
/* harmony import */ var _typeFromAST__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19);





/**
 * TypeInfo is a utility class which, given a GraphQL schema, can keep track
 * of the current field and type definitions at any point in a GraphQL document
 * AST during a recursive descent by calling `enter(node)` and `leave(node)`.
 */

var TypeInfo =
/*#__PURE__*/
function () {
  function TypeInfo(schema, // NOTE: this experimental optional second parameter is only needed in order
  // to support non-spec-compliant codebases. You should never need to use it.
  // It may disappear in the future.
  getFieldDefFn, // Initial type may be provided in rare cases to facilitate traversals
  // beginning somewhere other than documents.
  initialType) {
    this._schema = schema;
    this._typeStack = [];
    this._parentTypeStack = [];
    this._inputTypeStack = [];
    this._fieldDefStack = [];
    this._defaultValueStack = [];
    this._directive = null;
    this._argument = null;
    this._enumValue = null;
    this._getFieldDef = getFieldDefFn || getFieldDef;

    if (initialType) {
      if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isInputType */ "G"])(initialType)) {
        this._inputTypeStack.push(initialType);
      }

      if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isCompositeType */ "D"])(initialType)) {
        this._parentTypeStack.push(initialType);
      }

      if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isOutputType */ "O"])(initialType)) {
        this._typeStack.push(initialType);
      }
    }
  }

  var _proto = TypeInfo.prototype;

  _proto.getType = function getType() {
    if (this._typeStack.length > 0) {
      return this._typeStack[this._typeStack.length - 1];
    }
  };

  _proto.getParentType = function getParentType() {
    if (this._parentTypeStack.length > 0) {
      return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
  };

  _proto.getInputType = function getInputType() {
    if (this._inputTypeStack.length > 0) {
      return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
  };

  _proto.getParentInputType = function getParentInputType() {
    if (this._inputTypeStack.length > 1) {
      return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
  };

  _proto.getFieldDef = function getFieldDef() {
    if (this._fieldDefStack.length > 0) {
      return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
  };

  _proto.getDefaultValue = function getDefaultValue() {
    if (this._defaultValueStack.length > 0) {
      return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
  };

  _proto.getDirective = function getDirective() {
    return this._directive;
  };

  _proto.getArgument = function getArgument() {
    return this._argument;
  };

  _proto.getEnumValue = function getEnumValue() {
    return this._enumValue;
  };

  _proto.enter = function enter(node) {
    var schema = this._schema; // Note: many of the types below are explicitly typed as "mixed" to drop
    // any assumptions of a valid schema to ensure runtime types are properly
    // checked before continuing since TypeInfo is used as part of validation
    // which occurs before guarantees of schema and document validity.

    switch (node.kind) {
      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].SELECTION_SET:
        {
          var namedType = Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* getNamedType */ "A"])(this.getType());

          this._parentTypeStack.push(Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isCompositeType */ "D"])(namedType) ? namedType : undefined);

          break;
        }

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].FIELD:
        {
          var parentType = this.getParentType();
          var fieldDef;
          var fieldType;

          if (parentType) {
            fieldDef = this._getFieldDef(schema, parentType, node);

            if (fieldDef) {
              fieldType = fieldDef.type;
            }
          }

          this._fieldDefStack.push(fieldDef);

          this._typeStack.push(Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isOutputType */ "O"])(fieldType) ? fieldType : undefined);

          break;
        }

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].DIRECTIVE:
        this._directive = schema.getDirective(node.name.value);
        break;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].OPERATION_DEFINITION:
        {
          var type;

          if (node.operation === 'query') {
            type = schema.getQueryType();
          } else if (node.operation === 'mutation') {
            type = schema.getMutationType();
          } else if (node.operation === 'subscription') {
            type = schema.getSubscriptionType();
          }

          this._typeStack.push(Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isObjectType */ "N"])(type) ? type : undefined);

          break;
        }

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].INLINE_FRAGMENT:
      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].FRAGMENT_DEFINITION:
        {
          var typeConditionAST = node.typeCondition;
          var outputType = typeConditionAST ? Object(_typeFromAST__WEBPACK_IMPORTED_MODULE_4__[/* typeFromAST */ "a"])(schema, typeConditionAST) : Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* getNamedType */ "A"])(this.getType());

          this._typeStack.push(Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isOutputType */ "O"])(outputType) ? outputType : undefined);

          break;
        }

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].VARIABLE_DEFINITION:
        {
          var inputType = Object(_typeFromAST__WEBPACK_IMPORTED_MODULE_4__[/* typeFromAST */ "a"])(schema, node.type);

          this._inputTypeStack.push(Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isInputType */ "G"])(inputType) ? inputType : undefined);

          break;
        }

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].ARGUMENT:
        {
          var argDef;
          var argType;
          var fieldOrDirective = this.getDirective() || this.getFieldDef();

          if (fieldOrDirective) {
            argDef = Object(_polyfills_find__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(fieldOrDirective.args, function (arg) {
              return arg.name === node.name.value;
            });

            if (argDef) {
              argType = argDef.type;
            }
          }

          this._argument = argDef;

          this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);

          this._inputTypeStack.push(Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isInputType */ "G"])(argType) ? argType : undefined);

          break;
        }

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].LIST:
        {
          var listType = Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* getNullableType */ "B"])(this.getInputType());
          var itemType = Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isListType */ "J"])(listType) ? listType.ofType : listType; // List positions never have a default value.

          this._defaultValueStack.push(undefined);

          this._inputTypeStack.push(Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isInputType */ "G"])(itemType) ? itemType : undefined);

          break;
        }

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].OBJECT_FIELD:
        {
          var objectType = Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* getNamedType */ "A"])(this.getInputType());
          var inputFieldType;
          var inputField;

          if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isInputObjectType */ "F"])(objectType)) {
            inputField = objectType.getFields()[node.name.value];

            if (inputField) {
              inputFieldType = inputField.type;
            }
          }

          this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);

          this._inputTypeStack.push(Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isInputType */ "G"])(inputFieldType) ? inputFieldType : undefined);

          break;
        }

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].ENUM:
        {
          var enumType = Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* getNamedType */ "A"])(this.getInputType());
          var enumValue;

          if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isEnumType */ "E"])(enumType)) {
            enumValue = enumType.getValue(node.value);
          }

          this._enumValue = enumValue;
          break;
        }
    }
  };

  _proto.leave = function leave(node) {
    switch (node.kind) {
      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].SELECTION_SET:
        this._parentTypeStack.pop();

        break;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].FIELD:
        this._fieldDefStack.pop();

        this._typeStack.pop();

        break;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].DIRECTIVE:
        this._directive = null;
        break;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].OPERATION_DEFINITION:
      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].INLINE_FRAGMENT:
      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].FRAGMENT_DEFINITION:
        this._typeStack.pop();

        break;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].VARIABLE_DEFINITION:
        this._inputTypeStack.pop();

        break;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].ARGUMENT:
        this._argument = null;

        this._defaultValueStack.pop();

        this._inputTypeStack.pop();

        break;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].LIST:
      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].OBJECT_FIELD:
        this._defaultValueStack.pop();

        this._inputTypeStack.pop();

        break;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].ENUM:
        this._enumValue = null;
        break;
    }
  };

  return TypeInfo;
}();
/**
 * Not exactly the same as the executor's definition of getFieldDef, in this
 * statically evaluated environment we do not always have an Object type,
 * and need to handle Interface and Union types.
 */

function getFieldDef(schema, parentType, fieldNode) {
  var name = fieldNode.name.value;

  if (name === _type_introspection__WEBPACK_IMPORTED_MODULE_3__[/* SchemaMetaFieldDef */ "a"].name && schema.getQueryType() === parentType) {
    return _type_introspection__WEBPACK_IMPORTED_MODULE_3__[/* SchemaMetaFieldDef */ "a"];
  }

  if (name === _type_introspection__WEBPACK_IMPORTED_MODULE_3__[/* TypeMetaFieldDef */ "c"].name && schema.getQueryType() === parentType) {
    return _type_introspection__WEBPACK_IMPORTED_MODULE_3__[/* TypeMetaFieldDef */ "c"];
  }

  if (name === _type_introspection__WEBPACK_IMPORTED_MODULE_3__[/* TypeNameMetaFieldDef */ "d"].name && Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isCompositeType */ "D"])(parentType)) {
    return _type_introspection__WEBPACK_IMPORTED_MODULE_3__[/* TypeNameMetaFieldDef */ "d"];
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isObjectType */ "N"])(parentType) || Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isInterfaceType */ "H"])(parentType)) {
    return parentType.getFields()[name];
  }
}


/***/ }),
/* 45 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return valueFromAST; });
/* harmony import */ var _polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _jsutils_invariant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17);
/* harmony import */ var _jsutils_isInvalid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(30);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);







/**
 * Produces a JavaScript value given a GraphQL Value AST.
 *
 * A GraphQL type must be provided, which will be used to interpret different
 * GraphQL Value literals.
 *
 * Returns `undefined` when the value could not be validly coerced according to
 * the provided type.
 *
 * | GraphQL Value        | JSON Value    |
 * | -------------------- | ------------- |
 * | Input Object         | Object        |
 * | List                 | Array         |
 * | Boolean              | Boolean       |
 * | String               | String        |
 * | Int / Float          | Number        |
 * | Enum Value           | Mixed         |
 * | NullValue            | null          |
 *
 */

function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    // When there is no node, then there is also no value.
    // Importantly, this is different from returning the value null.
    return;
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNonNullType */ "L"])(type)) {
    if (valueNode.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_5__[/* Kind */ "a"].NULL) {
      return; // Invalid: intentionally return no value.
    }

    return valueFromAST(valueNode, type.ofType, variables);
  }

  if (valueNode.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_5__[/* Kind */ "a"].NULL) {
    // This is explicitly returning the value null.
    return null;
  }

  if (valueNode.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_5__[/* Kind */ "a"].VARIABLE) {
    var variableName = valueNode.name.value;

    if (!variables || Object(_jsutils_isInvalid__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(variables[variableName])) {
      // No valid return value.
      return;
    }

    var variableValue = variables[variableName];

    if (variableValue === null && Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNonNullType */ "L"])(type)) {
      return; // Invalid: intentionally return no value.
    } // Note: This does no further checking that this variable is correct.
    // This assumes that this query has been validated and the variable
    // usage here is of the correct type.


    return variableValue;
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isListType */ "J"])(type)) {
    var itemType = type.ofType;

    if (valueNode.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_5__[/* Kind */ "a"].LIST) {
      var coercedValues = [];

      for (var _i2 = 0, _valueNode$values2 = valueNode.values; _i2 < _valueNode$values2.length; _i2++) {
        var itemNode = _valueNode$values2[_i2];

        if (isMissingVariable(itemNode, variables)) {
          // If an array contains a missing variable, it is either coerced to
          // null or if the item type is non-null, it considered invalid.
          if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNonNullType */ "L"])(itemType)) {
            return; // Invalid: intentionally return no value.
          }

          coercedValues.push(null);
        } else {
          var itemValue = valueFromAST(itemNode, itemType, variables);

          if (Object(_jsutils_isInvalid__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(itemValue)) {
            return; // Invalid: intentionally return no value.
          }

          coercedValues.push(itemValue);
        }
      }

      return coercedValues;
    }

    var coercedValue = valueFromAST(valueNode, itemType, variables);

    if (Object(_jsutils_isInvalid__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(coercedValue)) {
      return; // Invalid: intentionally return no value.
    }

    return [coercedValue];
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isInputObjectType */ "F"])(type)) {
    if (valueNode.kind !== _language_kinds__WEBPACK_IMPORTED_MODULE_5__[/* Kind */ "a"].OBJECT) {
      return; // Invalid: intentionally return no value.
    }

    var coercedObj = Object.create(null);
    var fieldNodes = Object(_jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(valueNode.fields, function (field) {
      return field.name.value;
    });

    for (var _i4 = 0, _objectValues2 = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(type.getFields()); _i4 < _objectValues2.length; _i4++) {
      var field = _objectValues2[_i4];
      var fieldNode = fieldNodes[field.name];

      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== undefined) {
          coercedObj[field.name] = field.defaultValue;
        } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNonNullType */ "L"])(field.type)) {
          return; // Invalid: intentionally return no value.
        }

        continue;
      }

      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);

      if (Object(_jsutils_isInvalid__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(fieldValue)) {
        return; // Invalid: intentionally return no value.
      }

      coercedObj[field.name] = fieldValue;
    }

    return coercedObj;
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isEnumType */ "E"])(type)) {
    if (valueNode.kind !== _language_kinds__WEBPACK_IMPORTED_MODULE_5__[/* Kind */ "a"].ENUM) {
      return; // Invalid: intentionally return no value.
    }

    var enumValue = type.getValue(valueNode.value);

    if (!enumValue) {
      return; // Invalid: intentionally return no value.
    }

    return enumValue.value;
  }

  /* istanbul ignore else */
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isScalarType */ "R"])(type)) {
    // Scalars fulfill parsing a literal value via parseLiteral().
    // Invalid values represent a failure to parse correctly, in which case
    // no value is returned.
    var result;

    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return; // Invalid: intentionally return no value.
    }

    if (Object(_jsutils_isInvalid__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(result)) {
      return; // Invalid: intentionally return no value.
    }

    return result;
  } // Not reachable. All possible input types have been considered.


  /* istanbul ignore next */
  Object(_jsutils_invariant__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(false, 'Unexpected input type: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(type));
} // Returns true if the provided valueNode is a variable which is not defined
// in the set of variables.

function isMissingVariable(valueNode, variables) {
  return valueNode.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_5__[/* Kind */ "a"].VARIABLE && (!variables || Object(_jsutils_isInvalid__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(variables[valueNode.name.value]));
}


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var addResolveFunctionsToSchema_1 = __webpack_require__(169);

exports.addResolveFunctionsToSchema = addResolveFunctionsToSchema_1.default;

var addSchemaLevelResolveFunction_1 = __webpack_require__(171);

exports.addSchemaLevelResolveFunction = addSchemaLevelResolveFunction_1.default;

var assertResolveFunctionsPresent_1 = __webpack_require__(172);

exports.assertResolveFunctionsPresent = assertResolveFunctionsPresent_1.default;

var attachDirectiveResolvers_1 = __webpack_require__(173);

exports.attachDirectiveResolvers = attachDirectiveResolvers_1.default;

var attachConnectorsToContext_1 = __webpack_require__(174);

exports.attachConnectorsToContext = attachConnectorsToContext_1.default;

var buildSchemaFromTypeDefinitions_1 = __webpack_require__(176);

exports.buildSchemaFromTypeDefinitions = buildSchemaFromTypeDefinitions_1.default;

var chainResolvers_1 = __webpack_require__(177);

exports.chainResolvers = chainResolvers_1.chainResolvers;

var checkForResolveTypeResolver_1 = __webpack_require__(178);

exports.checkForResolveTypeResolver = checkForResolveTypeResolver_1.default;

var concatenateTypeDefs_1 = __webpack_require__(179);

exports.concatenateTypeDefs = concatenateTypeDefs_1.default;

var decorateWithLogger_1 = __webpack_require__(180);

exports.decorateWithLogger = decorateWithLogger_1.default;

var extendResolversFromInterfaces_1 = __webpack_require__(181);

exports.extendResolversFromInterfaces = extendResolversFromInterfaces_1.default;

var extractExtensionDefinitions_1 = __webpack_require__(182);

exports.extractExtensionDefinitions = extractExtensionDefinitions_1.default;

var forEachField_1 = __webpack_require__(183);

exports.forEachField = forEachField_1.default;

var SchemaError_1 = __webpack_require__(184);

exports.SchemaError = SchemaError_1.default;

/***/ }),
/* 47 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return astFromValue; });
/* harmony import */ var iterall__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var _polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _jsutils_invariant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17);
/* harmony import */ var _jsutils_isNullish__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75);
/* harmony import */ var _jsutils_isInvalid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(30);
/* harmony import */ var _jsutils_isObjectLike__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(18);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(2);
/* harmony import */ var _type_scalars__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(0);










/**
 * Produces a GraphQL Value AST given a JavaScript value.
 *
 * A GraphQL type must be provided, which will be used to interpret different
 * JavaScript values.
 *
 * | JSON Value    | GraphQL Value        |
 * | ------------- | -------------------- |
 * | Object        | Input Object         |
 * | Array         | List                 |
 * | Boolean       | Boolean              |
 * | String        | String / Enum Value  |
 * | Number        | Int / Float          |
 * | Mixed         | Enum Value           |
 * | null          | NullValue            |
 *
 */

function astFromValue(value, type) {
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_9__[/* isNonNullType */ "L"])(type)) {
    var astValue = astFromValue(value, type.ofType);

    if (astValue && astValue.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].NULL) {
      return null;
    }

    return astValue;
  } // only explicit null, not undefined, NaN


  if (value === null) {
    return {
      kind: _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].NULL
    };
  } // undefined, NaN


  if (Object(_jsutils_isInvalid__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(value)) {
    return null;
  } // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but
  // the value is not an array, convert the value using the list's item type.


  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_9__[/* isListType */ "J"])(type)) {
    var itemType = type.ofType;

    if (Object(iterall__WEBPACK_IMPORTED_MODULE_0__["isCollection"])(value)) {
      var valuesNodes = [];
      Object(iterall__WEBPACK_IMPORTED_MODULE_0__["forEach"])(value, function (item) {
        var itemNode = astFromValue(item, itemType);

        if (itemNode) {
          valuesNodes.push(itemNode);
        }
      });
      return {
        kind: _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].LIST,
        values: valuesNodes
      };
    }

    return astFromValue(value, itemType);
  } // Populate the fields of the input object by creating ASTs from each value
  // in the JavaScript object according to the fields in the input type.


  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_9__[/* isInputObjectType */ "F"])(type)) {
    if (!Object(_jsutils_isObjectLike__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(value)) {
      return null;
    }

    var fieldNodes = [];

    for (var _i2 = 0, _objectValues2 = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(type.getFields()); _i2 < _objectValues2.length; _i2++) {
      var field = _objectValues2[_i2];
      var fieldValue = astFromValue(value[field.name], field.type);

      if (fieldValue) {
        fieldNodes.push({
          kind: _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].OBJECT_FIELD,
          name: {
            kind: _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }

    return {
      kind: _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].OBJECT,
      fields: fieldNodes
    };
  }

  /* istanbul ignore else */
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_9__[/* isLeafType */ "I"])(type)) {
    // Since value is an internally represented value, it must be serialized
    // to an externally represented value before converting into an AST.
    var serialized = type.serialize(value);

    if (Object(_jsutils_isNullish__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(serialized)) {
      return null;
    } // Others serialize based on their corresponding JavaScript scalar types.


    if (typeof serialized === 'boolean') {
      return {
        kind: _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].BOOLEAN,
        value: serialized
      };
    } // JavaScript numbers can be Int or Float values.


    if (typeof serialized === 'number') {
      var stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].INT,
        value: stringNum
      } : {
        kind: _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].FLOAT,
        value: stringNum
      };
    }

    if (typeof serialized === 'string') {
      // Enum types use Enum literals.
      if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_9__[/* isEnumType */ "E"])(type)) {
        return {
          kind: _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].ENUM,
          value: serialized
        };
      } // ID types can use Int literals.


      if (type === _type_scalars__WEBPACK_IMPORTED_MODULE_8__[/* GraphQLID */ "c"] && integerStringRegExp.test(serialized)) {
        return {
          kind: _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].INT,
          value: serialized
        };
      }

      return {
        kind: _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].STRING,
        value: serialized
      };
    }

    throw new TypeError("Cannot convert value to AST: ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(serialized)));
  } // Not reachable. All possible input types have been considered.


  /* istanbul ignore next */
  Object(_jsutils_invariant__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(false, 'Unexpected input type: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(type));
}
/**
 * IntValue:
 *   - NegativeSign? 0
 *   - NegativeSign? NonZeroDigit ( Digit+ )?
 */

var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;


/***/ }),
/* 48 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseValue", function() { return parseValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseType", function() { return parseType; });
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _jsutils_devAssert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var _jsutils_defineToJSON__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _error_syntaxError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25);
/* harmony import */ var _kinds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2);
/* harmony import */ var _source__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58);
/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(67);
/* harmony import */ var _directiveLocation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(9);
/* harmony import */ var _tokenKind__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(5);










/**
 * Given a GraphQL source, parses it into a Document.
 * Throws GraphQLError if a syntax error is encountered.
 */
function parse(source, options) {
  var parser = new Parser(source, options);
  return parser.parseDocument();
}
/**
 * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for
 * that value.
 * Throws GraphQLError if a syntax error is encountered.
 *
 * This is useful within tools that operate upon GraphQL Values directly and
 * in isolation of complete GraphQL documents.
 *
 * Consider providing the results to the utility function: valueFromAST().
 */

function parseValue(source, options) {
  var parser = new Parser(source, options);
  parser.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].SOF);
  var value = parser.parseValueLiteral(false);
  parser.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].EOF);
  return value;
}
/**
 * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for
 * that type.
 * Throws GraphQLError if a syntax error is encountered.
 *
 * This is useful within tools that operate upon GraphQL Types directly and
 * in isolation of complete GraphQL documents.
 *
 * Consider providing the results to the utility function: typeFromAST().
 */

function parseType(source, options) {
  var parser = new Parser(source, options);
  parser.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].SOF);
  var type = parser.parseTypeReference();
  parser.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].EOF);
  return type;
}

var Parser =
/*#__PURE__*/
function () {
  function Parser(source, options) {
    var sourceObj = typeof source === 'string' ? new _source__WEBPACK_IMPORTED_MODULE_5__[/* Source */ "a"](source) : source;
    sourceObj instanceof _source__WEBPACK_IMPORTED_MODULE_5__[/* Source */ "a"] || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(0, "Must provide Source. Received: ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(sourceObj)));
    this._lexer = Object(_lexer__WEBPACK_IMPORTED_MODULE_6__[/* createLexer */ "a"])(sourceObj);
    this._options = options || {};
  }
  /**
   * Converts a name lex token into a name parse node.
   */


  var _proto = Parser.prototype;

  _proto.parseName = function parseName() {
    var token = this.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].NAME);
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].NAME,
      value: token.value,
      loc: this.loc(token)
    };
  } // Implements the parsing rules in the Document section.

  /**
   * Document : Definition+
   */
  ;

  _proto.parseDocument = function parseDocument() {
    var start = this._lexer.token;
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].DOCUMENT,
      definitions: this.many(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].SOF, this.parseDefinition, _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].EOF),
      loc: this.loc(start)
    };
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   */
  ;

  _proto.parseDefinition = function parseDefinition() {
    if (this.peek(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].NAME)) {
      switch (this._lexer.token.value) {
        case 'query':
        case 'mutation':
        case 'subscription':
          return this.parseOperationDefinition();

        case 'fragment':
          return this.parseFragmentDefinition();

        case 'schema':
        case 'scalar':
        case 'type':
        case 'interface':
        case 'union':
        case 'enum':
        case 'input':
        case 'directive':
          return this.parseTypeSystemDefinition();

        case 'extend':
          return this.parseTypeSystemExtension();
      }
    } else if (this.peek(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_L)) {
      return this.parseOperationDefinition();
    } else if (this.peekDescription()) {
      return this.parseTypeSystemDefinition();
    }

    throw this.unexpected();
  } // Implements the parsing rules in the Operations section.

  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  ;

  _proto.parseOperationDefinition = function parseOperationDefinition() {
    var start = this._lexer.token;

    if (this.peek(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_L)) {
      return {
        kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].OPERATION_DEFINITION,
        operation: 'query',
        name: undefined,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }

    var operation = this.parseOperationType();
    var name;

    if (this.peek(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].NAME)) {
      name = this.parseName();
    }

    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].OPERATION_DEFINITION,
      operation: operation,
      name: name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  }
  /**
   * OperationType : one of query mutation subscription
   */
  ;

  _proto.parseOperationType = function parseOperationType() {
    var operationToken = this.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].NAME);

    switch (operationToken.value) {
      case 'query':
        return 'query';

      case 'mutation':
        return 'mutation';

      case 'subscription':
        return 'subscription';
    }

    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  ;

  _proto.parseVariableDefinitions = function parseVariableDefinitions() {
    return this.optionalMany(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].PAREN_L, this.parseVariableDefinition, _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].PAREN_R);
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  ;

  _proto.parseVariableDefinition = function parseVariableDefinition() {
    var start = this._lexer.token;
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].EQUALS) ? this.parseValueLiteral(true) : undefined,
      directives: this.parseDirectives(true),
      loc: this.loc(start)
    };
  }
  /**
   * Variable : $ Name
   */
  ;

  _proto.parseVariable = function parseVariable() {
    var start = this._lexer.token;
    this.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].DOLLAR);
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].VARIABLE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  }
  /**
   * SelectionSet : { Selection+ }
   */
  ;

  _proto.parseSelectionSet = function parseSelectionSet() {
    var start = this._lexer.token;
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].SELECTION_SET,
      selections: this.many(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_L, this.parseSelection, _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_R),
      loc: this.loc(start)
    };
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  ;

  _proto.parseSelection = function parseSelection() {
    return this.peek(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  ;

  _proto.parseField = function parseField() {
    var start = this._lexer.token;
    var nameOrAlias = this.parseName();
    var alias;
    var name;

    if (this.expectOptionalToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }

    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].FIELD,
      alias: alias,
      name: name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_L) ? this.parseSelectionSet() : undefined,
      loc: this.loc(start)
    };
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  ;

  _proto.parseArguments = function parseArguments(isConst) {
    var item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].PAREN_L, item, _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  ;

  _proto.parseArgument = function parseArgument() {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].COLON);
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].ARGUMENT,
      name: name,
      value: this.parseValueLiteral(false),
      loc: this.loc(start)
    };
  };

  _proto.parseConstArgument = function parseConstArgument() {
    var start = this._lexer.token;
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].ARGUMENT,
      name: this.parseName(),
      value: (this.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].COLON), this.parseValueLiteral(true)),
      loc: this.loc(start)
    };
  } // Implements the parsing rules in the Fragments section.

  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  ;

  _proto.parseFragment = function parseFragment() {
    var start = this._lexer.token;
    this.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].SPREAD);
    var hasTypeCondition = this.expectOptionalKeyword('on');

    if (!hasTypeCondition && this.peek(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].NAME)) {
      return {
        kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false),
        loc: this.loc(start)
      };
    }

    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  ;

  _proto.parseFragmentDefinition = function parseFragmentDefinition() {
    var start = this._lexer.token;
    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes
    // the grammar of FragmentDefinition:
    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet

    if (this._options.experimentalFragmentVariables) {
      return {
        kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }

    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  }
  /**
   * FragmentName : Name but not `on`
   */
  ;

  _proto.parseFragmentName = function parseFragmentName() {
    if (this._lexer.token.value === 'on') {
      throw this.unexpected();
    }

    return this.parseName();
  } // Implements the parsing rules in the Values section.

  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  ;

  _proto.parseValueLiteral = function parseValueLiteral(isConst) {
    var token = this._lexer.token;

    switch (token.kind) {
      case _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACKET_L:
        return this.parseList(isConst);

      case _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_L:
        return this.parseObject(isConst);

      case _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].INT:
        this._lexer.advance();

        return {
          kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].INT,
          value: token.value,
          loc: this.loc(token)
        };

      case _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].FLOAT:
        this._lexer.advance();

        return {
          kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].FLOAT,
          value: token.value,
          loc: this.loc(token)
        };

      case _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].STRING:
      case _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BLOCK_STRING:
        return this.parseStringLiteral();

      case _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].NAME:
        if (token.value === 'true' || token.value === 'false') {
          this._lexer.advance();

          return {
            kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].BOOLEAN,
            value: token.value === 'true',
            loc: this.loc(token)
          };
        } else if (token.value === 'null') {
          this._lexer.advance();

          return {
            kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].NULL,
            loc: this.loc(token)
          };
        }

        this._lexer.advance();

        return {
          kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].ENUM,
          value: token.value,
          loc: this.loc(token)
        };

      case _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].DOLLAR:
        if (!isConst) {
          return this.parseVariable();
        }

        break;
    }

    throw this.unexpected();
  };

  _proto.parseStringLiteral = function parseStringLiteral() {
    var token = this._lexer.token;

    this._lexer.advance();

    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].STRING,
      value: token.value,
      block: token.kind === _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BLOCK_STRING,
      loc: this.loc(token)
    };
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  ;

  _proto.parseList = function parseList(isConst) {
    var _this = this;

    var start = this._lexer.token;

    var item = function item() {
      return _this.parseValueLiteral(isConst);
    };

    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].LIST,
      values: this.any(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACKET_L, item, _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACKET_R),
      loc: this.loc(start)
    };
  }
  /**
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   */
  ;

  _proto.parseObject = function parseObject(isConst) {
    var _this2 = this;

    var start = this._lexer.token;

    var item = function item() {
      return _this2.parseObjectField(isConst);
    };

    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].OBJECT,
      fields: this.any(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_L, item, _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_R),
      loc: this.loc(start)
    };
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  ;

  _proto.parseObjectField = function parseObjectField(isConst) {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].COLON);
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].OBJECT_FIELD,
      name: name,
      value: this.parseValueLiteral(isConst),
      loc: this.loc(start)
    };
  } // Implements the parsing rules in the Directives section.

  /**
   * Directives[Const] : Directive[?Const]+
   */
  ;

  _proto.parseDirectives = function parseDirectives(isConst) {
    var directives = [];

    while (this.peek(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].AT)) {
      directives.push(this.parseDirective(isConst));
    }

    return directives;
  }
  /**
   * Directive[Const] : @ Name Arguments[?Const]?
   */
  ;

  _proto.parseDirective = function parseDirective(isConst) {
    var start = this._lexer.token;
    this.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].AT);
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst),
      loc: this.loc(start)
    };
  } // Implements the parsing rules in the Types section.

  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  ;

  _proto.parseTypeReference = function parseTypeReference() {
    var start = this._lexer.token;
    var type;

    if (this.expectOptionalToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACKET_L)) {
      type = this.parseTypeReference();
      this.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACKET_R);
      type = {
        kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].LIST_TYPE,
        type: type,
        loc: this.loc(start)
      };
    } else {
      type = this.parseNamedType();
    }

    if (this.expectOptionalToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BANG)) {
      return {
        kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].NON_NULL_TYPE,
        type: type,
        loc: this.loc(start)
      };
    }

    return type;
  }
  /**
   * NamedType : Name
   */
  ;

  _proto.parseNamedType = function parseNamedType() {
    var start = this._lexer.token;
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].NAMED_TYPE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  } // Implements the parsing rules in the Type Definition section.

  /**
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  ;

  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
    // Many definitions begin with a description and require a lookahead.
    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;

    if (keywordToken.kind === _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].NAME) {
      switch (keywordToken.value) {
        case 'schema':
          return this.parseSchemaDefinition();

        case 'scalar':
          return this.parseScalarTypeDefinition();

        case 'type':
          return this.parseObjectTypeDefinition();

        case 'interface':
          return this.parseInterfaceTypeDefinition();

        case 'union':
          return this.parseUnionTypeDefinition();

        case 'enum':
          return this.parseEnumTypeDefinition();

        case 'input':
          return this.parseInputObjectTypeDefinition();

        case 'directive':
          return this.parseDirectiveDefinition();
      }
    }

    throw this.unexpected(keywordToken);
  };

  _proto.peekDescription = function peekDescription() {
    return this.peek(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].STRING) || this.peek(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  ;

  _proto.parseDescription = function parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }
   */
  ;

  _proto.parseSchemaDefinition = function parseSchemaDefinition() {
    var start = this._lexer.token;
    this.expectKeyword('schema');
    var directives = this.parseDirectives(true);
    var operationTypes = this.many(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_L, this.parseOperationTypeDefinition, _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_R);
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].SCHEMA_DEFINITION,
      directives: directives,
      operationTypes: operationTypes,
      loc: this.loc(start)
    };
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  ;

  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
    var start = this._lexer.token;
    var operation = this.parseOperationType();
    this.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].COLON);
    var type = this.parseNamedType();
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].OPERATION_TYPE_DEFINITION,
      operation: operation,
      type: type,
      loc: this.loc(start)
    };
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  ;

  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('scalar');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].SCALAR_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  ;

  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('type');
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].OBJECT_TYPE_DEFINITION,
      description: description,
      name: name,
      interfaces: interfaces,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  ;

  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
    var types = [];

    if (this.expectOptionalKeyword('implements')) {
      // Optional leading ampersand
      this.expectOptionalToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].AMP);

      do {
        types.push(this.parseNamedType());
      } while (this.expectOptionalToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].AMP) || // Legacy support for the SDL?
      this._options.allowLegacySDLImplementsInterfaces && this.peek(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].NAME));
    }

    return types;
  }
  /**
   * FieldsDefinition : { FieldDefinition+ }
   */
  ;

  _proto.parseFieldsDefinition = function parseFieldsDefinition() {
    // Legacy support for the SDL?
    if (this._options.allowLegacySDLEmptyFields && this.peek(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_L) && this._lexer.lookahead().kind === _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_R) {
      this._lexer.advance();

      this._lexer.advance();

      return [];
    }

    return this.optionalMany(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_L, this.parseFieldDefinition, _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_R);
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  ;

  _proto.parseFieldDefinition = function parseFieldDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var args = this.parseArgumentDefs();
    this.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].COLON);
    var type = this.parseTypeReference();
    var directives = this.parseDirectives(true);
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].FIELD_DEFINITION,
      description: description,
      name: name,
      arguments: args,
      type: type,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  ;

  _proto.parseArgumentDefs = function parseArgumentDefs() {
    return this.optionalMany(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].PAREN_L, this.parseInputValueDef, _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].PAREN_R);
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  ;

  _proto.parseInputValueDef = function parseInputValueDef() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    this.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].COLON);
    var type = this.parseTypeReference();
    var defaultValue;

    if (this.expectOptionalToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].EQUALS)) {
      defaultValue = this.parseValueLiteral(true);
    }

    var directives = this.parseDirectives(true);
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].INPUT_VALUE_DEFINITION,
      description: description,
      name: name,
      type: type,
      defaultValue: defaultValue,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  ;

  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('interface');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].INTERFACE_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  ;

  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('union');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].UNION_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      types: types,
      loc: this.loc(start)
    };
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  ;

  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
    var types = [];

    if (this.expectOptionalToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].EQUALS)) {
      // Optional leading pipe
      this.expectOptionalToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].PIPE);

      do {
        types.push(this.parseNamedType());
      } while (this.expectOptionalToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].PIPE));
    }

    return types;
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  ;

  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('enum');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var values = this.parseEnumValuesDefinition();
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].ENUM_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      values: values,
      loc: this.loc(start)
    };
  }
  /**
   * EnumValuesDefinition : { EnumValueDefinition+ }
   */
  ;

  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
    return this.optionalMany(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_L, this.parseEnumValueDefinition, _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_R);
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   *
   * EnumValue : Name
   */
  ;

  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].ENUM_VALUE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  ;

  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('input');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseInputFieldsDefinition();
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].INPUT_OBJECT_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * InputFieldsDefinition : { InputValueDefinition+ }
   */
  ;

  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
    return this.optionalMany(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_L, this.parseInputValueDef, _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_R);
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  ;

  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
    var keywordToken = this._lexer.lookahead();

    if (keywordToken.kind === _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].NAME) {
      switch (keywordToken.value) {
        case 'schema':
          return this.parseSchemaExtension();

        case 'scalar':
          return this.parseScalarTypeExtension();

        case 'type':
          return this.parseObjectTypeExtension();

        case 'interface':
          return this.parseInterfaceTypeExtension();

        case 'union':
          return this.parseUnionTypeExtension();

        case 'enum':
          return this.parseEnumTypeExtension();

        case 'input':
          return this.parseInputObjectTypeExtension();
      }
    }

    throw this.unexpected(keywordToken);
  }
  /**
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   */
  ;

  _proto.parseSchemaExtension = function parseSchemaExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('schema');
    var directives = this.parseDirectives(true);
    var operationTypes = this.optionalMany(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_L, this.parseOperationTypeDefinition, _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].BRACE_R);

    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].SCHEMA_EXTENSION,
      directives: directives,
      operationTypes: operationTypes,
      loc: this.loc(start)
    };
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  ;

  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('scalar');
    var name = this.parseName();
    var directives = this.parseDirectives(true);

    if (directives.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].SCALAR_TYPE_EXTENSION,
      name: name,
      directives: directives,
      loc: this.loc(start)
    };
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  ;

  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('type');
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();

    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].OBJECT_TYPE_EXTENSION,
      name: name,
      interfaces: interfaces,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * InterfaceTypeExtension :
   *   - extend interface Name Directives[Const]? FieldsDefinition
   *   - extend interface Name Directives[Const]
   */
  ;

  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('interface');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();

    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].INTERFACE_TYPE_EXTENSION,
      name: name,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  ;

  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('union');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();

    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].UNION_TYPE_EXTENSION,
      name: name,
      directives: directives,
      types: types,
      loc: this.loc(start)
    };
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  ;

  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('enum');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var values = this.parseEnumValuesDefinition();

    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].ENUM_TYPE_EXTENSION,
      name: name,
      directives: directives,
      values: values,
      loc: this.loc(start)
    };
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  ;

  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword('extend');
    this.expectKeyword('input');
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseInputFieldsDefinition();

    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }

    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].INPUT_OBJECT_TYPE_EXTENSION,
      name: name,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  }
  /**
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   */
  ;

  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword('directive');
    this.expectToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].AT);
    var name = this.parseName();
    var args = this.parseArgumentDefs();
    var repeatable = this.expectOptionalKeyword('repeatable');
    this.expectKeyword('on');
    var locations = this.parseDirectiveLocations();
    return {
      kind: _kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].DIRECTIVE_DEFINITION,
      description: description,
      name: name,
      arguments: args,
      repeatable: repeatable,
      locations: locations,
      loc: this.loc(start)
    };
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  ;

  _proto.parseDirectiveLocations = function parseDirectiveLocations() {
    // Optional leading pipe
    this.expectOptionalToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].PIPE);
    var locations = [];

    do {
      locations.push(this.parseDirectiveLocation());
    } while (this.expectOptionalToken(_tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].PIPE));

    return locations;
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  ;

  _proto.parseDirectiveLocation = function parseDirectiveLocation() {
    var start = this._lexer.token;
    var name = this.parseName();

    if (_directiveLocation__WEBPACK_IMPORTED_MODULE_7__[/* DirectiveLocation */ "a"][name.value] !== undefined) {
      return name;
    }

    throw this.unexpected(start);
  } // Core parsing utility functions

  /**
   * Returns a location object, used to identify the place in
   * the source that created a given parsed object.
   */
  ;

  _proto.loc = function loc(startToken) {
    if (!this._options.noLocation) {
      return new Loc(startToken, this._lexer.lastToken, this._lexer.source);
    }
  }
  /**
   * Determines if the next token is of a given kind
   */
  ;

  _proto.peek = function peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing
   * the lexer. Otherwise, do not change the parser state and throw an error.
   */
  ;

  _proto.expectToken = function expectToken(kind) {
    var token = this._lexer.token;

    if (token.kind === kind) {
      this._lexer.advance();

      return token;
    }

    throw Object(_error_syntaxError__WEBPACK_IMPORTED_MODULE_3__[/* syntaxError */ "a"])(this._lexer.source, token.start, "Expected ".concat(kind, ", found ").concat(getTokenDesc(token)));
  }
  /**
   * If the next token is of the given kind, return that token after advancing
   * the lexer. Otherwise, do not change the parser state and return undefined.
   */
  ;

  _proto.expectOptionalToken = function expectOptionalToken(kind) {
    var token = this._lexer.token;

    if (token.kind === kind) {
      this._lexer.advance();

      return token;
    }

    return undefined;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  ;

  _proto.expectKeyword = function expectKeyword(value) {
    var token = this._lexer.token;

    if (token.kind === _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].NAME && token.value === value) {
      this._lexer.advance();
    } else {
      throw Object(_error_syntaxError__WEBPACK_IMPORTED_MODULE_3__[/* syntaxError */ "a"])(this._lexer.source, token.start, "Expected \"".concat(value, "\", found ").concat(getTokenDesc(token)));
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing
   * the lexer. Otherwise, do not change the parser state and return "false".
   */
  ;

  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
    var token = this._lexer.token;

    if (token.kind === _tokenKind__WEBPACK_IMPORTED_MODULE_8__[/* TokenKind */ "a"].NAME && token.value === value) {
      this._lexer.advance();

      return true;
    }

    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token
   * is encountered.
   */
  ;

  _proto.unexpected = function unexpected(atToken) {
    var token = atToken || this._lexer.token;
    return Object(_error_syntaxError__WEBPACK_IMPORTED_MODULE_3__[/* syntaxError */ "a"])(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token)));
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by
   * the parseFn. This list begins with a lex token of openKind
   * and ends with a lex token of closeKind. Advances the parser
   * to the next lex token after the closing token.
   */
  ;

  _proto.any = function any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];

    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }

    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always
   * return non-empty list that begins with a lex token of openKind and ends
   * with a lex token of closeKind. Advances the parser to the next lex token
   * after the closing token.
   */
  ;

  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      var nodes = [];

      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));

      return nodes;
    }

    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by
   * the parseFn. This list begins with a lex token of openKind
   * and ends with a lex token of closeKind. Advances the parser
   * to the next lex token after the closing token.
   */
  ;

  _proto.many = function many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];

    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));

    return nodes;
  };

  return Parser;
}();

function Loc(startToken, endToken, source) {
  this.start = startToken.start;
  this.end = endToken.end;
  this.startToken = startToken;
  this.endToken = endToken;
  this.source = source;
} // Print a simplified form when appearing in JSON/util.inspect.


Object(_jsutils_defineToJSON__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(Loc, function () {
  return {
    start: this.start,
    end: this.end
  };
});
/**
 * A helper function to describe a token as a string for debugging
 */

function getTokenDesc(token) {
  var value = token.value;
  return value ? "".concat(token.kind, " \"").concat(value, "\"") : token.kind;
}


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ApolloLink", function() { return ApolloLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return concat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOperation", function() { return createOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "empty", function() { return empty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "execute", function() { return execute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "from", function() { return from; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromError", function() { return fromError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromPromise", function() { return fromPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makePromise", function() { return makePromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "split", function() { return split; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toPromise", function() { return toPromise; });
/* harmony import */ var zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Observable", function() { return zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony import */ var ts_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var apollo_utilities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getOperationName", function() { return apollo_utilities__WEBPACK_IMPORTED_MODULE_3__["n"]; });








function validateOperation(operation) {
  var OPERATION_FIELDS = ['query', 'operationName', 'variables', 'extensions', 'context'];

  for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {
    var key = _a[_i];

    if (OPERATION_FIELDS.indexOf(key) < 0) {
      throw  true ? new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* InvariantError */ "a"](2) : undefined;
    }
  }

  return operation;
}

var LinkError = function (_super) {
  Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __extends */ "d"])(LinkError, _super);

  function LinkError(message, link) {
    var _this = _super.call(this, message) || this;

    _this.link = link;
    return _this;
  }

  return LinkError;
}(Error);

function isTerminating(link) {
  return link.request.length <= 1;
}

function toPromise(observable) {
  var completed = false;
  return new Promise(function (resolve, reject) {
    observable.subscribe({
      next: function next(data) {
        if (completed) {
           true || false;
        } else {
          completed = true;
          resolve(data);
        }
      },
      error: reject
    });
  });
}

var makePromise = toPromise;

function fromPromise(promise) {
  return new zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](function (observer) {
    promise.then(function (value) {
      observer.next(value);
      observer.complete();
    }).catch(observer.error.bind(observer));
  });
}

function fromError(errorValue) {
  return new zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](function (observer) {
    observer.error(errorValue);
  });
}

function transformOperation(operation) {
  var transformedOperation = {
    variables: operation.variables || {},
    extensions: operation.extensions || {},
    operationName: operation.operationName,
    query: operation.query
  };

  if (!transformedOperation.operationName) {
    transformedOperation.operationName = typeof transformedOperation.query !== 'string' ? Object(apollo_utilities__WEBPACK_IMPORTED_MODULE_3__[/* getOperationName */ "n"])(transformedOperation.query) : '';
  }

  return transformedOperation;
}

function createOperation(starting, operation) {
  var context = Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])({}, starting);

  var setContext = function setContext(next) {
    if (typeof next === 'function') {
      context = Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])({}, context, next(context));
    } else {
      context = Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])({}, context, next);
    }
  };

  var getContext = function getContext() {
    return Object(tslib__WEBPACK_IMPORTED_MODULE_2__[/* __assign */ "a"])({}, context);
  };

  Object.defineProperty(operation, 'setContext', {
    enumerable: false,
    value: setContext
  });
  Object.defineProperty(operation, 'getContext', {
    enumerable: false,
    value: getContext
  });
  Object.defineProperty(operation, 'toKey', {
    enumerable: false,
    value: function value() {
      return getKey(operation);
    }
  });
  return operation;
}

function getKey(operation) {
  var query = operation.query,
      variables = operation.variables,
      operationName = operation.operationName;
  return JSON.stringify([operationName, query, variables]);
}

function passthrough(op, forward) {
  return forward ? forward(op) : zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].of();
}

function toLink(handler) {
  return typeof handler === 'function' ? new ApolloLink(handler) : handler;
}

function empty() {
  return new ApolloLink(function () {
    return zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].of();
  });
}

function from(links) {
  if (links.length === 0) return empty();
  return links.map(toLink).reduce(function (x, y) {
    return x.concat(y);
  });
}

function split(test, left, right) {
  var leftLink = toLink(left);
  var rightLink = toLink(right || new ApolloLink(passthrough));

  if (isTerminating(leftLink) && isTerminating(rightLink)) {
    return new ApolloLink(function (operation) {
      return test(operation) ? leftLink.request(operation) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].of() : rightLink.request(operation) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].of();
    });
  } else {
    return new ApolloLink(function (operation, forward) {
      return test(operation) ? leftLink.request(operation, forward) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].of() : rightLink.request(operation, forward) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].of();
    });
  }
}

var concat = function concat(first, second) {
  var firstLink = toLink(first);

  if (isTerminating(firstLink)) {
     true || false;
    return firstLink;
  }

  var nextLink = toLink(second);

  if (isTerminating(nextLink)) {
    return new ApolloLink(function (operation) {
      return firstLink.request(operation, function (op) {
        return nextLink.request(op) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].of();
      }) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].of();
    });
  } else {
    return new ApolloLink(function (operation, forward) {
      return firstLink.request(operation, function (op) {
        return nextLink.request(op, forward) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].of();
      }) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].of();
    });
  }
};

var ApolloLink = function () {
  function ApolloLink(request) {
    if (request) this.request = request;
  }

  ApolloLink.prototype.split = function (test, left, right) {
    return this.concat(split(test, left, right || new ApolloLink(passthrough)));
  };

  ApolloLink.prototype.concat = function (next) {
    return concat(this, next);
  };

  ApolloLink.prototype.request = function (operation, forward) {
    throw  true ? new ts_invariant__WEBPACK_IMPORTED_MODULE_1__[/* InvariantError */ "a"](1) : undefined;
  };

  ApolloLink.empty = empty;
  ApolloLink.from = from;
  ApolloLink.split = split;
  ApolloLink.execute = execute;
  return ApolloLink;
}();

function execute(link, operation) {
  return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || zen_observable_ts__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].of();
}



/***/ }),
/* 50 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVariableValues", function() { return getVariableValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArgumentValues", function() { return getArgumentValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDirectiveValues", function() { return getDirectiveValues; });
/* harmony import */ var _polyfills_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var _jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _jsutils_printPathArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(57);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2);
/* harmony import */ var _language_printer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(16);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);
/* harmony import */ var _utilities_typeFromAST__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(19);
/* harmony import */ var _utilities_valueFromAST__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(45);
/* harmony import */ var _utilities_coerceInputValue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(52);












/**
 * Prepares an object map of variableValues of the correct type based on the
 * provided variable definitions and arbitrary input. If the input cannot be
 * parsed to match the variable definitions, a GraphQLError will be thrown.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */
function getVariableValues(schema, varDefNodes, inputs, options) {
  var maxErrors = options && options.maxErrors;
  var errors = [];

  try {
    var coerced = coerceVariableValues(schema, varDefNodes, inputs, function (error) {
      if (maxErrors != null && errors.length >= maxErrors) {
        throw new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_4__[/* GraphQLError */ "a"]('Too many errors processing variables, error limit reached. Execution aborted.');
      }

      errors.push(error);
    });

    if (errors.length === 0) {
      return {
        coerced: coerced
      };
    }
  } catch (error) {
    errors.push(error);
  }

  return {
    errors: errors
  };
}

function coerceVariableValues(schema, varDefNodes, inputs, onError) {
  var coercedValues = {};

  var _loop = function _loop(_i2) {
    var varDefNode = varDefNodes[_i2];
    var varName = varDefNode.variable.name.value;
    var varType = Object(_utilities_typeFromAST__WEBPACK_IMPORTED_MODULE_8__[/* typeFromAST */ "a"])(schema, varDefNode.type);

    if (!Object(_type_definition__WEBPACK_IMPORTED_MODULE_7__[/* isInputType */ "G"])(varType)) {
      // Must use input types for variables. This should be caught during
      // validation, however is checked again here for safety.
      var varTypeStr = Object(_language_printer__WEBPACK_IMPORTED_MODULE_6__[/* print */ "a"])(varDefNode.type);
      onError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_4__[/* GraphQLError */ "a"]("Variable \"$".concat(varName, "\" expected value of type \"").concat(varTypeStr, "\" which cannot be used as an input type."), varDefNode.type));
      return "continue";
    }

    if (!hasOwnProperty(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = Object(_utilities_valueFromAST__WEBPACK_IMPORTED_MODULE_9__[/* valueFromAST */ "a"])(varDefNode.defaultValue, varType);
      } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_7__[/* isNonNullType */ "L"])(varType)) {
        var _varTypeStr = Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(varType);

        onError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_4__[/* GraphQLError */ "a"]("Variable \"$".concat(varName, "\" of required type \"").concat(_varTypeStr, "\" was not provided."), varDefNode));
      }

      return "continue";
    }

    var value = inputs[varName];

    if (value === null && Object(_type_definition__WEBPACK_IMPORTED_MODULE_7__[/* isNonNullType */ "L"])(varType)) {
      var _varTypeStr2 = Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(varType);

      onError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_4__[/* GraphQLError */ "a"]("Variable \"$".concat(varName, "\" of non-null type \"").concat(_varTypeStr2, "\" must not be null."), varDefNode));
      return "continue";
    }

    coercedValues[varName] = Object(_utilities_coerceInputValue__WEBPACK_IMPORTED_MODULE_10__[/* coerceInputValue */ "a"])(value, varType, function (path, invalidValue, error) {
      var prefix = "Variable \"$".concat(varName, "\" got invalid value ") + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(invalidValue);

      if (path.length > 0) {
        prefix += " at \"".concat(varName).concat(Object(_jsutils_printPathArray__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(path), "\"");
      }

      onError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_4__[/* GraphQLError */ "a"](prefix + '; ' + error.message, varDefNode, undefined, undefined, undefined, error.originalError));
    });
  };

  for (var _i2 = 0; _i2 < varDefNodes.length; _i2++) {
    var _ret = _loop(_i2);

    if (_ret === "continue") continue;
  }

  return coercedValues;
}
/**
 * Prepares an object map of argument values given a list of argument
 * definitions and list of argument AST nodes.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */


function getArgumentValues(def, node, variableValues) {
  var coercedValues = {};
  var argNodeMap = Object(_jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(node.arguments || [], function (arg) {
    return arg.name.value;
  });

  for (var _i4 = 0, _def$args2 = def.args; _i4 < _def$args2.length; _i4++) {
    var argDef = _def$args2[_i4];
    var name = argDef.name;
    var argType = argDef.type;
    var argumentNode = argNodeMap[name];

    if (!argumentNode) {
      if (argDef.defaultValue !== undefined) {
        coercedValues[name] = argDef.defaultValue;
      } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_7__[/* isNonNullType */ "L"])(argType)) {
        throw new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_4__[/* GraphQLError */ "a"]("Argument \"".concat(name, "\" of required type \"").concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(argType), "\" ") + 'was not provided.', node);
      }

      continue;
    }

    var valueNode = argumentNode.value;
    var isNull = valueNode.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_5__[/* Kind */ "a"].NULL;

    if (valueNode.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_5__[/* Kind */ "a"].VARIABLE) {
      var variableName = valueNode.name.value;

      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== undefined) {
          coercedValues[name] = argDef.defaultValue;
        } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_7__[/* isNonNullType */ "L"])(argType)) {
          throw new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_4__[/* GraphQLError */ "a"]("Argument \"".concat(name, "\" of required type \"").concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(argType), "\" ") + "was provided the variable \"$".concat(variableName, "\" which was not provided a runtime value."), valueNode);
        }

        continue;
      }

      isNull = variableValues[variableName] == null;
    }

    if (isNull && Object(_type_definition__WEBPACK_IMPORTED_MODULE_7__[/* isNonNullType */ "L"])(argType)) {
      throw new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_4__[/* GraphQLError */ "a"]("Argument \"".concat(name, "\" of non-null type \"").concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(argType), "\" ") + 'must not be null.', valueNode);
    }

    var coercedValue = Object(_utilities_valueFromAST__WEBPACK_IMPORTED_MODULE_9__[/* valueFromAST */ "a"])(valueNode, argType, variableValues);

    if (coercedValue === undefined) {
      // Note: ValuesOfCorrectType validation should catch this before
      // execution. This is a runtime check to ensure execution does not
      // continue with an invalid argument value.
      throw new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_4__[/* GraphQLError */ "a"]("Argument \"".concat(name, "\" has invalid value ").concat(Object(_language_printer__WEBPACK_IMPORTED_MODULE_6__[/* print */ "a"])(valueNode), "."), valueNode);
    }

    coercedValues[name] = coercedValue;
  }

  return coercedValues;
}
/**
 * Prepares an object map of argument values given a directive definition
 * and a AST node which may contain directives. Optionally also accepts a map
 * of variable values.
 *
 * If the directive does not exist on the node, returns undefined.
 *
 * Note: The returned value is a plain Object with a prototype, since it is
 * exposed to user code. Care should be taken to not pull values from the
 * Object prototype.
 */

function getDirectiveValues(directiveDef, node, variableValues) {
  var directiveNode = node.directives && Object(_polyfills_find__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(node.directives, function (directive) {
    return directive.name.value === directiveDef.name;
  });

  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}


/***/ }),
/* 51 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return buildASTSchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ASTDefinitionBuilder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getDescription; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return buildSchema; });
/* harmony import */ var _polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _jsutils_invariant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17);
/* harmony import */ var _jsutils_devAssert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);
/* harmony import */ var _jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(20);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2);
/* harmony import */ var _language_tokenKind__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5);
/* harmony import */ var _language_parser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(48);
/* harmony import */ var _language_predicates__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(38);
/* harmony import */ var _language_blockString__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(41);
/* harmony import */ var _validation_validate__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(56);
/* harmony import */ var _execution_values__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(50);
/* harmony import */ var _type_scalars__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(13);
/* harmony import */ var _type_introspection__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(12);
/* harmony import */ var _type_schema__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(36);
/* harmony import */ var _type_directives__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(15);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(0);
/* harmony import */ var _valueFromAST__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(45);




















/**
 * This takes the ast of a schema document produced by the parse function in
 * src/language/parser.js.
 *
 * If no schema definition is provided, then it will look for types named Query
 * and Mutation.
 *
 * Given that AST it constructs a GraphQLSchema. The resulting schema
 * has no resolve methods, so execution will use default resolvers.
 *
 * Accepts options as a second argument:
 *
 *    - commentDescriptions:
 *        Provide true to use preceding comments as the description.
 *
 */
function buildASTSchema(documentAST, options) {
  documentAST && documentAST.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_6__[/* Kind */ "a"].DOCUMENT || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(0, 'Must provide valid Document AST');

  if (!options || !(options.assumeValid || options.assumeValidSDL)) {
    Object(_validation_validate__WEBPACK_IMPORTED_MODULE_11__[/* assertValidSDL */ "a"])(documentAST);
  }

  var schemaDef;
  var typeDefs = [];
  var directiveDefs = [];

  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
    var def = _documentAST$definiti2[_i2];

    if (def.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_6__[/* Kind */ "a"].SCHEMA_DEFINITION) {
      schemaDef = def;
    } else if (Object(_language_predicates__WEBPACK_IMPORTED_MODULE_9__[/* isTypeDefinitionNode */ "d"])(def)) {
      typeDefs.push(def);
    } else if (def.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_6__[/* Kind */ "a"].DIRECTIVE_DEFINITION) {
      directiveDefs.push(def);
    }
  }

  var astBuilder = new ASTDefinitionBuilder(options, function (typeName) {
    var type = typeMap[typeName];

    if (type === undefined) {
      throw new Error("Type \"".concat(typeName, "\" not found in document."));
    }

    return type;
  });
  var typeMap = keyByNameNode(typeDefs, function (node) {
    return astBuilder.buildType(node);
  });
  var operationTypes = schemaDef ? getOperationTypes(schemaDef) : {
    query: 'Query',
    mutation: 'Mutation',
    subscription: 'Subscription'
  };
  var directives = directiveDefs.map(function (def) {
    return astBuilder.buildDirective(def);
  }); // If specified directives were not explicitly declared, add them.

  if (!directives.some(function (directive) {
    return directive.name === 'skip';
  })) {
    directives.push(_type_directives__WEBPACK_IMPORTED_MODULE_16__[/* GraphQLSkipDirective */ "e"]);
  }

  if (!directives.some(function (directive) {
    return directive.name === 'include';
  })) {
    directives.push(_type_directives__WEBPACK_IMPORTED_MODULE_16__[/* GraphQLIncludeDirective */ "d"]);
  }

  if (!directives.some(function (directive) {
    return directive.name === 'deprecated';
  })) {
    directives.push(_type_directives__WEBPACK_IMPORTED_MODULE_16__[/* GraphQLDeprecatedDirective */ "b"]);
  }

  return new _type_schema__WEBPACK_IMPORTED_MODULE_15__[/* GraphQLSchema */ "a"]({
    // Note: While this could make early assertions to get the correctly
    // typed values below, that would throw immediately while type system
    // validation with validateSchema() will produce more actionable results.
    query: operationTypes.query ? typeMap[operationTypes.query] : null,
    mutation: operationTypes.mutation ? typeMap[operationTypes.mutation] : null,
    subscription: operationTypes.subscription ? typeMap[operationTypes.subscription] : null,
    types: Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(typeMap),
    directives: directives,
    astNode: schemaDef,
    assumeValid: options && options.assumeValid,
    allowedLegacyNames: options && options.allowedLegacyNames
  });

  function getOperationTypes(schema) {
    var opTypes = {};

    for (var _i4 = 0, _schema$operationType2 = schema.operationTypes; _i4 < _schema$operationType2.length; _i4++) {
      var operationType = _schema$operationType2[_i4];
      opTypes[operationType.operation] = operationType.type.name.value;
    }

    return opTypes;
  }
}
var stdTypeMap = Object(_jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_type_scalars__WEBPACK_IMPORTED_MODULE_13__[/* specifiedScalarTypes */ "g"].concat(_type_introspection__WEBPACK_IMPORTED_MODULE_14__[/* introspectionTypes */ "m"]), function (type) {
  return type.name;
});
var ASTDefinitionBuilder =
/*#__PURE__*/
function () {
  function ASTDefinitionBuilder(options, resolveType) {
    this._options = options;
    this._resolveType = resolveType;
  }

  var _proto = ASTDefinitionBuilder.prototype;

  _proto.getNamedType = function getNamedType(node) {
    var name = node.name.value;
    return stdTypeMap[name] || this._resolveType(name);
  };

  _proto.getWrappedType = function getWrappedType(node) {
    if (node.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_6__[/* Kind */ "a"].LIST_TYPE) {
      return new _type_definition__WEBPACK_IMPORTED_MODULE_17__[/* GraphQLList */ "d"](this.getWrappedType(node.type));
    }

    if (node.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_6__[/* Kind */ "a"].NON_NULL_TYPE) {
      return new _type_definition__WEBPACK_IMPORTED_MODULE_17__[/* GraphQLNonNull */ "e"](this.getWrappedType(node.type));
    }

    return this.getNamedType(node);
  };

  _proto.buildDirective = function buildDirective(directive) {
    var _this = this;

    var locations = directive.locations.map(function (_ref) {
      var value = _ref.value;
      return value;
    });
    return new _type_directives__WEBPACK_IMPORTED_MODULE_16__[/* GraphQLDirective */ "c"]({
      name: directive.name.value,
      description: getDescription(directive, this._options),
      locations: locations,
      isRepeatable: directive.repeatable,
      args: keyByNameNode(directive.arguments || [], function (arg) {
        return _this.buildArg(arg);
      }),
      astNode: directive
    });
  };

  _proto.buildField = function buildField(field) {
    var _this2 = this;

    return {
      // Note: While this could make assertions to get the correctly typed
      // value, that would throw immediately while type system validation
      // with validateSchema() will produce more actionable results.
      type: this.getWrappedType(field.type),
      description: getDescription(field, this._options),
      args: keyByNameNode(field.arguments || [], function (arg) {
        return _this2.buildArg(arg);
      }),
      deprecationReason: getDeprecationReason(field),
      astNode: field
    };
  };

  _proto.buildArg = function buildArg(value) {
    // Note: While this could make assertions to get the correctly typed
    // value, that would throw immediately while type system validation
    // with validateSchema() will produce more actionable results.
    var type = this.getWrappedType(value.type);
    return {
      type: type,
      description: getDescription(value, this._options),
      defaultValue: Object(_valueFromAST__WEBPACK_IMPORTED_MODULE_18__[/* valueFromAST */ "a"])(value.defaultValue, type),
      astNode: value
    };
  };

  _proto.buildInputField = function buildInputField(value) {
    // Note: While this could make assertions to get the correctly typed
    // value, that would throw immediately while type system validation
    // with validateSchema() will produce more actionable results.
    var type = this.getWrappedType(value.type);
    return {
      type: type,
      description: getDescription(value, this._options),
      defaultValue: Object(_valueFromAST__WEBPACK_IMPORTED_MODULE_18__[/* valueFromAST */ "a"])(value.defaultValue, type),
      astNode: value
    };
  };

  _proto.buildEnumValue = function buildEnumValue(value) {
    return {
      description: getDescription(value, this._options),
      deprecationReason: getDeprecationReason(value),
      astNode: value
    };
  };

  _proto.buildType = function buildType(astNode) {
    var name = astNode.name.value;

    if (stdTypeMap[name]) {
      return stdTypeMap[name];
    }

    switch (astNode.kind) {
      case _language_kinds__WEBPACK_IMPORTED_MODULE_6__[/* Kind */ "a"].OBJECT_TYPE_DEFINITION:
        return this._makeTypeDef(astNode);

      case _language_kinds__WEBPACK_IMPORTED_MODULE_6__[/* Kind */ "a"].INTERFACE_TYPE_DEFINITION:
        return this._makeInterfaceDef(astNode);

      case _language_kinds__WEBPACK_IMPORTED_MODULE_6__[/* Kind */ "a"].ENUM_TYPE_DEFINITION:
        return this._makeEnumDef(astNode);

      case _language_kinds__WEBPACK_IMPORTED_MODULE_6__[/* Kind */ "a"].UNION_TYPE_DEFINITION:
        return this._makeUnionDef(astNode);

      case _language_kinds__WEBPACK_IMPORTED_MODULE_6__[/* Kind */ "a"].SCALAR_TYPE_DEFINITION:
        return this._makeScalarDef(astNode);

      case _language_kinds__WEBPACK_IMPORTED_MODULE_6__[/* Kind */ "a"].INPUT_OBJECT_TYPE_DEFINITION:
        return this._makeInputObjectDef(astNode);
    } // Not reachable. All possible type definition nodes have been considered.


    /* istanbul ignore next */
    Object(_jsutils_invariant__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(false, 'Unexpected type definition node: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(astNode));
  };

  _proto._makeTypeDef = function _makeTypeDef(astNode) {
    var _this3 = this;

    var interfaceNodes = astNode.interfaces;
    var fieldNodes = astNode.fields; // Note: While this could make assertions to get the correctly typed
    // values below, that would throw immediately while type system
    // validation with validateSchema() will produce more actionable results.

    var interfaces = interfaceNodes && interfaceNodes.length > 0 ? function () {
      return interfaceNodes.map(function (ref) {
        return _this3.getNamedType(ref);
      });
    } : [];
    var fields = fieldNodes && fieldNodes.length > 0 ? function () {
      return keyByNameNode(fieldNodes, function (field) {
        return _this3.buildField(field);
      });
    } : Object.create(null);
    return new _type_definition__WEBPACK_IMPORTED_MODULE_17__[/* GraphQLObjectType */ "f"]({
      name: astNode.name.value,
      description: getDescription(astNode, this._options),
      interfaces: interfaces,
      fields: fields,
      astNode: astNode
    });
  };

  _proto._makeInterfaceDef = function _makeInterfaceDef(astNode) {
    var _this4 = this;

    var fieldNodes = astNode.fields;
    var fields = fieldNodes && fieldNodes.length > 0 ? function () {
      return keyByNameNode(fieldNodes, function (field) {
        return _this4.buildField(field);
      });
    } : Object.create(null);
    return new _type_definition__WEBPACK_IMPORTED_MODULE_17__[/* GraphQLInterfaceType */ "c"]({
      name: astNode.name.value,
      description: getDescription(astNode, this._options),
      fields: fields,
      astNode: astNode
    });
  };

  _proto._makeEnumDef = function _makeEnumDef(astNode) {
    var _this5 = this;

    var valueNodes = astNode.values || [];
    return new _type_definition__WEBPACK_IMPORTED_MODULE_17__[/* GraphQLEnumType */ "a"]({
      name: astNode.name.value,
      description: getDescription(astNode, this._options),
      values: keyByNameNode(valueNodes, function (value) {
        return _this5.buildEnumValue(value);
      }),
      astNode: astNode
    });
  };

  _proto._makeUnionDef = function _makeUnionDef(astNode) {
    var _this6 = this;

    var typeNodes = astNode.types; // Note: While this could make assertions to get the correctly typed
    // values below, that would throw immediately while type system
    // validation with validateSchema() will produce more actionable results.

    var types = typeNodes && typeNodes.length > 0 ? function () {
      return typeNodes.map(function (ref) {
        return _this6.getNamedType(ref);
      });
    } : [];
    return new _type_definition__WEBPACK_IMPORTED_MODULE_17__[/* GraphQLUnionType */ "h"]({
      name: astNode.name.value,
      description: getDescription(astNode, this._options),
      types: types,
      astNode: astNode
    });
  };

  _proto._makeScalarDef = function _makeScalarDef(astNode) {
    return new _type_definition__WEBPACK_IMPORTED_MODULE_17__[/* GraphQLScalarType */ "g"]({
      name: astNode.name.value,
      description: getDescription(astNode, this._options),
      astNode: astNode
    });
  };

  _proto._makeInputObjectDef = function _makeInputObjectDef(def) {
    var _this7 = this;

    var fields = def.fields;
    return new _type_definition__WEBPACK_IMPORTED_MODULE_17__[/* GraphQLInputObjectType */ "b"]({
      name: def.name.value,
      description: getDescription(def, this._options),
      fields: fields ? function () {
        return keyByNameNode(fields, function (field) {
          return _this7.buildInputField(field);
        });
      } : Object.create(null),
      astNode: def
    });
  };

  return ASTDefinitionBuilder;
}();

function keyByNameNode(list, valFn) {
  return Object(_jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(list, function (_ref2) {
    var name = _ref2.name;
    return name.value;
  }, valFn);
}
/**
 * Given a field or enum value node, returns the string value for the
 * deprecation reason.
 */


function getDeprecationReason(node) {
  var deprecated = Object(_execution_values__WEBPACK_IMPORTED_MODULE_12__["getDirectiveValues"])(_type_directives__WEBPACK_IMPORTED_MODULE_16__[/* GraphQLDeprecatedDirective */ "b"], node);
  return deprecated && deprecated.reason;
}
/**
 * Given an ast node, returns its string description.
 * @deprecated: provided to ease adoption and will be removed in v16.
 *
 * Accepts options as a second argument:
 *
 *    - commentDescriptions:
 *        Provide true to use preceding comments as the description.
 *
 */


function getDescription(node, options) {
  if (node.description) {
    return node.description.value;
  }

  if (options && options.commentDescriptions) {
    var rawValue = getLeadingCommentBlock(node);

    if (rawValue !== undefined) {
      return Object(_language_blockString__WEBPACK_IMPORTED_MODULE_10__[/* dedentBlockStringValue */ "a"])('\n' + rawValue);
    }
  }
}

function getLeadingCommentBlock(node) {
  var loc = node.loc;

  if (!loc) {
    return;
  }

  var comments = [];
  var token = loc.startToken.prev;

  while (token && token.kind === _language_tokenKind__WEBPACK_IMPORTED_MODULE_7__[/* TokenKind */ "a"].COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {
    var value = String(token.value);
    comments.push(value);
    token = token.prev;
  }

  return comments.reverse().join('\n');
}
/**
 * A helper function to build a GraphQLSchema directly from a source
 * document.
 */


function buildSchema(source, options) {
  return buildASTSchema(Object(_language_parser__WEBPACK_IMPORTED_MODULE_8__["parse"])(source, options), options);
}


/***/ }),
/* 52 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return coerceInputValue; });
/* harmony import */ var iterall__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var _polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _jsutils_invariant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17);
/* harmony import */ var _jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26);
/* harmony import */ var _jsutils_isObjectLike__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(18);
/* harmony import */ var _jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(29);
/* harmony import */ var _jsutils_printPathArray__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(57);
/* harmony import */ var _jsutils_Path__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(21);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(4);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(0);












/**
 * Coerces a JavaScript value given a GraphQL Input Type.
 */
function coerceInputValue(inputValue, type) {
  var onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOnError;
  return coerceInputValueImpl(inputValue, type, onError);
}

function defaultOnError(path, invalidValue, error) {
  var errorPrefix = 'Invalid value ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(invalidValue);

  if (path.length > 0) {
    errorPrefix += " at \"value".concat(Object(_jsutils_printPathArray__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"])(path), "\": ");
  }

  error.message = errorPrefix + ': ' + error.message;
  throw error;
}

function coerceInputValueImpl(inputValue, type, onError, path) {
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_10__[/* isNonNullType */ "L"])(type)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type.ofType, onError, path);
    }

    onError(Object(_jsutils_Path__WEBPACK_IMPORTED_MODULE_8__[/* pathToArray */ "b"])(path), inputValue, new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_9__[/* GraphQLError */ "a"]("Expected non-nullable type ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(type), " not to be null.")));
    return;
  }

  if (inputValue == null) {
    // Explicitly return the value null.
    return null;
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_10__[/* isListType */ "J"])(type)) {
    var itemType = type.ofType;

    if (Object(iterall__WEBPACK_IMPORTED_MODULE_0__["isCollection"])(inputValue)) {
      var coercedValue = [];
      Object(iterall__WEBPACK_IMPORTED_MODULE_0__["forEach"])(inputValue, function (itemValue, index) {
        coercedValue.push(coerceInputValueImpl(itemValue, itemType, onError, Object(_jsutils_Path__WEBPACK_IMPORTED_MODULE_8__[/* addPath */ "a"])(path, index)));
      });
      return coercedValue;
    } // Lists accept a non-list value as a list of one.


    return [coerceInputValueImpl(inputValue, itemType, onError, path)];
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_10__[/* isInputObjectType */ "F"])(type)) {
    if (!Object(_jsutils_isObjectLike__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(inputValue)) {
      onError(Object(_jsutils_Path__WEBPACK_IMPORTED_MODULE_8__[/* pathToArray */ "b"])(path), inputValue, new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_9__[/* GraphQLError */ "a"]("Expected type ".concat(type.name, " to be an object.")));
      return;
    }

    var _coercedValue = {};
    var fieldDefs = type.getFields();

    for (var _i2 = 0, _objectValues2 = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(fieldDefs); _i2 < _objectValues2.length; _i2++) {
      var field = _objectValues2[_i2];
      var fieldValue = inputValue[field.name];

      if (fieldValue === undefined) {
        if (field.defaultValue !== undefined) {
          _coercedValue[field.name] = field.defaultValue;
        } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_10__[/* isNonNullType */ "L"])(field.type)) {
          var typeStr = Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(field.type);
          onError(Object(_jsutils_Path__WEBPACK_IMPORTED_MODULE_8__[/* pathToArray */ "b"])(path), inputValue, new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_9__[/* GraphQLError */ "a"]("Field ".concat(field.name, " of required type ").concat(typeStr, " was not provided.")));
        }

        continue;
      }

      _coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, Object(_jsutils_Path__WEBPACK_IMPORTED_MODULE_8__[/* addPath */ "a"])(path, field.name));
    } // Ensure every provided field is defined.


    for (var _i4 = 0, _Object$keys2 = Object.keys(inputValue); _i4 < _Object$keys2.length; _i4++) {
      var fieldName = _Object$keys2[_i4];

      if (!fieldDefs[fieldName]) {
        var suggestions = Object(_jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(fieldName, Object.keys(type.getFields()));
        onError(Object(_jsutils_Path__WEBPACK_IMPORTED_MODULE_8__[/* pathToArray */ "b"])(path), inputValue, new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_9__[/* GraphQLError */ "a"]("Field \"".concat(fieldName, "\" is not defined by type ").concat(type.name, ".") + Object(_jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(suggestions)));
      }
    }

    return _coercedValue;
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_10__[/* isScalarType */ "R"])(type)) {
    var parseResult; // Scalars determine if a input value is valid via parseValue(), which can
    // throw to indicate failure. If it throws, maintain a reference to
    // the original error.

    try {
      parseResult = type.parseValue(inputValue);
    } catch (error) {
      onError(Object(_jsutils_Path__WEBPACK_IMPORTED_MODULE_8__[/* pathToArray */ "b"])(path), inputValue, new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_9__[/* GraphQLError */ "a"]("Expected type ".concat(type.name, ". ") + error.message, undefined, undefined, undefined, undefined, error));
      return;
    }

    if (parseResult === undefined) {
      onError(Object(_jsutils_Path__WEBPACK_IMPORTED_MODULE_8__[/* pathToArray */ "b"])(path), inputValue, new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_9__[/* GraphQLError */ "a"]("Expected type ".concat(type.name, ".")));
    }

    return parseResult;
  }

  /* istanbul ignore else */
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_10__[/* isEnumType */ "E"])(type)) {
    if (typeof inputValue === 'string') {
      var enumValue = type.getValue(inputValue);

      if (enumValue) {
        return enumValue.value;
      }
    }

    var _suggestions = Object(_jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(String(inputValue), type.getValues().map(function (enumValue) {
      return enumValue.name;
    }));

    onError(Object(_jsutils_Path__WEBPACK_IMPORTED_MODULE_8__[/* pathToArray */ "b"])(path), inputValue, new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_9__[/* GraphQLError */ "a"]("Expected type ".concat(type.name, ".") + Object(_jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(_suggestions)));
    return;
  } // Not reachable. All possible input types have been considered.


  /* istanbul ignore next */
  Object(_jsutils_invariant__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(false, 'Unexpected input type: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(type));
}


/***/ }),
/* 53 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getOperationRootType; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);


/**
 * Extracts the root type of the operation from the schema.
 */
function getOperationRootType(schema, operation) {
  if (operation.operation === 'query') {
    var queryType = schema.getQueryType();

    if (!queryType) {
      throw new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"]('Schema does not define the required query root type.', operation);
    }

    return queryType;
  }

  if (operation.operation === 'mutation') {
    var mutationType = schema.getMutationType();

    if (!mutationType) {
      throw new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"]('Schema is not configured for mutations.', operation);
    }

    return mutationType;
  }

  if (operation.operation === 'subscription') {
    var subscriptionType = schema.getSubscriptionType();

    if (!subscriptionType) {
      throw new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"]('Schema is not configured for subscriptions.', operation);
    }

    return subscriptionType;
  }

  throw new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"]('Can only have query, mutation and subscription operations.', operation);
}


/***/ }),
/* 54 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return locatedError; });
/* harmony import */ var _GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

/**
 * Given an arbitrary Error, presumably thrown while attempting to execute a
 * GraphQL operation, produce a new GraphQLError aware of the location in the
 * document responsible for the original Error.
 */

function locatedError(originalError, nodes, path) {
  // Note: this uses a brand-check to support GraphQL errors originating from
  // other contexts.
  if (originalError && Array.isArray(originalError.path)) {
    return originalError;
  }

  return new _GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](originalError && originalError.message, originalError && originalError.nodes || nodes, originalError && originalError.source, originalError && originalError.positions, path, originalError);
}


/***/ }),
/* 55 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return validateSchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return assertValidSchema; });
/* harmony import */ var _polyfills_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var _polyfills_flatMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);
/* harmony import */ var _polyfills_objectValues__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _polyfills_objectEntries__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(37);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4);
/* harmony import */ var _utilities_assertValidName__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(63);
/* harmony import */ var _utilities_typeComparators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(35);
/* harmony import */ var _directives__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(15);
/* harmony import */ var _introspection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(12);
/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(36);
/* harmony import */ var _definition__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(0);












/**
 * Implements the "Type Validation" sub-sections of the specification's
 * "Type System" section.
 *
 * Validation runs synchronously, returning an array of encountered errors, or
 * an empty array if no errors were encountered and the Schema is valid.
 */

function validateSchema(schema) {
  // First check to ensure the provided value is in fact a GraphQLSchema.
  Object(_schema__WEBPACK_IMPORTED_MODULE_10__[/* assertSchema */ "b"])(schema); // If this Schema has already been validated, return the previous results.

  if (schema.__validationErrors) {
    return schema.__validationErrors;
  } // Validate the schema, producing a list of errors.


  var context = new SchemaValidationContext(schema);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context); // Persist the results of validation before returning to ensure validation
  // does not run multiple times for this schema.

  var errors = context.getErrors();
  schema.__validationErrors = errors;
  return errors;
}
/**
 * Utility function which asserts a schema is valid by throwing an error if
 * it is invalid.
 */

function assertValidSchema(schema) {
  var errors = validateSchema(schema);

  if (errors.length !== 0) {
    throw new Error(errors.map(function (error) {
      return error.message;
    }).join('\n\n'));
  }
}

var SchemaValidationContext =
/*#__PURE__*/
function () {
  function SchemaValidationContext(schema) {
    this._errors = [];
    this.schema = schema;
  }

  var _proto = SchemaValidationContext.prototype;

  _proto.reportError = function reportError(message, nodes) {
    var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;

    this.addError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_5__[/* GraphQLError */ "a"](message, _nodes));
  };

  _proto.addError = function addError(error) {
    this._errors.push(error);
  };

  _proto.getErrors = function getErrors() {
    return this._errors;
  };

  return SchemaValidationContext;
}();

function validateRootTypes(context) {
  var schema = context.schema;
  var queryType = schema.getQueryType();

  if (!queryType) {
    context.reportError('Query root type must be provided.', schema.astNode);
  } else if (!Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isObjectType */ "N"])(queryType)) {
    context.reportError("Query root type must be Object type, it cannot be ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(queryType), "."), getOperationTypeNode(schema, queryType, 'query'));
  }

  var mutationType = schema.getMutationType();

  if (mutationType && !Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isObjectType */ "N"])(mutationType)) {
    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + "".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(mutationType), "."), getOperationTypeNode(schema, mutationType, 'mutation'));
  }

  var subscriptionType = schema.getSubscriptionType();

  if (subscriptionType && !Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isObjectType */ "N"])(subscriptionType)) {
    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + "".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(subscriptionType), "."), getOperationTypeNode(schema, subscriptionType, 'subscription'));
  }
}

function getOperationTypeNode(schema, type, operation) {
  var operationNodes = getAllSubNodes(schema, function (node) {
    return node.operationTypes;
  });

  for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {
    var node = operationNodes[_i2];

    if (node.operation === operation) {
      return node.type;
    }
  }

  return type.astNode;
}

function validateDirectives(context) {
  for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {
    var directive = _context$schema$getDi2[_i4];

    // Ensure all directives are in fact GraphQL directives.
    if (!Object(_directives__WEBPACK_IMPORTED_MODULE_8__[/* isDirective */ "g"])(directive)) {
      context.reportError("Expected directive but got: ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(directive), "."), directive && directive.astNode);
      continue;
    } // Ensure they are named correctly.


    validateName(context, directive); // TODO: Ensure proper locations.
    // Ensure the arguments are valid.

    var argNames = Object.create(null);

    var _loop = function _loop(_i6, _directive$args2) {
      var arg = _directive$args2[_i6];
      var argName = arg.name; // Ensure they are named correctly.

      validateName(context, arg); // Ensure they are unique per directive.

      if (argNames[argName]) {
        context.reportError("Argument @".concat(directive.name, "(").concat(argName, ":) can only be defined once."), directive.astNode && directive.args.filter(function (_ref) {
          var name = _ref.name;
          return name === argName;
        }).map(function (_ref2) {
          var astNode = _ref2.astNode;
          return astNode;
        }));
        return "continue";
      }

      argNames[argName] = true; // Ensure the type is an input type.

      if (!Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isInputType */ "G"])(arg.type)) {
        context.reportError("The type of @".concat(directive.name, "(").concat(argName, ":) must be Input Type ") + "but got: ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(arg.type), "."), arg.astNode);
      }
    };

    for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {
      var _ret = _loop(_i6, _directive$args2);

      if (_ret === "continue") continue;
    }
  }
}

function validateName(context, node) {
  // If a schema explicitly allows some legacy name which is no longer valid,
  // allow it to be assumed valid.
  if (context.schema.__allowedLegacyNames.indexOf(node.name) !== -1) {
    return;
  } // Ensure names are valid, however introspection types opt out.


  var error = Object(_utilities_assertValidName__WEBPACK_IMPORTED_MODULE_6__[/* isValidNameError */ "b"])(node.name, node.astNode || undefined);

  if (error) {
    context.addError(error);
  }
}

function validateTypes(context) {
  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  var typeMap = context.schema.getTypeMap();

  for (var _i8 = 0, _objectValues2 = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(typeMap); _i8 < _objectValues2.length; _i8++) {
    var type = _objectValues2[_i8];

    // Ensure all provided types are in fact GraphQL type.
    if (!Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isNamedType */ "K"])(type)) {
      context.reportError("Expected GraphQL named type but got: ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(type), "."), type && type.astNode);
      continue;
    } // Ensure it is named correctly (excluding introspection types).


    if (!Object(_introspection__WEBPACK_IMPORTED_MODULE_9__[/* isIntrospectionType */ "n"])(type)) {
      validateName(context, type);
    }

    if (Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isObjectType */ "N"])(type)) {
      // Ensure fields are valid
      validateFields(context, type); // Ensure objects implement the interfaces they claim to.

      validateObjectInterfaces(context, type);
    } else if (Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isInterfaceType */ "H"])(type)) {
      // Ensure fields are valid.
      validateFields(context, type);
    } else if (Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isUnionType */ "T"])(type)) {
      // Ensure Unions include valid member types.
      validateUnionMembers(context, type);
    } else if (Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isEnumType */ "E"])(type)) {
      // Ensure Enums have valid values.
      validateEnumValues(context, type);
    } else if (Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isInputObjectType */ "F"])(type)) {
      // Ensure Input Object fields are valid.
      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references

      validateInputObjectCircularRefs(type);
    }
  }
}

function validateFields(context, type) {
  var fields = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(type.getFields()); // Objects and Interfaces both must define one or more fields.

  if (fields.length === 0) {
    context.reportError("Type ".concat(type.name, " must define one or more fields."), getAllNodes(type));
  }

  for (var _i10 = 0; _i10 < fields.length; _i10++) {
    var field = fields[_i10];
    // Ensure they are named correctly.
    validateName(context, field); // Ensure the type is an output type

    if (!Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isOutputType */ "O"])(field.type)) {
      context.reportError("The type of ".concat(type.name, ".").concat(field.name, " must be Output Type ") + "but got: ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(field.type), "."), field.astNode && field.astNode.type);
    } // Ensure the arguments are valid


    var argNames = Object.create(null);

    var _loop2 = function _loop2(_i12, _field$args2) {
      var arg = _field$args2[_i12];
      var argName = arg.name; // Ensure they are named correctly.

      validateName(context, arg); // Ensure they are unique per field.

      if (argNames[argName]) {
        context.reportError("Field argument ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) can only be defined once."), field.args.filter(function (_ref3) {
          var name = _ref3.name;
          return name === argName;
        }).map(function (_ref4) {
          var astNode = _ref4.astNode;
          return astNode;
        }));
      }

      argNames[argName] = true; // Ensure the type is an input type

      if (!Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isInputType */ "G"])(arg.type)) {
        context.reportError("The type of ".concat(type.name, ".").concat(field.name, "(").concat(argName, ":) must be Input ") + "Type but got: ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(arg.type), "."), arg.astNode && arg.astNode.type);
      }
    };

    for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {
      _loop2(_i12, _field$args2);
    }
  }
}

function validateObjectInterfaces(context, object) {
  var implementedTypeNames = Object.create(null);

  for (var _i14 = 0, _object$getInterfaces2 = object.getInterfaces(); _i14 < _object$getInterfaces2.length; _i14++) {
    var iface = _object$getInterfaces2[_i14];

    if (!Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isInterfaceType */ "H"])(iface)) {
      context.reportError("Type ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(object), " must only implement Interface types, ") + "it cannot implement ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(iface), "."), getAllImplementsInterfaceNodes(object, iface));
      continue;
    }

    if (implementedTypeNames[iface.name]) {
      context.reportError("Type ".concat(object.name, " can only implement ").concat(iface.name, " once."), getAllImplementsInterfaceNodes(object, iface));
      continue;
    }

    implementedTypeNames[iface.name] = true;
    validateObjectImplementsInterface(context, object, iface);
  }
}

function validateObjectImplementsInterface(context, object, iface) {
  var objectFieldMap = object.getFields();
  var ifaceFieldMap = iface.getFields(); // Assert each interface field is implemented.

  for (var _i16 = 0, _objectEntries2 = Object(_polyfills_objectEntries__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(ifaceFieldMap); _i16 < _objectEntries2.length; _i16++) {
    var _ref6 = _objectEntries2[_i16];
    var fieldName = _ref6[0];
    var ifaceField = _ref6[1];
    var objectField = objectFieldMap[fieldName]; // Assert interface field exists on object.

    if (!objectField) {
      context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expected but ").concat(object.name, " does not provide it."), [ifaceField.astNode].concat(getAllNodes(object)));
      continue;
    } // Assert interface field type is satisfied by object field type, by being
    // a valid subtype. (covariant)


    if (!Object(_utilities_typeComparators__WEBPACK_IMPORTED_MODULE_7__[/* isTypeSubTypeOf */ "c"])(context.schema, objectField.type, ifaceField.type)) {
      context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expects type ") + "".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(ifaceField.type), " but ").concat(object.name, ".").concat(fieldName, " ") + "is type ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(objectField.type), "."), [ifaceField.astNode && ifaceField.astNode.type, objectField.astNode && objectField.astNode.type]);
    } // Assert each interface field arg is implemented.


    var _loop3 = function _loop3(_i18, _ifaceField$args2) {
      var ifaceArg = _ifaceField$args2[_i18];
      var argName = ifaceArg.name;
      var objectArg = Object(_polyfills_find__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(objectField.args, function (arg) {
        return arg.name === argName;
      }); // Assert interface field arg exists on object field.

      if (!objectArg) {
        context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) expected but ").concat(object.name, ".").concat(fieldName, " does not provide it."), [ifaceArg.astNode, objectField.astNode]);
        return "continue";
      } // Assert interface field arg type matches object field arg type.
      // (invariant)
      // TODO: change to contravariant?


      if (!Object(_utilities_typeComparators__WEBPACK_IMPORTED_MODULE_7__[/* isEqualType */ "b"])(ifaceArg.type, objectArg.type)) {
        context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "expects type ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(ifaceArg.type), " but ") + "".concat(object.name, ".").concat(fieldName, "(").concat(argName, ":) is type ") + "".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(objectArg.type), "."), [ifaceArg.astNode && ifaceArg.astNode.type, objectArg.astNode && objectArg.astNode.type]);
      } // TODO: validate default values?

    };

    for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {
      var _ret2 = _loop3(_i18, _ifaceField$args2);

      if (_ret2 === "continue") continue;
    } // Assert additional arguments must not be required.


    var _loop4 = function _loop4(_i20, _objectField$args2) {
      var objectArg = _objectField$args2[_i20];
      var argName = objectArg.name;
      var ifaceArg = Object(_polyfills_find__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(ifaceField.args, function (arg) {
        return arg.name === argName;
      });

      if (!ifaceArg && Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isRequiredArgument */ "P"])(objectArg)) {
        context.reportError("Object field ".concat(object.name, ".").concat(fieldName, " includes required argument ").concat(argName, " that is missing from the Interface field ").concat(iface.name, ".").concat(fieldName, "."), [objectArg.astNode, ifaceField.astNode]);
      }
    };

    for (var _i20 = 0, _objectField$args2 = objectField.args; _i20 < _objectField$args2.length; _i20++) {
      _loop4(_i20, _objectField$args2);
    }
  }
}

function validateUnionMembers(context, union) {
  var memberTypes = union.getTypes();

  if (memberTypes.length === 0) {
    context.reportError("Union type ".concat(union.name, " must define one or more member types."), getAllNodes(union));
  }

  var includedTypeNames = Object.create(null);

  for (var _i22 = 0; _i22 < memberTypes.length; _i22++) {
    var memberType = memberTypes[_i22];

    if (includedTypeNames[memberType.name]) {
      context.reportError("Union type ".concat(union.name, " can only include type ").concat(memberType.name, " once."), getUnionMemberTypeNodes(union, memberType.name));
      continue;
    }

    includedTypeNames[memberType.name] = true;

    if (!Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isObjectType */ "N"])(memberType)) {
      context.reportError("Union type ".concat(union.name, " can only include Object types, ") + "it cannot include ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(memberType), "."), getUnionMemberTypeNodes(union, String(memberType)));
    }
  }
}

function validateEnumValues(context, enumType) {
  var enumValues = enumType.getValues();

  if (enumValues.length === 0) {
    context.reportError("Enum type ".concat(enumType.name, " must define one or more values."), getAllNodes(enumType));
  }

  for (var _i24 = 0; _i24 < enumValues.length; _i24++) {
    var enumValue = enumValues[_i24];
    var valueName = enumValue.name; // Ensure valid name.

    validateName(context, enumValue);

    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {
      context.reportError("Enum type ".concat(enumType.name, " cannot include value: ").concat(valueName, "."), enumValue.astNode);
    }
  }
}

function validateInputFields(context, inputObj) {
  var fields = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(inputObj.getFields());

  if (fields.length === 0) {
    context.reportError("Input Object type ".concat(inputObj.name, " must define one or more fields."), getAllNodes(inputObj));
  } // Ensure the arguments are valid


  for (var _i26 = 0; _i26 < fields.length; _i26++) {
    var field = fields[_i26];
    // Ensure they are named correctly.
    validateName(context, field); // Ensure the type is an input type

    if (!Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isInputType */ "G"])(field.type)) {
      context.reportError("The type of ".concat(inputObj.name, ".").concat(field.name, " must be Input Type ") + "but got: ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(field.type), "."), field.astNode && field.astNode.type);
    }
  }
}

function createInputObjectCircularRefsValidator(context) {
  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.
  // Tracks already visited types to maintain O(N) and to ensure that cycles
  // are not redundantly reported.
  var visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors

  var fieldPath = []; // Position in the type path

  var fieldPathIndexByTypeName = Object.create(null);
  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.
  // It does not terminate when a cycle was found but continues to explore
  // the graph to find all possible cycles.

  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }

    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    var fields = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(inputObj.getFields());

    for (var _i28 = 0; _i28 < fields.length; _i28++) {
      var field = fields[_i28];

      if (Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isNonNullType */ "L"])(field.type) && Object(_definition__WEBPACK_IMPORTED_MODULE_11__[/* isInputObjectType */ "F"])(field.type.ofType)) {
        var fieldType = field.type.ofType;
        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);

        if (cycleIndex === undefined) {
          detectCycleRecursive(fieldType);
        } else {
          var cyclePath = fieldPath.slice(cycleIndex);
          var pathStr = cyclePath.map(function (fieldObj) {
            return fieldObj.name;
          }).join('.');
          context.reportError("Cannot reference Input Object \"".concat(fieldType.name, "\" within itself through a series of non-null fields: \"").concat(pathStr, "\"."), cyclePath.map(function (fieldObj) {
            return fieldObj.astNode;
          }));
        }

        fieldPath.pop();
      }
    }

    fieldPathIndexByTypeName[inputObj.name] = undefined;
  }
}

function getAllNodes(object) {
  var astNode = object.astNode,
      extensionASTNodes = object.extensionASTNodes;
  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes || [];
}

function getAllSubNodes(object, getter) {
  return Object(_polyfills_flatMap__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(getAllNodes(object), function (item) {
    return getter(item) || [];
  });
}

function getAllImplementsInterfaceNodes(type, iface) {
  return getAllSubNodes(type, function (typeNode) {
    return typeNode.interfaces;
  }).filter(function (ifaceNode) {
    return ifaceNode.name.value === iface.name;
  });
}

function getUnionMemberTypeNodes(union, typeName) {
  return getAllSubNodes(union, function (unionNode) {
    return unionNode.types;
  }).filter(function (typeNode) {
    return typeNode.name.value === typeName;
  });
}


/***/ }),
/* 56 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ABORT_VALIDATION */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return validate; });
/* unused harmony export validateSDL */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return assertValidSDL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return assertValidSDLExtension; });
/* harmony import */ var _jsutils_devAssert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _language_visitor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);
/* harmony import */ var _type_validate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55);
/* harmony import */ var _utilities_TypeInfo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44);
/* harmony import */ var _specifiedRules__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(88);
/* harmony import */ var _ValidationContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(68);







var ABORT_VALIDATION = Object.freeze({});
/**
 * Implements the "Validation" section of the spec.
 *
 * Validation runs synchronously, returning an array of encountered errors, or
 * an empty array if no errors were encountered and the document is valid.
 *
 * A list of specific validation rules may be provided. If not provided, the
 * default list of rules defined by the GraphQL specification will be used.
 *
 * Each validation rules is a function which returns a visitor
 * (see the language/visitor API). Visitor methods are expected to return
 * GraphQLErrors, or Arrays of GraphQLErrors when invalid.
 *
 * Optionally a custom TypeInfo instance may be provided. If not provided, one
 * will be created from the provided schema.
 */

function validate(schema, documentAST) {
  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _specifiedRules__WEBPACK_IMPORTED_MODULE_5__[/* specifiedRules */ "a"];
  var typeInfo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new _utilities_TypeInfo__WEBPACK_IMPORTED_MODULE_4__[/* TypeInfo */ "a"](schema);
  var options = arguments.length > 4 ? arguments[4] : undefined;
  documentAST || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(0, 'Must provide document'); // If the schema used for validation is invalid, throw an error.

  Object(_type_validate__WEBPACK_IMPORTED_MODULE_3__[/* assertValidSchema */ "a"])(schema);
  var abortObj = Object.freeze({});
  var errors = [];
  var maxErrors = options && options.maxErrors;
  var context = new _ValidationContext__WEBPACK_IMPORTED_MODULE_6__[/* ValidationContext */ "b"](schema, documentAST, typeInfo, function (error) {
    if (maxErrors != null && errors.length >= maxErrors) {
      errors.push(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_1__[/* GraphQLError */ "a"]('Too many validation errors, error limit reached. Validation aborted.'));
      throw abortObj;
    }

    errors.push(error);
  }); // This uses a specialized visitor which runs multiple visitors in parallel,
  // while maintaining the visitor skip and break API.

  var visitor = Object(_language_visitor__WEBPACK_IMPORTED_MODULE_2__[/* visitInParallel */ "d"])(rules.map(function (rule) {
    return rule(context);
  })); // Visit the whole document with each instance of all provided rules.

  try {
    Object(_language_visitor__WEBPACK_IMPORTED_MODULE_2__[/* visit */ "c"])(documentAST, Object(_language_visitor__WEBPACK_IMPORTED_MODULE_2__[/* visitWithTypeInfo */ "e"])(typeInfo, visitor));
  } catch (e) {
    if (e !== abortObj) {
      throw e;
    }
  }

  return errors;
} // @internal

function validateSDL(documentAST, schemaToExtend) {
  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _specifiedRules__WEBPACK_IMPORTED_MODULE_5__[/* specifiedSDLRules */ "b"];
  var errors = [];
  var context = new _ValidationContext__WEBPACK_IMPORTED_MODULE_6__[/* SDLValidationContext */ "a"](documentAST, schemaToExtend, function (error) {
    errors.push(error);
  });
  var visitors = rules.map(function (rule) {
    return rule(context);
  });
  Object(_language_visitor__WEBPACK_IMPORTED_MODULE_2__[/* visit */ "c"])(documentAST, Object(_language_visitor__WEBPACK_IMPORTED_MODULE_2__[/* visitInParallel */ "d"])(visitors));
  return errors;
}
/**
 * Utility function which asserts a SDL document is valid by throwing an error
 * if it is invalid.
 *
 * @internal
 */

function assertValidSDL(documentAST) {
  var errors = validateSDL(documentAST);

  if (errors.length !== 0) {
    throw new Error(errors.map(function (error) {
      return error.message;
    }).join('\n\n'));
  }
}
/**
 * Utility function which asserts a SDL document is valid by throwing an error
 * if it is invalid.
 *
 * @internal
 */

function assertValidSDLExtension(documentAST, schema) {
  var errors = validateSDL(documentAST, schema);

  if (errors.length !== 0) {
    throw new Error(errors.map(function (error) {
      return error.message;
    }).join('\n\n'));
  }
}


/***/ }),
/* 57 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return printPathArray; });
/**
 * Build a string describing the path.
 */
function printPathArray(path) {
  return path.map(function (key) {
    return typeof key === 'number' ? '[' + key.toString() + ']' : '.' + key;
  }).join('');
}


/***/ }),
/* 58 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Source; });
/* harmony import */ var _jsutils_devAssert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _jsutils_defineToStringTag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);



/**
 * A representation of source input to GraphQL.
 * `name` and `locationOffset` are optional. They are useful for clients who
 * store GraphQL documents in source files; for example, if the GraphQL input
 * starts at line 40 in a file named Foo.graphql, it might be useful for name to
 * be "Foo.graphql" and location to be `{ line: 40, column: 0 }`.
 * line and column in locationOffset are 1-indexed
 */
var Source = function Source(body, name, locationOffset) {
  this.body = body;
  this.name = name || 'GraphQL request';
  this.locationOffset = locationOffset || {
    line: 1,
    column: 1
  };
  this.locationOffset.line > 0 || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(0, 'line in locationOffset is 1-indexed and must be positive');
  this.locationOffset.column > 0 || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(0, 'column in locationOffset is 1-indexed and must be positive');
}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported

Object(_jsutils_defineToStringTag__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(Source);


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var schemaVisitor_1 = __webpack_require__(70);

var mergeDeep_1 = __webpack_require__(108);

var generate_1 = __webpack_require__(46);

function makeExecutableSchema(_a) {
  var typeDefs = _a.typeDefs,
      _b = _a.resolvers,
      resolvers = _b === void 0 ? {} : _b,
      connectors = _a.connectors,
      logger = _a.logger,
      _c = _a.allowUndefinedInResolve,
      allowUndefinedInResolve = _c === void 0 ? true : _c,
      _d = _a.resolverValidationOptions,
      resolverValidationOptions = _d === void 0 ? {} : _d,
      _e = _a.directiveResolvers,
      directiveResolvers = _e === void 0 ? null : _e,
      _f = _a.schemaDirectives,
      schemaDirectives = _f === void 0 ? null : _f,
      _g = _a.parseOptions,
      parseOptions = _g === void 0 ? {} : _g,
      _h = _a.inheritResolversFromInterfaces,
      inheritResolversFromInterfaces = _h === void 0 ? false : _h; // Validate and clean up arguments

  if (typeof resolverValidationOptions !== 'object') {
    throw new generate_1.SchemaError('Expected `resolverValidationOptions` to be an object');
  }

  if (!typeDefs) {
    throw new generate_1.SchemaError('Must provide typeDefs');
  }

  if (!resolvers) {
    throw new generate_1.SchemaError('Must provide resolvers');
  } // We allow passing in an array of resolver maps, in which case we merge them


  var resolverMap = Array.isArray(resolvers) ? resolvers.filter(function (resolverObj) {
    return typeof resolverObj === 'object';
  }).reduce(mergeDeep_1.default, {}) : resolvers; // Arguments are now validated and cleaned up

  var schema = generate_1.buildSchemaFromTypeDefinitions(typeDefs, parseOptions);
  schema = generate_1.addResolveFunctionsToSchema({
    schema: schema,
    resolvers: resolverMap,
    resolverValidationOptions: resolverValidationOptions,
    inheritResolversFromInterfaces: inheritResolversFromInterfaces
  });
  generate_1.assertResolveFunctionsPresent(schema, resolverValidationOptions);

  if (!allowUndefinedInResolve) {
    addCatchUndefinedToSchema(schema);
  }

  if (logger) {
    addErrorLoggingToSchema(schema, logger);
  }

  if (typeof resolvers['__schema'] === 'function') {
    // TODO a bit of a hack now, better rewrite generateSchema to attach it there.
    // not doing that now, because I'd have to rewrite a lot of tests.
    generate_1.addSchemaLevelResolveFunction(schema, resolvers['__schema']);
  }

  if (connectors) {
    // connectors are optional, at least for now. That means you can just import them in the resolve
    // function if you want.
    generate_1.attachConnectorsToContext(schema, connectors);
  }

  if (directiveResolvers) {
    generate_1.attachDirectiveResolvers(schema, directiveResolvers);
  }

  if (schemaDirectives) {
    schemaVisitor_1.SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);
  }

  return schema;
}

exports.makeExecutableSchema = makeExecutableSchema;

function decorateToCatchUndefined(fn, hint) {
  if (typeof fn === 'undefined') {
    fn = graphql_1.defaultFieldResolver;
  }

  return function (root, args, ctx, info) {
    var result = fn(root, args, ctx, info);

    if (typeof result === 'undefined') {
      throw new Error("Resolve function for \"" + hint + "\" returned undefined");
    }

    return result;
  };
}

function addCatchUndefinedToSchema(schema) {
  generate_1.forEachField(schema, function (field, typeName, fieldName) {
    var errorHint = typeName + "." + fieldName;
    field.resolve = decorateToCatchUndefined(field.resolve, errorHint);
  });
}

exports.addCatchUndefinedToSchema = addCatchUndefinedToSchema;

function addErrorLoggingToSchema(schema, logger) {
  if (!logger) {
    throw new Error('Must provide a logger');
  }

  if (typeof logger.log !== 'function') {
    throw new Error('Logger.log must be a function');
  }

  generate_1.forEachField(schema, function (field, typeName, fieldName) {
    var errorHint = typeName + "." + fieldName;
    field.resolve = generate_1.decorateWithLogger(field.resolve, logger, errorHint);
  });
}

exports.addErrorLoggingToSchema = addErrorLoggingToSchema;

__export(__webpack_require__(46));

/***/ }),
/* 60 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BreakingChangeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return DangerousChangeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return findBreakingChanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return findDangerousChanges; });
/* harmony import */ var _polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _jsutils_invariant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17);
/* harmony import */ var _language_printer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16);
/* harmony import */ var _language_visitor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(14);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);
/* harmony import */ var _astFromValue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(47);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var BreakingChangeType = Object.freeze({
  TYPE_REMOVED: 'TYPE_REMOVED',
  TYPE_CHANGED_KIND: 'TYPE_CHANGED_KIND',
  TYPE_REMOVED_FROM_UNION: 'TYPE_REMOVED_FROM_UNION',
  VALUE_REMOVED_FROM_ENUM: 'VALUE_REMOVED_FROM_ENUM',
  REQUIRED_INPUT_FIELD_ADDED: 'REQUIRED_INPUT_FIELD_ADDED',
  INTERFACE_REMOVED_FROM_OBJECT: 'INTERFACE_REMOVED_FROM_OBJECT',
  FIELD_REMOVED: 'FIELD_REMOVED',
  FIELD_CHANGED_KIND: 'FIELD_CHANGED_KIND',
  REQUIRED_ARG_ADDED: 'REQUIRED_ARG_ADDED',
  ARG_REMOVED: 'ARG_REMOVED',
  ARG_CHANGED_KIND: 'ARG_CHANGED_KIND',
  DIRECTIVE_REMOVED: 'DIRECTIVE_REMOVED',
  DIRECTIVE_ARG_REMOVED: 'DIRECTIVE_ARG_REMOVED',
  REQUIRED_DIRECTIVE_ARG_ADDED: 'REQUIRED_DIRECTIVE_ARG_ADDED',
  DIRECTIVE_LOCATION_REMOVED: 'DIRECTIVE_LOCATION_REMOVED'
});
var DangerousChangeType = Object.freeze({
  VALUE_ADDED_TO_ENUM: 'VALUE_ADDED_TO_ENUM',
  TYPE_ADDED_TO_UNION: 'TYPE_ADDED_TO_UNION',
  OPTIONAL_INPUT_FIELD_ADDED: 'OPTIONAL_INPUT_FIELD_ADDED',
  OPTIONAL_ARG_ADDED: 'OPTIONAL_ARG_ADDED',
  INTERFACE_ADDED_TO_OBJECT: 'INTERFACE_ADDED_TO_OBJECT',
  ARG_DEFAULT_VALUE_CHANGE: 'ARG_DEFAULT_VALUE_CHANGE'
});

/**
 * Given two schemas, returns an Array containing descriptions of all the types
 * of breaking changes covered by the other functions down below.
 */
function findBreakingChanges(oldSchema, newSchema) {
  var breakingChanges = findSchemaChanges(oldSchema, newSchema).filter(function (change) {
    return change.type in BreakingChangeType;
  });
  return breakingChanges;
}
/**
 * Given two schemas, returns an Array containing descriptions of all the types
 * of potentially dangerous changes covered by the other functions down below.
 */

function findDangerousChanges(oldSchema, newSchema) {
  var dangerousChanges = findSchemaChanges(oldSchema, newSchema).filter(function (change) {
    return change.type in DangerousChangeType;
  });
  return dangerousChanges;
}

function findSchemaChanges(oldSchema, newSchema) {
  return [].concat(findTypeChanges(oldSchema, newSchema), findDirectiveChanges(oldSchema, newSchema));
}

function findDirectiveChanges(oldSchema, newSchema) {
  var schemaChanges = [];
  var directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());

  for (var _i2 = 0, _directivesDiff$remov2 = directivesDiff.removed; _i2 < _directivesDiff$remov2.length; _i2++) {
    var oldDirective = _directivesDiff$remov2[_i2];
    schemaChanges.push({
      type: BreakingChangeType.DIRECTIVE_REMOVED,
      description: "".concat(oldDirective.name, " was removed.")
    });
  }

  for (var _i4 = 0, _directivesDiff$persi2 = directivesDiff.persisted; _i4 < _directivesDiff$persi2.length; _i4++) {
    var _ref2 = _directivesDiff$persi2[_i4];
    var _oldDirective = _ref2[0];
    var newDirective = _ref2[1];
    var argsDiff = diff(_oldDirective.args, newDirective.args);

    for (var _i6 = 0, _argsDiff$added2 = argsDiff.added; _i6 < _argsDiff$added2.length; _i6++) {
      var newArg = _argsDiff$added2[_i6];

      if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isRequiredArgument */ "P"])(newArg)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
          description: "A required arg ".concat(newArg.name, " on directive ").concat(_oldDirective.name, " was added.")
        });
      }
    }

    for (var _i8 = 0, _argsDiff$removed2 = argsDiff.removed; _i8 < _argsDiff$removed2.length; _i8++) {
      var oldArg = _argsDiff$removed2[_i8];
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
        description: "".concat(oldArg.name, " was removed from ").concat(_oldDirective.name, ".")
      });
    }

    for (var _i10 = 0, _oldDirective$locatio2 = _oldDirective.locations; _i10 < _oldDirective$locatio2.length; _i10++) {
      var location = _oldDirective$locatio2[_i10];

      if (newDirective.locations.indexOf(location) === -1) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
          description: "".concat(location, " was removed from ").concat(_oldDirective.name, ".")
        });
      }
    }
  }

  return schemaChanges;
}

function findTypeChanges(oldSchema, newSchema) {
  var schemaChanges = [];
  var typesDiff = diff(Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(oldSchema.getTypeMap()), Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(newSchema.getTypeMap()));

  for (var _i12 = 0, _typesDiff$removed2 = typesDiff.removed; _i12 < _typesDiff$removed2.length; _i12++) {
    var oldType = _typesDiff$removed2[_i12];
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED,
      description: "".concat(oldType.name, " was removed.")
    });
  }

  for (var _i14 = 0, _typesDiff$persisted2 = typesDiff.persisted; _i14 < _typesDiff$persisted2.length; _i14++) {
    var _ref4 = _typesDiff$persisted2[_i14];
    var _oldType = _ref4[0];
    var newType = _ref4[1];

    if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isEnumType */ "E"])(_oldType) && Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isEnumType */ "E"])(newType)) {
      schemaChanges.push.apply(schemaChanges, findEnumTypeChanges(_oldType, newType));
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isUnionType */ "T"])(_oldType) && Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isUnionType */ "T"])(newType)) {
      schemaChanges.push.apply(schemaChanges, findUnionTypeChanges(_oldType, newType));
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isInputObjectType */ "F"])(_oldType) && Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isInputObjectType */ "F"])(newType)) {
      schemaChanges.push.apply(schemaChanges, findInputObjectTypeChanges(_oldType, newType));
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isObjectType */ "N"])(_oldType) && Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isObjectType */ "N"])(newType)) {
      schemaChanges.push.apply(schemaChanges, findObjectTypeChanges(_oldType, newType));
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isInterfaceType */ "H"])(_oldType) && Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isInterfaceType */ "H"])(newType)) {
      schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType));
    } else if (_oldType.constructor !== newType.constructor) {
      schemaChanges.push({
        type: BreakingChangeType.TYPE_CHANGED_KIND,
        description: "".concat(_oldType.name, " changed from ") + "".concat(typeKindName(_oldType), " to ").concat(typeKindName(newType), ".")
      });
    }
  }

  return schemaChanges;
}

function findInputObjectTypeChanges(oldType, newType) {
  var schemaChanges = [];
  var fieldsDiff = diff(Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(oldType.getFields()), Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(newType.getFields()));

  for (var _i16 = 0, _fieldsDiff$added2 = fieldsDiff.added; _i16 < _fieldsDiff$added2.length; _i16++) {
    var newField = _fieldsDiff$added2[_i16];

    if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isRequiredInputField */ "Q"])(newField)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
        description: "A required field ".concat(newField.name, " on input type ").concat(oldType.name, " was added.")
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
        description: "An optional field ".concat(newField.name, " on input type ").concat(oldType.name, " was added.")
      });
    }
  }

  for (var _i18 = 0, _fieldsDiff$removed2 = fieldsDiff.removed; _i18 < _fieldsDiff$removed2.length; _i18++) {
    var oldField = _fieldsDiff$removed2[_i18];
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: "".concat(oldType.name, ".").concat(oldField.name, " was removed.")
    });
  }

  for (var _i20 = 0, _fieldsDiff$persisted2 = fieldsDiff.persisted; _i20 < _fieldsDiff$persisted2.length; _i20++) {
    var _ref6 = _fieldsDiff$persisted2[_i20];
    var _oldField = _ref6[0];
    var _newField = _ref6[1];
    var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldField.type, _newField.type);

    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: "".concat(oldType.name, ".").concat(_oldField.name, " changed type from ") + "".concat(String(_oldField.type), " to ").concat(String(_newField.type), ".")
      });
    }
  }

  return schemaChanges;
}

function findUnionTypeChanges(oldType, newType) {
  var schemaChanges = [];
  var possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());

  for (var _i22 = 0, _possibleTypesDiff$ad2 = possibleTypesDiff.added; _i22 < _possibleTypesDiff$ad2.length; _i22++) {
    var newPossibleType = _possibleTypesDiff$ad2[_i22];
    schemaChanges.push({
      type: DangerousChangeType.TYPE_ADDED_TO_UNION,
      description: "".concat(newPossibleType.name, " was added to union type ").concat(oldType.name, ".")
    });
  }

  for (var _i24 = 0, _possibleTypesDiff$re2 = possibleTypesDiff.removed; _i24 < _possibleTypesDiff$re2.length; _i24++) {
    var oldPossibleType = _possibleTypesDiff$re2[_i24];
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
      description: "".concat(oldPossibleType.name, " was removed from union type ").concat(oldType.name, ".")
    });
  }

  return schemaChanges;
}

function findEnumTypeChanges(oldType, newType) {
  var schemaChanges = [];
  var valuesDiff = diff(oldType.getValues(), newType.getValues());

  for (var _i26 = 0, _valuesDiff$added2 = valuesDiff.added; _i26 < _valuesDiff$added2.length; _i26++) {
    var newValue = _valuesDiff$added2[_i26];
    schemaChanges.push({
      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
      description: "".concat(newValue.name, " was added to enum type ").concat(oldType.name, ".")
    });
  }

  for (var _i28 = 0, _valuesDiff$removed2 = valuesDiff.removed; _i28 < _valuesDiff$removed2.length; _i28++) {
    var oldValue = _valuesDiff$removed2[_i28];
    schemaChanges.push({
      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
      description: "".concat(oldValue.name, " was removed from enum type ").concat(oldType.name, ".")
    });
  }

  return schemaChanges;
}

function findObjectTypeChanges(oldType, newType) {
  var schemaChanges = findFieldChanges(oldType, newType);
  var interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());

  for (var _i30 = 0, _interfacesDiff$added2 = interfacesDiff.added; _i30 < _interfacesDiff$added2.length; _i30++) {
    var newInterface = _interfacesDiff$added2[_i30];
    schemaChanges.push({
      type: DangerousChangeType.INTERFACE_ADDED_TO_OBJECT,
      description: "".concat(newInterface.name, " added to interfaces implemented by ").concat(oldType.name, ".")
    });
  }

  for (var _i32 = 0, _interfacesDiff$remov2 = interfacesDiff.removed; _i32 < _interfacesDiff$remov2.length; _i32++) {
    var oldInterface = _interfacesDiff$remov2[_i32];
    schemaChanges.push({
      type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,
      description: "".concat(oldType.name, " no longer implements interface ").concat(oldInterface.name, ".")
    });
  }

  return schemaChanges;
}

function findFieldChanges(oldType, newType) {
  var schemaChanges = [];
  var fieldsDiff = diff(Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(oldType.getFields()), Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(newType.getFields()));

  for (var _i34 = 0, _fieldsDiff$removed4 = fieldsDiff.removed; _i34 < _fieldsDiff$removed4.length; _i34++) {
    var oldField = _fieldsDiff$removed4[_i34];
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: "".concat(oldType.name, ".").concat(oldField.name, " was removed.")
    });
  }

  for (var _i36 = 0, _fieldsDiff$persisted4 = fieldsDiff.persisted; _i36 < _fieldsDiff$persisted4.length; _i36++) {
    var _ref8 = _fieldsDiff$persisted4[_i36];
    var _oldField2 = _ref8[0];
    var newField = _ref8[1];
    schemaChanges.push.apply(schemaChanges, findArgChanges(oldType, _oldField2, newField));
    var isSafe = isChangeSafeForObjectOrInterfaceField(_oldField2.type, newField.type);

    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: "".concat(oldType.name, ".").concat(_oldField2.name, " changed type from ") + "".concat(String(_oldField2.type), " to ").concat(String(newField.type), ".")
      });
    }
  }

  return schemaChanges;
}

function findArgChanges(oldType, oldField, newField) {
  var schemaChanges = [];
  var argsDiff = diff(oldField.args, newField.args);

  for (var _i38 = 0, _argsDiff$removed4 = argsDiff.removed; _i38 < _argsDiff$removed4.length; _i38++) {
    var oldArg = _argsDiff$removed4[_i38];
    schemaChanges.push({
      type: BreakingChangeType.ARG_REMOVED,
      description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(oldArg.name, " was removed.")
    });
  }

  for (var _i40 = 0, _argsDiff$persisted2 = argsDiff.persisted; _i40 < _argsDiff$persisted2.length; _i40++) {
    var _ref10 = _argsDiff$persisted2[_i40];
    var _oldArg = _ref10[0];
    var newArg = _ref10[1];
    var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldArg.type, newArg.type);

    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.ARG_CHANGED_KIND,
        description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " has changed type from ") + "".concat(String(_oldArg.type), " to ").concat(String(newArg.type), ".")
      });
    } else if (_oldArg.defaultValue !== undefined) {
      if (newArg.defaultValue === undefined) {
        schemaChanges.push({
          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
          description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " defaultValue was removed.")
        });
      } else {
        // Since we looking only for client's observable changes we should
        // compare default values in the same representation as they are
        // represented inside introspection.
        var oldValueStr = stringifyValue(_oldArg.defaultValue, _oldArg.type);
        var newValueStr = stringifyValue(newArg.defaultValue, newArg.type);

        if (oldValueStr !== newValueStr) {
          schemaChanges.push({
            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
            description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " has changed defaultValue from ").concat(oldValueStr, " to ").concat(newValueStr, ".")
          });
        }
      }
    }
  }

  for (var _i42 = 0, _argsDiff$added4 = argsDiff.added; _i42 < _argsDiff$added4.length; _i42++) {
    var _newArg = _argsDiff$added4[_i42];

    if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isRequiredArgument */ "P"])(_newArg)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_ARG_ADDED,
        description: "A required arg ".concat(_newArg.name, " on ").concat(oldType.name, ".").concat(oldField.name, " was added.")
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_ARG_ADDED,
        description: "An optional arg ".concat(_newArg.name, " on ").concat(oldType.name, ".").concat(oldField.name, " was added.")
      });
    }
  }

  return schemaChanges;
}

function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isListType */ "J"])(oldType)) {
    return (// if they're both lists, make sure the underlying types are compatible
      Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isListType */ "J"])(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || // moving from nullable to non-null of the same underlying type is safe
      Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNonNullType */ "L"])(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
    );
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNonNullType */ "L"])(oldType)) {
    // if they're both non-null, make sure the underlying types are compatible
    return Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNonNullType */ "L"])(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
  }

  return (// if they're both named types, see if their names are equivalent
    Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNamedType */ "K"])(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe
    Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNonNullType */ "L"])(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
  );
}

function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isListType */ "J"])(oldType)) {
    // if they're both lists, make sure the underlying types are compatible
    return Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isListType */ "J"])(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNonNullType */ "L"])(oldType)) {
    return (// if they're both non-null, make sure the underlying types are
      // compatible
      Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNonNullType */ "L"])(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || // moving from non-null to nullable of the same underlying type is safe
      !Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNonNullType */ "L"])(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)
    );
  } // if they're both named types, see if their names are equivalent


  return Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNamedType */ "K"])(newType) && oldType.name === newType.name;
}

function typeKindName(type) {
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isScalarType */ "R"])(type)) {
    return 'a Scalar type';
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isObjectType */ "N"])(type)) {
    return 'an Object type';
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isInterfaceType */ "H"])(type)) {
    return 'an Interface type';
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isUnionType */ "T"])(type)) {
    return 'a Union type';
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isEnumType */ "E"])(type)) {
    return 'an Enum type';
  }

  /* istanbul ignore else */
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isInputObjectType */ "F"])(type)) {
    return 'an Input type';
  } // Not reachable. All possible named types have been considered.


  /* istanbul ignore next */
  Object(_jsutils_invariant__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(false, 'Unexpected type: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(type));
}

function stringifyValue(value, type) {
  var ast = Object(_astFromValue__WEBPACK_IMPORTED_MODULE_7__[/* astFromValue */ "a"])(value, type);

  /* istanbul ignore next */
  ast != null || Object(_jsutils_invariant__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(0);
  var sortedAST = Object(_language_visitor__WEBPACK_IMPORTED_MODULE_5__[/* visit */ "c"])(ast, {
    ObjectValue: function ObjectValue(objectNode) {
      var fields = [].concat(objectNode.fields).sort(function (fieldA, fieldB) {
        return fieldA.name.value.localeCompare(fieldB.name.value);
      });
      return _objectSpread({}, objectNode, {
        fields: fields
      });
    }
  });
  return Object(_language_printer__WEBPACK_IMPORTED_MODULE_4__[/* print */ "a"])(sortedAST);
}

function diff(oldArray, newArray) {
  var added = [];
  var removed = [];
  var persisted = [];
  var oldMap = Object(_jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(oldArray, function (_ref11) {
    var name = _ref11.name;
    return name;
  });
  var newMap = Object(_jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(newArray, function (_ref12) {
    var name = _ref12.name;
    return name;
  });

  for (var _i44 = 0; _i44 < oldArray.length; _i44++) {
    var oldItem = oldArray[_i44];
    var newItem = newMap[oldItem.name];

    if (newItem === undefined) {
      removed.push(oldItem);
    } else {
      persisted.push([oldItem, newItem]);
    }
  }

  for (var _i46 = 0; _i46 < newArray.length; _i46++) {
    var _newItem = newArray[_i46];

    if (oldMap[_newItem.name] === undefined) {
      added.push(_newItem);
    }
  }

  return {
    added: added,
    persisted: persisted,
    removed: removed
  };
}


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var schemaRecreation_1 = __webpack_require__(62);

var VisitSchemaKind;

(function (VisitSchemaKind) {
  VisitSchemaKind["TYPE"] = "VisitSchemaKind.TYPE";
  VisitSchemaKind["SCALAR_TYPE"] = "VisitSchemaKind.SCALAR_TYPE";
  VisitSchemaKind["ENUM_TYPE"] = "VisitSchemaKind.ENUM_TYPE";
  VisitSchemaKind["COMPOSITE_TYPE"] = "VisitSchemaKind.COMPOSITE_TYPE";
  VisitSchemaKind["OBJECT_TYPE"] = "VisitSchemaKind.OBJECT_TYPE";
  VisitSchemaKind["INPUT_OBJECT_TYPE"] = "VisitSchemaKind.INPUT_OBJECT_TYPE";
  VisitSchemaKind["ABSTRACT_TYPE"] = "VisitSchemaKind.ABSTRACT_TYPE";
  VisitSchemaKind["UNION_TYPE"] = "VisitSchemaKind.UNION_TYPE";
  VisitSchemaKind["INTERFACE_TYPE"] = "VisitSchemaKind.INTERFACE_TYPE";
  VisitSchemaKind["ROOT_OBJECT"] = "VisitSchemaKind.ROOT_OBJECT";
  VisitSchemaKind["QUERY"] = "VisitSchemaKind.QUERY";
  VisitSchemaKind["MUTATION"] = "VisitSchemaKind.MUTATION";
  VisitSchemaKind["SUBSCRIPTION"] = "VisitSchemaKind.SUBSCRIPTION";
})(VisitSchemaKind = exports.VisitSchemaKind || (exports.VisitSchemaKind = {}));

function visitSchema(schema, visitor, stripResolvers) {
  var types = {};
  var resolveType = schemaRecreation_1.createResolveType(function (name) {
    if (typeof types[name] === 'undefined') {
      throw new Error("Can't find type " + name + ".");
    }

    return types[name];
  });
  var queryType = schema.getQueryType();
  var mutationType = schema.getMutationType();
  var subscriptionType = schema.getSubscriptionType();
  var typeMap = schema.getTypeMap();
  Object.keys(typeMap).map(function (typeName) {
    var type = typeMap[typeName];

    if (graphql_1.isNamedType(type) && graphql_1.getNamedType(type).name.slice(0, 2) !== '__') {
      var specifiers = getTypeSpecifiers(type, schema);
      var typeVisitor = getVisitor(visitor, specifiers);

      if (typeVisitor) {
        var result = typeVisitor(type, schema);

        if (typeof result === 'undefined') {
          types[typeName] = schemaRecreation_1.recreateType(type, resolveType, !stripResolvers);
        } else if (result === null) {
          types[typeName] = null;
        } else {
          types[typeName] = schemaRecreation_1.recreateType(result, resolveType, !stripResolvers);
        }
      } else {
        types[typeName] = schemaRecreation_1.recreateType(type, resolveType, !stripResolvers);
      }
    }
  });
  return new graphql_1.GraphQLSchema({
    query: queryType ? types[queryType.name] : null,
    mutation: mutationType ? types[mutationType.name] : null,
    subscription: subscriptionType ? types[subscriptionType.name] : null,
    types: Object.keys(types).map(function (name) {
      return types[name];
    })
  });
}

exports.visitSchema = visitSchema;

function getTypeSpecifiers(type, schema) {
  var specifiers = [VisitSchemaKind.TYPE];

  if (type instanceof graphql_1.GraphQLObjectType) {
    specifiers.unshift(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.OBJECT_TYPE);
    var query = schema.getQueryType();
    var mutation = schema.getMutationType();
    var subscription = schema.getSubscriptionType();

    if (type === query) {
      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.QUERY);
    } else if (type === mutation) {
      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.MUTATION);
    } else if (type === subscription) {
      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.SUBSCRIPTION);
    }
  } else if (type instanceof graphql_1.GraphQLInputObjectType) {
    specifiers.push(VisitSchemaKind.INPUT_OBJECT_TYPE);
  } else if (type instanceof graphql_1.GraphQLInterfaceType) {
    specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.INTERFACE_TYPE);
  } else if (type instanceof graphql_1.GraphQLUnionType) {
    specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.UNION_TYPE);
  } else if (type instanceof graphql_1.GraphQLEnumType) {
    specifiers.push(VisitSchemaKind.ENUM_TYPE);
  } else if (type instanceof graphql_1.GraphQLScalarType) {
    specifiers.push(VisitSchemaKind.SCALAR_TYPE);
  }

  return specifiers;
}

function getVisitor(visitor, specifiers) {
  var typeVisitor = null;

  var stack = __spreadArrays(specifiers);

  while (!typeVisitor && stack.length > 0) {
    var next = stack.pop();
    typeVisitor = visitor[next];
  }

  return typeVisitor;
}

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var isSpecifiedScalarType_1 = __webpack_require__(109);

var resolveFromParentTypename_1 = __webpack_require__(78);

var defaultMergedResolver_1 = __webpack_require__(79);

function recreateType(type, resolveType, keepResolvers) {
  if (type instanceof graphql_1.GraphQLObjectType) {
    var fields_1 = type.getFields();
    var interfaces_1 = type.getInterfaces();
    return new graphql_1.GraphQLObjectType({
      name: type.name,
      description: type.description,
      astNode: type.astNode,
      isTypeOf: keepResolvers ? type.isTypeOf : undefined,
      fields: function fields() {
        return fieldMapToFieldConfigMap(fields_1, resolveType, keepResolvers);
      },
      interfaces: function interfaces() {
        return interfaces_1.map(function (iface) {
          return resolveType(iface);
        });
      }
    });
  } else if (type instanceof graphql_1.GraphQLInterfaceType) {
    var fields_2 = type.getFields();
    return new graphql_1.GraphQLInterfaceType({
      name: type.name,
      description: type.description,
      astNode: type.astNode,
      fields: function fields() {
        return fieldMapToFieldConfigMap(fields_2, resolveType, keepResolvers);
      },
      resolveType: keepResolvers ? type.resolveType : function (parent, context, info) {
        return resolveFromParentTypename_1.default(parent, info.schema);
      }
    });
  } else if (type instanceof graphql_1.GraphQLUnionType) {
    return new graphql_1.GraphQLUnionType({
      name: type.name,
      description: type.description,
      astNode: type.astNode,
      types: function types() {
        return type.getTypes().map(function (unionMember) {
          return resolveType(unionMember);
        });
      },
      resolveType: keepResolvers ? type.resolveType : function (parent, context, info) {
        return resolveFromParentTypename_1.default(parent, info.schema);
      }
    });
  } else if (type instanceof graphql_1.GraphQLInputObjectType) {
    return new graphql_1.GraphQLInputObjectType({
      name: type.name,
      description: type.description,
      astNode: type.astNode,
      fields: function fields() {
        return inputFieldMapToFieldConfigMap(type.getFields(), resolveType);
      }
    });
  } else if (type instanceof graphql_1.GraphQLEnumType) {
    var values = type.getValues();
    var newValues_1 = {};
    values.forEach(function (value) {
      newValues_1[value.name] = {
        value: value.value,
        deprecationReason: value.deprecationReason,
        description: value.description,
        astNode: value.astNode
      };
    });
    return new graphql_1.GraphQLEnumType({
      name: type.name,
      description: type.description,
      astNode: type.astNode,
      values: newValues_1
    });
  } else if (type instanceof graphql_1.GraphQLScalarType) {
    if (keepResolvers || isSpecifiedScalarType_1.default(type)) {
      return type;
    } else {
      return new graphql_1.GraphQLScalarType({
        name: type.name,
        description: type.description,
        astNode: type.astNode,
        serialize: function serialize(value) {
          return value;
        },
        parseValue: function parseValue(value) {
          return value;
        },
        parseLiteral: function parseLiteral(ast) {
          return _parseLiteral(ast);
        }
      });
    }
  } else {
    throw new Error("Invalid type " + type);
  }
}

exports.recreateType = recreateType;

function recreateDirective(directive, resolveType) {
  return new graphql_1.GraphQLDirective({
    name: directive.name,
    description: directive.description,
    locations: directive.locations,
    args: argsToFieldConfigArgumentMap(directive.args, resolveType),
    astNode: directive.astNode
  });
}

exports.recreateDirective = recreateDirective;

function _parseLiteral(ast) {
  switch (ast.kind) {
    case graphql_1.Kind.STRING:
    case graphql_1.Kind.BOOLEAN:
      {
        return ast.value;
      }

    case graphql_1.Kind.INT:
    case graphql_1.Kind.FLOAT:
      {
        return parseFloat(ast.value);
      }

    case graphql_1.Kind.OBJECT:
      {
        var value_1 = Object.create(null);
        ast.fields.forEach(function (field) {
          value_1[field.name.value] = _parseLiteral(field.value);
        });
        return value_1;
      }

    case graphql_1.Kind.LIST:
      {
        return ast.values.map(_parseLiteral);
      }

    default:
      return null;
  }
}

function fieldMapToFieldConfigMap(fields, resolveType, keepResolvers) {
  var result = {};
  Object.keys(fields).forEach(function (name) {
    var field = fields[name];
    var type = resolveType(field.type);

    if (type !== null) {
      result[name] = fieldToFieldConfig(fields[name], resolveType, keepResolvers);
    }
  });
  return result;
}

exports.fieldMapToFieldConfigMap = fieldMapToFieldConfigMap;

function createResolveType(getType) {
  var resolveType = function resolveType(type) {
    if (type instanceof graphql_1.GraphQLList) {
      var innerType = resolveType(type.ofType);

      if (innerType === null) {
        return null;
      } else {
        return new graphql_1.GraphQLList(innerType);
      }
    } else if (type instanceof graphql_1.GraphQLNonNull) {
      var innerType = resolveType(type.ofType);

      if (innerType === null) {
        return null;
      } else {
        return new graphql_1.GraphQLNonNull(innerType);
      }
    } else if (graphql_1.isNamedType(type)) {
      var typeName = graphql_1.getNamedType(type).name;

      switch (typeName) {
        case graphql_1.GraphQLInt.name:
          return graphql_1.GraphQLInt;

        case graphql_1.GraphQLFloat.name:
          return graphql_1.GraphQLFloat;

        case graphql_1.GraphQLString.name:
          return graphql_1.GraphQLString;

        case graphql_1.GraphQLBoolean.name:
          return graphql_1.GraphQLBoolean;

        case graphql_1.GraphQLID.name:
          return graphql_1.GraphQLID;

        default:
          return getType(typeName, type);
      }
    } else {
      return type;
    }
  };

  return resolveType;
}

exports.createResolveType = createResolveType;

function fieldToFieldConfig(field, resolveType, keepResolvers) {
  return {
    type: resolveType(field.type),
    args: argsToFieldConfigArgumentMap(field.args, resolveType),
    resolve: keepResolvers ? field.resolve : defaultMergedResolver_1.default,
    subscribe: keepResolvers ? field.subscribe : null,
    description: field.description,
    deprecationReason: field.deprecationReason,
    astNode: field.astNode
  };
}

exports.fieldToFieldConfig = fieldToFieldConfig;

function argsToFieldConfigArgumentMap(args, resolveType) {
  var result = {};
  args.forEach(function (arg) {
    var newArg = argumentToArgumentConfig(arg, resolveType);

    if (newArg) {
      result[newArg[0]] = newArg[1];
    }
  });
  return result;
}

exports.argsToFieldConfigArgumentMap = argsToFieldConfigArgumentMap;

function argumentToArgumentConfig(argument, resolveType) {
  var type = resolveType(argument.type);

  if (type === null) {
    return null;
  } else {
    return [argument.name, {
      type: type,
      defaultValue: argument.defaultValue,
      description: argument.description
    }];
  }
}

exports.argumentToArgumentConfig = argumentToArgumentConfig;

function inputFieldMapToFieldConfigMap(fields, resolveType) {
  var result = {};
  Object.keys(fields).forEach(function (name) {
    var field = fields[name];
    var type = resolveType(field.type);

    if (type !== null) {
      result[name] = inputFieldToFieldConfig(fields[name], resolveType);
    }
  });
  return result;
}

exports.inputFieldMapToFieldConfigMap = inputFieldMapToFieldConfigMap;

function inputFieldToFieldConfig(field, resolveType) {
  return {
    type: resolveType(field.type),
    defaultValue: field.defaultValue,
    description: field.description,
    astNode: field.astNode
  };
}

exports.inputFieldToFieldConfig = inputFieldToFieldConfig;

/***/ }),
/* 63 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return assertValidName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isValidNameError; });
/* harmony import */ var _jsutils_devAssert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);


var NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
/**
 * Upholds the spec rules about naming.
 */

function assertValidName(name) {
  var error = isValidNameError(name);

  if (error) {
    throw error;
  }

  return name;
}
/**
 * Returns an Error if a name is invalid.
 */

function isValidNameError(name, node) {
  typeof name === 'string' || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(0, 'Expected string');

  if (name.length > 1 && name[0] === '_' && name[1] === '_') {
    return new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_1__[/* GraphQLError */ "a"]("Name \"".concat(name, "\" must not begin with \"__\", which is reserved by GraphQL introspection."), node);
  }

  if (!NAME_RX.test(name)) {
    return new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_1__[/* GraphQLError */ "a"]("Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but \"".concat(name, "\" does not."), node);
  }
}


/***/ }),
/* 64 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getIntrospectionQuery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return introspectionQuery; });
function getIntrospectionQuery(options) {
  var descriptions = !(options && options.descriptions === false);
  return "\n    query IntrospectionQuery {\n      __schema {\n        queryType { name }\n        mutationType { name }\n        subscriptionType { name }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          ".concat(descriptions ? 'description' : '', "\n          locations\n          args {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      ").concat(descriptions ? 'description' : '', "\n      fields(includeDeprecated: true) {\n        name\n        ").concat(descriptions ? 'description' : '', "\n        args {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        ").concat(descriptions ? 'description' : '', "\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      ").concat(descriptions ? 'description' : '', "\n      type { ...TypeRef }\n      defaultValue\n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ");
}
/**
 * Deprecated, call getIntrospectionQuery directly.
 *
 * This function will be removed in v15
 */

var introspectionQuery = getIntrospectionQuery();


/***/ }),
/* 65 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
var nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;
/* harmony default export */ __webpack_exports__["a"] = (nodejsCustomInspectSymbol);


/***/ }),
/* 66 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getLocation; });
/**
 * Represents a location in a Source.
 */

/**
 * Takes a Source and a UTF-8 character offset, and returns the corresponding
 * line and column as a SourceLocation.
 */
function getLocation(source, position) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position + 1;
  var match;

  while ((match = lineRegexp.exec(source.body)) && match.index < position) {
    line += 1;
    column = position + 1 - (match.index + match[0].length);
  }

  return {
    line: line,
    column: column
  };
}


/***/ }),
/* 67 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createLexer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isPunctuatorToken; });
/* harmony import */ var _jsutils_defineToJSON__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32);
/* harmony import */ var _error_syntaxError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var _blockString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41);
/* harmony import */ var _tokenKind__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);




/**
 * Given a Source object, this returns a Lexer for that source.
 * A Lexer is a stateful stream generator in that every time
 * it is advanced, it returns the next token in the Source. Assuming the
 * source lexes, the final Token emitted by the lexer will be of kind
 * EOF, after which the lexer will repeatedly return the same EOF token
 * whenever called.
 */

function createLexer(source, options) {
  var startOfFileToken = new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].SOF, 0, 0, 0, 0, null);
  var lexer = {
    source: source,
    options: options,
    lastToken: startOfFileToken,
    token: startOfFileToken,
    line: 1,
    lineStart: 0,
    advance: advanceLexer,
    lookahead: lookahead
  };
  return lexer;
}

function advanceLexer() {
  this.lastToken = this.token;
  var token = this.token = this.lookahead();
  return token;
}

function lookahead() {
  var token = this.token;

  if (token.kind !== _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].EOF) {
    do {
      // Note: next is only mutable during parsing, so we cast to allow this.
      token = token.next || (token.next = readToken(this, token));
    } while (token.kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].COMMENT);
  }

  return token;
}
/**
 * The return type of createLexer.
 */


// @internal
function isPunctuatorToken(token) {
  var kind = token.kind;
  return kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].BANG || kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].DOLLAR || kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].AMP || kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].PAREN_L || kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].PAREN_R || kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].SPREAD || kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].COLON || kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].EQUALS || kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].AT || kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].BRACKET_L || kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].BRACKET_R || kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].BRACE_L || kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].PIPE || kind === _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].BRACE_R;
}
/**
 * Helper function for constructing the Token object.
 */

function Tok(kind, start, end, line, column, prev, value) {
  this.kind = kind;
  this.start = start;
  this.end = end;
  this.line = line;
  this.column = column;
  this.value = value;
  this.prev = prev;
  this.next = null;
} // Print a simplified form when appearing in JSON/util.inspect.


Object(_jsutils_defineToJSON__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(Tok, function () {
  return {
    kind: this.kind,
    value: this.value,
    line: this.line,
    column: this.column
  };
});

function printCharCode(code) {
  return (// NaN/undefined represents access beyond the end of the file.
    isNaN(code) ? _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].EOF : // Trust JSON for ASCII.
    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.
    "\"\\u".concat(('00' + code.toString(16).toUpperCase()).slice(-4), "\"")
  );
}
/**
 * Gets the next token from the source starting at the given position.
 *
 * This skips over whitespace until it finds the next lexable token, then lexes
 * punctuators immediately or calls the appropriate helper function for more
 * complicated tokens.
 */


function readToken(lexer, prev) {
  var source = lexer.source;
  var body = source.body;
  var bodyLength = body.length;
  var pos = positionAfterWhitespace(body, prev.end, lexer);
  var line = lexer.line;
  var col = 1 + pos - lexer.lineStart;

  if (pos >= bodyLength) {
    return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].EOF, bodyLength, bodyLength, line, col, prev);
  }

  var code = body.charCodeAt(pos); // SourceCharacter

  switch (code) {
    // !
    case 33:
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].BANG, pos, pos + 1, line, col, prev);
    // #

    case 35:
      return readComment(source, pos, line, col, prev);
    // $

    case 36:
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].DOLLAR, pos, pos + 1, line, col, prev);
    // &

    case 38:
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].AMP, pos, pos + 1, line, col, prev);
    // (

    case 40:
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].PAREN_L, pos, pos + 1, line, col, prev);
    // )

    case 41:
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].PAREN_R, pos, pos + 1, line, col, prev);
    // .

    case 46:
      if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {
        return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].SPREAD, pos, pos + 3, line, col, prev);
      }

      break;
    // :

    case 58:
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].COLON, pos, pos + 1, line, col, prev);
    // =

    case 61:
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].EQUALS, pos, pos + 1, line, col, prev);
    // @

    case 64:
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].AT, pos, pos + 1, line, col, prev);
    // [

    case 91:
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].BRACKET_L, pos, pos + 1, line, col, prev);
    // ]

    case 93:
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].BRACKET_R, pos, pos + 1, line, col, prev);
    // {

    case 123:
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].BRACE_L, pos, pos + 1, line, col, prev);
    // |

    case 124:
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].PIPE, pos, pos + 1, line, col, prev);
    // }

    case 125:
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].BRACE_R, pos, pos + 1, line, col, prev);
    // A-Z _ a-z

    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 95:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
      return readName(source, pos, line, col, prev);
    // - 0-9

    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return readNumber(source, pos, code, line, col, prev);
    // "

    case 34:
      if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {
        return readBlockString(source, pos, line, col, prev, lexer);
      }

      return readString(source, pos, line, col, prev);
  }

  throw Object(_error_syntaxError__WEBPACK_IMPORTED_MODULE_1__[/* syntaxError */ "a"])(source, pos, unexpectedCharacterMessage(code));
}
/**
 * Report a message that an unexpected character was encountered.
 */


function unexpectedCharacterMessage(code) {
  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {
    return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
  }

  if (code === 39) {
    // '
    return 'Unexpected single quote character (\'), did you mean to use a double quote (")?';
  }

  return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
}
/**
 * Reads from body starting at startPosition until it finds a non-whitespace
 * character, then returns the position of that character for lexing.
 */


function positionAfterWhitespace(body, startPosition, lexer) {
  var bodyLength = body.length;
  var position = startPosition;

  while (position < bodyLength) {
    var code = body.charCodeAt(position); // tab | space | comma | BOM

    if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {
      ++position;
    } else if (code === 10) {
      // new line
      ++position;
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code === 13) {
      // carriage return
      if (body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }

      ++lexer.line;
      lexer.lineStart = position;
    } else {
      break;
    }
  }

  return position;
}
/**
 * Reads a comment token from the source file.
 *
 * #[\u0009\u0020-\uFFFF]*
 */


function readComment(source, start, line, col, prev) {
  var body = source.body;
  var code;
  var position = start;

  do {
    code = body.charCodeAt(++position);
  } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator
  code > 0x001f || code === 0x0009));

  return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].COMMENT, start, position, line, col, prev, body.slice(start + 1, position));
}
/**
 * Reads a number token from the source file, either a float
 * or an int depending on whether a decimal point appears.
 *
 * Int:   -?(0|[1-9][0-9]*)
 * Float: -?(0|[1-9][0-9]*)(\.[0-9]+)?((E|e)(+|-)?[0-9]+)?
 */


function readNumber(source, start, firstCode, line, col, prev) {
  var body = source.body;
  var code = firstCode;
  var position = start;
  var isFloat = false;

  if (code === 45) {
    // -
    code = body.charCodeAt(++position);
  }

  if (code === 48) {
    // 0
    code = body.charCodeAt(++position);

    if (code >= 48 && code <= 57) {
      throw Object(_error_syntaxError__WEBPACK_IMPORTED_MODULE_1__[/* syntaxError */ "a"])(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
    }
  } else {
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }

  if (code === 46) {
    // .
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }

  if (code === 69 || code === 101) {
    // E e
    isFloat = true;
    code = body.charCodeAt(++position);

    if (code === 43 || code === 45) {
      // + -
      code = body.charCodeAt(++position);
    }

    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  } // Numbers cannot be followed by . or e


  if (code === 46 || code === 69 || code === 101) {
    throw Object(_error_syntaxError__WEBPACK_IMPORTED_MODULE_1__[/* syntaxError */ "a"])(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
  }

  return new Tok(isFloat ? _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].FLOAT : _tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].INT, start, position, line, col, prev, body.slice(start, position));
}
/**
 * Returns the new position in the source after reading digits.
 */


function readDigits(source, start, firstCode) {
  var body = source.body;
  var position = start;
  var code = firstCode;

  if (code >= 48 && code <= 57) {
    // 0 - 9
    do {
      code = body.charCodeAt(++position);
    } while (code >= 48 && code <= 57); // 0 - 9


    return position;
  }

  throw Object(_error_syntaxError__WEBPACK_IMPORTED_MODULE_1__[/* syntaxError */ "a"])(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
}
/**
 * Reads a string token from the source file.
 *
 * "([^"\\\u000A\u000D]|(\\(u[0-9a-fA-F]{4}|["\\/bfnrt])))*"
 */


function readString(source, start, line, col, prev) {
  var body = source.body;
  var position = start + 1;
  var chunkStart = position;
  var code = 0;
  var value = '';

  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator
  code !== 0x000a && code !== 0x000d) {
    // Closing Quote (")
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].STRING, start, position + 1, line, col, prev, value);
    } // SourceCharacter


    if (code < 0x0020 && code !== 0x0009) {
      throw Object(_error_syntaxError__WEBPACK_IMPORTED_MODULE_1__[/* syntaxError */ "a"])(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
    }

    ++position;

    if (code === 92) {
      // \
      value += body.slice(chunkStart, position - 1);
      code = body.charCodeAt(position);

      switch (code) {
        case 34:
          value += '"';
          break;

        case 47:
          value += '/';
          break;

        case 92:
          value += '\\';
          break;

        case 98:
          value += '\b';
          break;

        case 102:
          value += '\f';
          break;

        case 110:
          value += '\n';
          break;

        case 114:
          value += '\r';
          break;

        case 116:
          value += '\t';
          break;

        case 117:
          {
            // uXXXX
            var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));

            if (charCode < 0) {
              var invalidSequence = body.slice(position + 1, position + 5);
              throw Object(_error_syntaxError__WEBPACK_IMPORTED_MODULE_1__[/* syntaxError */ "a"])(source, position, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
            }

            value += String.fromCharCode(charCode);
            position += 4;
            break;
          }

        default:
          throw Object(_error_syntaxError__WEBPACK_IMPORTED_MODULE_1__[/* syntaxError */ "a"])(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
      }

      ++position;
      chunkStart = position;
    }
  }

  throw Object(_error_syntaxError__WEBPACK_IMPORTED_MODULE_1__[/* syntaxError */ "a"])(source, position, 'Unterminated string.');
}
/**
 * Reads a block string token from the source file.
 *
 * """("?"?(\\"""|\\(?!=""")|[^"\\]))*"""
 */


function readBlockString(source, start, line, col, prev, lexer) {
  var body = source.body;
  var position = start + 3;
  var chunkStart = position;
  var code = 0;
  var rawValue = '';

  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {
    // Closing Triple-Quote (""")
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      rawValue += body.slice(chunkStart, position);
      return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].BLOCK_STRING, start, position + 3, line, col, prev, Object(_blockString__WEBPACK_IMPORTED_MODULE_2__[/* dedentBlockStringValue */ "a"])(rawValue));
    } // SourceCharacter


    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {
      throw Object(_error_syntaxError__WEBPACK_IMPORTED_MODULE_1__[/* syntaxError */ "a"])(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
    }

    if (code === 10) {
      // new line
      ++position;
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code === 13) {
      // carriage return
      if (body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }

      ++lexer.line;
      lexer.lineStart = position;
    } else if ( // Escape Triple-Quote (\""")
    code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      rawValue += body.slice(chunkStart, position) + '"""';
      position += 4;
      chunkStart = position;
    } else {
      ++position;
    }
  }

  throw Object(_error_syntaxError__WEBPACK_IMPORTED_MODULE_1__[/* syntaxError */ "a"])(source, position, 'Unterminated string.');
}
/**
 * Converts four hexadecimal chars to the integer that the
 * string represents. For example, uniCharCode('0','0','0','f')
 * will return 15, and uniCharCode('0','0','f','f') returns 255.
 *
 * Returns a negative number on error, if a char was invalid.
 *
 * This is implemented by noting that char2hex() returns -1 on error,
 * which means the result of ORing the char2hex() will also be negative.
 */


function uniCharCode(a, b, c, d) {
  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);
}
/**
 * Converts a hex character to its integer value.
 * '0' becomes 0, '9' becomes 9
 * 'A' becomes 10, 'F' becomes 15
 * 'a' becomes 10, 'f' becomes 15
 *
 * Returns -1 on error.
 */


function char2hex(a) {
  return a >= 48 && a <= 57 ? a - 48 // 0-9
  : a >= 65 && a <= 70 ? a - 55 // A-F
  : a >= 97 && a <= 102 ? a - 87 // a-f
  : -1;
}
/**
 * Reads an alphanumeric + underscore name from the source.
 *
 * [_A-Za-z][_0-9A-Za-z]*
 */


function readName(source, start, line, col, prev) {
  var body = source.body;
  var bodyLength = body.length;
  var position = start + 1;
  var code = 0;

  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _
  code >= 48 && code <= 57 || // 0-9
  code >= 65 && code <= 90 || // A-Z
  code >= 97 && code <= 122) // a-z
  ) {
    ++position;
  }

  return new Tok(_tokenKind__WEBPACK_IMPORTED_MODULE_3__[/* TokenKind */ "a"].NAME, start, position, line, col, prev, body.slice(start, position));
}


/***/ }),
/* 68 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ASTValidationContext */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SDLValidationContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ValidationContext; });
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _language_visitor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _utilities_TypeInfo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }





/**
 * An instance of this class is passed as the "this" context to all validators,
 * allowing access to commonly useful contextual information from within a
 * validation rule.
 */
var ASTValidationContext =
/*#__PURE__*/
function () {
  function ASTValidationContext(ast, onError) {
    this._ast = ast;
    this._errors = [];
    this._fragments = undefined;
    this._fragmentSpreads = new Map();
    this._recursivelyReferencedFragments = new Map();
    this._onError = onError;
  }

  var _proto = ASTValidationContext.prototype;

  _proto.reportError = function reportError(error) {
    this._errors.push(error);

    if (this._onError) {
      this._onError(error);
    }
  } // @deprecated: use onError callback instead - will be removed in v15.
  ;

  _proto.getErrors = function getErrors() {
    return this._errors;
  };

  _proto.getDocument = function getDocument() {
    return this._ast;
  };

  _proto.getFragment = function getFragment(name) {
    var fragments = this._fragments;

    if (!fragments) {
      this._fragments = fragments = this.getDocument().definitions.reduce(function (frags, statement) {
        if (statement.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].FRAGMENT_DEFINITION) {
          frags[statement.name.value] = statement;
        }

        return frags;
      }, Object.create(null));
    }

    return fragments[name];
  };

  _proto.getFragmentSpreads = function getFragmentSpreads(node) {
    var spreads = this._fragmentSpreads.get(node);

    if (!spreads) {
      spreads = [];
      var setsToVisit = [node];

      while (setsToVisit.length !== 0) {
        var set = setsToVisit.pop();

        for (var _i2 = 0, _set$selections2 = set.selections; _i2 < _set$selections2.length; _i2++) {
          var selection = _set$selections2[_i2];

          if (selection.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].FRAGMENT_SPREAD) {
            spreads.push(selection);
          } else if (selection.selectionSet) {
            setsToVisit.push(selection.selectionSet);
          }
        }
      }

      this._fragmentSpreads.set(node, spreads);
    }

    return spreads;
  };

  _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {
    var fragments = this._recursivelyReferencedFragments.get(operation);

    if (!fragments) {
      fragments = [];
      var collectedNames = Object.create(null);
      var nodesToVisit = [operation.selectionSet];

      while (nodesToVisit.length !== 0) {
        var node = nodesToVisit.pop();

        for (var _i4 = 0, _this$getFragmentSpre2 = this.getFragmentSpreads(node); _i4 < _this$getFragmentSpre2.length; _i4++) {
          var spread = _this$getFragmentSpre2[_i4];
          var fragName = spread.name.value;

          if (collectedNames[fragName] !== true) {
            collectedNames[fragName] = true;
            var fragment = this.getFragment(fragName);

            if (fragment) {
              fragments.push(fragment);
              nodesToVisit.push(fragment.selectionSet);
            }
          }
        }
      }

      this._recursivelyReferencedFragments.set(operation, fragments);
    }

    return fragments;
  };

  return ASTValidationContext;
}();
var SDLValidationContext =
/*#__PURE__*/
function (_ASTValidationContext) {
  _inheritsLoose(SDLValidationContext, _ASTValidationContext);

  function SDLValidationContext(ast, schema, onError) {
    var _this;

    _this = _ASTValidationContext.call(this, ast, onError) || this;
    _this._schema = schema;
    return _this;
  }

  var _proto2 = SDLValidationContext.prototype;

  _proto2.getSchema = function getSchema() {
    return this._schema;
  };

  return SDLValidationContext;
}(ASTValidationContext);
var ValidationContext =
/*#__PURE__*/
function (_ASTValidationContext2) {
  _inheritsLoose(ValidationContext, _ASTValidationContext2);

  function ValidationContext(schema, ast, typeInfo, onError) {
    var _this2;

    _this2 = _ASTValidationContext2.call(this, ast, onError) || this;
    _this2._schema = schema;
    _this2._typeInfo = typeInfo;
    _this2._variableUsages = new Map();
    _this2._recursiveVariableUsages = new Map();
    return _this2;
  }

  var _proto3 = ValidationContext.prototype;

  _proto3.getSchema = function getSchema() {
    return this._schema;
  };

  _proto3.getVariableUsages = function getVariableUsages(node) {
    var usages = this._variableUsages.get(node);

    if (!usages) {
      var newUsages = [];
      var typeInfo = new _utilities_TypeInfo__WEBPACK_IMPORTED_MODULE_2__[/* TypeInfo */ "a"](this._schema);
      Object(_language_visitor__WEBPACK_IMPORTED_MODULE_1__[/* visit */ "c"])(node, Object(_language_visitor__WEBPACK_IMPORTED_MODULE_1__[/* visitWithTypeInfo */ "e"])(typeInfo, {
        VariableDefinition: function VariableDefinition() {
          return false;
        },
        Variable: function Variable(variable) {
          newUsages.push({
            node: variable,
            type: typeInfo.getInputType(),
            defaultValue: typeInfo.getDefaultValue()
          });
        }
      }));
      usages = newUsages;

      this._variableUsages.set(node, usages);
    }

    return usages;
  };

  _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {
    var usages = this._recursiveVariableUsages.get(operation);

    if (!usages) {
      usages = this.getVariableUsages(operation);

      for (var _i6 = 0, _this$getRecursivelyR2 = this.getRecursivelyReferencedFragments(operation); _i6 < _this$getRecursivelyR2.length; _i6++) {
        var frag = _this$getRecursivelyR2[_i6];
        usages = usages.concat(this.getVariableUsages(frag));
      }

      this._recursiveVariableUsages.set(operation, usages);
    }

    return usages;
  };

  _proto3.getType = function getType() {
    return this._typeInfo.getType();
  };

  _proto3.getParentType = function getParentType() {
    return this._typeInfo.getParentType();
  };

  _proto3.getInputType = function getInputType() {
    return this._typeInfo.getInputType();
  };

  _proto3.getParentInputType = function getParentInputType() {
    return this._typeInfo.getParentInputType();
  };

  _proto3.getFieldDef = function getFieldDef() {
    return this._typeInfo.getFieldDef();
  };

  _proto3.getDirective = function getDirective() {
    return this._typeInfo.getDirective();
  };

  _proto3.getArgument = function getArgument() {
    return this._typeInfo.getArgument();
  };

  return ValidationContext;
}(ASTValidationContext);


/***/ }),
/* 69 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return printSchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return printIntrospectionSchema; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return printType; });
/* harmony import */ var _polyfills_flatMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
/* harmony import */ var _polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _jsutils_invariant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(17);
/* harmony import */ var _language_printer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16);
/* harmony import */ var _language_blockString__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(41);
/* harmony import */ var _type_introspection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);
/* harmony import */ var _type_scalars__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(13);
/* harmony import */ var _type_directives__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(15);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(0);
/* harmony import */ var _utilities_astFromValue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(47);












/**
 * Accepts options as a second argument:
 *
 *    - commentDescriptions:
 *        Provide true to use preceding comments as the description.
 *
 */
function printSchema(schema, options) {
  return printFilteredSchema(schema, function (n) {
    return !Object(_type_directives__WEBPACK_IMPORTED_MODULE_8__[/* isSpecifiedDirective */ "h"])(n);
  }, isDefinedType, options);
}
function printIntrospectionSchema(schema, options) {
  return printFilteredSchema(schema, _type_directives__WEBPACK_IMPORTED_MODULE_8__[/* isSpecifiedDirective */ "h"], _type_introspection__WEBPACK_IMPORTED_MODULE_6__[/* isIntrospectionType */ "n"], options);
}

function isDefinedType(type) {
  return !Object(_type_scalars__WEBPACK_IMPORTED_MODULE_7__[/* isSpecifiedScalarType */ "f"])(type) && !Object(_type_introspection__WEBPACK_IMPORTED_MODULE_6__[/* isIntrospectionType */ "n"])(type);
}

function printFilteredSchema(schema, directiveFilter, typeFilter, options) {
  var directives = schema.getDirectives().filter(directiveFilter);
  var typeMap = schema.getTypeMap();
  var types = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(typeMap).sort(function (type1, type2) {
    return type1.name.localeCompare(type2.name);
  }).filter(typeFilter);
  return [printSchemaDefinition(schema)].concat(directives.map(function (directive) {
    return printDirective(directive, options);
  }), types.map(function (type) {
    return printType(type, options);
  })).filter(Boolean).join('\n\n') + '\n';
}

function printSchemaDefinition(schema) {
  if (isSchemaOfCommonNames(schema)) {
    return;
  }

  var operationTypes = [];
  var queryType = schema.getQueryType();

  if (queryType) {
    operationTypes.push("  query: ".concat(queryType.name));
  }

  var mutationType = schema.getMutationType();

  if (mutationType) {
    operationTypes.push("  mutation: ".concat(mutationType.name));
  }

  var subscriptionType = schema.getSubscriptionType();

  if (subscriptionType) {
    operationTypes.push("  subscription: ".concat(subscriptionType.name));
  }

  return "schema {\n".concat(operationTypes.join('\n'), "\n}");
}
/**
 * GraphQL schema define root types for each type of operation. These types are
 * the same as any other type and can be named in any manner, however there is
 * a common naming convention:
 *
 *   schema {
 *     query: Query
 *     mutation: Mutation
 *   }
 *
 * When using this naming convention, the schema description can be omitted.
 */


function isSchemaOfCommonNames(schema) {
  var queryType = schema.getQueryType();

  if (queryType && queryType.name !== 'Query') {
    return false;
  }

  var mutationType = schema.getMutationType();

  if (mutationType && mutationType.name !== 'Mutation') {
    return false;
  }

  var subscriptionType = schema.getSubscriptionType();

  if (subscriptionType && subscriptionType.name !== 'Subscription') {
    return false;
  }

  return true;
}

function printType(type, options) {
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_9__[/* isScalarType */ "R"])(type)) {
    return printScalar(type, options);
  } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_9__[/* isObjectType */ "N"])(type)) {
    return printObject(type, options);
  } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_9__[/* isInterfaceType */ "H"])(type)) {
    return printInterface(type, options);
  } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_9__[/* isUnionType */ "T"])(type)) {
    return printUnion(type, options);
  } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_9__[/* isEnumType */ "E"])(type)) {
    return printEnum(type, options);
  } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_9__[/* isInputObjectType */ "F"])(type)) {
    return printInputObject(type, options);
  } // Not reachable. All possible types have been considered.


  /* istanbul ignore next */
  Object(_jsutils_invariant__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(false, 'Unexpected type: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(type));
}

function printScalar(type, options) {
  return printDescription(options, type) + "scalar ".concat(type.name);
}

function printObject(type, options) {
  var interfaces = type.getInterfaces();
  var implementedInterfaces = interfaces.length ? ' implements ' + interfaces.map(function (i) {
    return i.name;
  }).join(' & ') : '';
  return printDescription(options, type) + "type ".concat(type.name).concat(implementedInterfaces) + printFields(options, type);
}

function printInterface(type, options) {
  return printDescription(options, type) + "interface ".concat(type.name) + printFields(options, type);
}

function printUnion(type, options) {
  var types = type.getTypes();
  var possibleTypes = types.length ? ' = ' + types.join(' | ') : '';
  return printDescription(options, type) + 'union ' + type.name + possibleTypes;
}

function printEnum(type, options) {
  var values = type.getValues().map(function (value, i) {
    return printDescription(options, value, '  ', !i) + '  ' + value.name + printDeprecated(value);
  });
  return printDescription(options, type) + "enum ".concat(type.name) + printBlock(values);
}

function printInputObject(type, options) {
  var fields = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(type.getFields()).map(function (f, i) {
    return printDescription(options, f, '  ', !i) + '  ' + printInputValue(f);
  });
  return printDescription(options, type) + "input ".concat(type.name) + printBlock(fields);
}

function printFields(options, type) {
  var fields = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(type.getFields()).map(function (f, i) {
    return printDescription(options, f, '  ', !i) + '  ' + f.name + printArgs(options, f.args, '  ') + ': ' + String(f.type) + printDeprecated(f);
  });
  return printBlock(fields);
}

function printBlock(items) {
  return items.length !== 0 ? ' {\n' + items.join('\n') + '\n}' : '';
}

function printArgs(options, args) {
  var indentation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

  if (args.length === 0) {
    return '';
  } // If every arg does not have a description, print them on one line.


  if (args.every(function (arg) {
    return !arg.description;
  })) {
    return '(' + args.map(printInputValue).join(', ') + ')';
  }

  return '(\n' + args.map(function (arg, i) {
    return printDescription(options, arg, '  ' + indentation, !i) + '  ' + indentation + printInputValue(arg);
  }).join('\n') + '\n' + indentation + ')';
}

function printInputValue(arg) {
  var defaultAST = Object(_utilities_astFromValue__WEBPACK_IMPORTED_MODULE_10__[/* astFromValue */ "a"])(arg.defaultValue, arg.type);
  var argDecl = arg.name + ': ' + String(arg.type);

  if (defaultAST) {
    argDecl += " = ".concat(Object(_language_printer__WEBPACK_IMPORTED_MODULE_4__[/* print */ "a"])(defaultAST));
  }

  return argDecl;
}

function printDirective(directive, options) {
  return printDescription(options, directive) + 'directive @' + directive.name + printArgs(options, directive.args) + (directive.isRepeatable ? ' repeatable' : '') + ' on ' + directive.locations.join(' | ');
}

function printDeprecated(fieldOrEnumVal) {
  if (!fieldOrEnumVal.isDeprecated) {
    return '';
  }

  var reason = fieldOrEnumVal.deprecationReason;
  var reasonAST = Object(_utilities_astFromValue__WEBPACK_IMPORTED_MODULE_10__[/* astFromValue */ "a"])(reason, _type_scalars__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLString */ "e"]);

  if (reasonAST && reason !== '' && reason !== _type_directives__WEBPACK_IMPORTED_MODULE_8__[/* DEFAULT_DEPRECATION_REASON */ "a"]) {
    return ' @deprecated(reason: ' + Object(_language_printer__WEBPACK_IMPORTED_MODULE_4__[/* print */ "a"])(reasonAST) + ')';
  }

  return ' @deprecated';
}

function printDescription(options, def) {
  var indentation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var firstInBlock = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  if (!def.description) {
    return '';
  }

  var lines = descriptionLines(def.description, 120 - indentation.length);

  if (options && options.commentDescriptions) {
    return printDescriptionWithComments(lines, indentation, firstInBlock);
  }

  var text = lines.join('\n');
  var preferMultipleLines = text.length > 70;
  var blockString = Object(_language_blockString__WEBPACK_IMPORTED_MODULE_5__[/* printBlockString */ "c"])(text, '', preferMultipleLines);
  var prefix = indentation && !firstInBlock ? '\n' + indentation : indentation;
  return prefix + blockString.replace(/\n/g, '\n' + indentation) + '\n';
}

function printDescriptionWithComments(lines, indentation, firstInBlock) {
  var description = indentation && !firstInBlock ? '\n' : '';

  for (var _i2 = 0; _i2 < lines.length; _i2++) {
    var line = lines[_i2];

    if (line === '') {
      description += indentation + '#\n';
    } else {
      description += indentation + '# ' + line + '\n';
    }
  }

  return description;
}

function descriptionLines(description, maxLen) {
  var rawLines = description.split('\n');
  return Object(_polyfills_flatMap__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(rawLines, function (line) {
    if (line.length < maxLen + 5) {
      return line;
    } // For > 120 character long lines, cut at space boundaries into sublines
    // of ~80 chars.


    return breakLine(line, maxLen);
  });
}

function breakLine(line, maxLen) {
  var parts = line.split(new RegExp("((?: |^).{15,".concat(maxLen - 40, "}(?= |$))")));

  if (parts.length < 4) {
    return [line];
  }

  var sublines = [parts[0] + parts[1] + parts[2]];

  for (var i = 3; i < parts.length; i += 2) {
    sublines.push(parts[i].slice(1) + parts[i + 1]);
  }

  return sublines;
}


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = this && this.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var values_1 = __webpack_require__(50);

var hasOwn = Object.prototype.hasOwnProperty; // Abstract base class of any visitor implementation, defining the available
// visitor methods along with their parameter types, and providing a static
// helper function for determining whether a subclass implements a given
// visitor method, as opposed to inheriting one of the stubs defined here.

var SchemaVisitor =
/** @class */
function () {
  function SchemaVisitor() {} // Determine if this SchemaVisitor (sub)class implements a particular
  // visitor method.


  SchemaVisitor.implementsVisitorMethod = function (methodName) {
    if (!methodName.startsWith('visit')) {
      return false;
    }

    var method = this.prototype[methodName];

    if (typeof method !== 'function') {
      return false;
    }

    if (this === SchemaVisitor) {
      // The SchemaVisitor class implements every visitor method.
      return true;
    }

    var stub = SchemaVisitor.prototype[methodName];

    if (method === stub) {
      // If this.prototype[methodName] was just inherited from SchemaVisitor,
      // then this class does not really implement the method.
      return false;
    }

    return true;
  }; // Concrete subclasses of SchemaVisitor should override one or more of these
  // visitor methods, in order to express their interest in handling certain
  // schema types/locations. Each method may return null to remove the given
  // type from the schema, a non-null value of the same type to update the
  // type in the schema, or nothing to leave the type as it was.

  /* tslint:disable:no-empty */


  SchemaVisitor.prototype.visitSchema = function (schema) {};

  SchemaVisitor.prototype.visitScalar = function (scalar) {};

  SchemaVisitor.prototype.visitObject = function (object) {};

  SchemaVisitor.prototype.visitFieldDefinition = function (field, details) {};

  SchemaVisitor.prototype.visitArgumentDefinition = function (argument, details) {};

  SchemaVisitor.prototype.visitInterface = function (iface) {};

  SchemaVisitor.prototype.visitUnion = function (union) {};

  SchemaVisitor.prototype.visitEnum = function (type) {};

  SchemaVisitor.prototype.visitEnumValue = function (value, details) {};

  SchemaVisitor.prototype.visitInputObject = function (object) {};

  SchemaVisitor.prototype.visitInputFieldDefinition = function (field, details) {};

  return SchemaVisitor;
}();

exports.SchemaVisitor = SchemaVisitor; // Generic function for visiting GraphQLSchema objects.

function visitSchema(schema, // To accommodate as many different visitor patterns as possible, the
// visitSchema function does not simply accept a single instance of the
// SchemaVisitor class, but instead accepts a function that takes the
// current VisitableSchemaType object and the name of a visitor method and
// returns an array of SchemaVisitor instances that implement the visitor
// method and have an interest in handling the given VisitableSchemaType
// object. In the simplest case, this function can always return an array
// containing a single visitor object, without even looking at the type or
// methodName parameters. In other cases, this function might sometimes
// return an empty array to indicate there are no visitors that should be
// applied to the given VisitableSchemaType object. For an example of a
// visitor pattern that benefits from this abstraction, see the
// SchemaDirectiveVisitor class below.
visitorSelector) {
  // Helper function that calls visitorSelector and applies the resulting
  // visitors to the given type, with arguments [type, ...args].
  function callMethod(methodName, type) {
    var args = [];

    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }

    visitorSelector(type, methodName).every(function (visitor) {
      var newType = visitor[methodName].apply(visitor, __spreadArrays([type], args));

      if (typeof newType === 'undefined') {
        // Keep going without modifying type.
        return true;
      }

      if (methodName === 'visitSchema' || type instanceof graphql_1.GraphQLSchema) {
        throw new Error("Method " + methodName + " cannot replace schema with " + newType);
      }

      if (newType === null) {
        // Stop the loop and return null form callMethod, which will cause
        // the type to be removed from the schema.
        type = null;
        return false;
      } // Update type to the new type returned by the visitor method, so that
      // later directives will see the new type, and callMethod will return
      // the final type.


      type = newType;
      return true;
    }); // If there were no directives for this type object, or if all visitor
    // methods returned nothing, type will be returned unmodified.

    return type;
  } // Recursive helper function that calls any appropriate visitor methods for
  // each object in the schema, then traverses the object's children (if any).


  function visit(type) {
    if (type instanceof graphql_1.GraphQLSchema) {
      // Unlike the other types, the root GraphQLSchema object cannot be
      // replaced by visitor methods, because that would make life very hard
      // for SchemaVisitor subclasses that rely on the original schema object.
      callMethod('visitSchema', type);
      updateEachKey(type.getTypeMap(), function (namedType, typeName) {
        if (!typeName.startsWith('__')) {
          // Call visit recursively to let it determine which concrete
          // subclass of GraphQLNamedType we found in the type map. Because
          // we're using updateEachKey, the result of visit(namedType) may
          // cause the type to be removed or replaced.
          return visit(namedType);
        }
      });
      return type;
    }

    if (type instanceof graphql_1.GraphQLObjectType) {
      // Note that callMethod('visitObject', type) may not actually call any
      // methods, if there are no @directive annotations associated with this
      // type, or if this SchemaDirectiveVisitor subclass does not override
      // the visitObject method.
      var newObject = callMethod('visitObject', type);

      if (newObject) {
        visitFields(newObject);
      }

      return newObject;
    }

    if (type instanceof graphql_1.GraphQLInterfaceType) {
      var newInterface = callMethod('visitInterface', type);

      if (newInterface) {
        visitFields(newInterface);
      }

      return newInterface;
    }

    if (type instanceof graphql_1.GraphQLInputObjectType) {
      var newInputObject_1 = callMethod('visitInputObject', type);

      if (newInputObject_1) {
        updateEachKey(newInputObject_1.getFields(), function (field) {
          // Since we call a different method for input object fields, we
          // can't reuse the visitFields function here.
          return callMethod('visitInputFieldDefinition', field, {
            objectType: newInputObject_1
          });
        });
      }

      return newInputObject_1;
    }

    if (type instanceof graphql_1.GraphQLScalarType) {
      return callMethod('visitScalar', type);
    }

    if (type instanceof graphql_1.GraphQLUnionType) {
      return callMethod('visitUnion', type);
    }

    if (type instanceof graphql_1.GraphQLEnumType) {
      var newEnum_1 = callMethod('visitEnum', type);

      if (newEnum_1) {
        updateEachKey(newEnum_1.getValues(), function (value) {
          return callMethod('visitEnumValue', value, {
            enumType: newEnum_1
          });
        });
      }

      return newEnum_1;
    }

    throw new Error("Unexpected schema type: " + type);
  }

  function visitFields(type) {
    updateEachKey(type.getFields(), function (field) {
      // It would be nice if we could call visit(field) recursively here, but
      // GraphQLField is merely a type, not a value that can be detected using
      // an instanceof check, so we have to visit the fields in this lexical
      // context, so that TypeScript can validate the call to
      // visitFieldDefinition.
      var newField = callMethod('visitFieldDefinition', field, {
        // While any field visitor needs a reference to the field object, some
        // field visitors may also need to know the enclosing (parent) type,
        // perhaps to determine if the parent is a GraphQLObjectType or a
        // GraphQLInterfaceType. To obtain a reference to the parent, a
        // visitor method can have a second parameter, which will be an object
        // with an .objectType property referring to the parent.
        objectType: type
      });

      if (newField && newField.args) {
        updateEachKey(newField.args, function (arg) {
          return callMethod('visitArgumentDefinition', arg, {
            // Like visitFieldDefinition, visitArgumentDefinition takes a
            // second parameter that provides additional context, namely the
            // parent .field and grandparent .objectType. Remember that the
            // current GraphQLSchema is always available via this.schema.
            field: newField,
            objectType: type
          });
        });
      }

      return newField;
    });
  }

  visit(schema); // Return the original schema for convenience, even though it cannot have
  // been replaced or removed by the code above.

  return schema;
}

exports.visitSchema = visitSchema; // Update any references to named schema types that disagree with the named
// types found in schema.getTypeMap().

function healSchema(schema) {
  heal(schema);
  return schema;

  function heal(type) {
    if (type instanceof graphql_1.GraphQLSchema) {
      var originalTypeMap_1 = type.getTypeMap();
      var actualNamedTypeMap_1 = Object.create(null); // If any of the .name properties of the GraphQLNamedType objects in
      // schema.getTypeMap() have changed, the keys of the type map need to
      // be updated accordingly.

      each(originalTypeMap_1, function (namedType, typeName) {
        if (typeName.startsWith('__')) {
          return;
        }

        var actualName = namedType.name;

        if (actualName.startsWith('__')) {
          return;
        }

        if (hasOwn.call(actualNamedTypeMap_1, actualName)) {
          throw new Error("Duplicate schema type name " + actualName);
        }

        actualNamedTypeMap_1[actualName] = namedType; // Note: we are deliberately leaving namedType in the schema by its
        // original name (which might be different from actualName), so that
        // references by that name can be healed.
      }); // Now add back every named type by its actual name.

      each(actualNamedTypeMap_1, function (namedType, typeName) {
        originalTypeMap_1[typeName] = namedType;
      }); // Directive declaration argument types can refer to named types.

      each(type.getDirectives(), function (decl) {
        if (decl.args) {
          each(decl.args, function (arg) {
            arg.type = healType(arg.type);
          });
        }
      });
      each(originalTypeMap_1, function (namedType, typeName) {
        if (!typeName.startsWith('__')) {
          heal(namedType);
        }
      });
      updateEachKey(originalTypeMap_1, function (namedType, typeName) {
        // Dangling references to renamed types should remain in the schema
        // during healing, but must be removed now, so that the following
        // invariant holds for all names: schema.getType(name).name === name
        if (!typeName.startsWith('__') && !hasOwn.call(actualNamedTypeMap_1, typeName)) {
          return null;
        }
      });
    } else if (type instanceof graphql_1.GraphQLObjectType) {
      healFields(type);
      each(type.getInterfaces(), function (iface) {
        return heal(iface);
      });
    } else if (type instanceof graphql_1.GraphQLInterfaceType) {
      healFields(type);
    } else if (type instanceof graphql_1.GraphQLInputObjectType) {
      each(type.getFields(), function (field) {
        field.type = healType(field.type);
      });
    } else if (type instanceof graphql_1.GraphQLScalarType) {// Nothing to do.
    } else if (type instanceof graphql_1.GraphQLUnionType) {
      updateEachKey(type.getTypes(), function (t) {
        return healType(t);
      });
    } else if (type instanceof graphql_1.GraphQLEnumType) {// Nothing to do.
    } else {
      throw new Error("Unexpected schema type: " + type);
    }
  }

  function healFields(type) {
    each(type.getFields(), function (field) {
      field.type = healType(field.type);

      if (field.args) {
        each(field.args, function (arg) {
          arg.type = healType(arg.type);
        });
      }
    });
  }

  function healType(type) {
    // Unwrap the two known wrapper types
    if (type instanceof graphql_1.GraphQLList) {
      type = new graphql_1.GraphQLList(healType(type.ofType));
    } else if (type instanceof graphql_1.GraphQLNonNull) {
      type = new graphql_1.GraphQLNonNull(healType(type.ofType));
    } else if (graphql_1.isNamedType(type)) {
      // If a type annotation on a field or an argument or a union member is
      // any `GraphQLNamedType` with a `name`, then it must end up identical
      // to `schema.getType(name)`, since `schema.getTypeMap()` is the source
      // of truth for all named schema types.
      var namedType = type;
      var officialType = schema.getType(namedType.name);

      if (officialType && namedType !== officialType) {
        return officialType;
      }
    }

    return type;
  }
}

exports.healSchema = healSchema; // This class represents a reusable implementation of a @directive that may
// appear in a GraphQL schema written in Schema Definition Language.
//
// By overriding one or more visit{Object,Union,...} methods, a subclass
// registers interest in certain schema types, such as GraphQLObjectType,
// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is
// called with a GraphQLSchema object and a map of visitor subclasses, the
// overidden methods of those subclasses allow the visitors to obtain
// references to any type objects that have @directives attached to them,
// enabling visitors to inspect or modify the schema as appropriate.
//
// For example, if a directive called @rest(url: "...") appears after a field
// definition, a SchemaDirectiveVisitor subclass could provide meaning to that
// directive by overriding the visitFieldDefinition method (which receives a
// GraphQLField parameter), and then the body of that visitor method could
// manipulate the field's resolver function to fetch data from a REST endpoint
// described by the url argument passed to the @rest directive:
//
//   const typeDefs = `
//   type Query {
//     people: [Person] @rest(url: "/api/v1/people")
//   }`;
//
//   const schema = makeExecutableSchema({ typeDefs });
//
//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {
//     rest: class extends SchemaDirectiveVisitor {
//       public visitFieldDefinition(field: GraphQLField<any, any>) {
//         const { url } = this.args;
//         field.resolve = () => fetch(url);
//       }
//     }
//   });
//
// The subclass in this example is defined as an anonymous class expression,
// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be
// defined in a library using a named class declaration, and then exported for
// consumption by other modules and packages.
//
// See below for a complete list of overridable visitor methods, their
// parameter types, and more details about the properties exposed by instances
// of the SchemaDirectiveVisitor class.

var SchemaDirectiveVisitor =
/** @class */
function (_super) {
  __extends(SchemaDirectiveVisitor, _super); // Mark the constructor protected to enforce passing SchemaDirectiveVisitor
  // subclasses (not instances) to visitSchemaDirectives.


  function SchemaDirectiveVisitor(config) {
    var _this = _super.call(this) || this;

    _this.name = config.name;
    _this.args = config.args;
    _this.visitedType = config.visitedType;
    _this.schema = config.schema;
    _this.context = config.context;
    return _this;
  } // Override this method to return a custom GraphQLDirective (or modify one
  // already present in the schema) to enforce argument types, provide default
  // argument values, or specify schema locations where this @directive may
  // appear. By default, any declaration found in the schema will be returned.


  SchemaDirectiveVisitor.getDirectiveDeclaration = function (directiveName, schema) {
    return schema.getDirective(directiveName);
  }; // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every
  // @directive in the schema and create an appropriate SchemaDirectiveVisitor
  // instance to visit the object decorated by the @directive.


  SchemaDirectiveVisitor.visitSchemaDirectives = function (schema, directiveVisitors, // Optional context object that will be available to all visitor instances
  // via this.context. Defaults to an empty null-prototype object.
  context) {
    if (context === void 0) {
      context = Object.create(null);
    } // If the schema declares any directives for public consumption, record
    // them here so that we can properly coerce arguments when/if we encounter
    // an occurrence of the directive while walking the schema below.


    var declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors); // Map from directive names to lists of SchemaDirectiveVisitor instances
    // created while visiting the schema.

    var createdVisitors = Object.create(null);
    Object.keys(directiveVisitors).forEach(function (directiveName) {
      createdVisitors[directiveName] = [];
    });

    function visitorSelector(type, methodName) {
      var visitors = [];
      var directiveNodes = type.astNode && type.astNode.directives;

      if (!directiveNodes) {
        return visitors;
      }

      directiveNodes.forEach(function (directiveNode) {
        var directiveName = directiveNode.name.value;

        if (!hasOwn.call(directiveVisitors, directiveName)) {
          return;
        }

        var visitorClass = directiveVisitors[directiveName]; // Avoid creating visitor objects if visitorClass does not override
        // the visitor method named by methodName.

        if (!visitorClass.implementsVisitorMethod(methodName)) {
          return;
        }

        var decl = declaredDirectives[directiveName];
        var args;

        if (decl) {
          // If this directive was explicitly declared, use the declared
          // argument types (and any default values) to check, coerce, and/or
          // supply default values for the given arguments.
          args = values_1.getArgumentValues(decl, directiveNode);
        } else {
          // If this directive was not explicitly declared, just convert the
          // argument nodes to their corresponding JavaScript values.
          args = Object.create(null);
          directiveNode.arguments.forEach(function (arg) {
            args[arg.name.value] = valueFromASTUntyped(arg.value);
          });
        } // As foretold in comments near the top of the visitSchemaDirectives
        // method, this is where instances of the SchemaDirectiveVisitor class
        // get created and assigned names. While subclasses could override the
        // constructor method, the constructor is marked as protected, so
        // these are the only arguments that will ever be passed.


        visitors.push(new visitorClass({
          name: directiveName,
          args: args,
          visitedType: type,
          schema: schema,
          context: context
        }));
      });

      if (visitors.length > 0) {
        visitors.forEach(function (visitor) {
          createdVisitors[visitor.name].push(visitor);
        });
      }

      return visitors;
    }

    visitSchema(schema, visitorSelector); // Automatically update any references to named schema types replaced
    // during the traversal, so implementors don't have to worry about that.

    healSchema(schema);
    return createdVisitors;
  };

  SchemaDirectiveVisitor.getDeclaredDirectives = function (schema, directiveVisitors) {
    var declaredDirectives = Object.create(null);
    each(schema.getDirectives(), function (decl) {
      declaredDirectives[decl.name] = decl;
    }); // If the visitor subclass overrides getDirectiveDeclaration, and it
    // returns a non-null GraphQLDirective, use that instead of any directive
    // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor
    // goes to the trouble of implementing getDirectiveDeclaration, it should
    // be able to rely on that implementation.

    each(directiveVisitors, function (visitorClass, directiveName) {
      var decl = visitorClass.getDirectiveDeclaration(directiveName, schema);

      if (decl) {
        declaredDirectives[directiveName] = decl;
      }
    });
    each(declaredDirectives, function (decl, name) {
      if (!hasOwn.call(directiveVisitors, name)) {
        // SchemaDirectiveVisitors.visitSchemaDirectives might be called
        // multiple times with partial directiveVisitors maps, so it's not
        // necessarily an error for directiveVisitors to be missing an
        // implementation of a directive that was declared in the schema.
        return;
      }

      var visitorClass = directiveVisitors[name];
      each(decl.locations, function (loc) {
        var visitorMethodName = directiveLocationToVisitorMethodName(loc);

        if (SchemaVisitor.implementsVisitorMethod(visitorMethodName) && !visitorClass.implementsVisitorMethod(visitorMethodName)) {
          // While visitor subclasses may implement extra visitor methods,
          // it's definitely a mistake if the GraphQLDirective declares itself
          // applicable to certain schema locations, and the visitor subclass
          // does not implement all the corresponding methods.
          throw new Error("SchemaDirectiveVisitor for @" + name + " must implement " + visitorMethodName + " method");
        }
      });
    });
    return declaredDirectives;
  };

  return SchemaDirectiveVisitor;
}(SchemaVisitor);

exports.SchemaDirectiveVisitor = SchemaDirectiveVisitor; // Convert a string like "FIELD_DEFINITION" to "visitFieldDefinition".

function directiveLocationToVisitorMethodName(loc) {
  return 'visit' + loc.replace(/([^_]*)_?/g, function (wholeMatch, part) {
    return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();
  });
}

function each(arrayOrObject, callback) {
  Object.keys(arrayOrObject).forEach(function (key) {
    callback(arrayOrObject[key], key);
  });
} // A more powerful version of each that has the ability to replace or remove
// array or object keys.


function updateEachKey(arrayOrObject, // The callback can return nothing to leave the key untouched, null to remove
// the key from the array or object, or a non-null V to replace the value.
callback) {
  var deletedCount = 0;
  Object.keys(arrayOrObject).forEach(function (key) {
    var result = callback(arrayOrObject[key], key);

    if (typeof result === 'undefined') {
      return;
    }

    if (result === null) {
      delete arrayOrObject[key];
      deletedCount++;
      return;
    }

    arrayOrObject[key] = result;
  });

  if (deletedCount > 0 && Array.isArray(arrayOrObject)) {
    // Remove any holes from the array due to deleted elements.
    arrayOrObject.splice(0).forEach(function (elem) {
      arrayOrObject.push(elem);
    });
  }
} // Similar to the graphql-js function of the same name, slightly simplified:
// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js


function valueFromASTUntyped(valueNode) {
  switch (valueNode.kind) {
    case graphql_1.Kind.NULL:
      return null;

    case graphql_1.Kind.INT:
      return parseInt(valueNode.value, 10);

    case graphql_1.Kind.FLOAT:
      return parseFloat(valueNode.value);

    case graphql_1.Kind.STRING:
    case graphql_1.Kind.ENUM:
    case graphql_1.Kind.BOOLEAN:
      return valueNode.value;

    case graphql_1.Kind.LIST:
      return valueNode.values.map(valueFromASTUntyped);

    case graphql_1.Kind.OBJECT:
      var obj_1 = Object.create(null);
      valueNode.fields.forEach(function (field) {
        obj_1[field.name.value] = valueFromASTUntyped(field.value);
      });
      return obj_1;

    /* istanbul ignore next */

    default:
      throw new Error('Unexpected value kind: ' + valueNode.kind);
  }
}

/***/ }),
/* 71 */
/***/ (function(module, exports) {

/**
 * @module 101/is-function
 */

/**
 * Functional version of val typeof 'function'
 * @function module:101/is-function
 * @param {*} val - value checked to be a function
 * @return {boolean} Whether the value is a function or not
 */
module.exports = isFunction;

function isFunction(v) {
  return typeof v === 'function';
}

/***/ }),
/* 72 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return valueFromASTUntyped; });
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _jsutils_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
/* harmony import */ var _jsutils_isInvalid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2);






/**
 * Produces a JavaScript value given a GraphQL Value AST.
 *
 * Unlike `valueFromAST()`, no type is provided. The resulting JavaScript value
 * will reflect the provided GraphQL value AST.
 *
 * | GraphQL Value        | JavaScript Value |
 * | -------------------- | ---------------- |
 * | Input Object         | Object           |
 * | List                 | Array            |
 * | Boolean              | Boolean          |
 * | String / Enum        | String           |
 * | Int / Float          | Number           |
 * | Null                 | null             |
 *
 */
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case _language_kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].NULL:
      return null;

    case _language_kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].INT:
      return parseInt(valueNode.value, 10);

    case _language_kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].FLOAT:
      return parseFloat(valueNode.value);

    case _language_kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].STRING:
    case _language_kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].ENUM:
    case _language_kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].BOOLEAN:
      return valueNode.value;

    case _language_kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].LIST:
      return valueNode.values.map(function (node) {
        return valueFromASTUntyped(node, variables);
      });

    case _language_kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].OBJECT:
      return Object(_jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(valueNode.fields, function (field) {
        return field.name.value;
      }, function (field) {
        return valueFromASTUntyped(field.value, variables);
      });

    case _language_kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].VARIABLE:
      {
        var variableName = valueNode.name.value;
        return variables && !Object(_jsutils_isInvalid__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(variables[variableName]) ? variables[variableName] : undefined;
      }
  } // Not reachable. All possible value nodes have been considered.


  /* istanbul ignore next */
  Object(_jsutils_invariant__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(false, 'Unexpected value node: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(valueNode));
}


/***/ }),
/* 73 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return coerceValue; });
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _jsutils_printPathArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _jsutils_Path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _coerceInputValue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(52);
/* istanbul ignore file */






/**
 * Deprecated. Use coerceInputValue() directly for richer information.
 *
 * This function will be removed in v15
 */
function coerceValue(inputValue, type, blameNode, path) {
  var errors = [];
  var value = Object(_coerceInputValue__WEBPACK_IMPORTED_MODULE_4__[/* coerceInputValue */ "a"])(inputValue, type, function (errorPath, invalidValue, error) {
    var errorPrefix = 'Invalid value ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(invalidValue);
    var pathArray = [].concat(Object(_jsutils_Path__WEBPACK_IMPORTED_MODULE_2__[/* pathToArray */ "b"])(path), errorPath);

    if (pathArray.length > 0) {
      errorPrefix += " at \"value".concat(Object(_jsutils_printPathArray__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(pathArray), "\"");
    }

    errors.push(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_3__[/* GraphQLError */ "a"](errorPrefix + ': ' + error.message, blameNode, undefined, undefined, undefined, error.originalError));
  });
  return errors.length > 0 ? {
    errors: errors,
    value: undefined
  } : {
    errors: undefined,
    value: value
  };
}


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

__export(__webpack_require__(59));

__export(__webpack_require__(185));

__export(__webpack_require__(189));

__export(__webpack_require__(124));

var schemaVisitor_1 = __webpack_require__(70);

exports.SchemaDirectiveVisitor = schemaVisitor_1.SchemaDirectiveVisitor;

/***/ }),
/* 75 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isNullish; });
/**
 * Returns true if a value is null, undefined, or NaN.
 */
function isNullish(value) {
  return value === null || value === undefined || value !== value;
}


/***/ }),
/* 76 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export badValueMessage */
/* unused harmony export badEnumValueMessage */
/* unused harmony export requiredFieldMessage */
/* unused harmony export unknownFieldMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ValuesOfCorrectType; });
/* harmony import */ var _polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _jsutils_isInvalid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony import */ var _jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26);
/* harmony import */ var _jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(29);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4);
/* harmony import */ var _language_printer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(16);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(0);









function badValueMessage(typeName, valueName, message) {
  return "Expected type ".concat(typeName, ", found ").concat(valueName) + (message ? "; ".concat(message) : '.');
}
function badEnumValueMessage(typeName, valueName, suggestedValues) {
  return "Expected type ".concat(typeName, ", found ").concat(valueName, ".") + Object(_jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])('the enum value', suggestedValues);
}
function requiredFieldMessage(typeName, fieldName, fieldTypeName) {
  return "Field ".concat(typeName, ".").concat(fieldName, " of required type ").concat(fieldTypeName, " was not provided.");
}
function unknownFieldMessage(typeName, fieldName, suggestedFields) {
  return "Field \"".concat(fieldName, "\" is not defined by type ").concat(typeName, ".") + Object(_jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(suggestedFields);
}
/**
 * Value literals of correct type
 *
 * A GraphQL document is only valid if all value literals are of the type
 * expected at their position.
 */

function ValuesOfCorrectType(context) {
  return {
    NullValue: function NullValue(node) {
      var type = context.getInputType();

      if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_8__[/* isNonNullType */ "L"])(type)) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLError */ "a"](badValueMessage(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(type), Object(_language_printer__WEBPACK_IMPORTED_MODULE_7__[/* print */ "a"])(node)), node));
      }
    },
    ListValue: function ListValue(node) {
      // Note: TypeInfo will traverse into a list's item type, so look to the
      // parent input type to check if it is a list.
      var type = Object(_type_definition__WEBPACK_IMPORTED_MODULE_8__[/* getNullableType */ "B"])(context.getParentInputType());

      if (!Object(_type_definition__WEBPACK_IMPORTED_MODULE_8__[/* isListType */ "J"])(type)) {
        isValidScalar(context, node);
        return false; // Don't traverse further.
      }
    },
    ObjectValue: function ObjectValue(node) {
      var type = Object(_type_definition__WEBPACK_IMPORTED_MODULE_8__[/* getNamedType */ "A"])(context.getInputType());

      if (!Object(_type_definition__WEBPACK_IMPORTED_MODULE_8__[/* isInputObjectType */ "F"])(type)) {
        isValidScalar(context, node);
        return false; // Don't traverse further.
      } // Ensure every required field exists.


      var fieldNodeMap = Object(_jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(node.fields, function (field) {
        return field.name.value;
      });

      for (var _i2 = 0, _objectValues2 = Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(type.getFields()); _i2 < _objectValues2.length; _i2++) {
        var fieldDef = _objectValues2[_i2];
        var fieldNode = fieldNodeMap[fieldDef.name];

        if (!fieldNode && Object(_type_definition__WEBPACK_IMPORTED_MODULE_8__[/* isRequiredInputField */ "Q"])(fieldDef)) {
          var typeStr = Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(fieldDef.type);
          context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLError */ "a"](requiredFieldMessage(type.name, fieldDef.name, typeStr), node));
        }
      }
    },
    ObjectField: function ObjectField(node) {
      var parentType = Object(_type_definition__WEBPACK_IMPORTED_MODULE_8__[/* getNamedType */ "A"])(context.getParentInputType());
      var fieldType = context.getInputType();

      if (!fieldType && Object(_type_definition__WEBPACK_IMPORTED_MODULE_8__[/* isInputObjectType */ "F"])(parentType)) {
        var suggestions = Object(_jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(node.name.value, Object.keys(parentType.getFields()));
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLError */ "a"](unknownFieldMessage(parentType.name, node.name.value, suggestions), node));
      }
    },
    EnumValue: function EnumValue(node) {
      var type = Object(_type_definition__WEBPACK_IMPORTED_MODULE_8__[/* getNamedType */ "A"])(context.getInputType());

      if (!Object(_type_definition__WEBPACK_IMPORTED_MODULE_8__[/* isEnumType */ "E"])(type)) {
        isValidScalar(context, node);
      } else if (!type.getValue(node.value)) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLError */ "a"](badEnumValueMessage(type.name, Object(_language_printer__WEBPACK_IMPORTED_MODULE_7__[/* print */ "a"])(node), enumTypeSuggestion(type, node)), node));
      }
    },
    IntValue: function IntValue(node) {
      return isValidScalar(context, node);
    },
    FloatValue: function FloatValue(node) {
      return isValidScalar(context, node);
    },
    StringValue: function StringValue(node) {
      return isValidScalar(context, node);
    },
    BooleanValue: function BooleanValue(node) {
      return isValidScalar(context, node);
    }
  };
}
/**
 * Any value literal may be a valid representation of a Scalar, depending on
 * that scalar type.
 */

function isValidScalar(context, node) {
  // Report any error at the full type expected by the location.
  var locationType = context.getInputType();

  if (!locationType) {
    return;
  }

  var type = Object(_type_definition__WEBPACK_IMPORTED_MODULE_8__[/* getNamedType */ "A"])(locationType);

  if (!Object(_type_definition__WEBPACK_IMPORTED_MODULE_8__[/* isScalarType */ "R"])(type)) {
    var message = Object(_type_definition__WEBPACK_IMPORTED_MODULE_8__[/* isEnumType */ "E"])(type) ? badEnumValueMessage(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(locationType), Object(_language_printer__WEBPACK_IMPORTED_MODULE_7__[/* print */ "a"])(node), enumTypeSuggestion(type, node)) : badValueMessage(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(locationType), Object(_language_printer__WEBPACK_IMPORTED_MODULE_7__[/* print */ "a"])(node));
    context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLError */ "a"](message, node));
    return;
  } // Scalars determine if a literal value is valid via parseLiteral() which
  // may throw or return an invalid value to indicate failure.


  try {
    var parseResult = type.parseLiteral(node, undefined
    /* variables */
    );

    if (Object(_jsutils_isInvalid__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(parseResult)) {
      context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLError */ "a"](badValueMessage(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(locationType), Object(_language_printer__WEBPACK_IMPORTED_MODULE_7__[/* print */ "a"])(node)), node));
    }
  } catch (error) {
    // Ensure a reference to the original error is maintained.
    context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLError */ "a"](badValueMessage(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(locationType), Object(_language_printer__WEBPACK_IMPORTED_MODULE_7__[/* print */ "a"])(node), error.message), node, undefined, undefined, undefined, error));
  }
}

function enumTypeSuggestion(type, node) {
  var allNames = type.getValues().map(function (value) {
    return value.name;
  });
  return Object(_jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(Object(_language_printer__WEBPACK_IMPORTED_MODULE_7__[/* print */ "a"])(node), allNames);
}


/***/ }),
/* 77 */
/***/ (function(module, exports) {

var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

function applySchemaTransforms(originalSchema, transforms) {
  return transforms.reduce(function (schema, transform) {
    return transform.transformSchema ? transform.transformSchema(schema) : schema;
  }, originalSchema);
}

exports.applySchemaTransforms = applySchemaTransforms;

function applyRequestTransforms(originalRequest, transforms) {
  return transforms.reduce(function (request, transform) {
    return transform.transformRequest ? transform.transformRequest(request) : request;
  }, originalRequest);
}

exports.applyRequestTransforms = applyRequestTransforms;

function applyResultTransforms(originalResult, transforms) {
  return transforms.reduce(function (result, transform) {
    return transform.transformResult ? transform.transformResult(result) : result;
  }, originalResult);
}

exports.applyResultTransforms = applyResultTransforms;

function composeTransforms() {
  var transforms = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    transforms[_i] = arguments[_i];
  }

  var reverseTransforms = __spreadArrays(transforms).reverse();

  return {
    transformSchema: function transformSchema(originalSchema) {
      return applySchemaTransforms(originalSchema, transforms);
    },
    transformRequest: function transformRequest(originalRequest) {
      return applyRequestTransforms(originalRequest, reverseTransforms);
    },
    transformResult: function transformResult(result) {
      return applyResultTransforms(result, reverseTransforms);
    }
  };
}

exports.composeTransforms = composeTransforms;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

function resolveFromParentTypename(parent, schema) {
  var parentTypename = parent['__typename'];

  if (!parentTypename) {
    throw new Error('Did not fetch typename for object, unable to resolve interface.');
  }

  var resolvedType = schema.getType(parentTypename);

  if (!(resolvedType instanceof graphql_1.GraphQLObjectType)) {
    throw new Error('__typename did not match an object type: ' + parentTypename);
  }

  return resolvedType;
}

exports.default = resolveFromParentTypename;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var error_1 = __webpack_require__(80);

var errors_1 = __webpack_require__(81);

var getResponseKeyFromInfo_1 = __webpack_require__(110); // Resolver that knows how to:
// a) handle aliases for proxied schemas
// b) handle errors from proxied schemas


var defaultMergedResolver = function defaultMergedResolver(parent, args, context, info) {
  if (!parent) {
    return null;
  }

  var responseKey = getResponseKeyFromInfo_1.getResponseKeyFromInfo(info);
  var errorResult = errors_1.getErrorsFromParent(parent, responseKey);

  if (errorResult.kind === 'OWN') {
    throw error_1.locatedError(new Error(errorResult.error.message), info.fieldNodes, graphql_1.responsePathAsArray(info.path));
  }

  var result = parent[responseKey];

  if (result == null) {
    result = parent[info.fieldName];
  } // subscription result mapping


  if (!result && parent.data && parent.data[responseKey]) {
    result = parent.data[responseKey];
  }

  if (errorResult.errors) {
    result = errors_1.annotateWithChildrenErrors(result, errorResult.errors);
  }

  return result;
};

exports.default = defaultMergedResolver;

/***/ }),
/* 80 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GraphQLError", function() { return _GraphQLError__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "printError", function() { return _GraphQLError__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony import */ var _syntaxError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "syntaxError", function() { return _syntaxError__WEBPACK_IMPORTED_MODULE_1__["a"]; });

/* harmony import */ var _locatedError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(54);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "locatedError", function() { return _locatedError__WEBPACK_IMPORTED_MODULE_2__["a"]; });

/* harmony import */ var _formatError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatError", function() { return _formatError__WEBPACK_IMPORTED_MODULE_3__["a"]; });







/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = this && this.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var error_1 = __webpack_require__(80);

var getResponseKeyFromInfo_1 = __webpack_require__(110);

if (typeof global !== 'undefined' && 'Symbol' in global || typeof window !== 'undefined' && 'Symbol' in window) {
  exports.ERROR_SYMBOL = Symbol('subSchemaErrors');
} else {
  exports.ERROR_SYMBOL = '@@__subSchemaErrors';
}

function annotateWithChildrenErrors(object, childrenErrors) {
  var _a;

  if (!childrenErrors || childrenErrors.length === 0) {
    // Nothing to see here, move along
    return object;
  }

  if (Array.isArray(object)) {
    var byIndex_1 = {};
    childrenErrors.forEach(function (error) {
      if (!error.path) {
        return;
      }

      var index = error.path[1];
      var current = byIndex_1[index] || [];
      current.push(__assign(__assign({}, error), {
        path: error.path.slice(1)
      }));
      byIndex_1[index] = current;
    });
    return object.map(function (item, index) {
      return annotateWithChildrenErrors(item, byIndex_1[index]);
    });
  }

  return __assign(__assign({}, object), (_a = {}, _a[exports.ERROR_SYMBOL] = childrenErrors.map(function (error) {
    return __assign(__assign({}, error), error.path ? {
      path: error.path.slice(1)
    } : {});
  }), _a));
}

exports.annotateWithChildrenErrors = annotateWithChildrenErrors;

function getErrorsFromParent(object, fieldName) {
  var errors = object && object[exports.ERROR_SYMBOL] || [];
  var childrenErrors = [];

  for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
    var error = errors_1[_i];

    if (!error.path || error.path.length === 1 && error.path[0] === fieldName) {
      return {
        kind: 'OWN',
        error: error
      };
    } else if (error.path[0] === fieldName) {
      childrenErrors.push(error);
    }
  }

  return {
    kind: 'CHILDREN',
    errors: childrenErrors
  };
}

exports.getErrorsFromParent = getErrorsFromParent;

var CombinedError =
/** @class */
function (_super) {
  __extends(CombinedError, _super);

  function CombinedError(message, errors) {
    var _this = _super.call(this, message) || this;

    _this.errors = errors;
    return _this;
  }

  return CombinedError;
}(Error);

function checkResultAndHandleErrors(result, info, responseKey) {
  if (!responseKey) {
    responseKey = getResponseKeyFromInfo_1.getResponseKeyFromInfo(info);
  }

  if (result.errors && (!result.data || result.data[responseKey] == null)) {
    // apollo-link-http & http-link-dataloader need the
    // result property to be passed through for better error handling.
    // If there is only one error, which contains a result property, pass the error through
    var newError = result.errors.length === 1 && hasResult(result.errors[0]) ? result.errors[0] : new CombinedError(concatErrors(result.errors), result.errors);
    throw error_1.locatedError(newError, info.fieldNodes, graphql_1.responsePathAsArray(info.path));
  }

  var resultObject = result.data[responseKey];

  if (result.errors) {
    resultObject = annotateWithChildrenErrors(resultObject, result.errors);
  }

  return resultObject;
}

exports.checkResultAndHandleErrors = checkResultAndHandleErrors;

function concatErrors(errors) {
  return errors.map(function (error) {
    return error.message;
  }).join('\n');
}

function hasResult(error) {
  return error.result || error.extensions || error.originalError && error.originalError.result;
}

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var transforms_1 = __webpack_require__(77);

var AddArgumentsAsVariables_1 = __webpack_require__(117);

var FilterToSchema_1 = __webpack_require__(118);

var AddTypenameToAbstract_1 = __webpack_require__(120);

var CheckResultAndHandleErrors_1 = __webpack_require__(121);

var mapAsyncIterator_1 = __webpack_require__(195);

var ExpandAbstractTypes_1 = __webpack_require__(122);

var ReplaceFieldWithFragment_1 = __webpack_require__(123);

var ConvertEnumResponse_1 = __webpack_require__(196);

function delegateToSchema(options) {
  var args = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }

  if (options instanceof graphql_1.GraphQLSchema) {
    throw new Error('Passing positional arguments to delegateToSchema is a deprecated. ' + 'Please pass named parameters instead.');
  }

  return delegateToSchemaImplementation(options);
}

exports.default = delegateToSchema;

function delegateToSchemaImplementation(options) {
  return __awaiter(this, void 0, void 0, function () {
    var info, _a, args, operation, rawDocument, rawRequest, transforms, processedRequest, errors, _b, executionResult;

    return __generator(this, function (_c) {
      switch (_c.label) {
        case 0:
          info = options.info, _a = options.args, args = _a === void 0 ? {} : _a;
          operation = options.operation || info.operation.operation;
          rawDocument = createDocument(options.fieldName, operation, info.fieldNodes, Object.keys(info.fragments).map(function (fragmentName) {
            return info.fragments[fragmentName];
          }), info.operation.variableDefinitions, info.operation.name);
          rawRequest = {
            document: rawDocument,
            variables: info.variableValues
          };
          transforms = __spreadArrays(options.transforms || [], [new ExpandAbstractTypes_1.default(info.schema, options.schema)]);

          if (info.mergeInfo && info.mergeInfo.fragments) {
            transforms.push(new ReplaceFieldWithFragment_1.default(options.schema, info.mergeInfo.fragments));
          }

          transforms = transforms.concat([new AddArgumentsAsVariables_1.default(options.schema, args), new FilterToSchema_1.default(options.schema), new AddTypenameToAbstract_1.default(options.schema), new CheckResultAndHandleErrors_1.default(info, options.fieldName)]);

          if (graphql_1.isEnumType(options.info.returnType)) {
            transforms = transforms.concat(new ConvertEnumResponse_1.default(options.info.returnType));
          }

          processedRequest = transforms_1.applyRequestTransforms(rawRequest, transforms);

          if (!options.skipValidation) {
            errors = graphql_1.validate(options.schema, processedRequest.document);

            if (errors.length > 0) {
              throw errors;
            }
          }

          if (!(operation === 'query' || operation === 'mutation')) return [3
          /*break*/
          , 2];
          _b = transforms_1.applyResultTransforms;
          return [4
          /*yield*/
          , graphql_1.execute(options.schema, processedRequest.document, info.rootValue, options.context, processedRequest.variables)];

        case 1:
          return [2
          /*return*/
          , _b.apply(void 0, [_c.sent(), transforms])];

        case 2:
          if (!(operation === 'subscription')) return [3
          /*break*/
          , 4];
          return [4
          /*yield*/
          , graphql_1.subscribe(options.schema, processedRequest.document, info.rootValue, options.context, processedRequest.variables)];

        case 3:
          executionResult = _c.sent(); // "subscribe" to the subscription result and map the result through the transforms

          return [2
          /*return*/
          , mapAsyncIterator_1.default(executionResult, function (result) {
            var _a;

            var transformedResult = transforms_1.applyResultTransforms(result, transforms);
            var subscriptionKey = Object.keys(result.data)[0]; // for some reason the returned transformedResult needs to be nested inside the root subscription field
            // does not work otherwise...

            return _a = {}, _a[subscriptionKey] = transformedResult, _a;
          })];

        case 4:
          return [2
          /*return*/
          ];
      }
    });
  });
}

function createDocument(targetField, targetOperation, originalSelections, fragments, variables, operationName) {
  var selections = [];
  var args = [];
  originalSelections.forEach(function (field) {
    var fieldSelections = field.selectionSet ? field.selectionSet.selections : [];
    selections = selections.concat(fieldSelections);
    args = args.concat(field.arguments || []);
  });
  var selectionSet = null;

  if (selections.length > 0) {
    selectionSet = {
      kind: graphql_1.Kind.SELECTION_SET,
      selections: selections
    };
  }

  var rootField = {
    kind: graphql_1.Kind.FIELD,
    alias: null,
    arguments: args,
    selectionSet: selectionSet,
    name: {
      kind: graphql_1.Kind.NAME,
      value: targetField
    }
  };
  var rootSelectionSet = {
    kind: graphql_1.Kind.SELECTION_SET,
    selections: [rootField]
  };
  var operationDefinition = {
    kind: graphql_1.Kind.OPERATION_DEFINITION,
    operation: targetOperation,
    variableDefinitions: variables,
    selectionSet: rootSelectionSet,
    name: operationName
  };
  return {
    kind: graphql_1.Kind.DOCUMENT,
    definitions: __spreadArrays([operationDefinition], fragments)
  };
}

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var isEmptyObject_1 = __webpack_require__(115);

var visitSchema_1 = __webpack_require__(61);

var schemaRecreation_1 = __webpack_require__(62);

var TransformRootFields =
/** @class */
function () {
  function TransformRootFields(transform) {
    this.transform = transform;
  }

  TransformRootFields.prototype.transformSchema = function (originalSchema) {
    var _a;

    var _this = this;

    return visitSchema_1.visitSchema(originalSchema, (_a = {}, _a[visitSchema_1.VisitSchemaKind.QUERY] = function (type) {
      return transformFields(type, function (fieldName, field) {
        return _this.transform('Query', fieldName, field);
      });
    }, _a[visitSchema_1.VisitSchemaKind.MUTATION] = function (type) {
      return transformFields(type, function (fieldName, field) {
        return _this.transform('Mutation', fieldName, field);
      });
    }, _a[visitSchema_1.VisitSchemaKind.SUBSCRIPTION] = function (type) {
      return transformFields(type, function (fieldName, field) {
        return _this.transform('Subscription', fieldName, field);
      });
    }, _a));
  };

  return TransformRootFields;
}();

exports.default = TransformRootFields;

function transformFields(type, transformer) {
  var resolveType = schemaRecreation_1.createResolveType(function (name, originalType) {
    return originalType;
  });
  var fields = type.getFields();
  var newFields = {};
  Object.keys(fields).forEach(function (fieldName) {
    var field = fields[fieldName];
    var newField = transformer(fieldName, field);

    if (typeof newField === 'undefined') {
      newFields[fieldName] = schemaRecreation_1.fieldToFieldConfig(field, resolveType, true);
    } else if (newField !== null) {
      if (newField.name) {
        newFields[newField.name] = newField.field;
      } else {
        newFields[fieldName] = newField;
      }
    }
  });

  if (isEmptyObject_1.default(newFields)) {
    return null;
  } else {
    return new graphql_1.GraphQLObjectType({
      name: type.name,
      description: type.description,
      astNode: type.astNode,
      fields: newFields
    });
  }
}

/***/ }),
/* 84 */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Functional version of a strict object check (Arrays and RegExps are not objects)
 * @module 101/is-object
 */

/**
 * @function module:101/is-object
 * @param {*} val - value checked to be an object
 * @return {boolean} Whether the value is an object or not
 */
var exists = __webpack_require__(132);

module.exports = isObject;

function isObject(val) {
  return typeof val === 'object' && exists(val) && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof String) && !(val instanceof Number);
}

/***/ }),
/* 86 */
/***/ (function(module, exports) {

/**
 * @module 101/is-string
 */

/**
 * Functional version of val typeof 'string'
 * @function module:101/is-string
 * @param {*} val - value checked to be a string
 * @return {boolean} Whether the value is an string or not
 */
module.exports = isString;

function isString(val) {
  return typeof val === 'string' || val instanceof String;
}

/***/ }),
/* 87 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return printLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return printSourceLocation; });
/* harmony import */ var _language_location__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66);

/**
 * Render a helpful description of the location in the GraphQL Source document.
 */

function printLocation(location) {
  return printSourceLocation(location.source, Object(_language_location__WEBPACK_IMPORTED_MODULE_0__[/* getLocation */ "a"])(location.source, location.start));
}
/**
 * Render a helpful description of the location in the GraphQL Source document.
 */

function printSourceLocation(source, sourceLocation) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = sourceLocation.line - 1;
  var lineOffset = source.locationOffset.line - 1;
  var lineNum = sourceLocation.line + lineOffset;
  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  var columnNum = sourceLocation.column + columnOffset;
  var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
  var lines = body.split(/\r\n|[\n\r]/g);
  var locationLine = lines[lineIndex]; // Special case for minified documents

  if (locationLine.length > 120) {
    var sublineIndex = Math.floor(columnNum / 80);
    var sublineColumnNum = columnNum % 80;
    var sublines = [];

    for (var i = 0; i < locationLine.length; i += 80) {
      sublines.push(locationLine.slice(i, i + 80));
    }

    return locationStr + printPrefixedLines([["".concat(lineNum), sublines[0]]].concat(sublines.slice(1, sublineIndex + 1).map(function (subline) {
      return ['', subline];
    }), [[' ', whitespace(sublineColumnNum - 1) + '^'], ['', sublines[sublineIndex + 1]]]));
  }

  return locationStr + printPrefixedLines([// Lines specified like this: ["prefix", "string"],
  ["".concat(lineNum - 1), lines[lineIndex - 1]], ["".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], ["".concat(lineNum + 1), lines[lineIndex + 1]]]);
}

function printPrefixedLines(lines) {
  var existingLines = lines.filter(function (_ref) {
    var _ = _ref[0],
        line = _ref[1];
    return line !== undefined;
  });
  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {
    var prefix = _ref2[0];
    return prefix.length;
  }));
  return existingLines.map(function (_ref3) {
    var prefix = _ref3[0],
        line = _ref3[1];
    return lpad(padLen, prefix) + (line ? ' | ' + line : ' |');
  }).join('\n');
}

function whitespace(len) {
  return Array(len + 1).join(' ');
}

function lpad(len, str) {
  return whitespace(len - str.length) + str;
}


/***/ }),
/* 88 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return specifiedRules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return specifiedSDLRules; });
/* harmony import */ var _rules_ExecutableDefinitions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(137);
/* harmony import */ var _rules_UniqueOperationNames__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(138);
/* harmony import */ var _rules_LoneAnonymousOperation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(139);
/* harmony import */ var _rules_SingleFieldSubscriptions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(140);
/* harmony import */ var _rules_KnownTypeNames__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89);
/* harmony import */ var _rules_FragmentsOnCompositeTypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(141);
/* harmony import */ var _rules_VariablesAreInputTypes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(142);
/* harmony import */ var _rules_ScalarLeafs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(143);
/* harmony import */ var _rules_FieldsOnCorrectType__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(144);
/* harmony import */ var _rules_UniqueFragmentNames__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(145);
/* harmony import */ var _rules_KnownFragmentNames__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(146);
/* harmony import */ var _rules_NoUnusedFragments__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(147);
/* harmony import */ var _rules_PossibleFragmentSpreads__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(148);
/* harmony import */ var _rules_NoFragmentCycles__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(149);
/* harmony import */ var _rules_UniqueVariableNames__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(150);
/* harmony import */ var _rules_NoUndefinedVariables__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(151);
/* harmony import */ var _rules_NoUnusedVariables__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(152);
/* harmony import */ var _rules_KnownDirectives__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(90);
/* harmony import */ var _rules_UniqueDirectivesPerLocation__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(91);
/* harmony import */ var _rules_KnownArgumentNames__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(92);
/* harmony import */ var _rules_UniqueArgumentNames__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(93);
/* harmony import */ var _rules_ValuesOfCorrectType__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(76);
/* harmony import */ var _rules_ProvidedRequiredArguments__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(94);
/* harmony import */ var _rules_VariablesInAllowedPosition__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(153);
/* harmony import */ var _rules_OverlappingFieldsCanBeMerged__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(154);
/* harmony import */ var _rules_UniqueInputFieldNames__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(95);
/* harmony import */ var _rules_LoneSchemaDefinition__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(155);
/* harmony import */ var _rules_UniqueOperationTypes__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(156);
/* harmony import */ var _rules_UniqueTypeNames__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(157);
/* harmony import */ var _rules_UniqueEnumValueNames__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(158);
/* harmony import */ var _rules_UniqueFieldDefinitionNames__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(159);
/* harmony import */ var _rules_UniqueDirectiveNames__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(160);
/* harmony import */ var _rules_PossibleTypeExtensions__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(161);
// Spec Section: "Executable Definitions"
 // Spec Section: "Operation Name Uniqueness"

 // Spec Section: "Lone Anonymous Operation"

 // Spec Section: "Subscriptions with Single Root Field"

 // Spec Section: "Fragment Spread Type Existence"

 // Spec Section: "Fragments on Composite Types"

 // Spec Section: "Variables are Input Types"

 // Spec Section: "Leaf Field Selections"

 // Spec Section: "Field Selections on Objects, Interfaces, and Unions Types"

 // Spec Section: "Fragment Name Uniqueness"

 // Spec Section: "Fragment spread target defined"

 // Spec Section: "Fragments must be used"

 // Spec Section: "Fragment spread is possible"

 // Spec Section: "Fragments must not form cycles"

 // Spec Section: "Variable Uniqueness"

 // Spec Section: "All Variable Used Defined"

 // Spec Section: "All Variables Used"

 // Spec Section: "Directives Are Defined"

 // Spec Section: "Directives Are Unique Per Location"

 // Spec Section: "Argument Names"

 // Spec Section: "Argument Uniqueness"

 // Spec Section: "Value Type Correctness"

 // Spec Section: "Argument Optionality"

 // Spec Section: "All Variable Usages Are Allowed"

 // Spec Section: "Field Selection Merging"

 // Spec Section: "Input Object Field Uniqueness"


/**
 * This set includes all validation rules defined by the GraphQL spec.
 *
 * The order of the rules in this list has been adjusted to lead to the
 * most clear output when encountering multiple validation errors.
 */

var specifiedRules = Object.freeze([_rules_ExecutableDefinitions__WEBPACK_IMPORTED_MODULE_0__[/* ExecutableDefinitions */ "a"], _rules_UniqueOperationNames__WEBPACK_IMPORTED_MODULE_1__[/* UniqueOperationNames */ "a"], _rules_LoneAnonymousOperation__WEBPACK_IMPORTED_MODULE_2__[/* LoneAnonymousOperation */ "a"], _rules_SingleFieldSubscriptions__WEBPACK_IMPORTED_MODULE_3__[/* SingleFieldSubscriptions */ "a"], _rules_KnownTypeNames__WEBPACK_IMPORTED_MODULE_4__[/* KnownTypeNames */ "a"], _rules_FragmentsOnCompositeTypes__WEBPACK_IMPORTED_MODULE_5__[/* FragmentsOnCompositeTypes */ "a"], _rules_VariablesAreInputTypes__WEBPACK_IMPORTED_MODULE_6__[/* VariablesAreInputTypes */ "a"], _rules_ScalarLeafs__WEBPACK_IMPORTED_MODULE_7__[/* ScalarLeafs */ "a"], _rules_FieldsOnCorrectType__WEBPACK_IMPORTED_MODULE_8__[/* FieldsOnCorrectType */ "a"], _rules_UniqueFragmentNames__WEBPACK_IMPORTED_MODULE_9__[/* UniqueFragmentNames */ "a"], _rules_KnownFragmentNames__WEBPACK_IMPORTED_MODULE_10__[/* KnownFragmentNames */ "a"], _rules_NoUnusedFragments__WEBPACK_IMPORTED_MODULE_11__[/* NoUnusedFragments */ "a"], _rules_PossibleFragmentSpreads__WEBPACK_IMPORTED_MODULE_12__[/* PossibleFragmentSpreads */ "a"], _rules_NoFragmentCycles__WEBPACK_IMPORTED_MODULE_13__[/* NoFragmentCycles */ "a"], _rules_UniqueVariableNames__WEBPACK_IMPORTED_MODULE_14__[/* UniqueVariableNames */ "a"], _rules_NoUndefinedVariables__WEBPACK_IMPORTED_MODULE_15__[/* NoUndefinedVariables */ "a"], _rules_NoUnusedVariables__WEBPACK_IMPORTED_MODULE_16__[/* NoUnusedVariables */ "a"], _rules_KnownDirectives__WEBPACK_IMPORTED_MODULE_17__[/* KnownDirectives */ "a"], _rules_UniqueDirectivesPerLocation__WEBPACK_IMPORTED_MODULE_18__[/* UniqueDirectivesPerLocation */ "a"], _rules_KnownArgumentNames__WEBPACK_IMPORTED_MODULE_19__[/* KnownArgumentNames */ "a"], _rules_UniqueArgumentNames__WEBPACK_IMPORTED_MODULE_20__[/* UniqueArgumentNames */ "a"], _rules_ValuesOfCorrectType__WEBPACK_IMPORTED_MODULE_21__[/* ValuesOfCorrectType */ "a"], _rules_ProvidedRequiredArguments__WEBPACK_IMPORTED_MODULE_22__[/* ProvidedRequiredArguments */ "a"], _rules_VariablesInAllowedPosition__WEBPACK_IMPORTED_MODULE_23__[/* VariablesInAllowedPosition */ "a"], _rules_OverlappingFieldsCanBeMerged__WEBPACK_IMPORTED_MODULE_24__[/* OverlappingFieldsCanBeMerged */ "a"], _rules_UniqueInputFieldNames__WEBPACK_IMPORTED_MODULE_25__[/* UniqueInputFieldNames */ "a"]]);






 // @internal

var specifiedSDLRules = Object.freeze([_rules_LoneSchemaDefinition__WEBPACK_IMPORTED_MODULE_26__[/* LoneSchemaDefinition */ "a"], _rules_UniqueOperationTypes__WEBPACK_IMPORTED_MODULE_27__[/* UniqueOperationTypes */ "a"], _rules_UniqueTypeNames__WEBPACK_IMPORTED_MODULE_28__[/* UniqueTypeNames */ "a"], _rules_UniqueEnumValueNames__WEBPACK_IMPORTED_MODULE_29__[/* UniqueEnumValueNames */ "a"], _rules_UniqueFieldDefinitionNames__WEBPACK_IMPORTED_MODULE_30__[/* UniqueFieldDefinitionNames */ "a"], _rules_UniqueDirectiveNames__WEBPACK_IMPORTED_MODULE_31__[/* UniqueDirectiveNames */ "a"], _rules_KnownTypeNames__WEBPACK_IMPORTED_MODULE_4__[/* KnownTypeNames */ "a"], _rules_KnownDirectives__WEBPACK_IMPORTED_MODULE_17__[/* KnownDirectives */ "a"], _rules_UniqueDirectivesPerLocation__WEBPACK_IMPORTED_MODULE_18__[/* UniqueDirectivesPerLocation */ "a"], _rules_PossibleTypeExtensions__WEBPACK_IMPORTED_MODULE_32__[/* PossibleTypeExtensions */ "a"], _rules_KnownArgumentNames__WEBPACK_IMPORTED_MODULE_19__[/* KnownArgumentNamesOnDirectives */ "b"], _rules_UniqueArgumentNames__WEBPACK_IMPORTED_MODULE_20__[/* UniqueArgumentNames */ "a"], _rules_UniqueInputFieldNames__WEBPACK_IMPORTED_MODULE_25__[/* UniqueInputFieldNames */ "a"], _rules_ProvidedRequiredArguments__WEBPACK_IMPORTED_MODULE_22__[/* ProvidedRequiredArgumentsOnDirectives */ "b"]]);


/***/ }),
/* 89 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export unknownTypeMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KnownTypeNames; });
/* harmony import */ var _jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/* harmony import */ var _jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _language_predicates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38);
/* harmony import */ var _type_scalars__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(13);





function unknownTypeMessage(typeName, suggestedTypes) {
  return "Unknown type \"".concat(typeName, "\".") + Object(_jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(suggestedTypes.map(function (x) {
    return "\"".concat(x, "\"");
  }));
}
/**
 * Known type names
 *
 * A GraphQL document is only valid if referenced types (specifically
 * variable definitions and fragment conditions) are defined by the type schema.
 */

function KnownTypeNames(context) {
  var schema = context.getSchema();
  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);
  var definedTypes = Object.create(null);

  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {
    var def = _context$getDocument$2[_i2];

    if (Object(_language_predicates__WEBPACK_IMPORTED_MODULE_3__[/* isTypeDefinitionNode */ "d"])(def)) {
      definedTypes[def.name.value] = true;
    }
  }

  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));
  return {
    NamedType: function NamedType(node, _1, parent, _2, ancestors) {
      var typeName = node.name.value;

      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var definitionNode = ancestors[2] || parent;
        var isSDL = isSDLNode(definitionNode);

        if (isSDL && isSpecifiedScalarName(typeName)) {
          return;
        }

        var suggestedTypes = Object(_jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(typeName, isSDL ? specifiedScalarsNames.concat(typeNames) : typeNames);
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_2__[/* GraphQLError */ "a"](unknownTypeMessage(typeName, suggestedTypes), node));
      }
    }
  };
}
var specifiedScalarsNames = _type_scalars__WEBPACK_IMPORTED_MODULE_4__[/* specifiedScalarTypes */ "g"].map(function (type) {
  return type.name;
});

function isSpecifiedScalarName(typeName) {
  return specifiedScalarsNames.indexOf(typeName) !== -1;
}

function isSDLNode(value) {
  return Boolean(value && !Array.isArray(value) && (Object(_language_predicates__WEBPACK_IMPORTED_MODULE_3__[/* isTypeSystemDefinitionNode */ "g"])(value) || Object(_language_predicates__WEBPACK_IMPORTED_MODULE_3__[/* isTypeSystemExtensionNode */ "h"])(value)));
}


/***/ }),
/* 90 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export unknownDirectiveMessage */
/* unused harmony export misplacedDirectiveMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KnownDirectives; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _type_directives__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15);




function unknownDirectiveMessage(directiveName) {
  return "Unknown directive \"".concat(directiveName, "\".");
}
function misplacedDirectiveMessage(directiveName, location) {
  return "Directive \"".concat(directiveName, "\" may not be used on ").concat(location, ".");
}
/**
 * Known directives
 *
 * A GraphQL document is only valid if all `@directives` are known by the
 * schema and legally positioned.
 */

function KnownDirectives(context) {
  var locationsMap = Object.create(null);
  var schema = context.getSchema();
  var definedDirectives = schema ? schema.getDirectives() : _type_directives__WEBPACK_IMPORTED_MODULE_3__[/* specifiedDirectives */ "i"];

  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
    var directive = definedDirectives[_i2];
    locationsMap[directive.name] = directive.locations;
  }

  var astDefinitions = context.getDocument().definitions;

  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
    var def = astDefinitions[_i4];

    if (def.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map(function (name) {
        return name.value;
      });
    }
  }

  return {
    Directive: function Directive(node, key, parent, path, ancestors) {
      var name = node.name.value;
      var locations = locationsMap[name];

      if (!locations) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](unknownDirectiveMessage(name), node));
        return;
      }

      var candidateLocation = getDirectiveLocationForASTPath(ancestors);

      if (candidateLocation && locations.indexOf(candidateLocation) === -1) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](misplacedDirectiveMessage(name, candidateLocation), node));
      }
    }
  };
}

function getDirectiveLocationForASTPath(ancestors) {
  var appliedTo = ancestors[ancestors.length - 1];

  if (!Array.isArray(appliedTo)) {
    switch (appliedTo.kind) {
      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].OPERATION_DEFINITION:
        switch (appliedTo.operation) {
          case 'query':
            return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].QUERY;

          case 'mutation':
            return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].MUTATION;

          case 'subscription':
            return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].SUBSCRIPTION;
        }

        break;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].FIELD:
        return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].FIELD;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].FRAGMENT_SPREAD:
        return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].FRAGMENT_SPREAD;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].INLINE_FRAGMENT:
        return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].INLINE_FRAGMENT;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].FRAGMENT_DEFINITION:
        return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].FRAGMENT_DEFINITION;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].VARIABLE_DEFINITION:
        return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].VARIABLE_DEFINITION;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].SCHEMA_DEFINITION:
      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].SCHEMA_EXTENSION:
        return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].SCHEMA;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].SCALAR_TYPE_DEFINITION:
      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].SCALAR_TYPE_EXTENSION:
        return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].SCALAR;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].OBJECT_TYPE_DEFINITION:
      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].OBJECT_TYPE_EXTENSION:
        return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].OBJECT;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].FIELD_DEFINITION:
        return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].FIELD_DEFINITION;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].INTERFACE_TYPE_DEFINITION:
      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].INTERFACE_TYPE_EXTENSION:
        return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].INTERFACE;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].UNION_TYPE_DEFINITION:
      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].UNION_TYPE_EXTENSION:
        return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].UNION;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].ENUM_TYPE_DEFINITION:
      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].ENUM_TYPE_EXTENSION:
        return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].ENUM;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].ENUM_VALUE_DEFINITION:
        return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].ENUM_VALUE;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].INPUT_OBJECT_TYPE_DEFINITION:
      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].INPUT_OBJECT_TYPE_EXTENSION:
        return _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].INPUT_OBJECT;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].INPUT_VALUE_DEFINITION:
        {
          var parentNode = ancestors[ancestors.length - 3];
          return parentNode.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].INPUT_OBJECT_TYPE_DEFINITION ? _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].INPUT_FIELD_DEFINITION : _language_directiveLocation__WEBPACK_IMPORTED_MODULE_2__[/* DirectiveLocation */ "a"].ARGUMENT_DEFINITION;
        }
    }
  }
}


/***/ }),
/* 91 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export duplicateDirectiveMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniqueDirectivesPerLocation; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _type_directives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15);



function duplicateDirectiveMessage(directiveName) {
  return "The directive \"".concat(directiveName, "\" can only be used once at this location.");
}
/**
 * Unique directive names per location
 *
 * A GraphQL document is only valid if all non-repeatable directives at
 * a given location are uniquely named.
 */

function UniqueDirectivesPerLocation(context) {
  var uniqueDirectiveMap = Object.create(null);
  var schema = context.getSchema();
  var definedDirectives = schema ? schema.getDirectives() : _type_directives__WEBPACK_IMPORTED_MODULE_2__[/* specifiedDirectives */ "i"];

  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
    var directive = definedDirectives[_i2];
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }

  var astDefinitions = context.getDocument().definitions;

  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
    var def = astDefinitions[_i4];

    if (def.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }

  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter: function enter(node) {
      // Flow can't refine that node.directives will only contain directives,
      // so we cast so the rest of the code is well typed.
      var directives = node.directives;

      if (directives) {
        var knownDirectives = Object.create(null);

        for (var _i6 = 0; _i6 < directives.length; _i6++) {
          var _directive = directives[_i6];
          var directiveName = _directive.name.value;

          if (uniqueDirectiveMap[directiveName]) {
            if (knownDirectives[directiveName]) {
              context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](duplicateDirectiveMessage(directiveName), [knownDirectives[directiveName], _directive]));
            } else {
              knownDirectives[directiveName] = _directive;
            }
          }
        }
      }
    }
  };
}


/***/ }),
/* 92 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export unknownArgMessage */
/* unused harmony export unknownDirectiveArgMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KnownArgumentNames; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return KnownArgumentNamesOnDirectives; });
/* harmony import */ var _jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/* harmony import */ var _jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);
/* harmony import */ var _type_directives__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(15);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






function unknownArgMessage(argName, fieldName, typeName, suggestedArgs) {
  return "Unknown argument \"".concat(argName, "\" on field \"").concat(fieldName, "\" of type \"").concat(typeName, "\".") + Object(_jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(suggestedArgs.map(function (x) {
    return "\"".concat(x, "\"");
  }));
}
function unknownDirectiveArgMessage(argName, directiveName, suggestedArgs) {
  return "Unknown argument \"".concat(argName, "\" on directive \"@").concat(directiveName, "\".") + Object(_jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(suggestedArgs.map(function (x) {
    return "\"".concat(x, "\"");
  }));
}
/**
 * Known argument names
 *
 * A GraphQL field is only valid if all supplied arguments are defined by
 * that field.
 */

function KnownArgumentNames(context) {
  return _objectSpread({}, KnownArgumentNamesOnDirectives(context), {
    Argument: function Argument(argNode) {
      var argDef = context.getArgument();
      var fieldDef = context.getFieldDef();
      var parentType = context.getParentType();

      if (!argDef && fieldDef && parentType) {
        var argName = argNode.name.value;
        var knownArgsNames = fieldDef.args.map(function (arg) {
          return arg.name;
        });
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_2__[/* GraphQLError */ "a"](unknownArgMessage(argName, fieldDef.name, parentType.name, Object(_jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(argName, knownArgsNames)), argNode));
      }
    }
  });
} // @internal

function KnownArgumentNamesOnDirectives(context) {
  var directiveArgs = Object.create(null);
  var schema = context.getSchema();
  var definedDirectives = schema ? schema.getDirectives() : _type_directives__WEBPACK_IMPORTED_MODULE_4__[/* specifiedDirectives */ "i"];

  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
    var directive = definedDirectives[_i2];
    directiveArgs[directive.name] = directive.args.map(function (arg) {
      return arg.name;
    });
  }

  var astDefinitions = context.getDocument().definitions;

  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
    var def = astDefinitions[_i4];

    if (def.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].DIRECTIVE_DEFINITION) {
      directiveArgs[def.name.value] = def.arguments ? def.arguments.map(function (arg) {
        return arg.name.value;
      }) : [];
    }
  }

  return {
    Directive: function Directive(directiveNode) {
      var directiveName = directiveNode.name.value;
      var knownArgs = directiveArgs[directiveName];

      if (directiveNode.arguments && knownArgs) {
        for (var _i6 = 0, _directiveNode$argume2 = directiveNode.arguments; _i6 < _directiveNode$argume2.length; _i6++) {
          var argNode = _directiveNode$argume2[_i6];
          var argName = argNode.name.value;

          if (knownArgs.indexOf(argName) === -1) {
            var suggestions = Object(_jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(argName, knownArgs);
            context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_2__[/* GraphQLError */ "a"](unknownDirectiveArgMessage(argName, directiveName, suggestions), argNode));
          }
        }
      }

      return false;
    }
  };
}


/***/ }),
/* 93 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export duplicateArgMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniqueArgumentNames; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function duplicateArgMessage(argName) {
  return "There can be only one argument named \"".concat(argName, "\".");
}
/**
 * Unique argument names
 *
 * A GraphQL field or directive is only valid if all supplied arguments are
 * uniquely named.
 */

function UniqueArgumentNames(context) {
  var knownArgNames = Object.create(null);
  return {
    Field: function Field() {
      knownArgNames = Object.create(null);
    },
    Directive: function Directive() {
      knownArgNames = Object.create(null);
    },
    Argument: function Argument(node) {
      var argName = node.name.value;

      if (knownArgNames[argName]) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](duplicateArgMessage(argName), [knownArgNames[argName], node.name]));
      } else {
        knownArgNames[argName] = node.name;
      }

      return false;
    }
  };
}


/***/ }),
/* 94 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export missingFieldArgMessage */
/* unused harmony export missingDirectiveArgMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ProvidedRequiredArguments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ProvidedRequiredArgumentsOnDirectives; });
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);
/* harmony import */ var _language_printer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16);
/* harmony import */ var _type_directives__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(15);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








function missingFieldArgMessage(fieldName, argName, type) {
  return "Field \"".concat(fieldName, "\" argument \"").concat(argName, "\" of type \"").concat(type, "\" is required, but it was not provided.");
}
function missingDirectiveArgMessage(directiveName, argName, type) {
  return "Directive \"@".concat(directiveName, "\" argument \"").concat(argName, "\" of type \"").concat(type, "\" is required, but it was not provided.");
}
/**
 * Provided required arguments
 *
 * A field or directive is only valid if all required (non-null without a
 * default value) field arguments have been provided.
 */

function ProvidedRequiredArguments(context) {
  return _objectSpread({}, ProvidedRequiredArgumentsOnDirectives(context), {
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave: function leave(fieldNode) {
        var fieldDef = context.getFieldDef();

        if (!fieldDef) {
          return false;
        }

        var argNodes = fieldNode.arguments || [];
        var argNodeMap = Object(_jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(argNodes, function (arg) {
          return arg.name.value;
        });

        for (var _i2 = 0, _fieldDef$args2 = fieldDef.args; _i2 < _fieldDef$args2.length; _i2++) {
          var argDef = _fieldDef$args2[_i2];
          var argNode = argNodeMap[argDef.name];

          if (!argNode && Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isRequiredArgument */ "P"])(argDef)) {
            context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_2__[/* GraphQLError */ "a"](missingFieldArgMessage(fieldDef.name, argDef.name, Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(argDef.type)), fieldNode));
          }
        }
      }
    }
  });
} // @internal

function ProvidedRequiredArgumentsOnDirectives(context) {
  var requiredArgsMap = Object.create(null);
  var schema = context.getSchema();
  var definedDirectives = schema ? schema.getDirectives() : _type_directives__WEBPACK_IMPORTED_MODULE_5__[/* specifiedDirectives */ "i"];

  for (var _i4 = 0; _i4 < definedDirectives.length; _i4++) {
    var directive = definedDirectives[_i4];
    requiredArgsMap[directive.name] = Object(_jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(directive.args.filter(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isRequiredArgument */ "P"]), function (arg) {
      return arg.name;
    });
  }

  var astDefinitions = context.getDocument().definitions;

  for (var _i6 = 0; _i6 < astDefinitions.length; _i6++) {
    var def = astDefinitions[_i6];

    if (def.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].DIRECTIVE_DEFINITION) {
      requiredArgsMap[def.name.value] = Object(_jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(def.arguments ? def.arguments.filter(isRequiredArgumentNode) : [], function (arg) {
        return arg.name.value;
      });
    }
  }

  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave: function leave(directiveNode) {
        var directiveName = directiveNode.name.value;
        var requiredArgs = requiredArgsMap[directiveName];

        if (requiredArgs) {
          var argNodes = directiveNode.arguments || [];
          var argNodeMap = Object(_jsutils_keyMap__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(argNodes, function (arg) {
            return arg.name.value;
          });

          for (var _i8 = 0, _Object$keys2 = Object.keys(requiredArgs); _i8 < _Object$keys2.length; _i8++) {
            var argName = _Object$keys2[_i8];

            if (!argNodeMap[argName]) {
              var argType = requiredArgs[argName].type;
              context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_2__[/* GraphQLError */ "a"](missingDirectiveArgMessage(directiveName, argName, Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isType */ "S"])(argType) ? Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(argType) : Object(_language_printer__WEBPACK_IMPORTED_MODULE_4__[/* print */ "a"])(argType)), directiveNode));
            }
          }
        }
      }
    }
  };
}

function isRequiredArgumentNode(arg) {
  return arg.type.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].NON_NULL_TYPE && arg.defaultValue == null;
}


/***/ }),
/* 95 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export duplicateInputFieldMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniqueInputFieldNames; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function duplicateInputFieldMessage(fieldName) {
  return "There can be only one input field named \"".concat(fieldName, "\".");
}
/**
 * Unique input field names
 *
 * A GraphQL input object value is only valid if all supplied fields are
 * uniquely named.
 */

function UniqueInputFieldNames(context) {
  var knownNameStack = [];
  var knownNames = Object.create(null);
  return {
    ObjectValue: {
      enter: function enter() {
        knownNameStack.push(knownNames);
        knownNames = Object.create(null);
      },
      leave: function leave() {
        knownNames = knownNameStack.pop();
      }
    },
    ObjectField: function ObjectField(node) {
      var fieldName = node.name.value;

      if (knownNames[fieldName]) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](duplicateInputFieldMessage(fieldName), [knownNames[fieldName], node.name]));
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}


/***/ }),
/* 96 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return formatError; });
/* harmony import */ var _jsutils_devAssert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);


/**
 * Given a GraphQLError, format it according to the rules described by the
 * Response Format, Errors section of the GraphQL Specification.
 */
function formatError(error) {
  error || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(0, 'Received null or undefined error.');
  var message = error.message || 'An unknown error occurred.';
  var locations = error.locations;
  var path = error.path;
  var extensions = error.extensions;
  return extensions ? {
    message: message,
    locations: locations,
    path: path,
    extensions: extensions
  } : {
    message: message,
    locations: locations,
    path: path
  };
}
/**
 * @see https://github.com/graphql/graphql-spec/blob/master/spec/Section%207%20--%20Response.md#errors
 */


/***/ }),
/* 97 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getOperationAST; });
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);


/**
 * Returns an operation AST given a document AST and optionally an operation
 * name. If a name is not provided, an operation is only returned if only one is
 * provided in the document.
 */
function getOperationAST(documentAST, operationName) {
  var operation = null;

  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
    var definition = _documentAST$definiti2[_i2];

    if (definition.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].OPERATION_DEFINITION) {
      if (!operationName) {
        // If no operation name was provided, only return an Operation if there
        // is one defined in the document. Upon encountering the second, return
        // null.
        if (operation) {
          return null;
        }

        operation = definition;
      } else if (definition.name && definition.name.value === operationName) {
        return definition;
      }
    }
  }

  return operation;
}


/***/ }),
/* 98 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return introspectionFromSchema; });
/* harmony import */ var _jsutils_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _jsutils_isPromise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var _language_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(48);
/* harmony import */ var _execution_execute__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
/* harmony import */ var _introspectionQuery__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(64);





/**
 * Build an IntrospectionQuery from a GraphQLSchema
 *
 * IntrospectionQuery is useful for utilities that care about type and field
 * relationships, but do not need to traverse through those relationships.
 *
 * This is the inverse of buildClientSchema. The primary use case is outside
 * of the server context, for instance when doing schema comparisons.
 */

function introspectionFromSchema(schema, options) {
  var queryAST = Object(_language_parser__WEBPACK_IMPORTED_MODULE_2__["parse"])(Object(_introspectionQuery__WEBPACK_IMPORTED_MODULE_4__[/* getIntrospectionQuery */ "a"])(options));
  var result = Object(_execution_execute__WEBPACK_IMPORTED_MODULE_3__[/* execute */ "g"])(schema, queryAST);

  /* istanbul ignore next */
  !Object(_jsutils_isPromise__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(result) && !result.errors && result.data || Object(_jsutils_invariant__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(0);
  return result.data;
}


/***/ }),
/* 99 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return buildClientSchema; });
/* harmony import */ var _polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _jsutils_devAssert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(20);
/* harmony import */ var _jsutils_isObjectLike__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18);
/* harmony import */ var _language_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(48);
/* harmony import */ var _type_directives__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(15);
/* harmony import */ var _type_scalars__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(13);
/* harmony import */ var _type_introspection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(12);
/* harmony import */ var _type_schema__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(36);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(0);
/* harmony import */ var _valueFromAST__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(45);













/**
 * Build a GraphQLSchema for use by client tools.
 *
 * Given the result of a client running the introspection query, creates and
 * returns a GraphQLSchema instance which can be then used with all graphql-js
 * tools, but cannot be used to execute a query, as introspection does not
 * represent the "resolver", "parse" or "serialize" functions or any other
 * server-internal mechanisms.
 *
 * This function expects a complete introspection result. Don't forget to check
 * the "errors" field of a server response before calling this function.
 */
function buildClientSchema(introspection, options) {
  Object(_jsutils_isObjectLike__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(introspection) && Object(_jsutils_isObjectLike__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(introspection.__schema) || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(0, 'Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(introspection)); // Get the schema from the introspection result.

  var schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.

  var typeMap = Object(_jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(schemaIntrospection.types, function (typeIntrospection) {
    return typeIntrospection.name;
  }, function (typeIntrospection) {
    return buildType(typeIntrospection);
  });

  for (var _i2 = 0, _ref2 = [].concat(_type_scalars__WEBPACK_IMPORTED_MODULE_7__[/* specifiedScalarTypes */ "g"], _type_introspection__WEBPACK_IMPORTED_MODULE_8__[/* introspectionTypes */ "m"]); _i2 < _ref2.length; _i2++) {
    var stdType = _ref2[_i2];

    if (typeMap[stdType.name]) {
      typeMap[stdType.name] = stdType;
    }
  } // Get the root Query, Mutation, and Subscription types.


  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if
  // directives were not queried for.

  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.

  return new _type_schema__WEBPACK_IMPORTED_MODULE_9__[/* GraphQLSchema */ "a"]({
    query: queryType,
    mutation: mutationType,
    subscription: subscriptionType,
    types: Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(typeMap),
    directives: directives,
    assumeValid: options && options.assumeValid,
    allowedLegacyNames: options && options.allowedLegacyNames
  }); // Given a type reference in introspection, return the GraphQLType instance.
  // preferring cached instances before building new instances.

  function getType(typeRef) {
    if (typeRef.kind === _type_introspection__WEBPACK_IMPORTED_MODULE_8__[/* TypeKind */ "b"].LIST) {
      var itemRef = typeRef.ofType;

      if (!itemRef) {
        throw new Error('Decorated type deeper than introspection query.');
      }

      return Object(_type_definition__WEBPACK_IMPORTED_MODULE_10__[/* GraphQLList */ "d"])(getType(itemRef));
    }

    if (typeRef.kind === _type_introspection__WEBPACK_IMPORTED_MODULE_8__[/* TypeKind */ "b"].NON_NULL) {
      var nullableRef = typeRef.ofType;

      if (!nullableRef) {
        throw new Error('Decorated type deeper than introspection query.');
      }

      var nullableType = getType(nullableRef);
      return Object(_type_definition__WEBPACK_IMPORTED_MODULE_10__[/* GraphQLNonNull */ "e"])(Object(_type_definition__WEBPACK_IMPORTED_MODULE_10__[/* assertNullableType */ "t"])(nullableType));
    }

    if (!typeRef.name) {
      throw new Error('Unknown type reference: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(typeRef));
    }

    return getNamedType(typeRef.name);
  }

  function getNamedType(typeName) {
    var type = typeMap[typeName];

    if (!type) {
      throw new Error("Invalid or incomplete schema, unknown type: ".concat(typeName, ". Ensure that a full introspection query is used in order to build a client schema."));
    }

    return type;
  }

  function getInputType(typeRef) {
    var type = getType(typeRef);

    if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_10__[/* isInputType */ "G"])(type)) {
      return type;
    }

    throw new Error('Introspection must provide input type for arguments, but received: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(type) + '.');
  }

  function getOutputType(typeRef) {
    var type = getType(typeRef);

    if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_10__[/* isOutputType */ "O"])(type)) {
      return type;
    }

    throw new Error('Introspection must provide output type for fields, but received: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(type) + '.');
  }

  function getObjectType(typeRef) {
    var type = getType(typeRef);
    return Object(_type_definition__WEBPACK_IMPORTED_MODULE_10__[/* assertObjectType */ "u"])(type);
  }

  function getInterfaceType(typeRef) {
    var type = getType(typeRef);
    return Object(_type_definition__WEBPACK_IMPORTED_MODULE_10__[/* assertInterfaceType */ "o"])(type);
  } // Given a type's introspection result, construct the correct
  // GraphQLType instance.


  function buildType(type) {
    if (type && type.name && type.kind) {
      switch (type.kind) {
        case _type_introspection__WEBPACK_IMPORTED_MODULE_8__[/* TypeKind */ "b"].SCALAR:
          return buildScalarDef(type);

        case _type_introspection__WEBPACK_IMPORTED_MODULE_8__[/* TypeKind */ "b"].OBJECT:
          return buildObjectDef(type);

        case _type_introspection__WEBPACK_IMPORTED_MODULE_8__[/* TypeKind */ "b"].INTERFACE:
          return buildInterfaceDef(type);

        case _type_introspection__WEBPACK_IMPORTED_MODULE_8__[/* TypeKind */ "b"].UNION:
          return buildUnionDef(type);

        case _type_introspection__WEBPACK_IMPORTED_MODULE_8__[/* TypeKind */ "b"].ENUM:
          return buildEnumDef(type);

        case _type_introspection__WEBPACK_IMPORTED_MODULE_8__[/* TypeKind */ "b"].INPUT_OBJECT:
          return buildInputObjectDef(type);
      }
    }

    throw new Error('Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema:' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(type));
  }

  function buildScalarDef(scalarIntrospection) {
    return new _type_definition__WEBPACK_IMPORTED_MODULE_10__[/* GraphQLScalarType */ "g"]({
      name: scalarIntrospection.name,
      description: scalarIntrospection.description
    });
  }

  function buildObjectDef(objectIntrospection) {
    if (!objectIntrospection.interfaces) {
      throw new Error('Introspection result missing interfaces: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(objectIntrospection));
    }

    return new _type_definition__WEBPACK_IMPORTED_MODULE_10__[/* GraphQLObjectType */ "f"]({
      name: objectIntrospection.name,
      description: objectIntrospection.description,
      interfaces: function interfaces() {
        return objectIntrospection.interfaces.map(getInterfaceType);
      },
      fields: function fields() {
        return buildFieldDefMap(objectIntrospection);
      }
    });
  }

  function buildInterfaceDef(interfaceIntrospection) {
    return new _type_definition__WEBPACK_IMPORTED_MODULE_10__[/* GraphQLInterfaceType */ "c"]({
      name: interfaceIntrospection.name,
      description: interfaceIntrospection.description,
      fields: function fields() {
        return buildFieldDefMap(interfaceIntrospection);
      }
    });
  }

  function buildUnionDef(unionIntrospection) {
    if (!unionIntrospection.possibleTypes) {
      throw new Error('Introspection result missing possibleTypes: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(unionIntrospection));
    }

    return new _type_definition__WEBPACK_IMPORTED_MODULE_10__[/* GraphQLUnionType */ "h"]({
      name: unionIntrospection.name,
      description: unionIntrospection.description,
      types: function types() {
        return unionIntrospection.possibleTypes.map(getObjectType);
      }
    });
  }

  function buildEnumDef(enumIntrospection) {
    if (!enumIntrospection.enumValues) {
      throw new Error('Introspection result missing enumValues: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(enumIntrospection));
    }

    return new _type_definition__WEBPACK_IMPORTED_MODULE_10__[/* GraphQLEnumType */ "a"]({
      name: enumIntrospection.name,
      description: enumIntrospection.description,
      values: Object(_jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(enumIntrospection.enumValues, function (valueIntrospection) {
        return valueIntrospection.name;
      }, function (valueIntrospection) {
        return {
          description: valueIntrospection.description,
          deprecationReason: valueIntrospection.deprecationReason
        };
      })
    });
  }

  function buildInputObjectDef(inputObjectIntrospection) {
    if (!inputObjectIntrospection.inputFields) {
      throw new Error('Introspection result missing inputFields: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(inputObjectIntrospection));
    }

    return new _type_definition__WEBPACK_IMPORTED_MODULE_10__[/* GraphQLInputObjectType */ "b"]({
      name: inputObjectIntrospection.name,
      description: inputObjectIntrospection.description,
      fields: function fields() {
        return buildInputValueDefMap(inputObjectIntrospection.inputFields);
      }
    });
  }

  function buildFieldDefMap(typeIntrospection) {
    if (!typeIntrospection.fields) {
      throw new Error('Introspection result missing fields: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(typeIntrospection));
    }

    return Object(_jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(typeIntrospection.fields, function (fieldIntrospection) {
      return fieldIntrospection.name;
    }, function (fieldIntrospection) {
      if (!fieldIntrospection.args) {
        throw new Error('Introspection result missing field args: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(fieldIntrospection));
      }

      return {
        description: fieldIntrospection.description,
        deprecationReason: fieldIntrospection.deprecationReason,
        type: getOutputType(fieldIntrospection.type),
        args: buildInputValueDefMap(fieldIntrospection.args)
      };
    });
  }

  function buildInputValueDefMap(inputValueIntrospections) {
    return Object(_jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(inputValueIntrospections, function (inputValue) {
      return inputValue.name;
    }, buildInputValue);
  }

  function buildInputValue(inputValueIntrospection) {
    var type = getInputType(inputValueIntrospection.type);
    var defaultValue = inputValueIntrospection.defaultValue ? Object(_valueFromAST__WEBPACK_IMPORTED_MODULE_11__[/* valueFromAST */ "a"])(Object(_language_parser__WEBPACK_IMPORTED_MODULE_5__["parseValue"])(inputValueIntrospection.defaultValue), type) : undefined;
    return {
      description: inputValueIntrospection.description,
      type: type,
      defaultValue: defaultValue
    };
  }

  function buildDirective(directiveIntrospection) {
    if (!directiveIntrospection.args) {
      throw new Error('Introspection result missing directive args: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(directiveIntrospection));
    }

    if (!directiveIntrospection.locations) {
      throw new Error('Introspection result missing directive locations: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(directiveIntrospection));
    }

    return new _type_directives__WEBPACK_IMPORTED_MODULE_6__[/* GraphQLDirective */ "c"]({
      name: directiveIntrospection.name,
      description: directiveIntrospection.description,
      locations: directiveIntrospection.locations.slice(),
      args: buildInputValueDefMap(directiveIntrospection.args)
    });
  }
}


/***/ }),
/* 100 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return extendSchema; });
/* harmony import */ var _polyfills_flatMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
/* harmony import */ var _polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _jsutils_mapValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
/* harmony import */ var _jsutils_invariant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17);
/* harmony import */ var _jsutils_devAssert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7);
/* harmony import */ var _jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(20);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(2);
/* harmony import */ var _language_predicates__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(38);
/* harmony import */ var _validation_validate__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(56);
/* harmony import */ var _type_directives__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(15);
/* harmony import */ var _type_scalars__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(13);
/* harmony import */ var _type_introspection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(12);
/* harmony import */ var _type_schema__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(36);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(0);
/* harmony import */ var _buildASTSchema__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(51);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


















/**
 * Produces a new schema given an existing schema and a document which may
 * contain GraphQL type extensions and definitions. The original schema will
 * remain unaltered.
 *
 * Because a schema represents a graph of references, a schema cannot be
 * extended without effectively making an entire copy. We do not know until it's
 * too late if subgraphs remain unchanged.
 *
 * This algorithm copies the provided schema, applying extensions while
 * producing the copy. The original schema remains unaltered.
 *
 * Accepts options as a third argument:
 *
 *    - commentDescriptions:
 *        Provide true to use preceding comments as the description.
 *
 */
function extendSchema(schema, documentAST, options) {
  Object(_type_schema__WEBPACK_IMPORTED_MODULE_13__[/* assertSchema */ "b"])(schema);
  documentAST && documentAST.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].DOCUMENT || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(0, 'Must provide valid Document AST');

  if (!options || !(options.assumeValid || options.assumeValidSDL)) {
    Object(_validation_validate__WEBPACK_IMPORTED_MODULE_9__[/* assertValidSDLExtension */ "b"])(documentAST, schema);
  } // Collect the type definitions and extensions found in the document.


  var typeDefs = [];
  var typeExtsMap = Object.create(null); // New directives and types are separate because a directives and types can
  // have the same name. For example, a type named "skip".

  var directiveDefs = [];
  var schemaDef; // Schema extensions are collected which may add additional operation types.

  var schemaExts = [];

  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
    var def = _documentAST$definiti2[_i2];

    if (def.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].SCHEMA_DEFINITION) {
      schemaDef = def;
    } else if (def.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].SCHEMA_EXTENSION) {
      schemaExts.push(def);
    } else if (Object(_language_predicates__WEBPACK_IMPORTED_MODULE_8__[/* isTypeDefinitionNode */ "d"])(def)) {
      typeDefs.push(def);
    } else if (Object(_language_predicates__WEBPACK_IMPORTED_MODULE_8__[/* isTypeExtensionNode */ "e"])(def)) {
      var extendedTypeName = def.name.value;
      var existingTypeExts = typeExtsMap[extendedTypeName];
      typeExtsMap[extendedTypeName] = existingTypeExts ? existingTypeExts.concat([def]) : [def];
    } else if (def.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_7__[/* Kind */ "a"].DIRECTIVE_DEFINITION) {
      directiveDefs.push(def);
    }
  } // If this document contains no new types, extensions, or directives then
  // return the same unmodified GraphQLSchema instance.


  if (Object.keys(typeExtsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExts.length === 0 && !schemaDef) {
    return schema;
  }

  var schemaConfig = schema.toConfig();
  var astBuilder = new _buildASTSchema__WEBPACK_IMPORTED_MODULE_15__[/* ASTDefinitionBuilder */ "a"](options, function (typeName) {
    var type = typeMap[typeName];

    if (type === undefined) {
      throw new Error("Unknown type: \"".concat(typeName, "\"."));
    }

    return type;
  });
  var typeMap = Object(_jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(typeDefs, function (node) {
    return node.name.value;
  }, function (node) {
    return astBuilder.buildType(node);
  });

  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {
    var existingType = _schemaConfig$types2[_i4];
    typeMap[existingType.name] = extendNamedType(existingType);
  } // Get the extended root operation types.


  var operationTypes = {
    query: schemaConfig.query && schemaConfig.query.name,
    mutation: schemaConfig.mutation && schemaConfig.mutation.name,
    subscription: schemaConfig.subscription && schemaConfig.subscription.name
  };

  if (schemaDef) {
    for (var _i6 = 0, _schemaDef$operationT2 = schemaDef.operationTypes; _i6 < _schemaDef$operationT2.length; _i6++) {
      var _ref2 = _schemaDef$operationT2[_i6];
      var operation = _ref2.operation;
      var type = _ref2.type;
      operationTypes[operation] = type.name.value;
    }
  } // Then, incorporate schema definition and all schema extensions.


  for (var _i8 = 0; _i8 < schemaExts.length; _i8++) {
    var schemaExt = schemaExts[_i8];

    if (schemaExt.operationTypes) {
      for (var _i10 = 0, _schemaExt$operationT2 = schemaExt.operationTypes; _i10 < _schemaExt$operationT2.length; _i10++) {
        var _ref4 = _schemaExt$operationT2[_i10];
        var _operation = _ref4.operation;
        var _type = _ref4.type;
        operationTypes[_operation] = _type.name.value;
      }
    }
  } // Support both original legacy names and extended legacy names.


  var allowedLegacyNames = schemaConfig.allowedLegacyNames.concat(options && options.allowedLegacyNames || []); // Then produce and return a Schema with these types.

  return new _type_schema__WEBPACK_IMPORTED_MODULE_13__[/* GraphQLSchema */ "a"]({
    // Note: While this could make early assertions to get the correctly
    // typed values, that would throw immediately while type system
    // validation with validateSchema() will produce more actionable results.
    query: getMaybeTypeByName(operationTypes.query),
    mutation: getMaybeTypeByName(operationTypes.mutation),
    subscription: getMaybeTypeByName(operationTypes.subscription),
    types: Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(typeMap),
    directives: getMergedDirectives(),
    astNode: schemaDef || schemaConfig.astNode,
    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExts),
    allowedLegacyNames: allowedLegacyNames
  }); // Below are functions used for producing this schema that have closed over
  // this scope and have access to the schema, cache, and newly defined types.

  function replaceType(type) {
    if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_14__[/* isListType */ "J"])(type)) {
      return new _type_definition__WEBPACK_IMPORTED_MODULE_14__[/* GraphQLList */ "d"](replaceType(type.ofType));
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_14__[/* isNonNullType */ "L"])(type)) {
      return new _type_definition__WEBPACK_IMPORTED_MODULE_14__[/* GraphQLNonNull */ "e"](replaceType(type.ofType));
    }

    return replaceNamedType(type);
  }

  function replaceNamedType(type) {
    return typeMap[type.name];
  }

  function getMaybeTypeByName(typeName) {
    return typeName ? typeMap[typeName] : null;
  }

  function getMergedDirectives() {
    var existingDirectives = schema.getDirectives().map(extendDirective);
    existingDirectives || Object(_jsutils_devAssert__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(0, 'schema must have default directives');
    return existingDirectives.concat(directiveDefs.map(function (node) {
      return astBuilder.buildDirective(node);
    }));
  }

  function extendNamedType(type) {
    if (Object(_type_introspection__WEBPACK_IMPORTED_MODULE_12__[/* isIntrospectionType */ "n"])(type) || Object(_type_scalars__WEBPACK_IMPORTED_MODULE_11__[/* isSpecifiedScalarType */ "f"])(type)) {
      // Builtin types are not extended.
      return type;
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_14__[/* isScalarType */ "R"])(type)) {
      return extendScalarType(type);
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_14__[/* isObjectType */ "N"])(type)) {
      return extendObjectType(type);
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_14__[/* isInterfaceType */ "H"])(type)) {
      return extendInterfaceType(type);
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_14__[/* isUnionType */ "T"])(type)) {
      return extendUnionType(type);
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_14__[/* isEnumType */ "E"])(type)) {
      return extendEnumType(type);
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_14__[/* isInputObjectType */ "F"])(type)) {
      return extendInputObjectType(type);
    } // Not reachable. All possible types have been considered.


    /* istanbul ignore next */
    Object(_jsutils_invariant__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(false, 'Unexpected type: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(type));
  }

  function extendDirective(directive) {
    var config = directive.toConfig();
    return new _type_directives__WEBPACK_IMPORTED_MODULE_10__[/* GraphQLDirective */ "c"](_objectSpread({}, config, {
      args: Object(_jsutils_mapValue__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(config.args, extendArg)
    }));
  }

  function extendInputObjectType(type) {
    var config = type.toConfig();
    var extensions = typeExtsMap[config.name] || [];
    var fieldNodes = Object(_polyfills_flatMap__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(extensions, function (node) {
      return node.fields || [];
    });
    return new _type_definition__WEBPACK_IMPORTED_MODULE_14__[/* GraphQLInputObjectType */ "b"](_objectSpread({}, config, {
      fields: function fields() {
        return _objectSpread({}, Object(_jsutils_mapValue__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(config.fields, function (field) {
          return _objectSpread({}, field, {
            type: replaceType(field.type)
          });
        }), {}, Object(_jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(fieldNodes, function (field) {
          return field.name.value;
        }, function (field) {
          return astBuilder.buildInputField(field);
        }));
      },
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    }));
  }

  function extendEnumType(type) {
    var config = type.toConfig();
    var extensions = typeExtsMap[type.name] || [];
    var valueNodes = Object(_polyfills_flatMap__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(extensions, function (node) {
      return node.values || [];
    });
    return new _type_definition__WEBPACK_IMPORTED_MODULE_14__[/* GraphQLEnumType */ "a"](_objectSpread({}, config, {
      values: _objectSpread({}, config.values, {}, Object(_jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(valueNodes, function (value) {
        return value.name.value;
      }, function (value) {
        return astBuilder.buildEnumValue(value);
      })),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    }));
  }

  function extendScalarType(type) {
    var config = type.toConfig();
    var extensions = typeExtsMap[config.name] || [];
    return new _type_definition__WEBPACK_IMPORTED_MODULE_14__[/* GraphQLScalarType */ "g"](_objectSpread({}, config, {
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    }));
  }

  function extendObjectType(type) {
    var config = type.toConfig();
    var extensions = typeExtsMap[config.name] || [];
    var interfaceNodes = Object(_polyfills_flatMap__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(extensions, function (node) {
      return node.interfaces || [];
    });
    var fieldNodes = Object(_polyfills_flatMap__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(extensions, function (node) {
      return node.fields || [];
    });
    return new _type_definition__WEBPACK_IMPORTED_MODULE_14__[/* GraphQLObjectType */ "f"](_objectSpread({}, config, {
      interfaces: function interfaces() {
        return [].concat(type.getInterfaces().map(replaceNamedType), interfaceNodes.map(function (node) {
          return astBuilder.getNamedType(node);
        }));
      },
      fields: function fields() {
        return _objectSpread({}, Object(_jsutils_mapValue__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(config.fields, extendField), {}, Object(_jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(fieldNodes, function (node) {
          return node.name.value;
        }, function (node) {
          return astBuilder.buildField(node);
        }));
      },
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    }));
  }

  function extendInterfaceType(type) {
    var config = type.toConfig();
    var extensions = typeExtsMap[config.name] || [];
    var fieldNodes = Object(_polyfills_flatMap__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(extensions, function (node) {
      return node.fields || [];
    });
    return new _type_definition__WEBPACK_IMPORTED_MODULE_14__[/* GraphQLInterfaceType */ "c"](_objectSpread({}, config, {
      fields: function fields() {
        return _objectSpread({}, Object(_jsutils_mapValue__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(config.fields, extendField), {}, Object(_jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(fieldNodes, function (node) {
          return node.name.value;
        }, function (node) {
          return astBuilder.buildField(node);
        }));
      },
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    }));
  }

  function extendUnionType(type) {
    var config = type.toConfig();
    var extensions = typeExtsMap[config.name] || [];
    var typeNodes = Object(_polyfills_flatMap__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(extensions, function (node) {
      return node.types || [];
    });
    return new _type_definition__WEBPACK_IMPORTED_MODULE_14__[/* GraphQLUnionType */ "h"](_objectSpread({}, config, {
      types: function types() {
        return [].concat(type.getTypes().map(replaceNamedType), typeNodes.map(function (node) {
          return astBuilder.getNamedType(node);
        }));
      },
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    }));
  }

  function extendField(field) {
    return _objectSpread({}, field, {
      type: replaceType(field.type),
      args: Object(_jsutils_mapValue__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(field.args, extendArg)
    });
  }

  function extendArg(arg) {
    return _objectSpread({}, arg, {
      type: replaceType(arg.type)
    });
  }
}


/***/ }),
/* 101 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return lexicographicSortSchema; });
/* harmony import */ var _polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _jsutils_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var _jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(20);
/* harmony import */ var _type_schema__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);
/* harmony import */ var _type_directives__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(15);
/* harmony import */ var _type_introspection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









/**
 * Sort GraphQLSchema.
 */

function lexicographicSortSchema(schema) {
  var schemaConfig = schema.toConfig();
  var typeMap = Object(_jsutils_keyValMap__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(sortByName(schemaConfig.types), function (type) {
    return type.name;
  }, sortNamedType);
  return new _type_schema__WEBPACK_IMPORTED_MODULE_4__[/* GraphQLSchema */ "a"](_objectSpread({}, schemaConfig, {
    types: Object(_polyfills_objectValues__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(typeMap),
    directives: sortByName(schemaConfig.directives).map(sortDirective),
    query: replaceMaybeType(schemaConfig.query),
    mutation: replaceMaybeType(schemaConfig.mutation),
    subscription: replaceMaybeType(schemaConfig.subscription)
  }));

  function replaceType(type) {
    if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_7__[/* isListType */ "J"])(type)) {
      return new _type_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLList */ "d"](replaceType(type.ofType));
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_7__[/* isNonNullType */ "L"])(type)) {
      return new _type_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLNonNull */ "e"](replaceType(type.ofType));
    }

    return replaceNamedType(type);
  }

  function replaceNamedType(type) {
    return typeMap[type.name];
  }

  function replaceMaybeType(maybeType) {
    return maybeType && replaceNamedType(maybeType);
  }

  function sortDirective(directive) {
    var config = directive.toConfig();
    return new _type_directives__WEBPACK_IMPORTED_MODULE_5__[/* GraphQLDirective */ "c"](_objectSpread({}, config, {
      locations: sortBy(config.locations, function (x) {
        return x;
      }),
      args: sortArgs(config.args)
    }));
  }

  function sortArgs(args) {
    return sortObjMap(args, function (arg) {
      return _objectSpread({}, arg, {
        type: replaceType(arg.type)
      });
    });
  }

  function sortFields(fieldsMap) {
    return sortObjMap(fieldsMap, function (field) {
      return _objectSpread({}, field, {
        type: replaceType(field.type),
        args: sortArgs(field.args)
      });
    });
  }

  function sortInputFields(fieldsMap) {
    return sortObjMap(fieldsMap, function (field) {
      return _objectSpread({}, field, {
        type: replaceType(field.type)
      });
    });
  }

  function sortTypes(arr) {
    return sortByName(arr).map(replaceNamedType);
  }

  function sortNamedType(type) {
    if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_7__[/* isScalarType */ "R"])(type) || Object(_type_introspection__WEBPACK_IMPORTED_MODULE_6__[/* isIntrospectionType */ "n"])(type)) {
      return type;
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_7__[/* isObjectType */ "N"])(type)) {
      var config = type.toConfig();
      return new _type_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLObjectType */ "f"](_objectSpread({}, config, {
        interfaces: function interfaces() {
          return sortTypes(config.interfaces);
        },
        fields: function fields() {
          return sortFields(config.fields);
        }
      }));
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_7__[/* isInterfaceType */ "H"])(type)) {
      var _config = type.toConfig();

      return new _type_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLInterfaceType */ "c"](_objectSpread({}, _config, {
        fields: function fields() {
          return sortFields(_config.fields);
        }
      }));
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_7__[/* isUnionType */ "T"])(type)) {
      var _config2 = type.toConfig();

      return new _type_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLUnionType */ "h"](_objectSpread({}, _config2, {
        types: function types() {
          return sortTypes(_config2.types);
        }
      }));
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_7__[/* isEnumType */ "E"])(type)) {
      var _config3 = type.toConfig();

      return new _type_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLEnumType */ "a"](_objectSpread({}, _config3, {
        values: sortObjMap(_config3.values)
      }));
    } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_7__[/* isInputObjectType */ "F"])(type)) {
      var _config4 = type.toConfig();

      return new _type_definition__WEBPACK_IMPORTED_MODULE_7__[/* GraphQLInputObjectType */ "b"](_objectSpread({}, _config4, {
        fields: function fields() {
          return sortInputFields(_config4.fields);
        }
      }));
    } // Not reachable. All possible types have been considered.


    /* istanbul ignore next */
    Object(_jsutils_invariant__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(false, 'Unexpected type: ' + Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(type));
  }
}

function sortObjMap(map, sortValueFn) {
  var sortedMap = Object.create(null);
  var sortedKeys = sortBy(Object.keys(map), function (x) {
    return x;
  });

  for (var _i2 = 0; _i2 < sortedKeys.length; _i2++) {
    var key = sortedKeys[_i2];
    var value = map[key];
    sortedMap[key] = sortValueFn ? sortValueFn(value) : value;
  }

  return sortedMap;
}

function sortByName(array) {
  return sortBy(array, function (obj) {
    return obj.name;
  });
}

function sortBy(array, mapToKey) {
  return array.slice().sort(function (obj1, obj2) {
    var key1 = mapToKey(obj1);
    var key2 = mapToKey(obj2);
    return key1.localeCompare(key2);
  });
}


/***/ }),
/* 102 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isValidJSValue; });
/* harmony import */ var _coerceValue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73);
/* istanbul ignore file */

/**
 * Deprecated. Use coerceInputValue() directly for richer information.
 *
 * This function will be removed in v15
 */

function isValidJSValue(value, type) {
  var errors = Object(_coerceValue__WEBPACK_IMPORTED_MODULE_0__[/* coerceValue */ "a"])(value, type).errors;
  return errors ? errors.map(function (error) {
    return error.message;
  }) : [];
}


/***/ }),
/* 103 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isValidLiteralValue; });
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _language_visitor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _validation_rules_ValuesOfCorrectType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(76);
/* harmony import */ var _validation_ValidationContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68);
/* harmony import */ var _type_schema__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);
/* harmony import */ var _TypeInfo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(44);






/**
 * Utility which determines if a value literal node is valid for an input type.
 *
 * Deprecated. Rely on validation for documents containing literal values.
 *
 * This function will be removed in v15
 */

function isValidLiteralValue(type, valueNode) {
  var emptySchema = new _type_schema__WEBPACK_IMPORTED_MODULE_4__[/* GraphQLSchema */ "a"]({});
  var emptyDoc = {
    kind: _language_kinds__WEBPACK_IMPORTED_MODULE_0__[/* Kind */ "a"].DOCUMENT,
    definitions: []
  };
  var typeInfo = new _TypeInfo__WEBPACK_IMPORTED_MODULE_5__[/* TypeInfo */ "a"](emptySchema, undefined, type);
  var context = new _validation_ValidationContext__WEBPACK_IMPORTED_MODULE_3__[/* ValidationContext */ "b"](emptySchema, emptyDoc, typeInfo);
  var visitor = Object(_validation_rules_ValuesOfCorrectType__WEBPACK_IMPORTED_MODULE_2__[/* ValuesOfCorrectType */ "a"])(context);
  Object(_language_visitor__WEBPACK_IMPORTED_MODULE_1__[/* visit */ "c"])(valueNode, Object(_language_visitor__WEBPACK_IMPORTED_MODULE_1__[/* visitWithTypeInfo */ "e"])(typeInfo, visitor));
  return context.getErrors();
}


/***/ }),
/* 104 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return concatAST; });
/* harmony import */ var _polyfills_flatMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);


/**
 * Provided a collection of ASTs, presumably each from different files,
 * concatenate the ASTs together into batched AST, useful for validating many
 * GraphQL source files which together represent one conceptual application.
 */
function concatAST(asts) {
  return {
    kind: 'Document',
    definitions: Object(_polyfills_flatMap__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(asts, function (ast) {
      return ast.definitions;
    })
  };
}


/***/ }),
/* 105 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return separateOperations; });
/* harmony import */ var _language_visitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);


/**
 * separateOperations accepts a single AST document which may contain many
 * operations and fragments and returns a collection of AST documents each of
 * which contains a single operation as well the fragment definitions it
 * refers to.
 */
function separateOperations(documentAST) {
  var operations = [];
  var fragments = Object.create(null);
  var positions = new Map();
  var depGraph = Object.create(null);
  var fromName;
  var idx = 0; // Populate metadata and build a dependency graph.

  Object(_language_visitor__WEBPACK_IMPORTED_MODULE_0__[/* visit */ "c"])(documentAST, {
    OperationDefinition: function OperationDefinition(node) {
      fromName = opName(node);
      operations.push(node);
      positions.set(node, idx++);
    },
    FragmentDefinition: function FragmentDefinition(node) {
      fromName = node.name.value;
      fragments[fromName] = node;
      positions.set(node, idx++);
    },
    FragmentSpread: function FragmentSpread(node) {
      var toName = node.name.value;
      (depGraph[fromName] || (depGraph[fromName] = Object.create(null)))[toName] = true;
    }
  }); // For each operation, produce a new synthesized AST which includes only what
  // is necessary for completing that operation.

  var separatedDocumentASTs = Object.create(null);

  for (var _i2 = 0; _i2 < operations.length; _i2++) {
    var operation = operations[_i2];
    var operationName = opName(operation);
    var dependencies = Object.create(null);
    collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted
    // to retain the same order as the original document.

    var definitions = [operation];

    for (var _i4 = 0, _Object$keys2 = Object.keys(dependencies); _i4 < _Object$keys2.length; _i4++) {
      var name = _Object$keys2[_i4];
      definitions.push(fragments[name]);
    }

    definitions.sort(function (n1, n2) {
      return (positions.get(n1) || 0) - (positions.get(n2) || 0);
    });
    separatedDocumentASTs[operationName] = {
      kind: 'Document',
      definitions: definitions
    };
  }

  return separatedDocumentASTs;
}

// Provides the empty string for anonymous operations.
function opName(operation) {
  return operation.name ? operation.name.value : '';
} // From a dependency graph, collects a list of transitive dependencies by
// recursing through a dependency graph.


function collectTransitiveDependencies(collected, depGraph, fromName) {
  var immediateDeps = depGraph[fromName];

  if (immediateDeps) {
    for (var _i6 = 0, _Object$keys4 = Object.keys(immediateDeps); _i6 < _Object$keys4.length; _i6++) {
      var toName = _Object$keys4[_i6];

      if (!collected[toName]) {
        collected[toName] = true;
        collectTransitiveDependencies(collected, depGraph, toName);
      }
    }
  }
}


/***/ }),
/* 106 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return stripIgnoredCharacters; });
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _language_source__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58);
/* harmony import */ var _language_tokenKind__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var _language_lexer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(67);
/* harmony import */ var _language_blockString__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(41);





/**
 * Strips characters that are not significant to the validity or execution
 * of a GraphQL document:
 *   - UnicodeBOM
 *   - WhiteSpace
 *   - LineTerminator
 *   - Comment
 *   - Comma
 *   - BlockString indentation
 *
 * Note: It is required to have a delimiter character between neighboring
 * non-punctuator tokens and this function always uses single space as delimiter.
 *
 * It is guaranteed that both input and output documents if parsed would result
 * in the exact same AST except for nodes location.
 *
 * Warning: It is guaranteed that this function will always produce stable results.
 * However, it's not guaranteed that it will stay the same between different
 * releases due to bugfixes or changes in the GraphQL specification.
 *
 * Query example:
 *
 * query SomeQuery($foo: String!, $bar: String) {
 *   someField(foo: $foo, bar: $bar) {
 *     a
 *     b {
 *       c
 *       d
 *     }
 *   }
 * }
 *
 * Becomes:
 *
 * query SomeQuery($foo:String!$bar:String){someField(foo:$foo bar:$bar){a b{c d}}}
 *
 * SDL example:
 *
 * """
 * Type description
 * """
 * type Foo {
 *   """
 *   Field description
 *   """
 *   bar: String
 * }
 *
 * Becomes:
 *
 * """Type description""" type Foo{"""Field description""" bar:String}
 */

function stripIgnoredCharacters(source) {
  var sourceObj = typeof source === 'string' ? new _language_source__WEBPACK_IMPORTED_MODULE_1__[/* Source */ "a"](source) : source;

  if (!(sourceObj instanceof _language_source__WEBPACK_IMPORTED_MODULE_1__[/* Source */ "a"])) {
    throw new TypeError("Must provide string or Source. Received: ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(sourceObj)));
  }

  var body = sourceObj.body;
  var lexer = Object(_language_lexer__WEBPACK_IMPORTED_MODULE_3__[/* createLexer */ "a"])(sourceObj);
  var strippedBody = '';
  var wasLastAddedTokenNonPunctuator = false;

  while (lexer.advance().kind !== _language_tokenKind__WEBPACK_IMPORTED_MODULE_2__[/* TokenKind */ "a"].EOF) {
    var currentToken = lexer.token;
    var tokenKind = currentToken.kind;
    /**
     * Every two non-punctuator tokens should have space between them.
     * Also prevent case of non-punctuator token following by spread resulting
     * in invalid token (e.g. `1...` is invalid Float token).
     */

    var isNonPunctuator = !Object(_language_lexer__WEBPACK_IMPORTED_MODULE_3__[/* isPunctuatorToken */ "b"])(currentToken);

    if (wasLastAddedTokenNonPunctuator) {
      if (isNonPunctuator || currentToken.kind === _language_tokenKind__WEBPACK_IMPORTED_MODULE_2__[/* TokenKind */ "a"].SPREAD) {
        strippedBody += ' ';
      }
    }

    var tokenBody = body.slice(currentToken.start, currentToken.end);

    if (tokenKind === _language_tokenKind__WEBPACK_IMPORTED_MODULE_2__[/* TokenKind */ "a"].BLOCK_STRING) {
      strippedBody += dedentBlockString(tokenBody);
    } else {
      strippedBody += tokenBody;
    }

    wasLastAddedTokenNonPunctuator = isNonPunctuator;
  }

  return strippedBody;
}

function dedentBlockString(blockStr) {
  // skip leading and trailing triple quotations
  var rawStr = blockStr.slice(3, -3);
  var body = Object(_language_blockString__WEBPACK_IMPORTED_MODULE_4__[/* dedentBlockStringValue */ "a"])(rawStr);
  var lines = body.split(/\r\n|[\n\r]/g);

  if (Object(_language_blockString__WEBPACK_IMPORTED_MODULE_4__[/* getBlockStringIndentation */ "b"])(lines) > 0) {
    body = '\n' + body;
  }

  var lastChar = body[body.length - 1];
  var hasTrailingQuote = lastChar === '"' && body.slice(-4) !== '\\"""';

  if (hasTrailingQuote || lastChar === '\\') {
    body += '\n';
  }

  return '"""' + body + '"""';
}


/***/ }),
/* 107 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return findDeprecatedUsages; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _language_visitor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var _TypeInfo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(44);




/**
 * A validation rule which reports deprecated usages.
 *
 * Returns a list of GraphQLError instances describing each deprecated use.
 */

function findDeprecatedUsages(schema, ast) {
  var errors = [];
  var typeInfo = new _TypeInfo__WEBPACK_IMPORTED_MODULE_3__[/* TypeInfo */ "a"](schema);
  Object(_language_visitor__WEBPACK_IMPORTED_MODULE_1__[/* visit */ "c"])(ast, Object(_language_visitor__WEBPACK_IMPORTED_MODULE_1__[/* visitWithTypeInfo */ "e"])(typeInfo, {
    Field: function Field(node) {
      var fieldDef = typeInfo.getFieldDef();

      if (fieldDef && fieldDef.isDeprecated) {
        var parentType = typeInfo.getParentType();

        if (parentType) {
          var reason = fieldDef.deprecationReason;
          errors.push(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"]("The field ".concat(parentType.name, ".").concat(fieldDef.name, " is deprecated.") + (reason ? ' ' + reason : ''), node));
        }
      }
    },
    EnumValue: function EnumValue(node) {
      var enumVal = typeInfo.getEnumValue();

      if (enumVal && enumVal.isDeprecated) {
        var type = Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* getNamedType */ "A"])(typeInfo.getInputType());

        if (type) {
          var reason = enumVal.deprecationReason;
          errors.push(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"]("The enum value ".concat(type.name, ".").concat(enumVal.name, " is deprecated.") + (reason ? ' ' + reason : ''), node));
        }
      }
    }
  }));
  return errors;
}


/***/ }),
/* 108 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

function mergeDeep(target, source) {
  var output = Object.assign({}, target);

  if (isObject(target) && isObject(source)) {
    Object.keys(source).forEach(function (key) {
      var _a, _b;

      if (isObject(source[key])) {
        if (!(key in target)) {
          Object.assign(output, (_a = {}, _a[key] = source[key], _a));
        } else {
          output[key] = mergeDeep(target[key], source[key]);
        }
      } else {
        Object.assign(output, (_b = {}, _b[key] = source[key], _b));
      }
    });
  }

  return output;
}

exports.default = mergeDeep;

function isObject(item) {
  return item && typeof item === 'object' && !Array.isArray(item);
}

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11); // FIXME: Replace with https://github.com/graphql/graphql-js/blob/master/src/type/scalars.js#L139


exports.specifiedScalarTypes = [graphql_1.GraphQLString, graphql_1.GraphQLInt, graphql_1.GraphQLFloat, graphql_1.GraphQLBoolean, graphql_1.GraphQLID];

function isSpecifiedScalarType(type) {
  return graphql_1.isNamedType(type) && ( // Would prefer to use specifiedScalarTypes.some(), however %checks needs
  // a simple expression.
  type.name === graphql_1.GraphQLString.name || type.name === graphql_1.GraphQLInt.name || type.name === graphql_1.GraphQLFloat.name || type.name === graphql_1.GraphQLBoolean.name || type.name === graphql_1.GraphQLID.name);
}

exports.default = isSpecifiedScalarType;

/***/ }),
/* 110 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just
 * resolves aliases.
 * @param info The info argument to the resolver.
 */

function getResponseKeyFromInfo(info) {
  return info.fieldNodes[0].alias ? info.fieldNodes[0].alias.value : info.fieldName;
}

exports.getResponseKeyFromInfo = getResponseKeyFromInfo;

/***/ }),
/* 111 */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

/***/ }),
/* 112 */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4

  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
}

module.exports = bytesToUuid;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var apollo_link_1 = __webpack_require__(49);

var apollo_link_2 = __webpack_require__(49);

exports.execute = apollo_link_2.execute;

function linkToFetcher(link) {
  return function (fetcherOperation) {
    return apollo_link_1.makePromise(apollo_link_1.execute(link, fetcherOperation));
  };
}

exports.default = linkToFetcher;

/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return equal; });
var _a = Object.prototype,
    toString = _a.toString,
    hasOwnProperty = _a.hasOwnProperty;
var previousComparisons = new Map();
/**
 * Performs a deep equality check on two JavaScript values, tolerating cycles.
 */

function equal(a, b) {
  try {
    return check(a, b);
  } finally {
    previousComparisons.clear();
  }
}

function check(a, b) {
  // If the two values are strictly equal, our job is easy.
  if (a === b) {
    return true;
  } // Object.prototype.toString returns a representation of the runtime type of
  // the given value that is considerably more precise than typeof.


  var aTag = toString.call(a);
  var bTag = toString.call(b); // If the runtime types of a and b are different, they could maybe be equal
  // under some interpretation of equality, but for simplicity and performance
  // we just return false instead.

  if (aTag !== bTag) {
    return false;
  }

  switch (aTag) {
    case '[object Array]':
      // Arrays are a lot like other objects, but we can cheaply compare their
      // lengths as a short-cut before comparing their elements.
      if (a.length !== b.length) return false;
    // Fall through to object case...

    case '[object Object]':
      {
        if (previouslyCompared(a, b)) return true;
        var aKeys = Object.keys(a);
        var bKeys = Object.keys(b); // If `a` and `b` have a different number of enumerable keys, they
        // must be different.

        var keyCount = aKeys.length;
        if (keyCount !== bKeys.length) return false; // Now make sure they have the same keys.

        for (var k = 0; k < keyCount; ++k) {
          if (!hasOwnProperty.call(b, aKeys[k])) {
            return false;
          }
        } // Finally, check deep equality of all child properties.


        for (var k = 0; k < keyCount; ++k) {
          var key = aKeys[k];

          if (!check(a[key], b[key])) {
            return false;
          }
        }

        return true;
      }

    case '[object Error]':
      return a.name === b.name && a.message === b.message;

    case '[object Number]':
      // Handle NaN, which is !== itself.
      if (a !== a) return b !== b;
    // Fall through to shared +a === +b case...

    case '[object Boolean]':
    case '[object Date]':
      return +a === +b;

    case '[object RegExp]':
    case '[object String]':
      return a == "" + b;

    case '[object Map]':
    case '[object Set]':
      {
        if (a.size !== b.size) return false;
        if (previouslyCompared(a, b)) return true;
        var aIterator = a.entries();
        var isMap = aTag === '[object Map]';

        while (true) {
          var info = aIterator.next();
          if (info.done) break; // If a instanceof Set, aValue === aKey.

          var _a = info.value,
              aKey = _a[0],
              aValue = _a[1]; // So this works the same way for both Set and Map.

          if (!b.has(aKey)) {
            return false;
          } // However, we care about deep equality of values only when dealing
          // with Map structures.


          if (isMap && !check(aValue, b.get(aKey))) {
            return false;
          }
        }

        return true;
      }
  } // Otherwise the values are not equal.


  return false;
}

function previouslyCompared(a, b) {
  // Though cyclic references can make an object graph appear infinite from the
  // perspective of a depth-first traversal, the graph still contains a finite
  // number of distinct object references. We use the previousComparisons cache
  // to avoid comparing the same pair of object references more than once, which
  // guarantees termination (even if we end up comparing every object in one
  // graph to every object in the other graph, which is extremely unlikely),
  // while still allowing weird isomorphic structures (like rings with different
  // lengths) a chance to pass the equality test.
  var bSet = previousComparisons.get(a);

  if (bSet) {
    // Return true here because we can be sure false will be returned somewhere
    // else if the objects are not equivalent.
    if (bSet.has(b)) return true;
  } else {
    previousComparisons.set(a, bSet = new Set());
  }

  bSet.add(b);
  return false;
}

/* unused harmony default export */ var _unused_webpack_default_export = (equal);


/***/ }),
/* 115 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

function isEmptyObject(obj) {
  if (!obj) {
    return true;
  }

  for (var key in obj) {
    if (Object.hasOwnProperty.call(obj, key)) {
      return false;
    }
  }

  return true;
}

exports.default = isEmptyObject;

/***/ }),
/* 116 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _introspectionQuery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getIntrospectionQuery", function() { return _introspectionQuery__WEBPACK_IMPORTED_MODULE_0__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "introspectionQuery", function() { return _introspectionQuery__WEBPACK_IMPORTED_MODULE_0__["b"]; });

/* harmony import */ var _getOperationAST__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getOperationAST", function() { return _getOperationAST__WEBPACK_IMPORTED_MODULE_1__["a"]; });

/* harmony import */ var _getOperationRootType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getOperationRootType", function() { return _getOperationRootType__WEBPACK_IMPORTED_MODULE_2__["a"]; });

/* harmony import */ var _introspectionFromSchema__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "introspectionFromSchema", function() { return _introspectionFromSchema__WEBPACK_IMPORTED_MODULE_3__["a"]; });

/* harmony import */ var _buildClientSchema__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(99);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buildClientSchema", function() { return _buildClientSchema__WEBPACK_IMPORTED_MODULE_4__["a"]; });

/* harmony import */ var _buildASTSchema__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(51);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buildASTSchema", function() { return _buildASTSchema__WEBPACK_IMPORTED_MODULE_5__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "buildSchema", function() { return _buildASTSchema__WEBPACK_IMPORTED_MODULE_5__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDescription", function() { return _buildASTSchema__WEBPACK_IMPORTED_MODULE_5__["d"]; });

/* harmony import */ var _extendSchema__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(100);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extendSchema", function() { return _extendSchema__WEBPACK_IMPORTED_MODULE_6__["a"]; });

/* harmony import */ var _lexicographicSortSchema__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(101);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lexicographicSortSchema", function() { return _lexicographicSortSchema__WEBPACK_IMPORTED_MODULE_7__["a"]; });

/* harmony import */ var _schemaPrinter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(69);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "printSchema", function() { return _schemaPrinter__WEBPACK_IMPORTED_MODULE_8__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "printType", function() { return _schemaPrinter__WEBPACK_IMPORTED_MODULE_8__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "printIntrospectionSchema", function() { return _schemaPrinter__WEBPACK_IMPORTED_MODULE_8__["a"]; });

/* harmony import */ var _typeFromAST__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(19);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "typeFromAST", function() { return _typeFromAST__WEBPACK_IMPORTED_MODULE_9__["a"]; });

/* harmony import */ var _valueFromAST__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(45);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valueFromAST", function() { return _valueFromAST__WEBPACK_IMPORTED_MODULE_10__["a"]; });

/* harmony import */ var _valueFromASTUntyped__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(72);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "valueFromASTUntyped", function() { return _valueFromASTUntyped__WEBPACK_IMPORTED_MODULE_11__["a"]; });

/* harmony import */ var _astFromValue__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(47);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "astFromValue", function() { return _astFromValue__WEBPACK_IMPORTED_MODULE_12__["a"]; });

/* harmony import */ var _TypeInfo__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(44);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TypeInfo", function() { return _TypeInfo__WEBPACK_IMPORTED_MODULE_13__["a"]; });

/* harmony import */ var _coerceInputValue__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(52);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "coerceInputValue", function() { return _coerceInputValue__WEBPACK_IMPORTED_MODULE_14__["a"]; });

/* harmony import */ var _coerceValue__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(73);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "coerceValue", function() { return _coerceValue__WEBPACK_IMPORTED_MODULE_15__["a"]; });

/* harmony import */ var _isValidJSValue__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(102);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isValidJSValue", function() { return _isValidJSValue__WEBPACK_IMPORTED_MODULE_16__["a"]; });

/* harmony import */ var _isValidLiteralValue__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(103);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isValidLiteralValue", function() { return _isValidLiteralValue__WEBPACK_IMPORTED_MODULE_17__["a"]; });

/* harmony import */ var _concatAST__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(104);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatAST", function() { return _concatAST__WEBPACK_IMPORTED_MODULE_18__["a"]; });

/* harmony import */ var _separateOperations__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(105);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "separateOperations", function() { return _separateOperations__WEBPACK_IMPORTED_MODULE_19__["a"]; });

/* harmony import */ var _stripIgnoredCharacters__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(106);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stripIgnoredCharacters", function() { return _stripIgnoredCharacters__WEBPACK_IMPORTED_MODULE_20__["a"]; });

/* harmony import */ var _typeComparators__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(35);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isEqualType", function() { return _typeComparators__WEBPACK_IMPORTED_MODULE_21__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isTypeSubTypeOf", function() { return _typeComparators__WEBPACK_IMPORTED_MODULE_21__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "doTypesOverlap", function() { return _typeComparators__WEBPACK_IMPORTED_MODULE_21__["a"]; });

/* harmony import */ var _assertValidName__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(63);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assertValidName", function() { return _assertValidName__WEBPACK_IMPORTED_MODULE_22__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isValidNameError", function() { return _assertValidName__WEBPACK_IMPORTED_MODULE_22__["b"]; });

/* harmony import */ var _findBreakingChanges__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(60);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BreakingChangeType", function() { return _findBreakingChanges__WEBPACK_IMPORTED_MODULE_23__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DangerousChangeType", function() { return _findBreakingChanges__WEBPACK_IMPORTED_MODULE_23__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findBreakingChanges", function() { return _findBreakingChanges__WEBPACK_IMPORTED_MODULE_23__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findDangerousChanges", function() { return _findBreakingChanges__WEBPACK_IMPORTED_MODULE_23__["d"]; });

/* harmony import */ var _findDeprecatedUsages__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(107);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findDeprecatedUsages", function() { return _findDeprecatedUsages__WEBPACK_IMPORTED_MODULE_24__["a"]; });

// The GraphQL query recommended for a full schema introspection.

// Gets the target Operation from a Document.
 // Gets the Type for the target Operation AST.

 // Convert a GraphQLSchema to an IntrospectionQuery.

 // Build a GraphQLSchema from an introspection result.

 // Build a GraphQLSchema from GraphQL Schema language.


// Extends an existing GraphQLSchema from a parsed GraphQL Schema language AST.
 // Sort a GraphQLSchema.

 // Print a GraphQLSchema to GraphQL Schema language.

 // Create a GraphQLType from a GraphQL language AST.

 // Create a JavaScript value from a GraphQL language AST with a type.

 // Create a JavaScript value from a GraphQL language AST without a type.

 // Create a GraphQL language AST from a JavaScript value.

 // A helper to use within recursive-descent visitors which need to be aware of
// the GraphQL type system.

 // Coerces a JavaScript value to a GraphQL type, or produces errors.

 // @deprecated use coerceInputValue - will be removed in v15.

 // @deprecated use coerceInputValue - will be removed in v15.

 // @deprecated use validation - will be removed in v15

 // Concatenates multiple AST together.

 // Separates an AST into an AST per Operation.

 // Strips characters that are not significant to the validity or execution
// of a GraphQL document.

 // Comparators for types

 // Asserts that a string is a valid GraphQL name

 // Compares two GraphQLSchemas and detects breaking changes.


// Report all deprecated usage within a GraphQL document.



/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var AddArgumentsAsVariablesTransform =
/** @class */
function () {
  function AddArgumentsAsVariablesTransform(schema, args) {
    this.schema = schema;
    this.args = args;
  }

  AddArgumentsAsVariablesTransform.prototype.transformRequest = function (originalRequest) {
    var _a = addVariablesToRootField(this.schema, originalRequest.document, this.args),
        document = _a.document,
        newVariables = _a.newVariables;

    var variables = __assign(__assign({}, originalRequest.variables), newVariables);

    return {
      document: document,
      variables: variables
    };
  };

  return AddArgumentsAsVariablesTransform;
}();

exports.default = AddArgumentsAsVariablesTransform;

function addVariablesToRootField(targetSchema, document, args) {
  var operations = document.definitions.filter(function (def) {
    return def.kind === graphql_1.Kind.OPERATION_DEFINITION;
  });
  var fragments = document.definitions.filter(function (def) {
    return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION;
  });
  var variableNames = {};
  var newOperations = operations.map(function (operation) {
    var existingVariables = operation.variableDefinitions.map(function (variableDefinition) {
      return variableDefinition.variable.name.value;
    });
    var variableCounter = 0;
    var variables = {};

    var generateVariableName = function generateVariableName(argName) {
      var varName;

      do {
        varName = "_v" + variableCounter + "_" + argName;
        variableCounter++;
      } while (existingVariables.indexOf(varName) !== -1);

      return varName;
    };

    var type;

    if (operation.operation === 'subscription') {
      type = targetSchema.getSubscriptionType();
    } else if (operation.operation === 'mutation') {
      type = targetSchema.getMutationType();
    } else {
      type = targetSchema.getQueryType();
    }

    var newSelectionSet = [];
    operation.selectionSet.selections.forEach(function (selection) {
      if (selection.kind === graphql_1.Kind.FIELD) {
        var newArgs_1 = {};
        selection.arguments.forEach(function (argument) {
          newArgs_1[argument.name.value] = argument;
        });
        var name_1 = selection.name.value;
        var field = type.getFields()[name_1];
        field.args.forEach(function (argument) {
          if (argument.name in args) {
            var variableName = generateVariableName(argument.name);
            variableNames[argument.name] = variableName;
            newArgs_1[argument.name] = {
              kind: graphql_1.Kind.ARGUMENT,
              name: {
                kind: graphql_1.Kind.NAME,
                value: argument.name
              },
              value: {
                kind: graphql_1.Kind.VARIABLE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: variableName
                }
              }
            };
            existingVariables.push(variableName);
            variables[variableName] = {
              kind: graphql_1.Kind.VARIABLE_DEFINITION,
              variable: {
                kind: graphql_1.Kind.VARIABLE,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: variableName
                }
              },
              type: typeToAst(argument.type)
            };
          }
        });
        newSelectionSet.push(__assign(__assign({}, selection), {
          arguments: Object.keys(newArgs_1).map(function (argName) {
            return newArgs_1[argName];
          })
        }));
      } else {
        newSelectionSet.push(selection);
      }
    });
    return __assign(__assign({}, operation), {
      variableDefinitions: operation.variableDefinitions.concat(Object.keys(variables).map(function (varName) {
        return variables[varName];
      })),
      selectionSet: {
        kind: graphql_1.Kind.SELECTION_SET,
        selections: newSelectionSet
      }
    });
  });
  var newVariables = {};
  Object.keys(variableNames).forEach(function (name) {
    newVariables[variableNames[name]] = args[name];
  });
  return {
    document: __assign(__assign({}, document), {
      definitions: __spreadArrays(newOperations, fragments)
    }),
    newVariables: newVariables
  };
}

function typeToAst(type) {
  if (type instanceof graphql_1.GraphQLNonNull) {
    var innerType = typeToAst(type.ofType);

    if (innerType.kind === graphql_1.Kind.LIST_TYPE || innerType.kind === graphql_1.Kind.NAMED_TYPE) {
      return {
        kind: graphql_1.Kind.NON_NULL_TYPE,
        type: innerType
      };
    } else {
      throw new Error('Incorrent inner non-null type');
    }
  } else if (type instanceof graphql_1.GraphQLList) {
    return {
      kind: graphql_1.Kind.LIST_TYPE,
      type: typeToAst(type.ofType)
    };
  } else {
    return {
      kind: graphql_1.Kind.NAMED_TYPE,
      name: {
        kind: graphql_1.Kind.NAME,
        value: type.toString()
      }
    };
  }
}

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var implementsAbstractType_1 = __webpack_require__(119);

var FilterToSchema =
/** @class */
function () {
  function FilterToSchema(targetSchema) {
    this.targetSchema = targetSchema;
  }

  FilterToSchema.prototype.transformRequest = function (originalRequest) {
    var document = filterDocumentToSchema(this.targetSchema, originalRequest.document);
    return __assign(__assign({}, originalRequest), {
      document: document
    });
  };

  return FilterToSchema;
}();

exports.default = FilterToSchema;

function filterDocumentToSchema(targetSchema, document) {
  var operations = document.definitions.filter(function (def) {
    return def.kind === graphql_1.Kind.OPERATION_DEFINITION;
  });
  var fragments = document.definitions.filter(function (def) {
    return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION;
  });
  var usedFragments = [];
  var newOperations = [];
  var newFragments = [];
  var validFragments = fragments.filter(function (fragment) {
    var typeName = fragment.typeCondition.name.value;
    return Boolean(targetSchema.getType(typeName));
  });
  var validFragmentsWithType = {};
  validFragments.forEach(function (fragment) {
    var typeName = fragment.typeCondition.name.value;
    var type = targetSchema.getType(typeName);
    validFragmentsWithType[fragment.name.value] = type;
  });
  var fragmentSet = Object.create(null);
  operations.forEach(function (operation) {
    var type;

    if (operation.operation === 'subscription') {
      type = targetSchema.getSubscriptionType();
    } else if (operation.operation === 'mutation') {
      type = targetSchema.getMutationType();
    } else {
      type = targetSchema.getQueryType();
    }

    var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, operation.selectionSet),
        selectionSet = _a.selectionSet,
        operationUsedFragments = _a.usedFragments,
        operationUsedVariables = _a.usedVariables;

    usedFragments = union(usedFragments, operationUsedFragments);

    var _b = collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments),
        collectedUsedVariables = _b.usedVariables,
        collectedNewFragments = _b.newFragments,
        collectedFragmentSet = _b.fragmentSet;

    var fullUsedVariables = union(operationUsedVariables, collectedUsedVariables);
    newFragments = collectedNewFragments;
    fragmentSet = collectedFragmentSet;
    var variableDefinitions = operation.variableDefinitions.filter(function (variable) {
      return fullUsedVariables.indexOf(variable.variable.name.value) !== -1;
    });
    newOperations.push({
      kind: graphql_1.Kind.OPERATION_DEFINITION,
      operation: operation.operation,
      name: operation.name,
      directives: operation.directives,
      variableDefinitions: variableDefinitions,
      selectionSet: selectionSet
    });
  });
  return {
    kind: graphql_1.Kind.DOCUMENT,
    definitions: __spreadArrays(newOperations, newFragments)
  };
}

function collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments) {
  var usedVariables = [];
  var newFragments = [];

  var _loop_1 = function _loop_1() {
    var nextFragmentName = usedFragments.pop();
    var fragment = validFragments.find(function (fr) {
      return fr.name.value === nextFragmentName;
    });

    if (fragment) {
      var name_1 = nextFragmentName;
      var typeName = fragment.typeCondition.name.value;
      var type = targetSchema.getType(typeName);

      var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, fragment.selectionSet),
          selectionSet = _a.selectionSet,
          fragmentUsedFragments = _a.usedFragments,
          fragmentUsedVariables = _a.usedVariables;

      usedFragments = union(usedFragments, fragmentUsedFragments);
      usedVariables = union(usedVariables, fragmentUsedVariables);

      if (!fragmentSet[name_1]) {
        fragmentSet[name_1] = true;
        newFragments.push({
          kind: graphql_1.Kind.FRAGMENT_DEFINITION,
          name: {
            kind: graphql_1.Kind.NAME,
            value: name_1
          },
          typeCondition: fragment.typeCondition,
          selectionSet: selectionSet
        });
      }
    }
  };

  while (usedFragments.length !== 0) {
    _loop_1();
  }

  return {
    usedVariables: usedVariables,
    newFragments: newFragments,
    fragmentSet: fragmentSet
  };
}

function filterSelectionSet(schema, type, validFragments, selectionSet) {
  var _a;

  var usedFragments = [];
  var usedVariables = [];
  var typeStack = [type]; // Should be rewritten using visitWithSchema

  var filteredSelectionSet = graphql_1.visit(selectionSet, (_a = {}, _a[graphql_1.Kind.FIELD] = {
    enter: function enter(node) {
      var parentType = resolveType(typeStack[typeStack.length - 1]);

      if (parentType instanceof graphql_1.GraphQLObjectType || parentType instanceof graphql_1.GraphQLInterfaceType) {
        var fields = parentType.getFields();
        var field = node.name.value === '__typename' ? graphql_1.TypeNameMetaFieldDef : fields[node.name.value];

        if (!field) {
          return null;
        } else {
          typeStack.push(field.type);
        }

        var argNames_1 = (field.args || []).map(function (arg) {
          return arg.name;
        });

        if (node.arguments) {
          var args = node.arguments.filter(function (arg) {
            return argNames_1.indexOf(arg.name.value) !== -1;
          });

          if (args.length !== node.arguments.length) {
            return __assign(__assign({}, node), {
              arguments: args
            });
          }
        }
      } else if (parentType instanceof graphql_1.GraphQLUnionType && node.name.value === '__typename') {
        typeStack.push(graphql_1.TypeNameMetaFieldDef.type);
      }
    },
    leave: function leave(node) {
      var _a;

      var currentType = typeStack.pop();
      var resolvedType = resolveType(currentType);

      if (resolvedType instanceof graphql_1.GraphQLObjectType || resolvedType instanceof graphql_1.GraphQLInterfaceType) {
        var selections = node.selectionSet && node.selectionSet.selections || null;

        if (!selections || selections.length === 0) {
          // need to remove any added variables. Is there a better way to do this?
          graphql_1.visit(node, (_a = {}, _a[graphql_1.Kind.VARIABLE] = function (variableNode) {
            var index = usedVariables.indexOf(variableNode.name.value);

            if (index !== -1) {
              usedVariables.splice(index, 1);
            }
          }, _a));
          return null;
        }
      }
    }
  }, _a[graphql_1.Kind.FRAGMENT_SPREAD] = function (node) {
    if (node.name.value in validFragments) {
      var parentType = resolveType(typeStack[typeStack.length - 1]);
      var innerType = validFragments[node.name.value];

      if (!implementsAbstractType_1.default(schema, parentType, innerType)) {
        return null;
      } else {
        usedFragments.push(node.name.value);
        return;
      }
    } else {
      return null;
    }
  }, _a[graphql_1.Kind.INLINE_FRAGMENT] = {
    enter: function enter(node) {
      if (node.typeCondition) {
        var innerType = schema.getType(node.typeCondition.name.value);
        var parentType = resolveType(typeStack[typeStack.length - 1]);

        if (implementsAbstractType_1.default(schema, parentType, innerType)) {
          typeStack.push(innerType);
        } else {
          return null;
        }
      }
    },
    leave: function leave(node) {
      typeStack.pop();
    }
  }, _a[graphql_1.Kind.VARIABLE] = function (node) {
    usedVariables.push(node.name.value);
  }, _a));
  return {
    selectionSet: filteredSelectionSet,
    usedFragments: usedFragments,
    usedVariables: usedVariables
  };
}

function resolveType(type) {
  var lastType = type;

  while (lastType instanceof graphql_1.GraphQLNonNull || lastType instanceof graphql_1.GraphQLList) {
    lastType = lastType.ofType;
  }

  return lastType;
}

function union() {
  var arrays = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    arrays[_i] = arguments[_i];
  }

  var cache = {};
  var result = [];
  arrays.forEach(function (array) {
    array.forEach(function (item) {
      if (!cache[item]) {
        cache[item] = true;
        result.push(item);
      }
    });
  });
  return result;
}

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

function implementsAbstractType(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  } else if (graphql_1.isCompositeType(typeA) && graphql_1.isCompositeType(typeB)) {
    return graphql_1.doTypesOverlap(schema, typeA, typeB);
  } else {
    return false;
  }
}

exports.default = implementsAbstractType;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var AddTypenameToAbstract =
/** @class */
function () {
  function AddTypenameToAbstract(targetSchema) {
    this.targetSchema = targetSchema;
  }

  AddTypenameToAbstract.prototype.transformRequest = function (originalRequest) {
    var document = addTypenameToAbstract(this.targetSchema, originalRequest.document);
    return __assign(__assign({}, originalRequest), {
      document: document
    });
  };

  return AddTypenameToAbstract;
}();

exports.default = AddTypenameToAbstract;

function addTypenameToAbstract(targetSchema, document) {
  var _a;

  var typeInfo = new graphql_1.TypeInfo(targetSchema);
  return graphql_1.visit(document, graphql_1.visitWithTypeInfo(typeInfo, (_a = {}, _a[graphql_1.Kind.SELECTION_SET] = function (node) {
    var parentType = typeInfo.getParentType();
    var selections = node.selections;

    if (parentType && (parentType instanceof graphql_1.GraphQLInterfaceType || parentType instanceof graphql_1.GraphQLUnionType) && !selections.find(function (_) {
      return _.kind === graphql_1.Kind.FIELD && _.name.value === '__typename';
    })) {
      selections = selections.concat({
        kind: graphql_1.Kind.FIELD,
        name: {
          kind: graphql_1.Kind.NAME,
          value: '__typename'
        }
      });
    }

    if (selections !== node.selections) {
      return __assign(__assign({}, node), {
        selections: selections
      });
    }
  }, _a)));
}

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var errors_1 = __webpack_require__(81);

var CheckResultAndHandleErrors =
/** @class */
function () {
  function CheckResultAndHandleErrors(info, fieldName) {
    this.info = info;
    this.fieldName = fieldName;
  }

  CheckResultAndHandleErrors.prototype.transformResult = function (result) {
    return errors_1.checkResultAndHandleErrors(result, this.info, this.fieldName);
  };

  return CheckResultAndHandleErrors;
}();

exports.default = CheckResultAndHandleErrors;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var implementsAbstractType_1 = __webpack_require__(119);

var ExpandAbstractTypes =
/** @class */
function () {
  function ExpandAbstractTypes(transformedSchema, targetSchema) {
    this.targetSchema = targetSchema;
    this.mapping = extractPossibleTypes(transformedSchema, targetSchema);
    this.reverseMapping = flipMapping(this.mapping);
  }

  ExpandAbstractTypes.prototype.transformRequest = function (originalRequest) {
    var document = expandAbstractTypes(this.targetSchema, this.mapping, this.reverseMapping, originalRequest.document);
    return __assign(__assign({}, originalRequest), {
      document: document
    });
  };

  return ExpandAbstractTypes;
}();

exports.default = ExpandAbstractTypes;

function extractPossibleTypes(transformedSchema, targetSchema) {
  var typeMap = transformedSchema.getTypeMap();
  var mapping = {};
  Object.keys(typeMap).forEach(function (typeName) {
    var type = typeMap[typeName];

    if (graphql_1.isAbstractType(type)) {
      var targetType = targetSchema.getType(typeName);

      if (!graphql_1.isAbstractType(targetType)) {
        var implementations = transformedSchema.getPossibleTypes(type) || [];
        mapping[typeName] = implementations.filter(function (impl) {
          return targetSchema.getType(impl.name);
        }).map(function (impl) {
          return impl.name;
        });
      }
    }
  });
  return mapping;
}

function flipMapping(mapping) {
  var result = {};
  Object.keys(mapping).forEach(function (typeName) {
    var toTypeNames = mapping[typeName];
    toTypeNames.forEach(function (toTypeName) {
      if (!result[toTypeName]) {
        result[toTypeName] = [];
      }

      result[toTypeName].push(typeName);
    });
  });
  return result;
}

function expandAbstractTypes(targetSchema, mapping, reverseMapping, document) {
  var _a;

  var operations = document.definitions.filter(function (def) {
    return def.kind === graphql_1.Kind.OPERATION_DEFINITION;
  });
  var fragments = document.definitions.filter(function (def) {
    return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION;
  });
  var existingFragmentNames = fragments.map(function (fragment) {
    return fragment.name.value;
  });
  var fragmentCounter = 0;

  var generateFragmentName = function generateFragmentName(typeName) {
    var fragmentName;

    do {
      fragmentName = "_" + typeName + "_Fragment" + fragmentCounter;
      fragmentCounter++;
    } while (existingFragmentNames.indexOf(fragmentName) !== -1);

    return fragmentName;
  };

  var newFragments = [];
  var fragmentReplacements = {};
  fragments.forEach(function (fragment) {
    newFragments.push(fragment);
    var possibleTypes = mapping[fragment.typeCondition.name.value];

    if (possibleTypes) {
      fragmentReplacements[fragment.name.value] = [];
      possibleTypes.forEach(function (possibleTypeName) {
        var name = generateFragmentName(possibleTypeName);
        existingFragmentNames.push(name);
        var newFragment = {
          kind: graphql_1.Kind.FRAGMENT_DEFINITION,
          name: {
            kind: graphql_1.Kind.NAME,
            value: name
          },
          typeCondition: {
            kind: graphql_1.Kind.NAMED_TYPE,
            name: {
              kind: graphql_1.Kind.NAME,
              value: possibleTypeName
            }
          },
          selectionSet: fragment.selectionSet
        };
        newFragments.push(newFragment);
        fragmentReplacements[fragment.name.value].push({
          fragmentName: name,
          typeName: possibleTypeName
        });
      });
    }
  });

  var newDocument = __assign(__assign({}, document), {
    definitions: __spreadArrays(operations, newFragments)
  });

  var typeInfo = new graphql_1.TypeInfo(targetSchema);
  return graphql_1.visit(newDocument, graphql_1.visitWithTypeInfo(typeInfo, (_a = {}, _a[graphql_1.Kind.SELECTION_SET] = function (node) {
    var newSelections = __spreadArrays(node.selections);

    var parentType = graphql_1.getNamedType(typeInfo.getParentType());
    node.selections.forEach(function (selection) {
      if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {
        var possibleTypes = mapping[selection.typeCondition.name.value];

        if (possibleTypes) {
          possibleTypes.forEach(function (possibleType) {
            if (implementsAbstractType_1.default(targetSchema, parentType, targetSchema.getType(possibleType))) {
              newSelections.push({
                kind: graphql_1.Kind.INLINE_FRAGMENT,
                typeCondition: {
                  kind: graphql_1.Kind.NAMED_TYPE,
                  name: {
                    kind: graphql_1.Kind.NAME,
                    value: possibleType
                  }
                },
                selectionSet: selection.selectionSet
              });
            }
          });
        }
      } else if (selection.kind === graphql_1.Kind.FRAGMENT_SPREAD) {
        var fragmentName = selection.name.value;
        var replacements = fragmentReplacements[fragmentName];

        if (replacements) {
          replacements.forEach(function (replacement) {
            var typeName = replacement.typeName;

            if (implementsAbstractType_1.default(targetSchema, parentType, targetSchema.getType(typeName))) {
              newSelections.push({
                kind: graphql_1.Kind.FRAGMENT_SPREAD,
                name: {
                  kind: graphql_1.Kind.NAME,
                  value: replacement.fragmentName
                }
              });
            }
          });
        }
      }
    });

    if (parentType && reverseMapping[parentType.name]) {
      newSelections.push({
        kind: graphql_1.Kind.FIELD,
        name: {
          kind: graphql_1.Kind.NAME,
          value: '__typename'
        }
      });
    }

    if (newSelections.length !== node.selections.length) {
      return __assign(__assign({}, node), {
        selections: newSelections
      });
    }
  }, _a)));
}

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var ReplaceFieldWithFragment =
/** @class */
function () {
  function ReplaceFieldWithFragment(targetSchema, fragments) {
    this.targetSchema = targetSchema;
    this.mapping = {};

    for (var _i = 0, fragments_1 = fragments; _i < fragments_1.length; _i++) {
      var _a = fragments_1[_i],
          field = _a.field,
          fragment = _a.fragment;
      var parsedFragment = parseFragmentToInlineFragment(fragment);
      var actualTypeName = parsedFragment.typeCondition.name.value;
      this.mapping[actualTypeName] = this.mapping[actualTypeName] || {};

      if (this.mapping[actualTypeName][field]) {
        this.mapping[actualTypeName][field].push(parsedFragment);
      } else {
        this.mapping[actualTypeName][field] = [parsedFragment];
      }
    }
  }

  ReplaceFieldWithFragment.prototype.transformRequest = function (originalRequest) {
    var document = replaceFieldsWithFragments(this.targetSchema, originalRequest.document, this.mapping);
    return __assign(__assign({}, originalRequest), {
      document: document
    });
  };

  return ReplaceFieldWithFragment;
}();

exports.default = ReplaceFieldWithFragment;

function replaceFieldsWithFragments(targetSchema, document, mapping) {
  var _a;

  var typeInfo = new graphql_1.TypeInfo(targetSchema);
  return graphql_1.visit(document, graphql_1.visitWithTypeInfo(typeInfo, (_a = {}, _a[graphql_1.Kind.SELECTION_SET] = function (node) {
    var parentType = typeInfo.getParentType();

    if (parentType) {
      var parentTypeName_1 = parentType.name;
      var selections_1 = node.selections;

      if (mapping[parentTypeName_1]) {
        node.selections.forEach(function (selection) {
          if (selection.kind === graphql_1.Kind.FIELD) {
            var name_1 = selection.name.value;
            var fragments = mapping[parentTypeName_1][name_1];

            if (fragments && fragments.length > 0) {
              var fragment = concatInlineFragments(parentTypeName_1, fragments);
              selections_1 = selections_1.concat(fragment);
            }
          }
        });
      }

      if (selections_1 !== node.selections) {
        return __assign(__assign({}, node), {
          selections: selections_1
        });
      }
    }
  }, _a)));
}

function parseFragmentToInlineFragment(definitions) {
  if (definitions.trim().startsWith('fragment')) {
    var document_1 = graphql_1.parse(definitions);

    for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {
      var definition = _a[_i];

      if (definition.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
        return {
          kind: graphql_1.Kind.INLINE_FRAGMENT,
          typeCondition: definition.typeCondition,
          selectionSet: definition.selectionSet
        };
      }
    }
  }

  var query = graphql_1.parse("{" + definitions + "}").definitions[0];

  for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {
    var selection = _c[_b];

    if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {
      return selection;
    }
  }

  throw new Error('Could not parse fragment');
}

function concatInlineFragments(type, fragments) {
  var fragmentSelections = fragments.reduce(function (selections, fragment) {
    return selections.concat(fragment.selectionSet.selections);
  }, []);
  var deduplicatedFragmentSelection = deduplicateSelection(fragmentSelections);
  return {
    kind: graphql_1.Kind.INLINE_FRAGMENT,
    typeCondition: {
      kind: graphql_1.Kind.NAMED_TYPE,
      name: {
        kind: graphql_1.Kind.NAME,
        value: type
      }
    },
    selectionSet: {
      kind: graphql_1.Kind.SELECTION_SET,
      selections: deduplicatedFragmentSelection
    }
  };
}

function deduplicateSelection(nodes) {
  var selectionMap = nodes.reduce(function (map, node) {
    var _a, _b, _c;

    switch (node.kind) {
      case 'Field':
        {
          if (node.alias) {
            if (map.hasOwnProperty(node.alias.value)) {
              return map;
            } else {
              return __assign(__assign({}, map), (_a = {}, _a[node.alias.value] = node, _a));
            }
          } else {
            if (map.hasOwnProperty(node.name.value)) {
              return map;
            } else {
              return __assign(__assign({}, map), (_b = {}, _b[node.name.value] = node, _b));
            }
          }
        }

      case 'FragmentSpread':
        {
          if (map.hasOwnProperty(node.name.value)) {
            return map;
          } else {
            return __assign(__assign({}, map), (_c = {}, _c[node.name.value] = node, _c));
          }
        }

      case 'InlineFragment':
        {
          if (map.__fragment) {
            var fragment = map.__fragment;
            return __assign(__assign({}, map), {
              __fragment: concatInlineFragments(fragment.typeCondition.name.value, [fragment, node])
            });
          } else {
            return __assign(__assign({}, map), {
              __fragment: node
            });
          }
        }

      default:
        {
          return map;
        }
    }
  }, {});
  var selection = Object.keys(selectionMap).reduce(function (selectionList, node) {
    return selectionList.concat(selectionMap[node]);
  }, []);
  return selection;
}

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var transformSchema_1 = __webpack_require__(198);

exports.transformSchema = transformSchema_1.default;

var AddArgumentsAsVariables_1 = __webpack_require__(117);

exports.AddArgumentsAsVariables = AddArgumentsAsVariables_1.default;

var CheckResultAndHandleErrors_1 = __webpack_require__(121);

exports.CheckResultAndHandleErrors = CheckResultAndHandleErrors_1.default;

var ReplaceFieldWithFragment_1 = __webpack_require__(123);

exports.ReplaceFieldWithFragment = ReplaceFieldWithFragment_1.default;

var AddTypenameToAbstract_1 = __webpack_require__(120);

exports.AddTypenameToAbstract = AddTypenameToAbstract_1.default;

var FilterToSchema_1 = __webpack_require__(118);

exports.FilterToSchema = FilterToSchema_1.default;

var RenameTypes_1 = __webpack_require__(200);

exports.RenameTypes = RenameTypes_1.default;

var FilterTypes_1 = __webpack_require__(201);

exports.FilterTypes = FilterTypes_1.default;

var TransformRootFields_1 = __webpack_require__(83);

exports.TransformRootFields = TransformRootFields_1.default;

var RenameRootFields_1 = __webpack_require__(202);

exports.RenameRootFields = RenameRootFields_1.default;

var FilterRootFields_1 = __webpack_require__(203);

exports.FilterRootFields = FilterRootFields_1.default;

var ExpandAbstractTypes_1 = __webpack_require__(122);

exports.ExpandAbstractTypes = ExpandAbstractTypes_1.default;

var ExtractField_1 = __webpack_require__(204);

exports.ExtractField = ExtractField_1.default;

var WrapQuery_1 = __webpack_require__(205);

exports.WrapQuery = WrapQuery_1.default;

/***/ }),
/* 125 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),
/* 126 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(128);

var assertThisInitialized = __webpack_require__(208);

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),
/* 128 */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 129 */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(209);

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty,
    prefix = '~';
/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */

function Events() {} //
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//


if (Object.create) {
  Events.prototype = Object.create(null); //
  // This hack is needed because the `__proto__` property is still inherited in
  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
  //

  if (!new Events().__proto__) prefix = false;
}
/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */


function EE(fn, context, once) {
  this.fn = fn;
  this.context = context;
  this.once = once || false;
}
/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */


function addListener(emitter, event, fn, context, once) {
  if (typeof fn !== 'function') {
    throw new TypeError('The listener must be a function');
  }

  var listener = new EE(fn, context || emitter, once),
      evt = prefix ? prefix + event : event;
  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
  return emitter;
}
/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */


function clearEvent(emitter, evt) {
  if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
}
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */


function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}
/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */


EventEmitter.prototype.eventNames = function eventNames() {
  var names = [],
      events,
      name;
  if (this._eventsCount === 0) return names;

  for (name in events = this._events) {
    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
  }

  if (Object.getOwnPropertySymbols) {
    return names.concat(Object.getOwnPropertySymbols(events));
  }

  return names;
};
/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */


EventEmitter.prototype.listeners = function listeners(event) {
  var evt = prefix ? prefix + event : event,
      handlers = this._events[evt];
  if (!handlers) return [];
  if (handlers.fn) return [handlers.fn];

  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
    ee[i] = handlers[i].fn;
  }

  return ee;
};
/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */


EventEmitter.prototype.listenerCount = function listenerCount(event) {
  var evt = prefix ? prefix + event : event,
      listeners = this._events[evt];
  if (!listeners) return 0;
  if (listeners.fn) return 1;
  return listeners.length;
};
/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */


EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
  var evt = prefix ? prefix + event : event;
  if (!this._events[evt]) return false;
  var listeners = this._events[evt],
      len = arguments.length,
      args,
      i;

  if (listeners.fn) {
    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

    switch (len) {
      case 1:
        return listeners.fn.call(listeners.context), true;

      case 2:
        return listeners.fn.call(listeners.context, a1), true;

      case 3:
        return listeners.fn.call(listeners.context, a1, a2), true;

      case 4:
        return listeners.fn.call(listeners.context, a1, a2, a3), true;

      case 5:
        return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;

      case 6:
        return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
    }

    for (i = 1, args = new Array(len - 1); i < len; i++) {
      args[i - 1] = arguments[i];
    }

    listeners.fn.apply(listeners.context, args);
  } else {
    var length = listeners.length,
        j;

    for (i = 0; i < length; i++) {
      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

      switch (len) {
        case 1:
          listeners[i].fn.call(listeners[i].context);
          break;

        case 2:
          listeners[i].fn.call(listeners[i].context, a1);
          break;

        case 3:
          listeners[i].fn.call(listeners[i].context, a1, a2);
          break;

        case 4:
          listeners[i].fn.call(listeners[i].context, a1, a2, a3);
          break;

        default:
          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
            args[j - 1] = arguments[j];
          }
          listeners[i].fn.apply(listeners[i].context, args);
      }
    }
  }

  return true;
};
/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */


EventEmitter.prototype.on = function on(event, fn, context) {
  return addListener(this, event, fn, context, false);
};
/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */


EventEmitter.prototype.once = function once(event, fn, context) {
  return addListener(this, event, fn, context, true);
};
/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */


EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
  var evt = prefix ? prefix + event : event;
  if (!this._events[evt]) return this;

  if (!fn) {
    clearEvent(this, evt);
    return this;
  }

  var listeners = this._events[evt];

  if (listeners.fn) {
    if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
      clearEvent(this, evt);
    }
  } else {
    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
      if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
        events.push(listeners[i]);
      }
    } //
    // Reset the array, or remove it completely if we have no more listeners.
    //


    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
  }

  return this;
};
/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */


EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
  var evt;

  if (event) {
    evt = prefix ? prefix + event : event;
    if (this._events[evt]) clearEvent(this, evt);
  } else {
    this._events = new Events();
    this._eventsCount = 0;
  }

  return this;
}; //
// Alias methods names because people roll like that.
//


EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on; //
// Expose the prefix.
//

EventEmitter.prefixed = prefix; //
// Allow `EventEmitter` to be imported as module namespace.
//

EventEmitter.EventEmitter = EventEmitter; //
// Expose the module.
//

if (true) {
  module.exports = EventEmitter;
}

/***/ }),
/* 132 */
/***/ (function(module, exports) {

/**
 * @module {function} 101/exists
 * @type {function}
 */

/**
 * Returns false for null and undefined, true for everything else.
 * @function module:101/exists
 * @param val {*} - value to be existance checked
 * @return {boolean} whether the value exists or not
 */
module.exports = exists;

function exists(val) {
  return val !== undefined && val !== null;
}

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(71);

var isInteger = __webpack_require__(221);

var isObject = __webpack_require__(85);

var isString = __webpack_require__(86);

var assertType = __webpack_require__(134);

var isClass = __webpack_require__(135);

var NoClass = function NoClass() {};

var startsWithVowel = __webpack_require__(136);

var classes = {
  // primitive classes
  string: String,
  number: Number,
  // extended typeof support
  array: Array,
  regexp: RegExp
};
module.exports = validate;
/**
 * validate an argument
 * @param  {string} key argument name
 * @param  {*} arg  argument value
 * @param  {string|function} validator argument validator
 */

function validate(key, arg, validator, _plural) {
  if (validator === '*') {
    return;
  }

  var keyStr = '"' + key + '"';
  var typeStr;
  var article;
  var Class;
  var errMessage;
  var assertion;

  if (Array.isArray(validator)) {
    // circular require
    return __webpack_require__(224)(key, arg, validator);
  } else if (isString(validator)) {
    // validator is a string
    typeStr = validator;
    Class = classes[typeStr] || NoClass;
    article = startsWithVowel(typeStr) ? 'an' : 'a';
    errMessage = _plural ? keyStr + ' must be ' + typeStr + 's' : keyStr + ' must be ' + article + ' ' + typeStr;

    if (typeStr === 'integer') {
      assertion = isInteger(arg);
    } else if (typeStr === 'object') {
      assertion = isObject(arg);
    } else {
      assertion = arg instanceof Class || typeof arg === validator;
    }

    assertType(assertion, errMessage);
  } else if (isClass(validator)) {
    // validator is a class
    typeStr = validator.name;
    Class = validator;
    errMessage = _plural ? keyStr + ' must be instances of "' + typeStr + '"' : keyStr + ' must be an instance of "' + typeStr + '"';
    assertType(arg instanceof Class, errMessage);
  } else if (isFunction(validator)) {
    // validator is a test
    try {
      // test will throw an error if it fails
      validator(arg);
    } catch (e) {
      e.message = keyStr += ': ' + e.message;
      throw e;
    }
  } else {
    throw new TypeError('"validator" must be a string, class or function');
  }
}

/***/ }),
/* 134 */
/***/ (function(module, exports) {

module.exports = assertType;

function assertType(bool, message) {
  if (!bool) {
    throw new TypeError(message);
  }
}

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var isCapitalized = __webpack_require__(222);

var isClassStrict = __webpack_require__(223);

var isFunction = __webpack_require__(71);

module.exports = isClass;

function isClass(fn) {
  return isClassStrict(fn) || isFunction(fn) && isCapitalized(fn.name);
}

/***/ }),
/* 136 */
/***/ (function(module, exports) {

module.exports = startsWithVowel;

function startsWithVowel(str) {
  return /^[aeiou]/i.test(str);
}

/***/ }),
/* 137 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export nonExecutableDefinitionMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ExecutableDefinitions; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _language_predicates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);



function nonExecutableDefinitionMessage(defName) {
  return "The ".concat(defName, " definition is not executable.");
}
/**
 * Executable definitions
 *
 * A GraphQL document is only valid for execution if all definitions are either
 * operation or fragment definitions.
 */

function ExecutableDefinitions(context) {
  return {
    Document: function Document(node) {
      for (var _i2 = 0, _node$definitions2 = node.definitions; _i2 < _node$definitions2.length; _i2++) {
        var definition = _node$definitions2[_i2];

        if (!Object(_language_predicates__WEBPACK_IMPORTED_MODULE_2__[/* isExecutableDefinitionNode */ "b"])(definition)) {
          context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](nonExecutableDefinitionMessage(definition.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].SCHEMA_DEFINITION || definition.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].SCHEMA_EXTENSION ? 'schema' : definition.name.value), definition));
        }
      }

      return false;
    }
  };
}


/***/ }),
/* 138 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export duplicateOperationNameMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniqueOperationNames; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function duplicateOperationNameMessage(operationName) {
  return "There can be only one operation named \"".concat(operationName, "\".");
}
/**
 * Unique operation names
 *
 * A GraphQL document is only valid if all defined operations have unique names.
 */

function UniqueOperationNames(context) {
  var knownOperationNames = Object.create(null);
  return {
    OperationDefinition: function OperationDefinition(node) {
      var operationName = node.name;

      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](duplicateOperationNameMessage(operationName.value), [knownOperationNames[operationName.value], operationName]));
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }

      return false;
    },
    FragmentDefinition: function FragmentDefinition() {
      return false;
    }
  };
}


/***/ }),
/* 139 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export anonOperationNotAloneMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LoneAnonymousOperation; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);


function anonOperationNotAloneMessage() {
  return 'This anonymous operation must be the only defined operation.';
}
/**
 * Lone anonymous operation
 *
 * A GraphQL document is only valid if when it contains an anonymous operation
 * (the query short-hand) that it contains only that one operation definition.
 */

function LoneAnonymousOperation(context) {
  var operationCount = 0;
  return {
    Document: function Document(node) {
      operationCount = node.definitions.filter(function (definition) {
        return definition.kind === _language_kinds__WEBPACK_IMPORTED_MODULE_1__[/* Kind */ "a"].OPERATION_DEFINITION;
      }).length;
    },
    OperationDefinition: function OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](anonOperationNotAloneMessage(), node));
      }
    }
  };
}


/***/ }),
/* 140 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export singleFieldOnlyMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SingleFieldSubscriptions; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function singleFieldOnlyMessage(name) {
  return name ? "Subscription \"".concat(name, "\" must select only one top level field.") : 'Anonymous Subscription must select only one top level field.';
}
/**
 * Subscriptions must only include one field.
 *
 * A GraphQL subscription is valid only if it contains a single root field.
 */

function SingleFieldSubscriptions(context) {
  return {
    OperationDefinition: function OperationDefinition(node) {
      if (node.operation === 'subscription') {
        if (node.selectionSet.selections.length !== 1) {
          context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](singleFieldOnlyMessage(node.name && node.name.value), node.selectionSet.selections.slice(1)));
        }
      }
    }
  };
}


/***/ }),
/* 141 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export inlineFragmentOnNonCompositeErrorMessage */
/* unused harmony export fragmentOnNonCompositeErrorMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FragmentsOnCompositeTypes; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _language_printer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var _utilities_typeFromAST__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19);




function inlineFragmentOnNonCompositeErrorMessage(type) {
  return "Fragment cannot condition on non composite type \"".concat(type, "\".");
}
function fragmentOnNonCompositeErrorMessage(fragName, type) {
  return "Fragment \"".concat(fragName, "\" cannot condition on non composite type \"").concat(type, "\".");
}
/**
 * Fragments on composite type
 *
 * Fragments use a type condition to determine if they apply, since fragments
 * can only be spread into a composite type (object, interface, or union), the
 * type condition must also be a composite type.
 */

function FragmentsOnCompositeTypes(context) {
  return {
    InlineFragment: function InlineFragment(node) {
      var typeCondition = node.typeCondition;

      if (typeCondition) {
        var type = Object(_utilities_typeFromAST__WEBPACK_IMPORTED_MODULE_3__[/* typeFromAST */ "a"])(context.getSchema(), typeCondition);

        if (type && !Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isCompositeType */ "D"])(type)) {
          context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](inlineFragmentOnNonCompositeErrorMessage(Object(_language_printer__WEBPACK_IMPORTED_MODULE_1__[/* print */ "a"])(typeCondition)), typeCondition));
        }
      }
    },
    FragmentDefinition: function FragmentDefinition(node) {
      var type = Object(_utilities_typeFromAST__WEBPACK_IMPORTED_MODULE_3__[/* typeFromAST */ "a"])(context.getSchema(), node.typeCondition);

      if (type && !Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isCompositeType */ "D"])(type)) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](fragmentOnNonCompositeErrorMessage(node.name.value, Object(_language_printer__WEBPACK_IMPORTED_MODULE_1__[/* print */ "a"])(node.typeCondition)), node.typeCondition));
      }
    }
  };
}


/***/ }),
/* 142 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export nonInputTypeOnVarMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VariablesAreInputTypes; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _language_printer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var _utilities_typeFromAST__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19);




function nonInputTypeOnVarMessage(variableName, typeName) {
  return "Variable \"$".concat(variableName, "\" cannot be non-input type \"").concat(typeName, "\".");
}
/**
 * Variables are input types
 *
 * A GraphQL operation is only valid if all the variables it defines are of
 * input types (scalar, enum, or input object).
 */

function VariablesAreInputTypes(context) {
  return {
    VariableDefinition: function VariableDefinition(node) {
      var type = Object(_utilities_typeFromAST__WEBPACK_IMPORTED_MODULE_3__[/* typeFromAST */ "a"])(context.getSchema(), node.type); // If the variable type is not an input type, return an error.

      if (type && !Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isInputType */ "G"])(type)) {
        var variableName = node.variable.name.value;
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](nonInputTypeOnVarMessage(variableName, Object(_language_printer__WEBPACK_IMPORTED_MODULE_1__[/* print */ "a"])(node.type)), node.type));
      }
    }
  };
}


/***/ }),
/* 143 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export noSubselectionAllowedMessage */
/* unused harmony export requiredSubselectionMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ScalarLeafs; });
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);



function noSubselectionAllowedMessage(fieldName, type) {
  return "Field \"".concat(fieldName, "\" must not have a selection since type \"").concat(type, "\" has no subfields.");
}
function requiredSubselectionMessage(fieldName, type) {
  return "Field \"".concat(fieldName, "\" of type \"").concat(type, "\" must have a selection of subfields. Did you mean \"").concat(fieldName, " { ... }\"?");
}
/**
 * Scalar leafs
 *
 * A GraphQL document is valid only if all leaf fields (fields without
 * sub selections) are of scalar or enum types.
 */

function ScalarLeafs(context) {
  return {
    Field: function Field(node) {
      var type = context.getType();
      var selectionSet = node.selectionSet;

      if (type) {
        if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isLeafType */ "I"])(Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* getNamedType */ "A"])(type))) {
          if (selectionSet) {
            context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_1__[/* GraphQLError */ "a"](noSubselectionAllowedMessage(node.name.value, Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(type)), selectionSet));
          }
        } else if (!selectionSet) {
          context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_1__[/* GraphQLError */ "a"](requiredSubselectionMessage(node.name.value, Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(type)), node));
        }
      }
    }
  };
}


/***/ }),
/* 144 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export undefinedFieldMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FieldsOnCorrectType; });
/* harmony import */ var _jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/* harmony import */ var _jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);




function undefinedFieldMessage(fieldName, type, suggestedTypeNames, suggestedFieldNames) {
  var quotedTypeNames = suggestedTypeNames.map(function (x) {
    return "\"".concat(x, "\"");
  });
  var quotedFieldNames = suggestedFieldNames.map(function (x) {
    return "\"".concat(x, "\"");
  });
  return "Cannot query field \"".concat(fieldName, "\" on type \"").concat(type, "\".") + (Object(_jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])('to use an inline fragment on', quotedTypeNames) || Object(_jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(quotedFieldNames));
}
/**
 * Fields on correct type
 *
 * A GraphQL document is only valid if all fields selected are defined by the
 * parent type, or are an allowed meta field such as __typename.
 */

function FieldsOnCorrectType(context) {
  return {
    Field: function Field(node) {
      var type = context.getParentType();

      if (type) {
        var fieldDef = context.getFieldDef();

        if (!fieldDef) {
          // This field doesn't exist, lets look for suggestions.
          var schema = context.getSchema();
          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.

          var suggestedTypeNames = getSuggestedTypeNames(schema, type, fieldName); // If there are no suggested types, then perhaps this was a typo?

          var suggestedFieldNames = suggestedTypeNames.length !== 0 ? [] : getSuggestedFieldNames(schema, type, fieldName); // Report an error, including helpful suggestions.

          context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_2__[/* GraphQLError */ "a"](undefinedFieldMessage(fieldName, type.name, suggestedTypeNames, suggestedFieldNames), node));
        }
      }
    }
  };
}
/**
 * Go through all of the implementations of type, as well as the interfaces that
 * they implement. If any of those types include the provided field, suggest
 * them, sorted by how often the type is referenced, starting with Interfaces.
 */

function getSuggestedTypeNames(schema, type, fieldName) {
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_3__[/* isAbstractType */ "C"])(type)) {
    var suggestedObjectTypes = [];
    var interfaceUsageCount = Object.create(null);

    for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {
      var possibleType = _schema$getPossibleTy2[_i2];

      if (!possibleType.getFields()[fieldName]) {
        continue;
      } // This object type defines this field.


      suggestedObjectTypes.push(possibleType.name);

      for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {
        var possibleInterface = _possibleType$getInte2[_i4];

        if (!possibleInterface.getFields()[fieldName]) {
          continue;
        } // This interface type defines this field.


        interfaceUsageCount[possibleInterface.name] = (interfaceUsageCount[possibleInterface.name] || 0) + 1;
      }
    } // Suggest interface types based on how common they are.


    var suggestedInterfaceTypes = Object.keys(interfaceUsageCount).sort(function (a, b) {
      return interfaceUsageCount[b] - interfaceUsageCount[a];
    }); // Suggest both interface and object types.

    return suggestedInterfaceTypes.concat(suggestedObjectTypes);
  } // Otherwise, must be an Object type, which does not have possible fields.


  return [];
}
/**
 * For the field name provided, determine if there are any similar field names
 * that may be the result of a typo.
 */


function getSuggestedFieldNames(schema, type, fieldName) {
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_3__[/* isObjectType */ "N"])(type) || Object(_type_definition__WEBPACK_IMPORTED_MODULE_3__[/* isInterfaceType */ "H"])(type)) {
    var possibleFieldNames = Object.keys(type.getFields());
    return Object(_jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(fieldName, possibleFieldNames);
  } // Otherwise, must be a Union type, which does not define fields.


  return [];
}


/***/ }),
/* 145 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export duplicateFragmentNameMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniqueFragmentNames; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function duplicateFragmentNameMessage(fragName) {
  return "There can be only one fragment named \"".concat(fragName, "\".");
}
/**
 * Unique fragment names
 *
 * A GraphQL document is only valid if all defined fragments have unique names.
 */

function UniqueFragmentNames(context) {
  var knownFragmentNames = Object.create(null);
  return {
    OperationDefinition: function OperationDefinition() {
      return false;
    },
    FragmentDefinition: function FragmentDefinition(node) {
      var fragmentName = node.name.value;

      if (knownFragmentNames[fragmentName]) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](duplicateFragmentNameMessage(fragmentName), [knownFragmentNames[fragmentName], node.name]));
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }

      return false;
    }
  };
}


/***/ }),
/* 146 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export unknownFragmentMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KnownFragmentNames; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function unknownFragmentMessage(fragName) {
  return "Unknown fragment \"".concat(fragName, "\".");
}
/**
 * Known fragment names
 *
 * A GraphQL document is only valid if all `...Fragment` fragment spreads refer
 * to fragments defined in the same document.
 */

function KnownFragmentNames(context) {
  return {
    FragmentSpread: function FragmentSpread(node) {
      var fragmentName = node.name.value;
      var fragment = context.getFragment(fragmentName);

      if (!fragment) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](unknownFragmentMessage(fragmentName), node.name));
      }
    }
  };
}


/***/ }),
/* 147 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export unusedFragMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NoUnusedFragments; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function unusedFragMessage(fragName) {
  return "Fragment \"".concat(fragName, "\" is never used.");
}
/**
 * No unused fragments
 *
 * A GraphQL document is only valid if all fragment definitions are spread
 * within operations, or spread within other fragments spread within operations.
 */

function NoUnusedFragments(context) {
  var operationDefs = [];
  var fragmentDefs = [];
  return {
    OperationDefinition: function OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition: function FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave: function leave() {
        var fragmentNameUsed = Object.create(null);

        for (var _i2 = 0; _i2 < operationDefs.length; _i2++) {
          var operation = operationDefs[_i2];

          for (var _i4 = 0, _context$getRecursive2 = context.getRecursivelyReferencedFragments(operation); _i4 < _context$getRecursive2.length; _i4++) {
            var fragment = _context$getRecursive2[_i4];
            fragmentNameUsed[fragment.name.value] = true;
          }
        }

        for (var _i6 = 0; _i6 < fragmentDefs.length; _i6++) {
          var fragmentDef = fragmentDefs[_i6];
          var fragName = fragmentDef.name.value;

          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](unusedFragMessage(fragName), fragmentDef));
          }
        }
      }
    }
  };
}


/***/ }),
/* 148 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export typeIncompatibleSpreadMessage */
/* unused harmony export typeIncompatibleAnonSpreadMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PossibleFragmentSpreads; });
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var _utilities_typeFromAST__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19);
/* harmony import */ var _utilities_typeComparators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);





function typeIncompatibleSpreadMessage(fragName, parentType, fragType) {
  return "Fragment \"".concat(fragName, "\" cannot be spread here as objects of type \"").concat(parentType, "\" can never be of type \"").concat(fragType, "\".");
}
function typeIncompatibleAnonSpreadMessage(parentType, fragType) {
  return "Fragment cannot be spread here as objects of type \"".concat(parentType, "\" can never be of type \"").concat(fragType, "\".");
}
/**
 * Possible fragment spread
 *
 * A fragment spread is only valid if the type condition could ever possibly
 * be true: if there is a non-empty intersection of the possible parent types,
 * and possible types which pass the type condition.
 */

function PossibleFragmentSpreads(context) {
  return {
    InlineFragment: function InlineFragment(node) {
      var fragType = context.getType();
      var parentType = context.getParentType();

      if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isCompositeType */ "D"])(fragType) && Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isCompositeType */ "D"])(parentType) && !Object(_utilities_typeComparators__WEBPACK_IMPORTED_MODULE_4__[/* doTypesOverlap */ "a"])(context.getSchema(), fragType, parentType)) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_1__[/* GraphQLError */ "a"](typeIncompatibleAnonSpreadMessage(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(parentType), Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(fragType)), node));
      }
    },
    FragmentSpread: function FragmentSpread(node) {
      var fragName = node.name.value;
      var fragType = getFragmentType(context, fragName);
      var parentType = context.getParentType();

      if (fragType && parentType && !Object(_utilities_typeComparators__WEBPACK_IMPORTED_MODULE_4__[/* doTypesOverlap */ "a"])(context.getSchema(), fragType, parentType)) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_1__[/* GraphQLError */ "a"](typeIncompatibleSpreadMessage(fragName, Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(parentType), Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(fragType)), node));
      }
    }
  };
}

function getFragmentType(context, name) {
  var frag = context.getFragment(name);

  if (frag) {
    var type = Object(_utilities_typeFromAST__WEBPACK_IMPORTED_MODULE_3__[/* typeFromAST */ "a"])(context.getSchema(), frag.typeCondition);

    if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_2__[/* isCompositeType */ "D"])(type)) {
      return type;
    }
  }
}


/***/ }),
/* 149 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export cycleErrorMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NoFragmentCycles; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function cycleErrorMessage(fragName, spreadNames) {
  var via = spreadNames.length ? ' via ' + spreadNames.join(', ') : '';
  return "Cannot spread fragment \"".concat(fragName, "\" within itself").concat(via, ".");
}
function NoFragmentCycles(context) {
  // Tracks already visited fragments to maintain O(N) and to ensure that cycles
  // are not redundantly reported.
  var visitedFrags = Object.create(null); // Array of AST nodes used to produce meaningful errors

  var spreadPath = []; // Position in the spread path

  var spreadPathIndexByName = Object.create(null);
  return {
    OperationDefinition: function OperationDefinition() {
      return false;
    },
    FragmentDefinition: function FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  }; // This does a straight-forward DFS to find cycles.
  // It does not terminate when a cycle was found but continues to explore
  // the graph to find all possible cycles.

  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }

    var fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);

    if (spreadNodes.length === 0) {
      return;
    }

    spreadPathIndexByName[fragmentName] = spreadPath.length;

    for (var _i2 = 0; _i2 < spreadNodes.length; _i2++) {
      var spreadNode = spreadNodes[_i2];
      var spreadName = spreadNode.name.value;
      var cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);

      if (cycleIndex === undefined) {
        var spreadFragment = context.getFragment(spreadName);

        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        var cyclePath = spreadPath.slice(cycleIndex);
        var fragmentNames = cyclePath.slice(0, -1).map(function (s) {
          return s.name.value;
        });
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](cycleErrorMessage(spreadName, fragmentNames), cyclePath));
      }

      spreadPath.pop();
    }

    spreadPathIndexByName[fragmentName] = undefined;
  }
}


/***/ }),
/* 150 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export duplicateVariableMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniqueVariableNames; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function duplicateVariableMessage(variableName) {
  return "There can be only one variable named \"".concat(variableName, "\".");
}
/**
 * Unique variable names
 *
 * A GraphQL operation is only valid if all its variables are uniquely named.
 */

function UniqueVariableNames(context) {
  var knownVariableNames = Object.create(null);
  return {
    OperationDefinition: function OperationDefinition() {
      knownVariableNames = Object.create(null);
    },
    VariableDefinition: function VariableDefinition(node) {
      var variableName = node.variable.name.value;

      if (knownVariableNames[variableName]) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](duplicateVariableMessage(variableName), [knownVariableNames[variableName], node.variable.name]));
      } else {
        knownVariableNames[variableName] = node.variable.name;
      }
    }
  };
}


/***/ }),
/* 151 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export undefinedVarMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NoUndefinedVariables; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function undefinedVarMessage(varName, opName) {
  return opName ? "Variable \"$".concat(varName, "\" is not defined by operation \"").concat(opName, "\".") : "Variable \"$".concat(varName, "\" is not defined.");
}
/**
 * No undefined variables
 *
 * A GraphQL operation is only valid if all variables encountered, both directly
 * and via fragment spreads, are defined by that operation.
 */

function NoUndefinedVariables(context) {
  var variableNameDefined = Object.create(null);
  return {
    OperationDefinition: {
      enter: function enter() {
        variableNameDefined = Object.create(null);
      },
      leave: function leave(operation) {
        var usages = context.getRecursiveVariableUsages(operation);

        for (var _i2 = 0; _i2 < usages.length; _i2++) {
          var _ref2 = usages[_i2];
          var node = _ref2.node;
          var varName = node.name.value;

          if (variableNameDefined[varName] !== true) {
            context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](undefinedVarMessage(varName, operation.name && operation.name.value), [node, operation]));
          }
        }
      }
    },
    VariableDefinition: function VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}


/***/ }),
/* 152 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export unusedVariableMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NoUnusedVariables; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function unusedVariableMessage(varName, opName) {
  return opName ? "Variable \"$".concat(varName, "\" is never used in operation \"").concat(opName, "\".") : "Variable \"$".concat(varName, "\" is never used.");
}
/**
 * No unused variables
 *
 * A GraphQL operation is only valid if all variables defined by an operation
 * are used, either directly or within a spread fragment.
 */

function NoUnusedVariables(context) {
  var variableDefs = [];
  return {
    OperationDefinition: {
      enter: function enter() {
        variableDefs = [];
      },
      leave: function leave(operation) {
        var variableNameUsed = Object.create(null);
        var usages = context.getRecursiveVariableUsages(operation);
        var opName = operation.name ? operation.name.value : null;

        for (var _i2 = 0; _i2 < usages.length; _i2++) {
          var _ref2 = usages[_i2];
          var node = _ref2.node;
          variableNameUsed[node.name.value] = true;
        }

        for (var _i4 = 0, _variableDefs2 = variableDefs; _i4 < _variableDefs2.length; _i4++) {
          var variableDef = _variableDefs2[_i4];
          var variableName = variableDef.variable.name.value;

          if (variableNameUsed[variableName] !== true) {
            context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](unusedVariableMessage(variableName, opName), variableDef));
          }
        }
      }
    },
    VariableDefinition: function VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}


/***/ }),
/* 153 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export badVarPosMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return VariablesInAllowedPosition; });
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _utilities_typeFromAST__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19);
/* harmony import */ var _utilities_typeComparators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(35);






function badVarPosMessage(varName, varType, expectedType) {
  return "Variable \"$".concat(varName, "\" of type \"").concat(varType, "\" used in position expecting type \"").concat(expectedType, "\".");
}
/**
 * Variables passed to field arguments conform to type
 */

function VariablesInAllowedPosition(context) {
  var varDefMap = Object.create(null);
  return {
    OperationDefinition: {
      enter: function enter() {
        varDefMap = Object.create(null);
      },
      leave: function leave(operation) {
        var usages = context.getRecursiveVariableUsages(operation);

        for (var _i2 = 0; _i2 < usages.length; _i2++) {
          var _ref2 = usages[_i2];
          var node = _ref2.node;
          var type = _ref2.type;
          var defaultValue = _ref2.defaultValue;
          var varName = node.name.value;
          var varDef = varDefMap[varName];

          if (varDef && type) {
            // A var type is allowed if it is the same or more strict (e.g. is
            // a subtype of) than the expected type. It can be more strict if
            // the variable type is non-null when the expected type is nullable.
            // If both are list types, the variable item type can be more strict
            // than the expected item type (contravariant).
            var schema = context.getSchema();
            var varType = Object(_utilities_typeFromAST__WEBPACK_IMPORTED_MODULE_4__[/* typeFromAST */ "a"])(schema, varDef.type);

            if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type, defaultValue)) {
              context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_1__[/* GraphQLError */ "a"](badVarPosMessage(varName, Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(varType), Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(type)), [varDef, node]));
            }
          }
        }
      }
    },
    VariableDefinition: function VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
/**
 * Returns true if the variable is allowed in the location it was found,
 * which includes considering if default values exist for either the variable
 * or the location at which it is located.
 */

function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_3__[/* isNonNullType */ "L"])(locationType) && !Object(_type_definition__WEBPACK_IMPORTED_MODULE_3__[/* isNonNullType */ "L"])(varType)) {
    var hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== _language_kinds__WEBPACK_IMPORTED_MODULE_2__[/* Kind */ "a"].NULL;
    var hasLocationDefaultValue = locationDefaultValue !== undefined;

    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }

    var nullableLocationType = locationType.ofType;
    return Object(_utilities_typeComparators__WEBPACK_IMPORTED_MODULE_5__[/* isTypeSubTypeOf */ "c"])(schema, varType, nullableLocationType);
  }

  return Object(_utilities_typeComparators__WEBPACK_IMPORTED_MODULE_5__[/* isTypeSubTypeOf */ "c"])(schema, varType, locationType);
}


/***/ }),
/* 154 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export fieldsConflictMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OverlappingFieldsCanBeMerged; });
/* harmony import */ var _polyfills_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var _polyfills_objectEntries__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2);
/* harmony import */ var _language_printer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(16);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);
/* harmony import */ var _utilities_typeFromAST__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(19);








function fieldsConflictMessage(responseName, reason) {
  return "Fields \"".concat(responseName, "\" conflict because ").concat(reasonMessage(reason), ". ") + 'Use different aliases on the fields to fetch both if this was intentional.';
}

function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(function (_ref) {
      var responseName = _ref[0],
          subreason = _ref[1];
      return "subfields \"".concat(responseName, "\" conflict because ").concat(reasonMessage(subreason));
    }).join(' and ');
  }

  return reason;
}
/**
 * Overlapping fields can be merged
 *
 * A selection set is only valid if all fields (including spreading any
 * fragments) either correspond to distinct response names or can be merged
 * without ambiguity.
 */


function OverlappingFieldsCanBeMerged(context) {
  // A memoization for when two fragments are compared "between" each other for
  // conflicts. Two fragments may be compared many times, so memoizing this can
  // dramatically improve the performance of this validator.
  var comparedFragmentPairs = new PairSet(); // A cache for the "field map" and list of fragment names found in any given
  // selection set. Selection sets may be asked for this information multiple
  // times, so this improves the performance of this validator.

  var cachedFieldsAndFragmentNames = new Map();
  return {
    SelectionSet: function SelectionSet(selectionSet) {
      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);

      for (var _i2 = 0; _i2 < conflicts.length; _i2++) {
        var _ref3 = conflicts[_i2];
        var _ref2$ = _ref3[0];
        var responseName = _ref2$[0];
        var reason = _ref2$[1];
        var fields1 = _ref3[1];
        var fields2 = _ref3[2];
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_3__[/* GraphQLError */ "a"](fieldsConflictMessage(responseName, reason), fields1.concat(fields2)));
      }
    }
  };
}

/**
 * Algorithm:
 *
 * Conflicts occur when two fields exist in a query which will produce the same
 * response name, but represent differing values, thus creating a conflict.
 * The algorithm below finds all conflicts via making a series of comparisons
 * between fields. In order to compare as few fields as possible, this makes
 * a series of comparisons "within" sets of fields and "between" sets of fields.
 *
 * Given any selection set, a collection produces both a set of fields by
 * also including all inline fragments, as well as a list of fragments
 * referenced by fragment spreads.
 *
 * A) Each selection set represented in the document first compares "within" its
 * collected set of fields, finding any conflicts between every pair of
 * overlapping fields.
 * Note: This is the *only time* that a the fields "within" a set are compared
 * to each other. After this only fields "between" sets are compared.
 *
 * B) Also, if any fragment is referenced in a selection set, then a
 * comparison is made "between" the original set of fields and the
 * referenced fragment.
 *
 * C) Also, if multiple fragments are referenced, then comparisons
 * are made "between" each referenced fragment.
 *
 * D) When comparing "between" a set of fields and a referenced fragment, first
 * a comparison is made between each field in the original set of fields and
 * each field in the the referenced set of fields.
 *
 * E) Also, if any fragment is referenced in the referenced selection set,
 * then a comparison is made "between" the original set of fields and the
 * referenced fragment (recursively referring to step D).
 *
 * F) When comparing "between" two fragments, first a comparison is made between
 * each field in the first referenced set of fields and each field in the the
 * second referenced set of fields.
 *
 * G) Also, any fragments referenced by the first must be compared to the
 * second, and any fragments referenced by the second must be compared to the
 * first (recursively referring to step F).
 *
 * H) When comparing two fields, if both have selection sets, then a comparison
 * is made "between" both selection sets, first comparing the set of fields in
 * the first selection set with the set of fields in the second.
 *
 * I) Also, if any fragment is referenced in either selection set, then a
 * comparison is made "between" the other set of fields and the
 * referenced fragment.
 *
 * J) Also, if two fragments are referenced in both selection sets, then a
 * comparison is made "between" the two fragments.
 *
 */
// Find all conflicts found "within" a selection set, including those found
// via spreading in fragments. Called when visiting each SelectionSet in the
// GraphQL Document.
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  var conflicts = [];

  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet),
      fieldMap = _getFieldsAndFragment[0],
      fragmentNames = _getFieldsAndFragment[1]; // (A) Find find all conflicts "within" the fields of this selection set.
  // Note: this is the *only place* `collectConflictsWithin` is called.


  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);

  if (fragmentNames.length !== 0) {
    // (B) Then collect conflicts between these fields and those represented by
    // each spread fragment name found.
    var comparedFragments = Object.create(null);

    for (var i = 0; i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this
      // selection set to collect conflicts between fragments spread together.
      // This compares each item in the list of fragment names to every other
      // item in that same list (except for itself).

      for (var j = i + 1; j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
      }
    }
  }

  return conflicts;
} // Collect all conflicts found between a set of fields and a fragment reference
// including via spreading in any nested fragments.


function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  // Memoize so a fragment is not compared for conflicts more than once.
  if (comparedFragments[fragmentName]) {
    return;
  }

  comparedFragments[fragmentName] = true;
  var fragment = context.getFragment(fragmentName);

  if (!fragment) {
    return;
  }

  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment),
      fieldMap2 = _getReferencedFieldsA[0],
      fragmentNames2 = _getReferencedFieldsA[1]; // Do not compare a fragment's fieldMap to itself.


  if (fieldMap === fieldMap2) {
    return;
  } // (D) First collect any conflicts between the provided collection of fields
  // and the collection of fields represented by the given fragment.


  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields
  // and any fragment names found in the given fragment.

  for (var i = 0; i < fragmentNames2.length; i++) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);
  }
} // Collect all conflicts found between two fragments, including via spreading in
// any nested fragments.


function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  // No need to compare a fragment to itself.
  if (fragmentName1 === fragmentName2) {
    return;
  } // Memoize so two fragments are not compared for conflicts more than once.


  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
    return;
  }

  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  var fragment1 = context.getFragment(fragmentName1);
  var fragment2 = context.getFragment(fragmentName2);

  if (!fragment1 || !fragment2) {
    return;
  }

  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1),
      fieldMap1 = _getReferencedFieldsA2[0],
      fragmentNames1 = _getReferencedFieldsA2[1];

  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2),
      fieldMap2 = _getReferencedFieldsA3[0],
      fragmentNames2 = _getReferencedFieldsA3[1]; // (F) First, collect all conflicts between these two collections of fields
  // (not including any nested fragments).


  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested
  // fragments spread in the second fragment.

  for (var j = 0; j < fragmentNames2.length; j++) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);
  } // (G) Then collect conflicts between the second fragment and any nested
  // fragments spread in the first fragment.


  for (var i = 0; i < fragmentNames1.length; i++) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);
  }
} // Find all conflicts found between two selection sets, including those found
// via spreading in fragments. Called when determining if conflicts exist
// between the sub-fields of two overlapping fields.


function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  var conflicts = [];

  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1),
      fieldMap1 = _getFieldsAndFragment2[0],
      fragmentNames1 = _getFieldsAndFragment2[1];

  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2),
      fieldMap2 = _getFieldsAndFragment3[0],
      fragmentNames2 = _getFieldsAndFragment3[1]; // (H) First, collect all conflicts between these two collections of field.


  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and
  // those referenced by each fragment name associated with the second.

  if (fragmentNames2.length !== 0) {
    var comparedFragments = Object.create(null);

    for (var j = 0; j < fragmentNames2.length; j++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);
    }
  } // (I) Then collect conflicts between the second collection of fields and
  // those referenced by each fragment name associated with the first.


  if (fragmentNames1.length !== 0) {
    var _comparedFragments = Object.create(null);

    for (var i = 0; i < fragmentNames1.length; i++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, _comparedFragments, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);
    }
  } // (J) Also collect conflicts between any fragment names by the first and
  // fragment names by the second. This compares each item in the first set of
  // names to each item in the second set of names.


  for (var _i3 = 0; _i3 < fragmentNames1.length; _i3++) {
    for (var _j = 0; _j < fragmentNames2.length; _j++) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i3], fragmentNames2[_j]);
    }
  }

  return conflicts;
} // Collect all Conflicts "within" one collection of fields.


function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  // A field map is a keyed collection, where each key represents a response
  // name and the value at that key is a list of all fields which provide that
  // response name. For every response name, if there are multiple fields, they
  // must be compared to find a potential conflict.
  for (var _i5 = 0, _objectEntries2 = Object(_polyfills_objectEntries__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(fieldMap); _i5 < _objectEntries2.length; _i5++) {
    var _ref5 = _objectEntries2[_i5];
    var responseName = _ref5[0];
    var fields = _ref5[1];

    // This compares every field in the list to every other field in this list
    // (except to itself). If the list only has one item, nothing needs to
    // be compared.
    if (fields.length > 1) {
      for (var i = 0; i < fields.length; i++) {
        for (var j = i + 1; j < fields.length; j++) {
          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive
          responseName, fields[i], fields[j]);

          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
} // Collect all Conflicts between two collections of fields. This is similar to,
// but different from the `collectConflictsWithin` function above. This check
// assumes that `collectConflictsWithin` has already been called on each
// provided collection of fields. This is true because this validator traverses
// each individual selection set.


function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  // A field map is a keyed collection, where each key represents a response
  // name and the value at that key is a list of all fields which provide that
  // response name. For any response name which appears in both provided field
  // maps, each field from the first field map must be compared to every field
  // in the second field map to find potential conflicts.
  for (var _i7 = 0, _Object$keys2 = Object.keys(fieldMap1); _i7 < _Object$keys2.length; _i7++) {
    var responseName = _Object$keys2[_i7];
    var fields2 = fieldMap2[responseName];

    if (fields2) {
      var fields1 = fieldMap1[responseName];

      for (var i = 0; i < fields1.length; i++) {
        for (var j = 0; j < fields2.length; j++) {
          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields2[j]);

          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
} // Determines if there is a conflict between two particular fields, including
// comparing their sub-fields.


function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  var parentType1 = field1[0],
      node1 = field1[1],
      def1 = field1[2];
  var parentType2 = field2[0],
      node2 = field2[1],
      def2 = field2[2]; // If it is known that two fields could not possibly apply at the same
  // time, due to the parent types, then it is safe to permit them to diverge
  // in aliased field or arguments used as they will not present any ambiguity
  // by differing.
  // It is known that two parent types could never overlap if they are
  // different Object types. Interface or Union types might overlap - if not
  // in the current state of the schema, then perhaps in some future version,
  // thus may not safely diverge.

  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isObjectType */ "N"])(parentType1) && Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isObjectType */ "N"])(parentType2); // The return type for each field.

  var type1 = def1 && def1.type;
  var type2 = def2 && def2.type;

  if (!areMutuallyExclusive) {
    // Two aliases must refer to the same field.
    var name1 = node1.name.value;
    var name2 = node2.name.value;

    if (name1 !== name2) {
      return [[responseName, "".concat(name1, " and ").concat(name2, " are different fields")], [node1], [node2]];
    } // Two field calls must have the same arguments.


    if (!sameArguments(node1.arguments || [], node2.arguments || [])) {
      return [[responseName, 'they have differing arguments'], [node1], [node2]];
    }
  }

  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [[responseName, "they return conflicting types ".concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(type1), " and ").concat(Object(_jsutils_inspect__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(type2))], [node1], [node2]];
  } // Collect and compare sub-fields. Use the same "visited fragment names" list
  // for both collections so fields in a fragment reference are never
  // compared to themselves.


  var selectionSet1 = node1.selectionSet;
  var selectionSet2 = node2.selectionSet;

  if (selectionSet1 && selectionSet2) {
    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* getNamedType */ "A"])(type1), selectionSet1, Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* getNamedType */ "A"])(type2), selectionSet2);
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}

function sameArguments(arguments1, arguments2) {
  if (arguments1.length !== arguments2.length) {
    return false;
  }

  return arguments1.every(function (argument1) {
    var argument2 = Object(_polyfills_find__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(arguments2, function (argument) {
      return argument.name.value === argument1.name.value;
    });

    if (!argument2) {
      return false;
    }

    return sameValue(argument1.value, argument2.value);
  });
}

function sameValue(value1, value2) {
  return !value1 && !value2 || Object(_language_printer__WEBPACK_IMPORTED_MODULE_5__[/* print */ "a"])(value1) === Object(_language_printer__WEBPACK_IMPORTED_MODULE_5__[/* print */ "a"])(value2);
} // Two types conflict if both types could not apply to a value simultaneously.
// Composite types are ignored as their individual field types will be compared
// later recursively. However List and Non-Null types must match.


function doTypesConflict(type1, type2) {
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isListType */ "J"])(type1)) {
    return Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isListType */ "J"])(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isListType */ "J"])(type2)) {
    return true;
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNonNullType */ "L"])(type1)) {
    return Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNonNullType */ "L"])(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isNonNullType */ "L"])(type2)) {
    return true;
  }

  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isLeafType */ "I"])(type1) || Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isLeafType */ "I"])(type2)) {
    return type1 !== type2;
  }

  return false;
} // Given a selection set, return the collection of fields (a mapping of response
// name to field nodes and definitions) as well as a list of fragment names
// referenced via fragment spreads.


function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  var cached = cachedFieldsAndFragmentNames.get(selectionSet);

  if (!cached) {
    var nodeAndDefs = Object.create(null);
    var fragmentNames = Object.create(null);

    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);

    cached = [nodeAndDefs, Object.keys(fragmentNames)];
    cachedFieldsAndFragmentNames.set(selectionSet, cached);
  }

  return cached;
} // Given a reference to a fragment, return the represented collection of fields
// as well as a list of nested fragment names referenced via fragment spreads.


function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  // Short-circuit building a type from the node if possible.
  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);

  if (cached) {
    return cached;
  }

  var fragmentType = Object(_utilities_typeFromAST__WEBPACK_IMPORTED_MODULE_7__[/* typeFromAST */ "a"])(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
}

function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (var _i9 = 0, _selectionSet$selecti2 = selectionSet.selections; _i9 < _selectionSet$selecti2.length; _i9++) {
    var selection = _selectionSet$selecti2[_i9];

    switch (selection.kind) {
      case _language_kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].FIELD:
        {
          var fieldName = selection.name.value;
          var fieldDef = void 0;

          if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isObjectType */ "N"])(parentType) || Object(_type_definition__WEBPACK_IMPORTED_MODULE_6__[/* isInterfaceType */ "H"])(parentType)) {
            fieldDef = parentType.getFields()[fieldName];
          }

          var responseName = selection.alias ? selection.alias.value : fieldName;

          if (!nodeAndDefs[responseName]) {
            nodeAndDefs[responseName] = [];
          }

          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
          break;
        }

      case _language_kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;

      case _language_kinds__WEBPACK_IMPORTED_MODULE_4__[/* Kind */ "a"].INLINE_FRAGMENT:
        {
          var typeCondition = selection.typeCondition;
          var inlineFragmentType = typeCondition ? Object(_utilities_typeFromAST__WEBPACK_IMPORTED_MODULE_7__[/* typeFromAST */ "a"])(context.getSchema(), typeCondition) : parentType;

          _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);

          break;
        }
    }
  }
} // Given a series of Conflicts which occurred between two sub-fields, generate
// a single Conflict.


function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [[responseName, conflicts.map(function (_ref6) {
      var reason = _ref6[0];
      return reason;
    })], conflicts.reduce(function (allFields, _ref7) {
      var fields1 = _ref7[1];
      return allFields.concat(fields1);
    }, [node1]), conflicts.reduce(function (allFields, _ref8) {
      var fields2 = _ref8[2];
      return allFields.concat(fields2);
    }, [node2])];
  }
}
/**
 * A way to keep track of pairs of things when the ordering of the pair does
 * not matter. We do this by maintaining a sort of double adjacency sets.
 */


var PairSet =
/*#__PURE__*/
function () {
  function PairSet() {
    this._data = Object.create(null);
  }

  var _proto = PairSet.prototype;

  _proto.has = function has(a, b, areMutuallyExclusive) {
    var first = this._data[a];
    var result = first && first[b];

    if (result === undefined) {
      return false;
    } // areMutuallyExclusive being false is a superset of being true,
    // hence if we want to know if this PairSet "has" these two with no
    // exclusivity, we have to ensure it was added as such.


    if (areMutuallyExclusive === false) {
      return result === false;
    }

    return true;
  };

  _proto.add = function add(a, b, areMutuallyExclusive) {
    _pairSetAdd(this._data, a, b, areMutuallyExclusive);

    _pairSetAdd(this._data, b, a, areMutuallyExclusive);
  };

  return PairSet;
}();

function _pairSetAdd(data, a, b, areMutuallyExclusive) {
  var map = data[a];

  if (!map) {
    map = Object.create(null);
    data[a] = map;
  }

  map[b] = areMutuallyExclusive;
}


/***/ }),
/* 155 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export schemaDefinitionNotAloneMessage */
/* unused harmony export canNotDefineSchemaWithinExtensionMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LoneSchemaDefinition; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function schemaDefinitionNotAloneMessage() {
  return 'Must provide only one schema definition.';
}
function canNotDefineSchemaWithinExtensionMessage() {
  return 'Cannot define a new schema within a schema extension.';
}
/**
 * Lone Schema definition
 *
 * A GraphQL document is only valid if it contains only one schema definition.
 */

function LoneSchemaDefinition(context) {
  var oldSchema = context.getSchema();
  var alreadyDefined = oldSchema && (oldSchema.astNode || oldSchema.getQueryType() || oldSchema.getMutationType() || oldSchema.getSubscriptionType());
  var schemaDefinitionsCount = 0;
  return {
    SchemaDefinition: function SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](canNotDefineSchemaWithinExtensionMessage(), node));
        return;
      }

      if (schemaDefinitionsCount > 0) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](schemaDefinitionNotAloneMessage(), node));
      }

      ++schemaDefinitionsCount;
    }
  };
}


/***/ }),
/* 156 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export duplicateOperationTypeMessage */
/* unused harmony export existedOperationTypeMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniqueOperationTypes; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function duplicateOperationTypeMessage(operation) {
  return "There can be only one ".concat(operation, " type in schema.");
}
function existedOperationTypeMessage(operation) {
  return "Type for ".concat(operation, " already defined in the schema. It cannot be redefined.");
}
/**
 * Unique operation types
 *
 * A GraphQL document is only valid if it has only one type per operation.
 */

function UniqueOperationTypes(context) {
  var schema = context.getSchema();
  var definedOperationTypes = Object.create(null);
  var existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };

  function checkOperationTypes(node) {
    if (node.operationTypes) {
      for (var _i2 = 0, _ref2 = node.operationTypes || []; _i2 < _ref2.length; _i2++) {
        var operationType = _ref2[_i2];
        var operation = operationType.operation;
        var alreadyDefinedOperationType = definedOperationTypes[operation];

        if (existingOperationTypes[operation]) {
          context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](existedOperationTypeMessage(operation), operationType));
        } else if (alreadyDefinedOperationType) {
          context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](duplicateOperationTypeMessage(operation), [alreadyDefinedOperationType, operationType]));
        } else {
          definedOperationTypes[operation] = operationType;
        }
      }
    }

    return false;
  }
}


/***/ }),
/* 157 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export duplicateTypeNameMessage */
/* unused harmony export existedTypeNameMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniqueTypeNames; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function duplicateTypeNameMessage(typeName) {
  return "There can be only one type named \"".concat(typeName, "\".");
}
function existedTypeNameMessage(typeName) {
  return "Type \"".concat(typeName, "\" already exists in the schema. It cannot also be defined in this type definition.");
}
/**
 * Unique type names
 *
 * A GraphQL document is only valid if all defined types have unique names.
 */

function UniqueTypeNames(context) {
  var knownTypeNames = Object.create(null);
  var schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };

  function checkTypeName(node) {
    var typeName = node.name.value;

    if (schema && schema.getType(typeName)) {
      context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](existedTypeNameMessage(typeName), node.name));
      return;
    }

    if (knownTypeNames[typeName]) {
      context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](duplicateTypeNameMessage(typeName), [knownTypeNames[typeName], node.name]));
    } else {
      knownTypeNames[typeName] = node.name;
    }

    return false;
  }
}


/***/ }),
/* 158 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export duplicateEnumValueNameMessage */
/* unused harmony export existedEnumValueNameMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniqueEnumValueNames; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);


function duplicateEnumValueNameMessage(typeName, valueName) {
  return "Enum value \"".concat(typeName, ".").concat(valueName, "\" can only be defined once.");
}
function existedEnumValueNameMessage(typeName, valueName) {
  return "Enum value \"".concat(typeName, ".").concat(valueName, "\" already exists in the schema. It cannot also be defined in this type extension.");
}
/**
 * Unique enum value names
 *
 * A GraphQL enum type is only valid if all its values are uniquely named.
 */

function UniqueEnumValueNames(context) {
  var schema = context.getSchema();
  var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
  var knownValueNames = Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };

  function checkValueUniqueness(node) {
    var typeName = node.name.value;

    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = Object.create(null);
    }

    if (node.values) {
      var valueNames = knownValueNames[typeName];

      for (var _i2 = 0, _node$values2 = node.values; _i2 < _node$values2.length; _i2++) {
        var valueDef = _node$values2[_i2];
        var valueName = valueDef.name.value;
        var existingType = existingTypeMap[typeName];

        if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_1__[/* isEnumType */ "E"])(existingType) && existingType.getValue(valueName)) {
          context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](existedEnumValueNameMessage(typeName, valueName), valueDef.name));
        } else if (valueNames[valueName]) {
          context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](duplicateEnumValueNameMessage(typeName, valueName), [valueNames[valueName], valueDef.name]));
        } else {
          valueNames[valueName] = valueDef.name;
        }
      }
    }

    return false;
  }
}


/***/ }),
/* 159 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export duplicateFieldDefinitionNameMessage */
/* unused harmony export existedFieldDefinitionNameMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniqueFieldDefinitionNames; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);


function duplicateFieldDefinitionNameMessage(typeName, fieldName) {
  return "Field \"".concat(typeName, ".").concat(fieldName, "\" can only be defined once.");
}
function existedFieldDefinitionNameMessage(typeName, fieldName) {
  return "Field \"".concat(typeName, ".").concat(fieldName, "\" already exists in the schema. It cannot also be defined in this type extension.");
}
/**
 * Unique field definition names
 *
 * A GraphQL complex type is only valid if all its fields are uniquely named.
 */

function UniqueFieldDefinitionNames(context) {
  var schema = context.getSchema();
  var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
  var knownFieldNames = Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };

  function checkFieldUniqueness(node) {
    var typeName = node.name.value;

    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = Object.create(null);
    }

    if (node.fields) {
      var fieldNames = knownFieldNames[typeName];

      for (var _i2 = 0, _node$fields2 = node.fields; _i2 < _node$fields2.length; _i2++) {
        var fieldDef = _node$fields2[_i2];
        var fieldName = fieldDef.name.value;

        if (hasField(existingTypeMap[typeName], fieldName)) {
          context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](existedFieldDefinitionNameMessage(typeName, fieldName), fieldDef.name));
        } else if (fieldNames[fieldName]) {
          context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](duplicateFieldDefinitionNameMessage(typeName, fieldName), [fieldNames[fieldName], fieldDef.name]));
        } else {
          fieldNames[fieldName] = fieldDef.name;
        }
      }
    }

    return false;
  }
}

function hasField(type, fieldName) {
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_1__[/* isObjectType */ "N"])(type) || Object(_type_definition__WEBPACK_IMPORTED_MODULE_1__[/* isInterfaceType */ "H"])(type) || Object(_type_definition__WEBPACK_IMPORTED_MODULE_1__[/* isInputObjectType */ "F"])(type)) {
    return type.getFields()[fieldName];
  }

  return false;
}


/***/ }),
/* 160 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export duplicateDirectiveNameMessage */
/* unused harmony export existedDirectiveNameMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UniqueDirectiveNames; });
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

function duplicateDirectiveNameMessage(directiveName) {
  return "There can be only one directive named \"".concat(directiveName, "\".");
}
function existedDirectiveNameMessage(directiveName) {
  return "Directive \"".concat(directiveName, "\" already exists in the schema. It cannot be redefined.");
}
/**
 * Unique directive names
 *
 * A GraphQL document is only valid if all defined directives have unique names.
 */

function UniqueDirectiveNames(context) {
  var knownDirectiveNames = Object.create(null);
  var schema = context.getSchema();
  return {
    DirectiveDefinition: function DirectiveDefinition(node) {
      var directiveName = node.name.value;

      if (schema && schema.getDirective(directiveName)) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](existedDirectiveNameMessage(directiveName), node.name));
        return;
      }

      if (knownDirectiveNames[directiveName]) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_0__[/* GraphQLError */ "a"](duplicateDirectiveNameMessage(directiveName), [knownDirectiveNames[directiveName], node.name]));
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }

      return false;
    }
  };
}


/***/ }),
/* 161 */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export extendingUnknownTypeMessage */
/* unused harmony export extendingDifferentTypeKindMessage */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PossibleTypeExtensions; });
/* harmony import */ var _jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/* harmony import */ var _jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _error_GraphQLError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _language_kinds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2);
/* harmony import */ var _language_predicates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38);
/* harmony import */ var _type_definition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(0);
var _defKindToExtKind;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







function extendingUnknownTypeMessage(typeName, suggestedTypes) {
  return "Cannot extend type \"".concat(typeName, "\" because it is not defined.") + Object(_jsutils_didYouMean__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(suggestedTypes.map(function (x) {
    return "\"".concat(x, "\"");
  }));
}
function extendingDifferentTypeKindMessage(typeName, kind) {
  return "Cannot extend non-".concat(kind, " type \"").concat(typeName, "\".");
}
/**
 * Possible type extension
 *
 * A type extension is only valid if the type is defined and has the same kind.
 */

function PossibleTypeExtensions(context) {
  var schema = context.getSchema();
  var definedTypes = Object.create(null);

  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {
    var def = _context$getDocument$2[_i2];

    if (Object(_language_predicates__WEBPACK_IMPORTED_MODULE_4__[/* isTypeDefinitionNode */ "d"])(def)) {
      definedTypes[def.name.value] = def;
    }
  }

  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };

  function checkExtension(node) {
    var typeName = node.name.value;
    var defNode = definedTypes[typeName];
    var existingType = schema && schema.getType(typeName);

    if (defNode) {
      var expectedKind = defKindToExtKind[defNode.kind];

      if (expectedKind !== node.kind) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_2__[/* GraphQLError */ "a"](extendingDifferentTypeKindMessage(typeName, extensionKindToTypeName(expectedKind)), [defNode, node]));
      }
    } else if (existingType) {
      var _expectedKind = typeToExtKind(existingType);

      if (_expectedKind !== node.kind) {
        context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_2__[/* GraphQLError */ "a"](extendingDifferentTypeKindMessage(typeName, extensionKindToTypeName(_expectedKind)), node));
      }
    } else {
      var allTypeNames = Object.keys(definedTypes);

      if (schema) {
        allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));
      }

      var suggestedTypes = Object(_jsutils_suggestionList__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(typeName, allTypeNames);
      context.reportError(new _error_GraphQLError__WEBPACK_IMPORTED_MODULE_2__[/* GraphQLError */ "a"](extendingUnknownTypeMessage(typeName, suggestedTypes), node.name));
    }
  }
}
var defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].SCALAR_TYPE_DEFINITION, _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].OBJECT_TYPE_DEFINITION, _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].INTERFACE_TYPE_DEFINITION, _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].UNION_TYPE_DEFINITION, _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].ENUM_TYPE_DEFINITION, _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].INPUT_OBJECT_TYPE_DEFINITION, _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);

function typeToExtKind(type) {
  if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_5__[/* isScalarType */ "R"])(type)) {
    return _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].SCALAR_TYPE_EXTENSION;
  } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_5__[/* isObjectType */ "N"])(type)) {
    return _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].OBJECT_TYPE_EXTENSION;
  } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_5__[/* isInterfaceType */ "H"])(type)) {
    return _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].INTERFACE_TYPE_EXTENSION;
  } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_5__[/* isUnionType */ "T"])(type)) {
    return _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].UNION_TYPE_EXTENSION;
  } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_5__[/* isEnumType */ "E"])(type)) {
    return _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].ENUM_TYPE_EXTENSION;
  } else if (Object(_type_definition__WEBPACK_IMPORTED_MODULE_5__[/* isInputObjectType */ "F"])(type)) {
    return _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].INPUT_OBJECT_TYPE_EXTENSION;
  }
}

function extensionKindToTypeName(kind) {
  switch (kind) {
    case _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].SCALAR_TYPE_EXTENSION:
      return 'scalar';

    case _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].OBJECT_TYPE_EXTENSION:
      return 'object';

    case _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].INTERFACE_TYPE_EXTENSION:
      return 'interface';

    case _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].UNION_TYPE_EXTENSION:
      return 'union';

    case _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].ENUM_TYPE_EXTENSION:
      return 'enum';

    case _language_kinds__WEBPACK_IMPORTED_MODULE_3__[/* Kind */ "a"].INPUT_OBJECT_TYPE_EXTENSION:
      return 'input object';

    default:
      return 'unknown type';
  }
}


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(191).Observable;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (data, opts) {
  if (!opts) opts = {};
  if (typeof opts === 'function') opts = {
    cmp: opts
  };
  var cycles = typeof opts.cycles === 'boolean' ? opts.cycles : false;

  var cmp = opts.cmp && function (f) {
    return function (node) {
      return function (a, b) {
        var aobj = {
          key: a,
          value: node[a]
        };
        var bobj = {
          key: b,
          value: node[b]
        };
        return f(aobj, bobj);
      };
    };
  }(opts.cmp);

  var seen = [];
  return function stringify(node) {
    if (node && node.toJSON && typeof node.toJSON === 'function') {
      node = node.toJSON();
    }

    if (node === undefined) return;
    if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
    if (typeof node !== 'object') return JSON.stringify(node);
    var i, out;

    if (Array.isArray(node)) {
      out = '[';

      for (i = 0; i < node.length; i++) {
        if (i) out += ',';
        out += stringify(node[i]) || 'null';
      }

      return out + ']';
    }

    if (node === null) return 'null';

    if (seen.indexOf(node) !== -1) {
      if (cycles) return JSON.stringify('__cycle__');
      throw new TypeError('Converting circular structure to JSON');
    }

    var seenIndex = seen.push(node) - 1;
    var keys = Object.keys(node).sort(cmp && cmp(node));
    out = '';

    for (i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = stringify(node[key]);
      if (!value) continue;
      if (out) out += ',';
      out += JSON.stringify(key) + ':' + value;
    }

    seen.splice(seenIndex, 1);
    return '{' + out + '}';
  }(data);
};

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var _this = this;

Object.defineProperty(exports, "__esModule", {
  value: true
});

var rpc_websockets_1 = __webpack_require__(206);

__webpack_require__(228);

var CONDUCTOR_CONFIG = '/_dna_connections.json';
var DEFAULT_TIMEOUT = 5000;
/**
 * Establish a websocket connection to a Conductor interface
 * Accepts an object of options:
 *   - url (optional): Specifies the URL to establish the connection with
 *   - wsClient (optional): Object of options that gets passed through as configuration to the rpc-websockets client
 *   - timeout (optional): If the socket is not ready, `call` and `callZome` will wait this many milliseconds for the
 *       socket to be ready before timing out and rejecting the promise. Defaults to 5 seconds, but if you set it
 *       to 0 or null, it will never timeout.
 */

exports.connect = function (opts) {
  if (opts === void 0) {
    opts = {};
  }

  return new Promise(function (fulfill, reject) {
    return __awaiter(_this, void 0, void 0, function () {
      var url, _a, timeout, ws;

      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            _a = opts.url;
            if (_a) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , getUrlFromConductor().catch(function () {
              return reject('Could not auto-detect DNA interface from conductor. \
Ensure the web UI is hosted by a Holochain Conductor or manually specify url as parameter to connect');
            })];

          case 1:
            _a = _b.sent();
            _b.label = 2;

          case 2:
            url = _a;
            timeout = opts.timeout || DEFAULT_TIMEOUT;
            ws = new rpc_websockets_1.Client(url, opts.wsClient);
            ws.on('open', function () {
              return 'WS open';
            });
            ws.on('close', function () {
              return 'WS closed';
            });
            ws.on('error', function (e) {
              return reject(e || 'Could not establish websocket connection with requested url');
            });
            ws.once('open', function () {
              var call = function call() {
                var methodSegments = [];

                for (var _i = 0; _i < arguments.length; _i++) {
                  methodSegments[_i] = arguments[_i];
                }

                return function (params) {
                  var method = methodSegments.length === 1 ? methodSegments[0] : methodSegments.join('/');
                  return callWhenConnected(ws, method, params, opts.timeout);
                };
              };

              var callZome = function callZome(instanceId, zome, func) {
                return function (args) {
                  var callObject = {
                    'instance_id': instanceId,
                    zome: zome,
                    'function': func,
                    args: args
                  };
                  return callWhenConnected(ws, 'call', callObject, opts.timeout);
                };
              };

              var onSignal = function onSignal(callback) {
                // go down to the underlying websocket connection (.socket)
                // for a simpler API
                ws.socket.on('message', function (message) {
                  if (!message) return;
                  var msg = JSON.parse(message);

                  if (msg.signal || msg.instance_stats) {
                    callback(msg);
                  }
                });
              }; // define a function which will close the websocket connection


              var close = function close() {
                return ws.close();
              };

              fulfill({
                call: call,
                callZome: callZome,
                close: close,
                onSignal: onSignal,
                ws: ws
              });
            });
            return [2
            /*return*/
            ];
        }
      });
    });
  });
};

function getUrlFromConductor() {
  return fetch(CONDUCTOR_CONFIG).then(function (data) {
    return data.json();
  }).then(function (json) {
    return json.dna_interface.driver.port;
  }).then(function (port) {
    return "ws://localhost:" + port;
  });
}
/**
 * Ensure that a ws client never attempts to call when the socket is not ready
 * Instead, return a promise that resolves only when the socket is connected and the call is made
 */


function callWhenConnected(ws, method, payload, timeout) {
  if (timeout === void 0) {
    timeout = null;
  }

  return __awaiter(this, void 0, void 0, function () {
    return __generator(this, function (_a) {
      if (ws.ready) {
        return [2
        /*return*/
        , Promise.resolve(ws.call(method, payload))];
      } else {
        return [2
        /*return*/
        , new Promise(function (resolve, reject) {
          var timer = timeout ? setTimeout(function () {
            reject("Timeout while waiting for ws to connect. method: " + method + ", payload: " + JSON.stringify(payload));
          }, timeout) : null;
          ws.once('open', function () {
            clearTimeout(timer);
            ws.call(method, payload).then(resolve).catch(reject);
          });
        })];
      }

      return [2
      /*return*/
      ];
    });
  });
}

var holochainclient = {
  connect: exports.connect
};

/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(166);
/* global window */

var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {}

var result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(root);
/* harmony default export */ __webpack_exports__["a"] = (result);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(230)(module)))

/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return symbolObservablePonyfill; });
function symbolObservablePonyfill(root) {
  var result;
  var Symbol = root.Symbol;

  if (typeof Symbol === 'function') {
    if (Symbol.observable) {
      result = Symbol.observable;
    } else {
      result = Symbol('observable');
      Symbol.observable = result;
    }
  } else {
    result = '@@observable';
  }

  return result;
}
;

/***/ }),
/* 167 */
/***/ (function(module, exports) {

/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(() => {
  var _a, _b, _c;
  /* Symbols for private properties */


  const _blockingElements = Symbol();

  const _alreadyInertElements = Symbol();

  const _topElParents = Symbol();

  const _siblingsToRestore = Symbol();

  const _parentMO = Symbol();
  /* Symbols for private static methods */


  const _topChanged = Symbol();

  const _swapInertedSibling = Symbol();

  const _inertSiblings = Symbol();

  const _restoreInertedSiblings = Symbol();

  const _getParents = Symbol();

  const _getDistributedChildren = Symbol();

  const _isInertable = Symbol();

  const _handleMutations = Symbol();

  class BlockingElementsImpl {
    constructor() {
      /**
       * The blocking elements.
       */
      this[_a] = [];
      /**
       * Used to keep track of the parents of the top element, from the element
       * itself up to body. When top changes, the old top might have been removed
       * from the document, so we need to memoize the inerted parents' siblings
       * in order to restore their inerteness when top changes.
       */

      this[_b] = [];
      /**
       * Elements that are already inert before the first blocking element is
       * pushed.
       */

      this[_c] = new Set();
    }

    destructor() {
      // Restore original inertness.
      this[_restoreInertedSiblings](this[_topElParents]); // Note we don't want to make these properties nullable on the class,
      // since then we'd need non-null casts in many places. Calling a method on
      // a BlockingElements instance after calling destructor will result in an
      // exception.


      const nullable = this;
      nullable[_blockingElements] = null;
      nullable[_topElParents] = null;
      nullable[_alreadyInertElements] = null;
    }

    get top() {
      const elems = this[_blockingElements];
      return elems[elems.length - 1] || null;
    }

    push(element) {
      if (!element || element === this.top) {
        return;
      } // Remove it from the stack, we'll bring it to the top.


      this.remove(element);

      this[_topChanged](element);

      this[_blockingElements].push(element);
    }

    remove(element) {
      const i = this[_blockingElements].indexOf(element);

      if (i === -1) {
        return false;
      }

      this[_blockingElements].splice(i, 1); // Top changed only if the removed element was the top element.


      if (i === this[_blockingElements].length) {
        this[_topChanged](this.top);
      }

      return true;
    }

    pop() {
      const top = this.top;
      top && this.remove(top);
      return top;
    }

    has(element) {
      return this[_blockingElements].indexOf(element) !== -1;
    }
    /**
     * Sets `inert` to all document elements except the new top element, its
     * parents, and its distributed content.
     */


    [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
      const toKeepInert = this[_alreadyInertElements];
      const oldParents = this[_topElParents]; // No new top, reset old top if any.

      if (!newTop) {
        this[_restoreInertedSiblings](oldParents);

        toKeepInert.clear();
        this[_topElParents] = [];
        return;
      }

      const newParents = this[_getParents](newTop); // New top is not contained in the main document!


      if (newParents[newParents.length - 1].parentNode !== document.body) {
        throw Error('Non-connected element cannot be a blocking element');
      } // Cast here because we know we'll call _inertSiblings on newParents
      // below.


      this[_topElParents] = newParents;

      const toSkip = this[_getDistributedChildren](newTop); // No previous top element.


      if (!oldParents.length) {
        this[_inertSiblings](newParents, toSkip, toKeepInert);

        return;
      }

      let i = oldParents.length - 1;
      let j = newParents.length - 1; // Find common parent. Index 0 is the element itself (so stop before it).

      while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
        i--;
        j--;
      } // If up the parents tree there are 2 elements that are siblings, swap
      // the inerted sibling.


      if (oldParents[i] !== newParents[j]) {
        this[_swapInertedSibling](oldParents[i], newParents[j]);
      } // Restore old parents siblings inertness.


      i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i)); // Make new parents siblings inert.

      j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
    }
    /**
     * Swaps inertness between two sibling elements.
     * Sets the property `inert` over the attribute since the inert spec
     * doesn't specify if it should be reflected.
     * https://html.spec.whatwg.org/multipage/interaction.html#inert
     */


    [_swapInertedSibling](oldInert, newInert) {
      const siblingsToRestore = oldInert[_siblingsToRestore]; // oldInert is not contained in siblings to restore, so we have to check
      // if it's inertable and if already inert.

      if (this[_isInertable](oldInert) && !oldInert.inert) {
        oldInert.inert = true;
        siblingsToRestore.add(oldInert);
      } // If newInert was already between the siblings to restore, it means it is
      // inertable and must be restored.


      if (siblingsToRestore.has(newInert)) {
        newInert.inert = false;
        siblingsToRestore.delete(newInert);
      }

      newInert[_parentMO] = oldInert[_parentMO];
      newInert[_siblingsToRestore] = siblingsToRestore;
      oldInert[_parentMO] = undefined;
      oldInert[_siblingsToRestore] = undefined;
    }
    /**
     * Restores original inertness to the siblings of the elements.
     * Sets the property `inert` over the attribute since the inert spec
     * doesn't specify if it should be reflected.
     * https://html.spec.whatwg.org/multipage/interaction.html#inert
     */


    [_restoreInertedSiblings](elements) {
      for (const element of elements) {
        const mo = element[_parentMO];
        mo.disconnect();
        element[_parentMO] = undefined;
        const siblings = element[_siblingsToRestore];

        for (const sibling of siblings) {
          sibling.inert = false;
        }

        element[_siblingsToRestore] = undefined;
      }
    }
    /**
     * Inerts the siblings of the elements except the elements to skip. Stores
     * the inerted siblings into the element's symbol `_siblingsToRestore`.
     * Pass `toKeepInert` to collect the already inert elements.
     * Sets the property `inert` over the attribute since the inert spec
     * doesn't specify if it should be reflected.
     * https://html.spec.whatwg.org/multipage/interaction.html#inert
     */


    [_inertSiblings](elements, toSkip, toKeepInert) {
      for (const element of elements) {
        // Assume element is not a Document, so it must have a parentNode.
        const parent = element.parentNode;
        const children = parent.children;
        const inertedSiblings = new Set();

        for (let j = 0; j < children.length; j++) {
          const sibling = children[j]; // Skip the input element, if not inertable or to be skipped.

          if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
            continue;
          } // Should be collected since already inerted.


          if (toKeepInert && sibling.inert) {
            toKeepInert.add(sibling);
          } else {
            sibling.inert = true;
            inertedSiblings.add(sibling);
          }
        } // Store the siblings that were inerted.


        element[_siblingsToRestore] = inertedSiblings; // Observe only immediate children mutations on the parent.

        const mo = new MutationObserver(this[_handleMutations].bind(this));
        element[_parentMO] = mo;
        let parentToObserve = parent; // If we're using the ShadyDOM polyfill, then our parent could be a
        // shady root, which is an object that acts like a ShadowRoot, but isn't
        // actually a node in the real DOM. Observe the real DOM parent instead.

        const maybeShadyRoot = parentToObserve;

        if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
          parentToObserve = maybeShadyRoot.host;
        }

        mo.observe(parentToObserve, {
          childList: true
        });
      }
    }
    /**
     * Handles newly added/removed nodes by toggling their inertness.
     * It also checks if the current top Blocking Element has been removed,
     * notifying and removing it.
     */


    [_handleMutations](mutations) {
      const parents = this[_topElParents];
      const toKeepInert = this[_alreadyInertElements];

      for (const mutation of mutations) {
        // If the target is a shadowRoot, get its host as we skip shadowRoots when
        // computing _topElParents.
        const target = mutation.target.host || mutation.target;
        const idx = target === document.body ? parents.length : parents.indexOf(target);
        const inertedChild = parents[idx - 1];
        const inertedSiblings = inertedChild[_siblingsToRestore]; // To restore.

        for (let i = 0; i < mutation.removedNodes.length; i++) {
          const sibling = mutation.removedNodes[i];

          if (sibling === inertedChild) {
            console.info('Detected removal of the top Blocking Element.');
            this.pop();
            return;
          }

          if (inertedSiblings.has(sibling)) {
            sibling.inert = false;
            inertedSiblings.delete(sibling);
          }
        } // To inert.


        for (let i = 0; i < mutation.addedNodes.length; i++) {
          const sibling = mutation.addedNodes[i];

          if (!this[_isInertable](sibling)) {
            continue;
          }

          if (toKeepInert && sibling.inert) {
            toKeepInert.add(sibling);
          } else {
            sibling.inert = true;
            inertedSiblings.add(sibling);
          }
        }
      }
    }
    /**
     * Returns if the element is inertable.
     */


    [_isInertable](element) {
      return false === /^(style|template|script)$/.test(element.localName);
    }
    /**
     * Returns the list of newParents of an element, starting from element
     * (included) up to `document.body` (excluded).
     */


    [_getParents](element) {
      const parents = [];
      let current = element; // Stop to body.

      while (current && current !== document.body) {
        // Skip shadow roots.
        if (current.nodeType === Node.ELEMENT_NODE) {
          parents.push(current);
        } // ShadowDom v1


        if (current.assignedSlot) {
          // Collect slots from deepest slot to top.
          while (current = current.assignedSlot) {
            parents.push(current);
          } // Continue the search on the top slot.


          current = parents.pop();
          continue;
        }

        current = current.parentNode || current.host;
      }

      return parents;
    }
    /**
     * Returns the distributed children of the element's shadow root.
     * Returns null if the element doesn't have a shadow root.
     */


    [_getDistributedChildren](element) {
      const shadowRoot = element.shadowRoot;

      if (!shadowRoot) {
        return null;
      }

      const result = new Set();
      let i;
      let j;
      let nodes;
      const slots = shadowRoot.querySelectorAll('slot');

      if (slots.length && slots[0].assignedNodes) {
        for (i = 0; i < slots.length; i++) {
          nodes = slots[i].assignedNodes({
            flatten: true
          });

          for (j = 0; j < nodes.length; j++) {
            if (nodes[j].nodeType === Node.ELEMENT_NODE) {
              result.add(nodes[j]);
            }
          }
        } // No need to search for <content>.

      }

      return result;
    }

  }

  document.$blockingElements = new BlockingElementsImpl();
})();

/***/ }),
/* 168 */
/***/ (function(module, exports) {

/**
 * This work is licensed under the W3C Software and Document License
 * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
 */
// Convenience function for converting NodeLists.

/** @type {typeof Array.prototype.slice} */
const slice = Array.prototype.slice;
/**
 * IE has a non-standard name for "matches".
 * @type {typeof Element.prototype.matches}
 */

const matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
/** @type {string} */

const _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');
/**
 * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
 * attribute.
 *
 * Its main functions are:
 *
 * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
 *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
 *   each focusable node in the subtree with the singleton `InertManager` which manages all known
 *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
 *   instance exists for each focusable node which has at least one inert root as an ancestor.
 *
 * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
 *   attribute is removed from the root node). This is handled in the destructor, which calls the
 *   `deregister` method on `InertManager` for each managed inert node.
 */


class InertRoot {
  /**
   * @param {!Element} rootElement The Element at the root of the inert subtree.
   * @param {!InertManager} inertManager The global singleton InertManager object.
   */
  constructor(rootElement, inertManager) {
    /** @type {!InertManager} */
    this._inertManager = inertManager;
    /** @type {!Element} */

    this._rootElement = rootElement;
    /**
     * @type {!Set<!InertNode>}
     * All managed focusable nodes in this InertRoot's subtree.
     */

    this._managedNodes = new Set(); // Make the subtree hidden from assistive technology

    if (this._rootElement.hasAttribute('aria-hidden')) {
      /** @type {?string} */
      this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
    } else {
      this._savedAriaHidden = null;
    }

    this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes


    this._makeSubtreeUnfocusable(this._rootElement); // Watch for:
    // - any additions in the subtree: make them unfocusable too
    // - any removals from the subtree: remove them from this inert root's managed nodes
    // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
    //   element, make that node a managed node.


    this._observer = new MutationObserver(this._onMutation.bind(this));

    this._observer.observe(this._rootElement, {
      attributes: true,
      childList: true,
      subtree: true
    });
  }
  /**
   * Call this whenever this object is about to become obsolete.  This unwinds all of the state
   * stored in this object and updates the state of all of the managed nodes.
   */


  destructor() {
    this._observer.disconnect();

    if (this._rootElement) {
      if (this._savedAriaHidden !== null) {
        this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
      } else {
        this._rootElement.removeAttribute('aria-hidden');
      }
    }

    this._managedNodes.forEach(function (inertNode) {
      this._unmanageNode(inertNode.node);
    }, this); // Note we cast the nulls to the ANY type here because:
    // 1) We want the class properties to be declared as non-null, or else we
    //    need even more casts throughout this code. All bets are off if an
    //    instance has been destroyed and a method is called.
    // 2) We don't want to cast "this", because we want type-aware optimizations
    //    to know which properties we're setting.


    this._observer =
    /** @type {?} */
    null;
    this._rootElement =
    /** @type {?} */
    null;
    this._managedNodes =
    /** @type {?} */
    null;
    this._inertManager =
    /** @type {?} */
    null;
  }
  /**
   * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
   */


  get managedNodes() {
    return new Set(this._managedNodes);
  }
  /** @return {boolean} */


  get hasSavedAriaHidden() {
    return this._savedAriaHidden !== null;
  }
  /** @param {?string} ariaHidden */


  set savedAriaHidden(ariaHidden) {
    this._savedAriaHidden = ariaHidden;
  }
  /** @return {?string} */


  get savedAriaHidden() {
    return this._savedAriaHidden;
  }
  /**
   * @param {!Node} startNode
   */


  _makeSubtreeUnfocusable(startNode) {
    composedTreeWalk(startNode, node => this._visitNode(node));
    let activeElement = document.activeElement;

    if (!document.body.contains(startNode)) {
      // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
      let node = startNode;
      /** @type {!ShadowRoot|undefined} */

      let root = undefined;

      while (node) {
        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          root =
          /** @type {!ShadowRoot} */
          node;
          break;
        }

        node = node.parentNode;
      }

      if (root) {
        activeElement = root.activeElement;
      }
    }

    if (startNode.contains(activeElement)) {
      activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1
      // calling blur() will not actually move the focus.
      // To work around this we call focus() on the body instead.

      if (activeElement === document.activeElement) {
        document.body.focus();
      }
    }
  }
  /**
   * @param {!Node} node
   */


  _visitNode(node) {
    if (node.nodeType !== Node.ELEMENT_NODE) {
      return;
    }

    const element =
    /** @type {!Element} */
    node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of
    // this inert root, so all of its managed nodes need to be adopted by this InertRoot.

    if (element !== this._rootElement && element.hasAttribute('inert')) {
      this._adoptInertRoot(element);
    }

    if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
      this._manageNode(element);
    }
  }
  /**
   * Register the given node with this InertRoot and with InertManager.
   * @param {!Node} node
   */


  _manageNode(node) {
    const inertNode = this._inertManager.register(node, this);

    this._managedNodes.add(inertNode);
  }
  /**
   * Unregister the given node with this InertRoot and with InertManager.
   * @param {!Node} node
   */


  _unmanageNode(node) {
    const inertNode = this._inertManager.deregister(node, this);

    if (inertNode) {
      this._managedNodes.delete(inertNode);
    }
  }
  /**
   * Unregister the entire subtree starting at `startNode`.
   * @param {!Node} startNode
   */


  _unmanageSubtree(startNode) {
    composedTreeWalk(startNode, node => this._unmanageNode(node));
  }
  /**
   * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
   * @param {!Element} node
   */


  _adoptInertRoot(node) {
    let inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,
    // so register it now if need be.


    if (!inertSubroot) {
      this._inertManager.setInert(node, true);

      inertSubroot = this._inertManager.getInertRoot(node);
    }

    inertSubroot.managedNodes.forEach(function (savedInertNode) {
      this._manageNode(savedInertNode.node);
    }, this);
  }
  /**
   * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
   * @param {!Array<!MutationRecord>} records
   * @param {!MutationObserver} self
   */


  _onMutation(records, self) {
    records.forEach(function (record) {
      const target =
      /** @type {!Element} */
      record.target;

      if (record.type === 'childList') {
        // Manage added nodes
        slice.call(record.addedNodes).forEach(function (node) {
          this._makeSubtreeUnfocusable(node);
        }, this); // Un-manage removed nodes

        slice.call(record.removedNodes).forEach(function (node) {
          this._unmanageSubtree(node);
        }, this);
      } else if (record.type === 'attributes') {
        if (record.attributeName === 'tabindex') {
          // Re-initialise inert node if tabindex changes
          this._manageNode(target);
        } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
          // If a new inert root is added, adopt its managed nodes and make sure it knows about the
          // already managed nodes from this inert subroot.
          this._adoptInertRoot(target);

          const inertSubroot = this._inertManager.getInertRoot(target);

          this._managedNodes.forEach(function (managedNode) {
            if (target.contains(managedNode.node)) {
              inertSubroot._manageNode(managedNode.node);
            }
          });
        }
      }
    }, this);
  }

}
/**
 * `InertNode` initialises and manages a single inert node.
 * A node is inert if it is a descendant of one or more inert root elements.
 *
 * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
 * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
 * is intrinsically focusable or not.
 *
 * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
 * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
 * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
 * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
 * or removes the `tabindex` attribute if the element is intrinsically focusable.
 */


class InertNode {
  /**
   * @param {!Node} node A focusable element to be made inert.
   * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
   */
  constructor(node, inertRoot) {
    /** @type {!Node} */
    this._node = node;
    /** @type {boolean} */

    this._overrodeFocusMethod = false;
    /**
     * @type {!Set<!InertRoot>} The set of descendant inert roots.
     *    If and only if this set becomes empty, this node is no longer inert.
     */

    this._inertRoots = new Set([inertRoot]);
    /** @type {?number} */

    this._savedTabIndex = null;
    /** @type {boolean} */

    this._destroyed = false; // Save any prior tabindex info and make this node untabbable

    this.ensureUntabbable();
  }
  /**
   * Call this whenever this object is about to become obsolete.
   * This makes the managed node focusable again and deletes all of the previously stored state.
   */


  destructor() {
    this._throwIfDestroyed();

    if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
      const element =
      /** @type {!Element} */
      this._node;

      if (this._savedTabIndex !== null) {
        element.setAttribute('tabindex', this._savedTabIndex);
      } else {
        element.removeAttribute('tabindex');
      } // Use `delete` to restore native focus method.


      if (this._overrodeFocusMethod) {
        delete element.focus;
      }
    } // See note in InertRoot.destructor for why we cast these nulls to ANY.


    this._node =
    /** @type {?} */
    null;
    this._inertRoots =
    /** @type {?} */
    null;
    this._destroyed = true;
  }
  /**
   * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
   * If the object has been destroyed, any attempt to access it will cause an exception.
   */


  get destroyed() {
    return (
      /** @type {!InertNode} */
      this._destroyed
    );
  }
  /**
   * Throw if user tries to access destroyed InertNode.
   */


  _throwIfDestroyed() {
    if (this.destroyed) {
      throw new Error('Trying to access destroyed InertNode');
    }
  }
  /** @return {boolean} */


  get hasSavedTabIndex() {
    return this._savedTabIndex !== null;
  }
  /** @return {!Node} */


  get node() {
    this._throwIfDestroyed();

    return this._node;
  }
  /** @param {?number} tabIndex */


  set savedTabIndex(tabIndex) {
    this._throwIfDestroyed();

    this._savedTabIndex = tabIndex;
  }
  /** @return {?number} */


  get savedTabIndex() {
    this._throwIfDestroyed();

    return this._savedTabIndex;
  }
  /** Save the existing tabindex value and make the node untabbable and unfocusable */


  ensureUntabbable() {
    if (this.node.nodeType !== Node.ELEMENT_NODE) {
      return;
    }

    const element =
    /** @type {!Element} */
    this.node;

    if (matches.call(element, _focusableElementsString)) {
      if (
      /** @type {!HTMLElement} */
      element.tabIndex === -1 && this.hasSavedTabIndex) {
        return;
      }

      if (element.hasAttribute('tabindex')) {
        this._savedTabIndex =
        /** @type {!HTMLElement} */
        element.tabIndex;
      }

      element.setAttribute('tabindex', '-1');

      if (element.nodeType === Node.ELEMENT_NODE) {
        element.focus = function () {};

        this._overrodeFocusMethod = true;
      }
    } else if (element.hasAttribute('tabindex')) {
      this._savedTabIndex =
      /** @type {!HTMLElement} */
      element.tabIndex;
      element.removeAttribute('tabindex');
    }
  }
  /**
   * Add another inert root to this inert node's set of managing inert roots.
   * @param {!InertRoot} inertRoot
   */


  addInertRoot(inertRoot) {
    this._throwIfDestroyed();

    this._inertRoots.add(inertRoot);
  }
  /**
   * Remove the given inert root from this inert node's set of managing inert roots.
   * If the set of managing inert roots becomes empty, this node is no longer inert,
   * so the object should be destroyed.
   * @param {!InertRoot} inertRoot
   */


  removeInertRoot(inertRoot) {
    this._throwIfDestroyed();

    this._inertRoots.delete(inertRoot);

    if (this._inertRoots.size === 0) {
      this.destructor();
    }
  }

}
/**
 * InertManager is a per-document singleton object which manages all inert roots and nodes.
 *
 * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
 * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
 * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
 * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
 * is created for each such node, via the `_managedNodes` map.
 */


class InertManager {
  /**
   * @param {!Document} document
   */
  constructor(document) {
    if (!document) {
      throw new Error('Missing required argument; InertManager needs to wrap a document.');
    }
    /** @type {!Document} */


    this._document = document;
    /**
     * All managed nodes known to this InertManager. In a map to allow looking up by Node.
     * @type {!Map<!Node, !InertNode>}
     */

    this._managedNodes = new Map();
    /**
     * All inert roots known to this InertManager. In a map to allow looking up by Node.
     * @type {!Map<!Node, !InertRoot>}
     */

    this._inertRoots = new Map();
    /**
     * Observer for mutations on `document.body`.
     * @type {!MutationObserver}
     */

    this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.

    addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
    } else {
      this._onDocumentLoaded();
    }
  }
  /**
   * Set whether the given element should be an inert root or not.
   * @param {!Element} root
   * @param {boolean} inert
   */


  setInert(root, inert) {
    if (inert) {
      if (this._inertRoots.has(root)) {
        // element is already inert
        return;
      }

      const inertRoot = new InertRoot(root, this);
      root.setAttribute('inert', '');

      this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.
      // Ensure inert styles are added there.


      if (!this._document.body.contains(root)) {
        let parent = root.parentNode;

        while (parent) {
          if (parent.nodeType === 11) {
            addInertStyle(parent);
          }

          parent = parent.parentNode;
        }
      }
    } else {
      if (!this._inertRoots.has(root)) {
        // element is already non-inert
        return;
      }

      const inertRoot = this._inertRoots.get(root);

      inertRoot.destructor();

      this._inertRoots.delete(root);

      root.removeAttribute('inert');
    }
  }
  /**
   * Get the InertRoot object corresponding to the given inert root element, if any.
   * @param {!Node} element
   * @return {!InertRoot|undefined}
   */


  getInertRoot(element) {
    return this._inertRoots.get(element);
  }
  /**
   * Register the given InertRoot as managing the given node.
   * In the case where the node has a previously existing inert root, this inert root will
   * be added to its set of inert roots.
   * @param {!Node} node
   * @param {!InertRoot} inertRoot
   * @return {!InertNode} inertNode
   */


  register(node, inertRoot) {
    let inertNode = this._managedNodes.get(node);

    if (inertNode !== undefined) {
      // node was already in an inert subtree
      inertNode.addInertRoot(inertRoot);
    } else {
      inertNode = new InertNode(node, inertRoot);
    }

    this._managedNodes.set(node, inertNode);

    return inertNode;
  }
  /**
   * De-register the given InertRoot as managing the given inert node.
   * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
   * node from the InertManager's set of managed nodes if it is destroyed.
   * If the node is not currently managed, this is essentially a no-op.
   * @param {!Node} node
   * @param {!InertRoot} inertRoot
   * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
   */


  deregister(node, inertRoot) {
    const inertNode = this._managedNodes.get(node);

    if (!inertNode) {
      return null;
    }

    inertNode.removeInertRoot(inertRoot);

    if (inertNode.destroyed) {
      this._managedNodes.delete(node);
    }

    return inertNode;
  }
  /**
   * Callback used when document has finished loading.
   */


  _onDocumentLoaded() {
    // Find all inert roots in document and make them actually inert.
    const inertElements = slice.call(this._document.querySelectorAll('[inert]'));
    inertElements.forEach(function (inertElement) {
      this.setInert(inertElement, true);
    }, this); // Comment this out to use programmatic API only.

    this._observer.observe(this._document.body || this._document.documentElement, {
      attributes: true,
      subtree: true,
      childList: true
    });
  }
  /**
   * Callback used when mutation observer detects attribute changes.
   * @param {!Array<!MutationRecord>} records
   * @param {!MutationObserver} self
   */


  _watchForInert(records, self) {
    const _this = this;

    records.forEach(function (record) {
      switch (record.type) {
        case 'childList':
          slice.call(record.addedNodes).forEach(function (node) {
            if (node.nodeType !== Node.ELEMENT_NODE) {
              return;
            }

            const inertElements = slice.call(node.querySelectorAll('[inert]'));

            if (matches.call(node, '[inert]')) {
              inertElements.unshift(node);
            }

            inertElements.forEach(function (inertElement) {
              this.setInert(inertElement, true);
            }, _this);
          }, _this);
          break;

        case 'attributes':
          if (record.attributeName !== 'inert') {
            return;
          }

          const target =
          /** @type {!Element} */
          record.target;
          const inert = target.hasAttribute('inert');

          _this.setInert(target, inert);

          break;
      }
    }, this);
  }

}
/**
 * Recursively walk the composed tree from |node|.
 * @param {!Node} node
 * @param {(function (!Element))=} callback Callback to be called for each element traversed,
 *     before descending into child nodes.
 * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
 */


function composedTreeWalk(node, callback, shadowRootAncestor) {
  if (node.nodeType == Node.ELEMENT_NODE) {
    const element =
    /** @type {!Element} */
    node;

    if (callback) {
      callback(element);
    } // Descend into node:
    // If it has a ShadowRoot, ignore all child elements - these will be picked
    // up by the <content> or <shadow> elements. Descend straight into the
    // ShadowRoot.


    const shadowRoot =
    /** @type {!HTMLElement} */
    element.shadowRoot;

    if (shadowRoot) {
      composedTreeWalk(shadowRoot, callback, shadowRoot);
      return;
    } // If it is a <content> element, descend into distributed elements - these
    // are elements from outside the shadow root which are rendered inside the
    // shadow DOM.


    if (element.localName == 'content') {
      const content =
      /** @type {!HTMLContentElement} */
      element; // Verifies if ShadowDom v0 is supported.

      const distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];

      for (let i = 0; i < distributedNodes.length; i++) {
        composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);
      }

      return;
    } // If it is a <slot> element, descend into assigned nodes - these
    // are elements from outside the shadow root which are rendered inside the
    // shadow DOM.


    if (element.localName == 'slot') {
      const slot =
      /** @type {!HTMLSlotElement} */
      element; // Verify if ShadowDom v1 is supported.

      const distributedNodes = slot.assignedNodes ? slot.assignedNodes({
        flatten: true
      }) : [];

      for (let i = 0; i < distributedNodes.length; i++) {
        composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);
      }

      return;
    }
  } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
  // element, nor a <shadow> element recurse normally.


  let child = node.firstChild;

  while (child != null) {
    composedTreeWalk(child, callback, shadowRootAncestor);
    child = child.nextSibling;
  }
}
/**
 * Adds a style element to the node containing the inert specific styles
 * @param {!Node} node
 */


function addInertStyle(node) {
  if (node.querySelector('style#inert-style')) {
    return;
  }

  const style = document.createElement('style');
  style.setAttribute('id', 'inert-style');
  style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  user-select: none;\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '}\n';
  node.appendChild(style);
}
/** @type {!InertManager} */


const inertManager = new InertManager(document);

if (!Element.prototype.hasOwnProperty('inert')) {
  Object.defineProperty(Element.prototype, 'inert', {
    enumerable: true,

    /** @this {!Element} */
    get: function get() {
      return this.hasAttribute('inert');
    },

    /** @this {!Element} */
    set: function set(inert) {
      inertManager.setInert(this, inert);
    }
  });
}

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _1 = __webpack_require__(46);

var graphql_1 = __webpack_require__(11);

var transforms_1 = __webpack_require__(77);

var _2 = __webpack_require__(46);

var ConvertEnumValues_1 = __webpack_require__(170);

function addResolveFunctionsToSchema(options, legacyInputResolvers, legacyInputValidationOptions) {
  if (options instanceof graphql_1.GraphQLSchema) {
    console.warn('The addResolveFunctionsToSchema function takes named options now; see IAddResolveFunctionsToSchemaOptions');
    options = {
      schema: options,
      resolvers: legacyInputResolvers,
      resolverValidationOptions: legacyInputValidationOptions
    };
  }

  var schema = options.schema,
      inputResolvers = options.resolvers,
      _a = options.resolverValidationOptions,
      resolverValidationOptions = _a === void 0 ? {} : _a,
      _b = options.inheritResolversFromInterfaces,
      inheritResolversFromInterfaces = _b === void 0 ? false : _b;
  var _c = resolverValidationOptions.allowResolversNotInSchema,
      allowResolversNotInSchema = _c === void 0 ? false : _c,
      requireResolversForResolveType = resolverValidationOptions.requireResolversForResolveType;
  var resolvers = inheritResolversFromInterfaces ? _2.extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers; // Used to map the external value of an enum to its internal value, when
  // that internal value is provided by a resolver.

  var enumValueMap = Object.create(null);
  Object.keys(resolvers).forEach(function (typeName) {
    var resolverValue = resolvers[typeName];
    var resolverType = typeof resolverValue;

    if (resolverType !== 'object' && resolverType !== 'function') {
      throw new _1.SchemaError("\"" + typeName + "\" defined in resolvers, but has invalid value \"" + resolverValue + "\". A resolver's value " + "must be of type object or function.");
    }

    var type = schema.getType(typeName);

    if (!type && typeName !== '__schema') {
      if (allowResolversNotInSchema) {
        return;
      }

      throw new _1.SchemaError("\"" + typeName + "\" defined in resolvers, but not in schema");
    }

    Object.keys(resolverValue).forEach(function (fieldName) {
      if (fieldName.startsWith('__')) {
        // this is for isTypeOf and resolveType and all the other stuff.
        type[fieldName.substring(2)] = resolverValue[fieldName];
        return;
      }

      if (type instanceof graphql_1.GraphQLScalarType) {
        type[fieldName] = resolverValue[fieldName];
        return;
      }

      if (type instanceof graphql_1.GraphQLEnumType) {
        if (!type.getValue(fieldName)) {
          if (allowResolversNotInSchema) {
            return;
          }

          throw new _1.SchemaError(typeName + "." + fieldName + " was defined in resolvers, but enum is not in schema");
        } // We've encountered an enum resolver that is being used to provide an
        // internal enum value.
        // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values
        //
        // We're storing a map of the current enums external facing value to
        // its resolver provided internal value. This map is used to transform
        // the current schema to a new schema that includes enums with the new
        // internal value.


        enumValueMap[type.name] = enumValueMap[type.name] || {};
        enumValueMap[type.name][fieldName] = resolverValue[fieldName];
        return;
      } // object type


      var fields = getFieldsForType(type);

      if (!fields) {
        if (allowResolversNotInSchema) {
          return;
        }

        throw new _1.SchemaError(typeName + " was defined in resolvers, but it's not an object");
      }

      if (!fields[fieldName]) {
        if (allowResolversNotInSchema) {
          return;
        }

        throw new _1.SchemaError(typeName + "." + fieldName + " defined in resolvers, but not in schema");
      }

      var field = fields[fieldName];
      var fieldResolve = resolverValue[fieldName];

      if (typeof fieldResolve === 'function') {
        // for convenience. Allows shorter syntax in resolver definition file
        setFieldProperties(field, {
          resolve: fieldResolve
        });
      } else {
        if (typeof fieldResolve !== 'object') {
          throw new _1.SchemaError("Resolver " + typeName + "." + fieldName + " must be object or function");
        }

        setFieldProperties(field, fieldResolve);
      }
    });
  });

  _2.checkForResolveTypeResolver(schema, requireResolversForResolveType); // If there are any enum resolver functions (that are used to return
  // internal enum values), create a new schema that includes enums with the
  // new internal facing values.


  var updatedSchema = transforms_1.applySchemaTransforms(schema, [new ConvertEnumValues_1.default(enumValueMap)]);
  return updatedSchema;
}

function getFieldsForType(type) {
  if (type instanceof graphql_1.GraphQLObjectType || type instanceof graphql_1.GraphQLInterfaceType) {
    return type.getFields();
  } else {
    return undefined;
  }
}

function setFieldProperties(field, propertiesObj) {
  Object.keys(propertiesObj).forEach(function (propertyName) {
    field[propertyName] = propertiesObj[propertyName];
  });
}

exports.default = addResolveFunctionsToSchema;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var visitSchema_1 = __webpack_require__(61); // Transformation used to modifiy `GraphQLEnumType` values in a schema.


var ConvertEnumValues =
/** @class */
function () {
  function ConvertEnumValues(enumValueMap) {
    this.enumValueMap = enumValueMap;
  } // Walk a schema looking for `GraphQLEnumType` types. If found, and
  // matching types have been identified in `this.enumValueMap`, create new
  // `GraphQLEnumType` types using the `this.enumValueMap` specified new
  // values, and return them in the new schema.


  ConvertEnumValues.prototype.transformSchema = function (schema) {
    var _a;

    var enumValueMap = this.enumValueMap;

    if (!enumValueMap || Object.keys(enumValueMap).length === 0) {
      return schema;
    }

    var transformedSchema = visitSchema_1.visitSchema(schema, (_a = {}, _a[visitSchema_1.VisitSchemaKind.ENUM_TYPE] = function (enumType) {
      var externalToInternalValueMap = enumValueMap[enumType.name];

      if (externalToInternalValueMap) {
        var values = enumType.getValues();
        var newValues_1 = {};
        values.forEach(function (value) {
          var newValue = Object.keys(externalToInternalValueMap).includes(value.name) ? externalToInternalValueMap[value.name] : value.name;
          newValues_1[value.name] = {
            value: newValue,
            deprecationReason: value.deprecationReason,
            description: value.description,
            astNode: value.astNode
          };
        });
        return new graphql_1.GraphQLEnumType({
          name: enumType.name,
          description: enumType.description,
          astNode: enumType.astNode,
          values: newValues_1
        });
      }

      return enumType;
    }, _a));
    return transformedSchema;
  };

  return ConvertEnumValues;
}();

exports.default = ConvertEnumValues;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11); // wraps all resolve functions of query, mutation or subscription fields
// with the provided function to simulate a root schema level resolve funciton


function addSchemaLevelResolveFunction(schema, fn) {
  // TODO test that schema is a schema, fn is a function
  var rootTypes = [schema.getQueryType(), schema.getMutationType(), schema.getSubscriptionType()].filter(function (x) {
    return !!x;
  });
  rootTypes.forEach(function (type) {
    // XXX this should run at most once per request to simulate a true root resolver
    // for graphql-js this is an approximation that works with queries but not mutations
    var rootResolveFn = runAtMostOncePerRequest(fn);
    var fields = type.getFields();
    Object.keys(fields).forEach(function (fieldName) {
      // XXX if the type is a subscription, a same query AST will be ran multiple times so we
      // deactivate here the runOnce if it's a subscription. This may not be optimal though...
      if (type === schema.getSubscriptionType()) {
        fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, fn);
      } else {
        fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, rootResolveFn);
      }
    });
  });
} // XXX badly named function. this doesn't really wrap, it just chains resolvers...


function wrapResolver(innerResolver, outerResolver) {
  return function (obj, args, ctx, info) {
    return Promise.resolve(outerResolver(obj, args, ctx, info)).then(function (root) {
      if (innerResolver) {
        return innerResolver(root, args, ctx, info);
      }

      return graphql_1.defaultFieldResolver(root, args, ctx, info);
    });
  };
} // XXX this function only works for resolvers
// XXX very hacky way to remember if the function
// already ran for this request. This will only work
// if people don't actually cache the operation.
// if they do cache the operation, they will have to
// manually remove the __runAtMostOnce before every request.


function runAtMostOncePerRequest(fn) {
  var value;
  var randomNumber = Math.random();
  return function (root, args, ctx, info) {
    if (!info.operation['__runAtMostOnce']) {
      info.operation['__runAtMostOnce'] = {};
    }

    if (!info.operation['__runAtMostOnce'][randomNumber]) {
      info.operation['__runAtMostOnce'][randomNumber] = true;
      value = fn(root, args, ctx, info);
    }

    return value;
  };
}

exports.default = addSchemaLevelResolveFunction;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var _1 = __webpack_require__(46);

function assertResolveFunctionsPresent(schema, resolverValidationOptions) {
  if (resolverValidationOptions === void 0) {
    resolverValidationOptions = {};
  }

  var _a = resolverValidationOptions.requireResolversForArgs,
      requireResolversForArgs = _a === void 0 ? false : _a,
      _b = resolverValidationOptions.requireResolversForNonScalar,
      requireResolversForNonScalar = _b === void 0 ? false : _b,
      _c = resolverValidationOptions.requireResolversForAllFields,
      requireResolversForAllFields = _c === void 0 ? false : _c;

  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
    throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' + 'Please configure either requireResolversForAllFields or requireResolversForArgs / ' + 'requireResolversForNonScalar, but not a combination of them.');
  }

  _1.forEachField(schema, function (field, typeName, fieldName) {
    // requires a resolve function for *every* field.
    if (requireResolversForAllFields) {
      expectResolveFunction(field, typeName, fieldName);
    } // requires a resolve function on every field that has arguments


    if (requireResolversForArgs && field.args.length > 0) {
      expectResolveFunction(field, typeName, fieldName);
    } // requires a resolve function on every field that returns a non-scalar type


    if (requireResolversForNonScalar && !(graphql_1.getNamedType(field.type) instanceof graphql_1.GraphQLScalarType)) {
      expectResolveFunction(field, typeName, fieldName);
    }
  });
}

function expectResolveFunction(field, typeName, fieldName) {
  if (!field.resolve) {
    console.warn( // tslint:disable-next-line: max-line-length
    "Resolve function missing for \"" + typeName + "." + fieldName + "\". To disable this warning check https://github.com/apollostack/graphql-tools/issues/131");
    return;
  }

  if (typeof field.resolve !== 'function') {
    throw new _1.SchemaError("Resolver \"" + typeName + "." + fieldName + "\" must be a function");
  }
}

exports.default = assertResolveFunctionsPresent;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var __extends = this && this.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var schemaVisitor_1 = __webpack_require__(70);

function attachDirectiveResolvers(schema, directiveResolvers) {
  if (typeof directiveResolvers !== 'object') {
    throw new Error("Expected directiveResolvers to be of type object, got " + typeof directiveResolvers);
  }

  if (Array.isArray(directiveResolvers)) {
    throw new Error('Expected directiveResolvers to be of type object, got Array');
  }

  var schemaDirectives = Object.create(null);
  Object.keys(directiveResolvers).forEach(function (directiveName) {
    schemaDirectives[directiveName] =
    /** @class */
    function (_super) {
      __extends(class_1, _super);

      function class_1() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      class_1.prototype.visitFieldDefinition = function (field) {
        var _this = this;

        var resolver = directiveResolvers[directiveName];
        var originalResolver = field.resolve || graphql_1.defaultFieldResolver;
        var directiveArgs = this.args;

        field.resolve = function () {
          var args = [];

          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }

          var source = args[0]
          /* original args */
          ,
              context = args[2],
              info = args[3];
          return resolver(function () {
            return __awaiter(_this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                return [2
                /*return*/
                , originalResolver.apply(field, args)];
              });
            });
          }, source, directiveArgs, context, info);
        };
      };

      return class_1;
    }(schemaVisitor_1.SchemaDirectiveVisitor);
  });
  schemaVisitor_1.SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);
}

exports.default = attachDirectiveResolvers;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var deprecated_decorator_1 = __webpack_require__(175);

var _1 = __webpack_require__(46); // takes a GraphQL-JS schema and an object of connectors, then attaches
// the connectors to the context by wrapping each query or mutation resolve
// function with a function that attaches connectors if they don't exist.
// attaches connectors only once to make sure they are singletons


var attachConnectorsToContext = deprecated_decorator_1.deprecated({
  version: '0.7.0',
  url: 'https://github.com/apollostack/graphql-tools/issues/140'
}, function (schema, connectors) {
  if (!schema || !(schema instanceof graphql_1.GraphQLSchema)) {
    throw new Error('schema must be an instance of GraphQLSchema. ' + 'This error could be caused by installing more than one version of GraphQL-JS');
  }

  if (typeof connectors !== 'object') {
    var connectorType = typeof connectors;
    throw new Error("Expected connectors to be of type object, got " + connectorType);
  }

  if (Object.keys(connectors).length === 0) {
    throw new Error('Expected connectors to not be an empty object');
  }

  if (Array.isArray(connectors)) {
    throw new Error('Expected connectors to be of type object, got Array');
  }

  if (schema['_apolloConnectorsAttached']) {
    throw new Error('Connectors already attached to context, cannot attach more than once');
  }

  schema['_apolloConnectorsAttached'] = true;

  var attachconnectorFn = function attachconnectorFn(root, args, ctx) {
    if (typeof ctx !== 'object') {
      // if in any way possible, we should throw an error when the attachconnectors
      // function is called, not when a query is executed.
      var contextType = typeof ctx;
      throw new Error("Cannot attach connector because context is not an object: " + contextType);
    }

    if (typeof ctx.connectors === 'undefined') {
      ctx.connectors = {};
    }

    Object.keys(connectors).forEach(function (connectorName) {
      var connector = connectors[connectorName];

      if (!!connector.prototype) {
        ctx.connectors[connectorName] = new connector(ctx);
      } else {
        throw new Error("Connector must be a function or an class");
      }
    });
    return root;
  };

  _1.addSchemaLevelResolveFunction(schema, attachconnectorFn);
});
exports.default = attachConnectorsToContext;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
    Deprecated Decorator v0.1
    https://github.com/vilic/deprecated-decorator
*/

/** @internal */

exports.options = {
  getWarner: undefined
};

function createWarner(type, name, alternative, version, url) {
  var warnedPositions = {};
  return function () {
    var stack = new Error().stack || '';
    var at = (stack.match(/(?:\s+at\s.+){2}\s+at\s(.+)/) || [undefined, ''])[1];

    if (/\)$/.test(at)) {
      at = at.match(/[^(]+(?=\)$)/)[0];
    } else {
      at = at.trim();
    }

    if (at in warnedPositions) {
      return;
    }

    warnedPositions[at] = true;
    var message;

    switch (type) {
      case 'class':
        message = 'Class';
        break;

      case 'property':
        message = 'Property';
        break;

      case 'method':
        message = 'Method';
        break;

      case 'function':
        message = 'Function';
        break;
    }

    message += " `" + name + "` has been deprecated";

    if (version) {
      message += " since version " + version;
    }

    if (alternative) {
      message += ", use `" + alternative + "` instead";
    }

    message += '.';

    if (at) {
      message += "\n    at " + at;
    }

    if (url) {
      message += "\nCheck out " + url + " for more information.";
    }

    console.warn(message);
  };
}

function decorateProperty(type, name, descriptor, alternative, version, url) {
  var warner = (exports.options.getWarner || createWarner)(type, name, alternative, version, url);
  descriptor = descriptor || {
    writable: true,
    enumerable: false,
    configurable: true
  };
  var deprecatedDescriptor = {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable
  };

  if (descriptor.get || descriptor.set) {
    if (descriptor.get) {
      deprecatedDescriptor.get = function () {
        warner();
        return descriptor.get.call(this);
      };
    }

    if (descriptor.set) {
      deprecatedDescriptor.set = function (value) {
        warner();
        return descriptor.set.call(this, value);
      };
    }
  } else {
    var propertyValue_1 = descriptor.value;

    deprecatedDescriptor.get = function () {
      warner();
      return propertyValue_1;
    };

    if (descriptor.writable) {
      deprecatedDescriptor.set = function (value) {
        warner();
        propertyValue_1 = value;
      };
    }
  }

  return deprecatedDescriptor;
}

function decorateFunction(type, target, alternative, version, url) {
  var name = target.name;
  var warner = (exports.options.getWarner || createWarner)(type, name, alternative, version, url);

  var fn = function fn() {
    warner();
    return target.apply(this, arguments);
  };

  for (var _i = 0, _a = Object.getOwnPropertyNames(target); _i < _a.length; _i++) {
    var propertyName = _a[_i];
    var descriptor = Object.getOwnPropertyDescriptor(target, propertyName);

    if (descriptor.writable) {
      fn[propertyName] = target[propertyName];
    } else if (descriptor.configurable) {
      Object.defineProperty(fn, propertyName, descriptor);
    }
  }

  return fn;
}

function deprecated() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i - 0] = arguments[_i];
  }

  var fn = args[args.length - 1];

  if (typeof fn === 'function') {
    fn = args.pop();
  } else {
    fn = undefined;
  }

  var options = args[0];
  var alternative;
  var version;
  var url;

  if (typeof options === 'string') {
    alternative = options;
    version = args[1];
    url = args[2];
  } else if (options) {
    alternative = options.alternative, version = options.version, url = options.url, options;
  }

  if (fn) {
    return decorateFunction('function', fn, alternative, version, url);
  }

  return function (target, name, descriptor) {
    if (typeof name === 'string') {
      var type = descriptor && typeof descriptor.value === 'function' ? 'method' : 'property';
      return decorateProperty(type, name, descriptor, alternative, version, url);
    } else if (typeof target === 'function') {
      var constructor = decorateFunction('class', target, alternative, version, url);
      var className = target.name;

      for (var _i = 0, _a = Object.getOwnPropertyNames(constructor); _i < _a.length; _i++) {
        var propertyName = _a[_i];
        var descriptor_1 = Object.getOwnPropertyDescriptor(constructor, propertyName);
        descriptor_1 = decorateProperty('class', className, descriptor_1, alternative, version, url);

        if (descriptor_1.writable) {
          constructor[propertyName] = target[propertyName];
        } else if (descriptor_1.configurable) {
          Object.defineProperty(constructor, propertyName, descriptor_1);
        }
      }

      return constructor;
    }
  };
}

exports.deprecated = deprecated;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = deprecated;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var _1 = __webpack_require__(46);

function buildSchemaFromTypeDefinitions(typeDefinitions, parseOptions) {
  // TODO: accept only array here, otherwise interfaces get confusing.
  var myDefinitions = typeDefinitions;
  var astDocument;

  if (isDocumentNode(typeDefinitions)) {
    astDocument = typeDefinitions;
  } else if (typeof myDefinitions !== 'string') {
    if (!Array.isArray(myDefinitions)) {
      var type = typeof myDefinitions;
      throw new _1.SchemaError("typeDefs must be a string, array or schema AST, got " + type);
    }

    myDefinitions = _1.concatenateTypeDefs(myDefinitions);
  }

  if (typeof myDefinitions === 'string') {
    astDocument = graphql_1.parse(myDefinitions, parseOptions);
  }

  var backcompatOptions = {
    commentDescriptions: true
  }; // TODO fix types https://github.com/apollographql/graphql-tools/issues/542

  var schema = graphql_1.buildASTSchema(astDocument, backcompatOptions);

  var extensionsAst = _1.extractExtensionDefinitions(astDocument);

  if (extensionsAst.definitions.length > 0) {
    // TODO fix types https://github.com/apollographql/graphql-tools/issues/542
    schema = graphql_1.extendSchema(schema, extensionsAst, backcompatOptions);
  }

  return schema;
}

function isDocumentNode(typeDefinitions) {
  return typeDefinitions.kind !== undefined;
}

exports.default = buildSchemaFromTypeDefinitions;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

function chainResolvers(resolvers) {
  return function (root, args, ctx, info) {
    return resolvers.reduce(function (prev, curResolver) {
      if (curResolver) {
        return curResolver(prev, args, ctx, info);
      }

      return graphql_1.defaultFieldResolver(prev, args, ctx, info);
    }, root);
  };
}

exports.chainResolvers = chainResolvers;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var _1 = __webpack_require__(46); // If we have any union or interface types throw if no there is no resolveType or isTypeOf resolvers


function checkForResolveTypeResolver(schema, requireResolversForResolveType) {
  Object.keys(schema.getTypeMap()).map(function (typeName) {
    return schema.getType(typeName);
  }).forEach(function (type) {
    if (!(type instanceof graphql_1.GraphQLUnionType || type instanceof graphql_1.GraphQLInterfaceType)) {
      return;
    }

    if (!type.resolveType) {
      if (requireResolversForResolveType === false) {
        return;
      }

      if (requireResolversForResolveType === true) {
        throw new _1.SchemaError("Type \"" + type.name + "\" is missing a \"resolveType\" resolver");
      } // tslint:disable-next-line:max-line-length


      console.warn("Type \"" + type.name + "\" is missing a \"__resolveType\" resolver. Pass false into " + "\"resolverValidationOptions.requireResolversForResolveType\" to disable this warning.");
    }
  });
}

exports.default = checkForResolveTypeResolver;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var _1 = __webpack_require__(46);

function concatenateTypeDefs(typeDefinitionsAry, calledFunctionRefs) {
  if (calledFunctionRefs === void 0) {
    calledFunctionRefs = [];
  }

  var resolvedTypeDefinitions = [];
  typeDefinitionsAry.forEach(function (typeDef) {
    if (typeDef.kind !== undefined) {
      typeDef = graphql_1.print(typeDef);
    }

    if (typeof typeDef === 'function') {
      if (calledFunctionRefs.indexOf(typeDef) === -1) {
        calledFunctionRefs.push(typeDef);
        resolvedTypeDefinitions = resolvedTypeDefinitions.concat(concatenateTypeDefs(typeDef(), calledFunctionRefs));
      }
    } else if (typeof typeDef === 'string') {
      resolvedTypeDefinitions.push(typeDef.trim());
    } else {
      var type = typeof typeDef;
      throw new _1.SchemaError("typeDef array must contain only strings and functions, got " + type);
    }
  });
  return uniq(resolvedTypeDefinitions.map(function (x) {
    return x.trim();
  })).join('\n');
}

function uniq(array) {
  return array.reduce(function (accumulator, currentValue) {
    return accumulator.indexOf(currentValue) === -1 ? __spreadArrays(accumulator, [currentValue]) : accumulator;
  }, []);
}

exports.default = concatenateTypeDefs;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);
/*
 * fn: The function to decorate with the logger
 * logger: an object instance of type Logger
 * hint: an optional hint to add to the error's message
 */


function decorateWithLogger(fn, logger, hint) {
  if (typeof fn === 'undefined') {
    fn = graphql_1.defaultFieldResolver;
  }

  var logError = function logError(e) {
    // TODO: clone the error properly
    var newE = new Error();
    newE.stack = e.stack;
    /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */

    if (hint) {
      newE['originalMessage'] = e.message;
      newE['message'] = "Error in resolver " + hint + "\n" + e.message;
    }

    logger.log(newE);
  };

  return function (root, args, ctx, info) {
    try {
      var result = fn(root, args, ctx, info); // If the resolve function returns a Promise log any Promise rejects.

      if (result && typeof result.then === 'function' && typeof result.catch === 'function') {
        result.catch(function (reason) {
          // make sure that it's an error we're logging.
          var error = reason instanceof Error ? reason : new Error(reason);
          logError(error); // We don't want to leave an unhandled exception so pass on error.

          return reason;
        });
      }

      return result;
    } catch (e) {
      logError(e); // we want to pass on the error, just in case.

      throw e;
    }
  };
}

exports.default = decorateWithLogger;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

function extendResolversFromInterfaces(schema, resolvers) {
  var typeNames = Object.keys(__assign(__assign({}, schema.getTypeMap()), resolvers));
  var extendedResolvers = {};
  typeNames.forEach(function (typeName) {
    var typeResolvers = resolvers[typeName];
    var type = schema.getType(typeName);

    if (type instanceof graphql_1.GraphQLObjectType) {
      var interfaceResolvers = type.getInterfaces().map(function (iFace) {
        return resolvers[iFace.name];
      });
      extendedResolvers[typeName] = Object.assign.apply(Object, __spreadArrays([{}], interfaceResolvers, [typeResolvers]));
    } else {
      if (typeResolvers) {
        extendedResolvers[typeName] = typeResolvers;
      }
    }
  });
  return extendedResolvers;
}

exports.default = extendResolversFromInterfaces;

/***/ }),
/* 182 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
var newExtensionDefinitionKind = 'ObjectTypeExtension';
var interfaceExtensionDefinitionKind = 'InterfaceTypeExtension';
var inputObjectExtensionDefinitionKind = 'InputObjectTypeExtension';
var unionExtensionDefinitionKind = 'UnionTypeExtension';
var enumExtensionDefinitionKind = 'EnumTypeExtension';

function extractExtensionDefinitions(ast) {
  var extensionDefs = ast.definitions.filter(function (def) {
    return def.kind === newExtensionDefinitionKind || def.kind === interfaceExtensionDefinitionKind || def.kind === inputObjectExtensionDefinitionKind || def.kind === unionExtensionDefinitionKind || def.kind === enumExtensionDefinitionKind;
  });
  return Object.assign({}, ast, {
    definitions: extensionDefs
  });
}

exports.default = extractExtensionDefinitions;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

function forEachField(schema, fn) {
  var typeMap = schema.getTypeMap();
  Object.keys(typeMap).forEach(function (typeName) {
    var type = typeMap[typeName]; // TODO: maybe have an option to include these?

    if (!graphql_1.getNamedType(type).name.startsWith('__') && type instanceof graphql_1.GraphQLObjectType) {
      var fields_1 = type.getFields();
      Object.keys(fields_1).forEach(function (fieldName) {
        var field = fields_1[fieldName];
        fn(field, typeName, fieldName);
      });
    }
  });
}

exports.default = forEachField;

/***/ }),
/* 184 */
/***/ (function(module, exports) {

var __extends = this && this.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
}); // @schemaDefinition: A GraphQL type schema in shorthand
// @resolvers: Definitions for resolvers to be merged with schema

var SchemaError =
/** @class */
function (_super) {
  __extends(SchemaError, _super);

  function SchemaError(message) {
    var _this = _super.call(this, message) || this;

    _this.message = message;
    Error.captureStackTrace(_this, _this.constructor);
    return _this;
  }

  return SchemaError;
}(Error);

exports.default = SchemaError;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var uuid = __webpack_require__(186);

var makeExecutableSchema_1 = __webpack_require__(59); // This function wraps addMockFunctionsToSchema for more convenience


function mockServer(schema, mocks, preserveResolvers) {
  if (preserveResolvers === void 0) {
    preserveResolvers = false;
  }

  var mySchema;

  if (!(schema instanceof graphql_1.GraphQLSchema)) {
    // TODO: provide useful error messages here if this fails
    mySchema = makeExecutableSchema_1.buildSchemaFromTypeDefinitions(schema);
  } else {
    mySchema = schema;
  }

  addMockFunctionsToSchema({
    schema: mySchema,
    mocks: mocks,
    preserveResolvers: preserveResolvers
  });
  return {
    query: function query(_query, vars) {
      return graphql_1.graphql(mySchema, _query, {}, {}, vars);
    }
  };
}

exports.mockServer = mockServer;
var defaultMockMap = new Map();
defaultMockMap.set('Int', function () {
  return Math.round(Math.random() * 200) - 100;
});
defaultMockMap.set('Float', function () {
  return Math.random() * 200 - 100;
});
defaultMockMap.set('String', function () {
  return 'Hello World';
});
defaultMockMap.set('Boolean', function () {
  return Math.random() > 0.5;
});
defaultMockMap.set('ID', function () {
  return uuid.v4();
}); // TODO allow providing a seed such that lengths of list could be deterministic
// this could be done by using casual to get a random list length if the casual
// object is global.

function addMockFunctionsToSchema(_a) {
  var schema = _a.schema,
      _b = _a.mocks,
      mocks = _b === void 0 ? {} : _b,
      _c = _a.preserveResolvers,
      preserveResolvers = _c === void 0 ? false : _c;

  if (!schema) {
    throw new Error('Must provide schema to mock');
  }

  if (!(schema instanceof graphql_1.GraphQLSchema)) {
    throw new Error('Value at "schema" must be of type GraphQLSchema');
  }

  if (!isObject(mocks)) {
    throw new Error('mocks must be of type Object');
  } // use Map internally, because that API is nicer.


  var mockFunctionMap = new Map();
  Object.keys(mocks).forEach(function (typeName) {
    mockFunctionMap.set(typeName, mocks[typeName]);
  });
  mockFunctionMap.forEach(function (mockFunction, mockTypeName) {
    if (typeof mockFunction !== 'function') {
      throw new Error("mockFunctionMap[" + mockTypeName + "] must be a function");
    }
  });

  var mockType = function mockType(type, typeName, fieldName) {
    // order of precendence for mocking:
    // 1. if the object passed in already has fieldName, just use that
    // --> if it's a function, that becomes your resolver
    // --> if it's a value, the mock resolver will return that
    // 2. if the nullableType is a list, recurse
    // 2. if there's a mock defined for this typeName, that will be used
    // 3. if there's no mock defined, use the default mocks for this type
    return function (root, args, context, info) {
      // nullability doesn't matter for the purpose of mocking.
      var fieldType = graphql_1.getNullableType(type);
      var namedFieldType = graphql_1.getNamedType(fieldType);

      if (root && typeof root[fieldName] !== 'undefined') {
        var result = void 0; // if we're here, the field is already defined

        if (typeof root[fieldName] === 'function') {
          result = root[fieldName](root, args, context, info);

          if (result instanceof MockList) {
            result = result.mock(root, args, context, info, fieldType, mockType);
          }
        } else {
          result = root[fieldName];
        } // Now we merge the result with the default mock for this type.
        // This allows overriding defaults while writing very little code.


        if (mockFunctionMap.has(namedFieldType.name)) {
          result = mergeMocks(mockFunctionMap.get(namedFieldType.name).bind(null, root, args, context, info), result);
        }

        return result;
      }

      if (fieldType instanceof graphql_1.GraphQLList || fieldType instanceof graphql_1.GraphQLNonNull) {
        return [mockType(fieldType.ofType)(root, args, context, info), mockType(fieldType.ofType)(root, args, context, info)];
      }

      if (mockFunctionMap.has(fieldType.name) && !(fieldType instanceof graphql_1.GraphQLUnionType || fieldType instanceof graphql_1.GraphQLInterfaceType)) {
        // the object passed doesn't have this field, so we apply the default mock
        return mockFunctionMap.get(fieldType.name)(root, args, context, info);
      }

      if (fieldType instanceof graphql_1.GraphQLObjectType) {
        // objects don't return actual data, we only need to mock scalars!
        return {};
      } // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type
      // otherwise randomly pick a type from all implementation types


      if (fieldType instanceof graphql_1.GraphQLUnionType || fieldType instanceof graphql_1.GraphQLInterfaceType) {
        var implementationType = void 0;

        if (mockFunctionMap.has(fieldType.name)) {
          var interfaceMockObj = mockFunctionMap.get(fieldType.name)(root, args, context, info);

          if (!interfaceMockObj || !interfaceMockObj.__typename) {
            return Error("Please return a __typename in \"" + fieldType.name + "\"");
          }

          implementationType = schema.getType(interfaceMockObj.__typename);
        } else {
          var possibleTypes = schema.getPossibleTypes(fieldType);
          implementationType = getRandomElement(possibleTypes);
        }

        return Object.assign({
          __typename: implementationType
        }, mockType(implementationType)(root, args, context, info));
      }

      if (fieldType instanceof graphql_1.GraphQLEnumType) {
        return getRandomElement(fieldType.getValues()).value;
      }

      if (defaultMockMap.has(fieldType.name)) {
        return defaultMockMap.get(fieldType.name)(root, args, context, info);
      } // if we get to here, we don't have a value, and we don't have a mock for this type,
      // we could return undefined, but that would be hard to debug, so we throw instead.
      // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.


      return Error("No mock defined for type \"" + fieldType.name + "\"");
    };
  };

  makeExecutableSchema_1.forEachField(schema, function (field, typeName, fieldName) {
    assignResolveType(field.type, preserveResolvers);
    var mockResolver; // we have to handle the root mutation and root query types differently,
    // because no resolver is called at the root.

    /* istanbul ignore next: Must provide schema DefinitionNode with query type or a type named Query. */

    var isOnQueryType = schema.getQueryType() && schema.getQueryType().name === typeName;
    var isOnMutationType = schema.getMutationType() && schema.getMutationType().name === typeName;

    if (isOnQueryType || isOnMutationType) {
      if (mockFunctionMap.has(typeName)) {
        var rootMock_1 = mockFunctionMap.get(typeName); // XXX: BUG in here, need to provide proper signature for rootMock.

        if (typeof rootMock_1(undefined, {}, {}, {})[fieldName] === 'function') {
          mockResolver = function mockResolver(root, args, context, info) {
            var updatedRoot = root || {}; // TODO: should we clone instead?

            updatedRoot[fieldName] = rootMock_1(root, args, context, info)[fieldName]; // XXX this is a bit of a hack to still use mockType, which
            // lets you mock lists etc. as well
            // otherwise we could just set field.resolve to rootMock()[fieldName]
            // it's like pretending there was a resolve function that ran before
            // the root resolve function.

            return mockType(field.type, typeName, fieldName)(updatedRoot, args, context, info);
          };
        }
      }
    }

    if (!mockResolver) {
      mockResolver = mockType(field.type, typeName, fieldName);
    }

    if (!preserveResolvers || !field.resolve) {
      field.resolve = mockResolver;
    } else {
      var oldResolver_1 = field.resolve;

      field.resolve = function (rootObject, args, context, info) {
        return Promise.all([mockResolver(rootObject, args, context, info), oldResolver_1(rootObject, args, context, info)]).then(function (values) {
          var mockedValue = values[0],
              resolvedValue = values[1]; // In case we couldn't mock

          if (mockedValue instanceof Error) {
            // only if value was not resolved, populate the error.
            if (undefined === resolvedValue) {
              throw mockedValue;
            }

            return resolvedValue;
          }

          if (resolvedValue instanceof Date && mockedValue instanceof Date) {
            return undefined !== resolvedValue ? resolvedValue : mockedValue;
          }

          if (isObject(mockedValue) && isObject(resolvedValue)) {
            // Object.assign() won't do here, as we need to all properties, including
            // the non-enumerable ones and defined using Object.defineProperty
            var emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));
            return copyOwnProps(emptyObject, resolvedValue, mockedValue);
          }

          return undefined !== resolvedValue ? resolvedValue : mockedValue;
        });
      };
    }
  });
}

exports.addMockFunctionsToSchema = addMockFunctionsToSchema;

function isObject(thing) {
  return thing === Object(thing) && !Array.isArray(thing);
} // returns a random element from that ary


function getRandomElement(ary) {
  var sample = Math.floor(Math.random() * ary.length);
  return ary[sample];
}

function mergeObjects(a, b) {
  return Object.assign(a, b);
}

function copyOwnPropsIfNotPresent(target, source) {
  Object.getOwnPropertyNames(source).forEach(function (prop) {
    if (!Object.getOwnPropertyDescriptor(target, prop)) {
      Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));
    }
  });
}

function copyOwnProps(target) {
  var sources = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    sources[_i - 1] = arguments[_i];
  }

  sources.forEach(function (source) {
    var chain = source;

    while (chain) {
      copyOwnPropsIfNotPresent(target, chain);
      chain = Object.getPrototypeOf(chain);
    }
  });
  return target;
} // takes either an object or a (possibly nested) array
// and completes the customMock object with any fields
// defined on genericMock
// only merges objects or arrays. Scalars are returned as is


function mergeMocks(genericMockFunction, customMock) {
  if (Array.isArray(customMock)) {
    return customMock.map(function (el) {
      return mergeMocks(genericMockFunction, el);
    });
  }

  if (isObject(customMock)) {
    return mergeObjects(genericMockFunction(), customMock);
  }

  return customMock;
}

function getResolveType(namedFieldType) {
  if (namedFieldType instanceof graphql_1.GraphQLInterfaceType || namedFieldType instanceof graphql_1.GraphQLUnionType) {
    return namedFieldType.resolveType;
  } else {
    return undefined;
  }
}

function assignResolveType(type, preserveResolvers) {
  var fieldType = graphql_1.getNullableType(type);
  var namedFieldType = graphql_1.getNamedType(fieldType);
  var oldResolveType = getResolveType(namedFieldType);

  if (preserveResolvers && oldResolveType && oldResolveType.length) {
    return;
  }

  if (namedFieldType instanceof graphql_1.GraphQLUnionType || namedFieldType instanceof graphql_1.GraphQLInterfaceType) {
    // the default `resolveType` always returns null. We add a fallback
    // resolution that works with how unions and interface are mocked
    namedFieldType.resolveType = function (data, context, info) {
      return info.schema.getType(data.__typename);
    };
  }
}

var MockList =
/** @class */
function () {
  // wrappedFunction can return another MockList or a value
  function MockList(len, wrappedFunction) {
    this.len = len;

    if (typeof wrappedFunction !== 'undefined') {
      if (typeof wrappedFunction !== 'function') {
        throw new Error('Second argument to MockList must be a function or undefined');
      }

      this.wrappedFunction = wrappedFunction;
    }
  }

  MockList.prototype.mock = function (root, args, context, info, fieldType, mockTypeFunc) {
    var arr;

    if (Array.isArray(this.len)) {
      arr = new Array(this.randint(this.len[0], this.len[1]));
    } else {
      arr = new Array(this.len);
    }

    for (var i = 0; i < arr.length; i++) {
      if (typeof this.wrappedFunction === 'function') {
        var res = this.wrappedFunction(root, args, context, info);

        if (res instanceof MockList) {
          var nullableType = graphql_1.getNullableType(fieldType.ofType);
          arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);
        } else {
          arr[i] = res;
        }
      } else {
        arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);
      }
    }

    return arr;
  };

  MockList.prototype.randint = function (low, high) {
    return Math.floor(Math.random() * (high - low + 1) + low);
  };

  return MockList;
}();

exports.MockList = MockList;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(187);

var v4 = __webpack_require__(188);

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
module.exports = uuid;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(111);

var bytesToUuid = __webpack_require__(112); // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html


var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = rng();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(111);

var bytesToUuid = __webpack_require__(112);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }

  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var makeRemoteExecutableSchema_1 = __webpack_require__(190);

exports.makeRemoteExecutableSchema = makeRemoteExecutableSchema_1.default;
exports.defaultCreateRemoteResolver = makeRemoteExecutableSchema_1.createResolver;

var introspectSchema_1 = __webpack_require__(193);

exports.introspectSchema = introspectSchema_1.default;

var mergeSchemas_1 = __webpack_require__(194);

exports.mergeSchemas = mergeSchemas_1.default;

var delegateToSchema_1 = __webpack_require__(82);

exports.delegateToSchema = delegateToSchema_1.default;

var defaultMergedResolver_1 = __webpack_require__(79);

exports.defaultMergedResolver = defaultMergedResolver_1.default;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var linkToFetcher_1 = __webpack_require__(113);

var isEmptyObject_1 = __webpack_require__(115);

var makeExecutableSchema_1 = __webpack_require__(59);

var schemaRecreation_1 = __webpack_require__(62);

var resolveFromParentTypename_1 = __webpack_require__(78);

var defaultMergedResolver_1 = __webpack_require__(79);

var errors_1 = __webpack_require__(81);

var observableToAsyncIterable_1 = __webpack_require__(192);

function makeRemoteExecutableSchema(_a) {
  var _b;

  var schema = _a.schema,
      link = _a.link,
      fetcher = _a.fetcher,
      _c = _a.createResolver,
      customCreateResolver = _c === void 0 ? createResolver : _c,
      buildSchemaOptions = _a.buildSchemaOptions,
      _d = _a.printSchemaOptions,
      printSchemaOptions = _d === void 0 ? {
    commentDescriptions: true
  } : _d;

  if (!fetcher && link) {
    fetcher = linkToFetcher_1.default(link);
  }

  var typeDefs;

  if (typeof schema === 'string') {
    typeDefs = schema;
    schema = graphql_1.buildSchema(typeDefs, buildSchemaOptions);
  } else {
    typeDefs = graphql_1.printSchema(schema, printSchemaOptions);
  } // prepare query resolvers


  var queryResolvers = {};
  var queryType = schema.getQueryType();
  var queries = queryType.getFields();
  Object.keys(queries).forEach(function (key) {
    queryResolvers[key] = customCreateResolver(fetcher);
  }); // prepare mutation resolvers

  var mutationResolvers = {};
  var mutationType = schema.getMutationType();

  if (mutationType) {
    var mutations = mutationType.getFields();
    Object.keys(mutations).forEach(function (key) {
      mutationResolvers[key] = customCreateResolver(fetcher);
    });
  } // prepare subscription resolvers


  var subscriptionResolvers = {};
  var subscriptionType = schema.getSubscriptionType();

  if (subscriptionType) {
    var subscriptions = subscriptionType.getFields();
    Object.keys(subscriptions).forEach(function (key) {
      subscriptionResolvers[key] = {
        subscribe: createSubscriptionResolver(key, link)
      };
    });
  } // merge resolvers into resolver map


  var resolvers = (_b = {}, _b[queryType.name] = queryResolvers, _b);

  if (!isEmptyObject_1.default(mutationResolvers)) {
    resolvers[mutationType.name] = mutationResolvers;
  }

  if (!isEmptyObject_1.default(subscriptionResolvers)) {
    resolvers[subscriptionType.name] = subscriptionResolvers;
  } // add missing abstract resolvers (scalar, unions, interfaces)


  var typeMap = schema.getTypeMap();
  var types = Object.keys(typeMap).map(function (name) {
    return typeMap[name];
  });

  var _loop_1 = function _loop_1(type) {
    if (type instanceof graphql_1.GraphQLInterfaceType || type instanceof graphql_1.GraphQLUnionType) {
      resolvers[type.name] = {
        __resolveType: function __resolveType(parent, context, info) {
          return resolveFromParentTypename_1.default(parent, info.schema);
        }
      };
    } else if (type instanceof graphql_1.GraphQLScalarType) {
      if (!(type === graphql_1.GraphQLID || type === graphql_1.GraphQLString || type === graphql_1.GraphQLFloat || type === graphql_1.GraphQLBoolean || type === graphql_1.GraphQLInt)) {
        resolvers[type.name] = schemaRecreation_1.recreateType(type, function (name) {
          return null;
        }, false);
      }
    } else if (type instanceof graphql_1.GraphQLObjectType && type.name.slice(0, 2) !== '__' && type !== queryType && type !== mutationType && type !== subscriptionType) {
      var resolver_1 = {};
      Object.keys(type.getFields()).forEach(function (field) {
        resolver_1[field] = defaultMergedResolver_1.default;
      });
      resolvers[type.name] = resolver_1;
    }
  };

  for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {
    var type = types_1[_i];

    _loop_1(type);
  }

  return makeExecutableSchema_1.makeExecutableSchema({
    typeDefs: typeDefs,
    resolvers: resolvers
  });
}

exports.default = makeRemoteExecutableSchema;

function createResolver(fetcher) {
  var _this = this;

  return function (root, args, context, info) {
    return __awaiter(_this, void 0, void 0, function () {
      var fragments, document, result;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            fragments = Object.keys(info.fragments).map(function (fragment) {
              return info.fragments[fragment];
            });
            document = {
              kind: graphql_1.Kind.DOCUMENT,
              definitions: __spreadArrays([info.operation], fragments)
            };
            return [4
            /*yield*/
            , fetcher({
              query: document,
              variables: info.variableValues,
              context: {
                graphqlContext: context
              }
            })];

          case 1:
            result = _a.sent();
            return [2
            /*return*/
            , errors_1.checkResultAndHandleErrors(result, info)];
        }
      });
    });
  };
}

exports.createResolver = createResolver;

function createSubscriptionResolver(name, link) {
  return function (root, args, context, info) {
    var fragments = Object.keys(info.fragments).map(function (fragment) {
      return info.fragments[fragment];
    });
    var document = {
      kind: graphql_1.Kind.DOCUMENT,
      definitions: __spreadArrays([info.operation], fragments)
    };
    var operation = {
      query: document,
      variables: info.variableValues,
      context: {
        graphqlContext: context
      }
    };
    var observable = linkToFetcher_1.execute(link, operation);
    return observableToAsyncIterable_1.observableToAsyncIterable(observable);
  };
}

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Observable = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
} // === Symbol Support ===


var hasSymbols = function hasSymbols() {
  return typeof Symbol === 'function';
};

var hasSymbol = function hasSymbol(name) {
  return hasSymbols() && Boolean(Symbol[name]);
};

var getSymbol = function getSymbol(name) {
  return hasSymbol(name) ? Symbol[name] : '@@' + name;
};

if (hasSymbols() && !hasSymbol('observable')) {
  Symbol.observable = Symbol('observable');
}

var SymbolIterator = getSymbol('iterator');
var SymbolObservable = getSymbol('observable');
var SymbolSpecies = getSymbol('species'); // === Abstract Operations ===

function getMethod(obj, key) {
  var value = obj[key];
  if (value == null) return undefined;
  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');
  return value;
}

function getSpecies(obj) {
  var ctor = obj.constructor;

  if (ctor !== undefined) {
    ctor = ctor[SymbolSpecies];

    if (ctor === null) {
      ctor = undefined;
    }
  }

  return ctor !== undefined ? ctor : Observable;
}

function isObservable(x) {
  return x instanceof Observable; // SPEC: Brand check
}

function hostReportError(e) {
  if (hostReportError.log) {
    hostReportError.log(e);
  } else {
    setTimeout(function () {
      throw e;
    });
  }
}

function enqueue(fn) {
  Promise.resolve().then(function () {
    try {
      fn();
    } catch (e) {
      hostReportError(e);
    }
  });
}

function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === undefined) return;
  subscription._cleanup = undefined;

  if (!cleanup) {
    return;
  }

  try {
    if (typeof cleanup === 'function') {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, 'unsubscribe');

      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError(e);
  }
}

function closeSubscription(subscription) {
  subscription._observer = undefined;
  subscription._queue = undefined;
  subscription._state = 'closed';
}

function flushSubscription(subscription) {
  var queue = subscription._queue;

  if (!queue) {
    return;
  }

  subscription._queue = undefined;
  subscription._state = 'ready';

  for (var i = 0; i < queue.length; ++i) {
    notifySubscription(subscription, queue[i].type, queue[i].value);
    if (subscription._state === 'closed') break;
  }
}

function notifySubscription(subscription, type, value) {
  subscription._state = 'running';
  var observer = subscription._observer;

  try {
    var m = getMethod(observer, type);

    switch (type) {
      case 'next':
        if (m) m.call(observer, value);
        break;

      case 'error':
        closeSubscription(subscription);
        if (m) m.call(observer, value);else throw value;
        break;

      case 'complete':
        closeSubscription(subscription);
        if (m) m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError(e);
  }

  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';
}

function onNotify(subscription, type, value) {
  if (subscription._state === 'closed') return;

  if (subscription._state === 'buffering') {
    subscription._queue.push({
      type: type,
      value: value
    });

    return;
  }

  if (subscription._state !== 'ready') {
    subscription._state = 'buffering';
    subscription._queue = [{
      type: type,
      value: value
    }];
    enqueue(function () {
      return flushSubscription(subscription);
    });
    return;
  }

  notifySubscription(subscription, type, value);
}

var Subscription =
/*#__PURE__*/
function () {
  function Subscription(observer, subscriber) {
    _classCallCheck(this, Subscription); // ASSERT: observer is an object
    // ASSERT: subscriber is callable


    this._cleanup = undefined;
    this._observer = observer;
    this._queue = undefined;
    this._state = 'initializing';
    var subscriptionObserver = new SubscriptionObserver(this);

    try {
      this._cleanup = subscriber.call(undefined, subscriptionObserver);
    } catch (e) {
      subscriptionObserver.error(e);
    }

    if (this._state === 'initializing') this._state = 'ready';
  }

  _createClass(Subscription, [{
    key: "unsubscribe",
    value: function unsubscribe() {
      if (this._state !== 'closed') {
        closeSubscription(this);
        cleanupSubscription(this);
      }
    }
  }, {
    key: "closed",
    get: function get() {
      return this._state === 'closed';
    }
  }]);

  return Subscription;
}();

var SubscriptionObserver =
/*#__PURE__*/
function () {
  function SubscriptionObserver(subscription) {
    _classCallCheck(this, SubscriptionObserver);

    this._subscription = subscription;
  }

  _createClass(SubscriptionObserver, [{
    key: "next",
    value: function next(value) {
      onNotify(this._subscription, 'next', value);
    }
  }, {
    key: "error",
    value: function error(value) {
      onNotify(this._subscription, 'error', value);
    }
  }, {
    key: "complete",
    value: function complete() {
      onNotify(this._subscription, 'complete');
    }
  }, {
    key: "closed",
    get: function get() {
      return this._subscription._state === 'closed';
    }
  }]);

  return SubscriptionObserver;
}();

var Observable =
/*#__PURE__*/
function () {
  function Observable(subscriber) {
    _classCallCheck(this, Observable);

    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');
    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');
    this._subscriber = subscriber;
  }

  _createClass(Observable, [{
    key: "subscribe",
    value: function subscribe(observer) {
      if (typeof observer !== 'object' || observer === null) {
        observer = {
          next: observer,
          error: arguments[1],
          complete: arguments[2]
        };
      }

      return new Subscription(observer, this._subscriber);
    }
  }, {
    key: "forEach",
    value: function forEach(fn) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (typeof fn !== 'function') {
          reject(new TypeError(fn + ' is not a function'));
          return;
        }

        function done() {
          subscription.unsubscribe();
          resolve();
        }

        var subscription = _this.subscribe({
          next: function next(value) {
            try {
              fn(value, done);
            } catch (e) {
              reject(e);
              subscription.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
      });
    }
  }, {
    key: "map",
    value: function map(fn) {
      var _this2 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
      var C = getSpecies(this);
      return new C(function (observer) {
        return _this2.subscribe({
          next: function next(value) {
            try {
              value = fn(value);
            } catch (e) {
              return observer.error(e);
            }

            observer.next(value);
          },
          error: function error(e) {
            observer.error(e);
          },
          complete: function complete() {
            observer.complete();
          }
        });
      });
    }
  }, {
    key: "filter",
    value: function filter(fn) {
      var _this3 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
      var C = getSpecies(this);
      return new C(function (observer) {
        return _this3.subscribe({
          next: function next(value) {
            try {
              if (!fn(value)) return;
            } catch (e) {
              return observer.error(e);
            }

            observer.next(value);
          },
          error: function error(e) {
            observer.error(e);
          },
          complete: function complete() {
            observer.complete();
          }
        });
      });
    }
  }, {
    key: "reduce",
    value: function reduce(fn) {
      var _this4 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
      var C = getSpecies(this);
      var hasSeed = arguments.length > 1;
      var hasValue = false;
      var seed = arguments[1];
      var acc = seed;
      return new C(function (observer) {
        return _this4.subscribe({
          next: function next(value) {
            var first = !hasValue;
            hasValue = true;

            if (!first || hasSeed) {
              try {
                acc = fn(acc, value);
              } catch (e) {
                return observer.error(e);
              }
            } else {
              acc = value;
            }
          },
          error: function error(e) {
            observer.error(e);
          },
          complete: function complete() {
            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));
            observer.next(acc);
            observer.complete();
          }
        });
      });
    }
  }, {
    key: "concat",
    value: function concat() {
      var _this5 = this;

      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }

      var C = getSpecies(this);
      return new C(function (observer) {
        var subscription;
        var index = 0;

        function startNext(next) {
          subscription = next.subscribe({
            next: function next(v) {
              observer.next(v);
            },
            error: function error(e) {
              observer.error(e);
            },
            complete: function complete() {
              if (index === sources.length) {
                subscription = undefined;
                observer.complete();
              } else {
                startNext(C.from(sources[index++]));
              }
            }
          });
        }

        startNext(_this5);
        return function () {
          if (subscription) {
            subscription.unsubscribe();
            subscription = undefined;
          }
        };
      });
    }
  }, {
    key: "flatMap",
    value: function flatMap(fn) {
      var _this6 = this;

      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');
      var C = getSpecies(this);
      return new C(function (observer) {
        var subscriptions = [];

        var outer = _this6.subscribe({
          next: function next(value) {
            if (fn) {
              try {
                value = fn(value);
              } catch (e) {
                return observer.error(e);
              }
            }

            var inner = C.from(value).subscribe({
              next: function next(value) {
                observer.next(value);
              },
              error: function error(e) {
                observer.error(e);
              },
              complete: function complete() {
                var i = subscriptions.indexOf(inner);
                if (i >= 0) subscriptions.splice(i, 1);
                completeIfDone();
              }
            });
            subscriptions.push(inner);
          },
          error: function error(e) {
            observer.error(e);
          },
          complete: function complete() {
            completeIfDone();
          }
        });

        function completeIfDone() {
          if (outer.closed && subscriptions.length === 0) observer.complete();
        }

        return function () {
          subscriptions.forEach(function (s) {
            return s.unsubscribe();
          });
          outer.unsubscribe();
        };
      });
    }
  }, {
    key: SymbolObservable,
    value: function value() {
      return this;
    }
  }], [{
    key: "from",
    value: function from(x) {
      var C = typeof this === 'function' ? this : Observable;
      if (x == null) throw new TypeError(x + ' is not an object');
      var method = getMethod(x, SymbolObservable);

      if (method) {
        var observable = method.call(x);
        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');
        if (isObservable(observable) && observable.constructor === C) return observable;
        return new C(function (observer) {
          return observable.subscribe(observer);
        });
      }

      if (hasSymbol('iterator')) {
        method = getMethod(x, SymbolIterator);

        if (method) {
          return new C(function (observer) {
            enqueue(function () {
              if (observer.closed) return;
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var _item = _step.value;
                  observer.next(_item);
                  if (observer.closed) return;
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return != null) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              observer.complete();
            });
          });
        }
      }

      if (Array.isArray(x)) {
        return new C(function (observer) {
          enqueue(function () {
            if (observer.closed) return;

            for (var i = 0; i < x.length; ++i) {
              observer.next(x[i]);
              if (observer.closed) return;
            }

            observer.complete();
          });
        });
      }

      throw new TypeError(x + ' is not observable');
    }
  }, {
    key: "of",
    value: function of() {
      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }

      var C = typeof this === 'function' ? this : Observable;
      return new C(function (observer) {
        enqueue(function () {
          if (observer.closed) return;

          for (var i = 0; i < items.length; ++i) {
            observer.next(items[i]);
            if (observer.closed) return;
          }

          observer.complete();
        });
      });
    }
  }, {
    key: SymbolSpecies,
    get: function get() {
      return this;
    }
  }]);

  return Observable;
}();

exports.Observable = Observable;

if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol('extensions'), {
    value: {
      symbol: SymbolObservable,
      hostReportError: hostReportError
    },
    configurable: true
  });
}

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var iterall_1 = __webpack_require__(24);

function observableToAsyncIterable(observable) {
  var _a;

  var pullQueue = [];
  var pushQueue = [];
  var listening = true;

  var pushValue = function pushValue(_a) {
    var data = _a.data;

    if (pullQueue.length !== 0) {
      pullQueue.shift()({
        value: data,
        done: false
      });
    } else {
      pushQueue.push({
        value: data
      });
    }
  };

  var pushError = function pushError(error) {
    if (pullQueue.length !== 0) {
      pullQueue.shift()({
        value: {
          errors: [error]
        },
        done: false
      });
    } else {
      pushQueue.push({
        value: {
          errors: [error]
        }
      });
    }
  };

  var pullValue = function pullValue() {
    return new Promise(function (resolve) {
      if (pushQueue.length !== 0) {
        var element = pushQueue.shift(); // either {value: {errors: [...]}} or {value: ...}

        resolve(__assign(__assign({}, element), {
          done: false
        }));
      } else {
        pullQueue.push(resolve);
      }
    });
  };

  var subscription = observable.subscribe({
    next: function next(value) {
      pushValue(value);
    },
    error: function error(err) {
      pushError(err);
    }
  });

  var emptyQueue = function emptyQueue() {
    if (listening) {
      listening = false;
      subscription.unsubscribe();
      pullQueue.forEach(function (resolve) {
        return resolve({
          value: undefined,
          done: true
        });
      });
      pullQueue.length = 0;
      pushQueue.length = 0;
    }
  };

  return _a = {
    next: function next() {
      return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
          return [2
          /*return*/
          , listening ? pullValue() : this.return()];
        });
      });
    },
    return: function _return() {
      emptyQueue();
      return Promise.resolve({
        value: undefined,
        done: true
      });
    },
    throw: function _throw(error) {
      emptyQueue();
      return Promise.reject(error);
    }
  }, _a[iterall_1.$$asyncIterator] = function () {
    return this;
  }, _a;
}

exports.observableToAsyncIterable = observableToAsyncIterable;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = this && this.__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var utilities_1 = __webpack_require__(116);

var linkToFetcher_1 = __webpack_require__(113);

var parsedIntrospectionQuery = graphql_1.parse(utilities_1.getIntrospectionQuery());

function introspectSchema(fetcher, linkContext) {
  return __awaiter(this, void 0, void 0, function () {
    var introspectionResult, schema;
    return __generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          // Convert link to fetcher
          if (fetcher.request) {
            fetcher = linkToFetcher_1.default(fetcher);
          }

          return [4
          /*yield*/
          , fetcher({
            query: parsedIntrospectionQuery,
            context: linkContext
          })];

        case 1:
          introspectionResult = _a.sent();

          if (introspectionResult.errors && introspectionResult.errors.length || !introspectionResult.data.__schema) {
            throw introspectionResult.errors;
          } else {
            schema = graphql_1.buildClientSchema(introspectionResult.data);
            return [2
            /*return*/
            , schema];
          }

          return [2
          /*return*/
          ];
      }
    });
  });
}

exports.default = introspectSchema;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var makeExecutableSchema_1 = __webpack_require__(59);

var schemaRecreation_1 = __webpack_require__(62);

var delegateToSchema_1 = __webpack_require__(82);

var typeFromAST_1 = __webpack_require__(197);

var transforms_1 = __webpack_require__(124);

var mergeDeep_1 = __webpack_require__(108);

var schemaVisitor_1 = __webpack_require__(70);

function mergeSchemas(_a) {
  var schemas = _a.schemas,
      onTypeConflict = _a.onTypeConflict,
      resolvers = _a.resolvers,
      schemaDirectives = _a.schemaDirectives,
      inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces,
      mergeDirectives = _a.mergeDirectives;
  return mergeSchemasImplementation({
    schemas: schemas,
    resolvers: resolvers,
    schemaDirectives: schemaDirectives,
    inheritResolversFromInterfaces: inheritResolversFromInterfaces,
    mergeDirectives: mergeDirectives
  });
}

exports.default = mergeSchemas;

function mergeSchemasImplementation(_a) {
  var schemas = _a.schemas,
      resolvers = _a.resolvers,
      schemaDirectives = _a.schemaDirectives,
      inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces,
      mergeDirectives = _a.mergeDirectives;
  var allSchemas = [];
  var typeCandidates = {};
  var types = {};
  var extensions = [];
  var directives = [];
  var fragments = [];
  var resolveType = schemaRecreation_1.createResolveType(function (name) {
    if (types[name] === undefined) {
      throw new Error("Can't find type " + name + ".");
    }

    return types[name];
  });
  schemas.forEach(function (schema) {
    if (schema instanceof graphql_1.GraphQLSchema) {
      allSchemas.push(schema);
      var queryType_1 = schema.getQueryType();
      var mutationType_1 = schema.getMutationType();
      var subscriptionType_1 = schema.getSubscriptionType();

      if (queryType_1) {
        addTypeCandidate(typeCandidates, 'Query', {
          schema: schema,
          type: queryType_1
        });
      }

      if (mutationType_1) {
        addTypeCandidate(typeCandidates, 'Mutation', {
          schema: schema,
          type: mutationType_1
        });
      }

      if (subscriptionType_1) {
        addTypeCandidate(typeCandidates, 'Subscription', {
          schema: schema,
          type: subscriptionType_1
        });
      }

      if (mergeDirectives) {
        var directiveInstances = schema.getDirectives();
        directiveInstances.forEach(function (directive) {
          directives.push(directive);
        });
      }

      var typeMap_1 = schema.getTypeMap();
      Object.keys(typeMap_1).forEach(function (typeName) {
        var type = typeMap_1[typeName];

        if (graphql_1.isNamedType(type) && graphql_1.getNamedType(type).name.slice(0, 2) !== '__' && type !== queryType_1 && type !== mutationType_1 && type !== subscriptionType_1) {
          addTypeCandidate(typeCandidates, type.name, {
            schema: schema,
            type: type
          });
        }
      });
    } else if (typeof schema === 'string' || schema && schema.kind === graphql_1.Kind.DOCUMENT) {
      var parsedSchemaDocument = typeof schema === 'string' ? graphql_1.parse(schema) : schema;
      parsedSchemaDocument.definitions.forEach(function (def) {
        var type = typeFromAST_1.default(def);

        if (type instanceof graphql_1.GraphQLDirective && mergeDirectives) {
          directives.push(type);
        } else if (type && !(type instanceof graphql_1.GraphQLDirective)) {
          addTypeCandidate(typeCandidates, type.name, {
            type: type
          });
        }
      });
      var extensionsDocument = makeExecutableSchema_1.extractExtensionDefinitions(parsedSchemaDocument);

      if (extensionsDocument.definitions.length > 0) {
        extensions.push(extensionsDocument);
      }
    } else if (Array.isArray(schema)) {
      schema.forEach(function (type) {
        addTypeCandidate(typeCandidates, type.name, {
          type: type
        });
      });
    } else {
      throw new Error("Invalid schema passed");
    }
  });
  var mergeInfo = createMergeInfo(allSchemas, fragments);

  if (!resolvers) {
    resolvers = {};
  } else if (typeof resolvers === 'function') {
    console.warn('Passing functions as resolver parameter is deprecated. Use `info.mergeInfo` instead.');
    resolvers = resolvers(mergeInfo);
  } else if (Array.isArray(resolvers)) {
    resolvers = resolvers.reduce(function (left, right) {
      if (typeof right === 'function') {
        console.warn('Passing functions as resolver parameter is deprecated. Use `info.mergeInfo` instead.');
        right = right(mergeInfo);
      }

      return mergeDeep_1.default(left, right);
    }, {});
  }

  var generatedResolvers = {};
  Object.keys(typeCandidates).forEach(function (typeName) {
    var resultType = defaultVisitType(typeName, typeCandidates[typeName]);

    if (resultType === null) {
      types[typeName] = null;
    } else {
      var type = void 0;
      var typeResolvers = void 0;

      if (graphql_1.isNamedType(resultType)) {
        type = resultType;
      } else if (resultType.type) {
        type = resultType.type;
        typeResolvers = resultType.resolvers;
      } else {
        throw new Error("Invalid visitType result for type " + typeName);
      }

      types[typeName] = schemaRecreation_1.recreateType(type, resolveType, false);

      if (typeResolvers) {
        generatedResolvers[typeName] = typeResolvers;
      }
    }
  });
  var mergedSchema = new graphql_1.GraphQLSchema({
    query: types.Query,
    mutation: types.Mutation,
    subscription: types.Subscription,
    types: Object.keys(types).map(function (key) {
      return types[key];
    }),
    directives: directives.map(function (directive) {
      return schemaRecreation_1.recreateDirective(directive, resolveType);
    })
  });
  extensions.forEach(function (extension) {
    mergedSchema = graphql_1.extendSchema(mergedSchema, extension, {
      commentDescriptions: true
    });
  });

  if (!resolvers) {
    resolvers = {};
  } else if (Array.isArray(resolvers)) {
    resolvers = resolvers.reduce(mergeDeep_1.default, {});
  }

  Object.keys(resolvers).forEach(function (typeName) {
    var type = resolvers[typeName];

    if (type instanceof graphql_1.GraphQLScalarType) {
      return;
    }

    Object.keys(type).forEach(function (fieldName) {
      var field = type[fieldName];

      if (field.fragment) {
        fragments.push({
          field: fieldName,
          fragment: field.fragment
        });
      }
    });
  });
  mergedSchema = makeExecutableSchema_1.addResolveFunctionsToSchema({
    schema: mergedSchema,
    resolvers: mergeDeep_1.default(generatedResolvers, resolvers),
    inheritResolversFromInterfaces: inheritResolversFromInterfaces
  });
  forEachField(mergedSchema, function (field) {
    if (field.resolve) {
      var fieldResolver_1 = field.resolve;

      field.resolve = function (parent, args, context, info) {
        var newInfo = __assign(__assign({}, info), {
          mergeInfo: mergeInfo
        });

        return fieldResolver_1(parent, args, context, newInfo);
      };
    }

    if (field.subscribe) {
      var fieldResolver_2 = field.subscribe;

      field.subscribe = function (parent, args, context, info) {
        var newInfo = __assign(__assign({}, info), {
          mergeInfo: mergeInfo
        });

        return fieldResolver_2(parent, args, context, newInfo);
      };
    }
  });

  if (schemaDirectives) {
    schemaVisitor_1.SchemaDirectiveVisitor.visitSchemaDirectives(mergedSchema, schemaDirectives);
  }

  return mergedSchema;
}

function createMergeInfo(allSchemas, fragments) {
  return {
    delegate: function delegate(operation, fieldName, args, context, info, transforms) {
      console.warn('`mergeInfo.delegate` is deprecated. ' + 'Use `mergeInfo.delegateToSchema and pass explicit schema instances.');
      var schema = guessSchemaByRootField(allSchemas, operation, fieldName);
      var expandTransforms = new transforms_1.ExpandAbstractTypes(info.schema, schema);
      var fragmentTransform = new transforms_1.ReplaceFieldWithFragment(schema, fragments);
      return delegateToSchema_1.default({
        schema: schema,
        operation: operation,
        fieldName: fieldName,
        args: args,
        context: context,
        info: info,
        transforms: __spreadArrays(transforms || [], [expandTransforms, fragmentTransform])
      });
    },
    delegateToSchema: function delegateToSchema(options) {
      return delegateToSchema_1.default(__assign(__assign({}, options), {
        transforms: options.transforms
      }));
    },
    fragments: fragments
  };
}

function guessSchemaByRootField(schemas, operation, fieldName) {
  for (var _i = 0, schemas_1 = schemas; _i < schemas_1.length; _i++) {
    var schema = schemas_1[_i];
    var rootObject = void 0;

    if (operation === 'subscription') {
      rootObject = schema.getSubscriptionType();
    } else if (operation === 'mutation') {
      rootObject = schema.getMutationType();
    } else {
      rootObject = schema.getQueryType();
    }

    if (rootObject) {
      var fields = rootObject.getFields();

      if (fields[fieldName]) {
        return schema;
      }
    }
  }

  throw new Error("Could not find subschema with field `" + operation + "." + fieldName + "`");
}

function createDelegatingResolver(schema, operation, fieldName) {
  return function (root, args, context, info) {
    return info.mergeInfo.delegateToSchema({
      schema: schema,
      operation: operation,
      fieldName: fieldName,
      args: args,
      context: context,
      info: info
    });
  };
}

function forEachField(schema, fn) {
  var typeMap = schema.getTypeMap();
  Object.keys(typeMap).forEach(function (typeName) {
    var type = typeMap[typeName];

    if (!graphql_1.getNamedType(type).name.startsWith('__') && type instanceof graphql_1.GraphQLObjectType) {
      var fields_1 = type.getFields();
      Object.keys(fields_1).forEach(function (fieldName) {
        var field = fields_1[fieldName];
        fn(field, typeName, fieldName);
      });
    }
  });
}

function addTypeCandidate(typeCandidates, name, typeCandidate) {
  if (!typeCandidates[name]) {
    typeCandidates[name] = [];
  }

  typeCandidates[name].push(typeCandidate);
}

function defaultVisitType(name, candidates, candidateSelector) {
  if (!candidateSelector) {
    candidateSelector = function candidateSelector(cands) {
      return cands[cands.length - 1];
    };
  }

  var resolveType = schemaRecreation_1.createResolveType(function (_, type) {
    return type;
  });

  if (name === 'Query' || name === 'Mutation' || name === 'Subscription') {
    var fields_2 = {};
    var operationName_1;

    switch (name) {
      case 'Query':
        operationName_1 = 'query';
        break;

      case 'Mutation':
        operationName_1 = 'mutation';
        break;

      case 'Subscription':
        operationName_1 = 'subscription';
        break;

      default:
        break;
    }

    var resolvers_1 = {};
    var resolverKey_1 = operationName_1 === 'subscription' ? 'subscribe' : 'resolve';
    candidates.forEach(function (_a) {
      var candidateType = _a.type,
          schema = _a.schema;
      var candidateFields = candidateType.getFields();
      fields_2 = __assign(__assign({}, fields_2), candidateFields);
      Object.keys(candidateFields).forEach(function (fieldName) {
        var _a;

        resolvers_1[fieldName] = (_a = {}, _a[resolverKey_1] = createDelegatingResolver(schema, operationName_1, fieldName), _a);
      });
    });
    var type = new graphql_1.GraphQLObjectType({
      name: name,
      fields: schemaRecreation_1.fieldMapToFieldConfigMap(fields_2, resolveType, false)
    });
    return {
      type: type,
      resolvers: resolvers_1
    };
  } else {
    var candidate = candidateSelector(candidates);
    return candidate.type;
  }
}

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var iterall_1 = __webpack_require__(24);
/**
 * Given an AsyncIterable and a callback function, return an AsyncIterator
 * which produces values mapped via calling the callback function.
 */


function mapAsyncIterator(iterator, callback, rejectCallback) {
  var _a;

  var $return;
  var abruptClose;

  if (typeof iterator.return === 'function') {
    $return = iterator.return;

    abruptClose = function abruptClose(error) {
      var rethrow = function rethrow() {
        return Promise.reject(error);
      };

      return $return.call(iterator).then(rethrow, rethrow);
    };
  }

  function mapResult(result) {
    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
  }

  var mapReject;

  if (rejectCallback) {
    // Capture rejectCallback to ensure it cannot be null.
    var reject_1 = rejectCallback;

    mapReject = function mapReject(error) {
      return asyncMapValue(error, reject_1).then(iteratorResult, abruptClose);
    };
  }

  return _a = {
    next: function next() {
      return iterator.next().then(mapResult, mapReject);
    },
    return: function _return() {
      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({
        value: undefined,
        done: true
      });
    },
    throw: function _throw(error) {
      if (typeof iterator.throw === 'function') {
        return iterator.throw(error).then(mapResult, mapReject);
      }

      return Promise.reject(error).catch(abruptClose);
    }
  }, _a[iterall_1.$$asyncIterator] = function () {
    return this;
  }, _a;
}

exports.default = mapAsyncIterator;

function asyncMapValue(value, callback) {
  return new Promise(function (resolve) {
    return resolve(callback(value));
  });
}

function iteratorResult(value) {
  return {
    value: value,
    done: false
  };
}

/***/ }),
/* 196 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var ConvertEnumResponse =
/** @class */
function () {
  function ConvertEnumResponse(enumNode) {
    this.enumNode = enumNode;
  }

  ConvertEnumResponse.prototype.transformResult = function (result) {
    var value = this.enumNode.getValue(result);

    if (value) {
      return value.value;
    }

    return result;
  };

  return ConvertEnumResponse;
}();

exports.default = ConvertEnumResponse;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var resolveFromParentTypename_1 = __webpack_require__(78);

var backcompatOptions = {
  commentDescriptions: true
};

function typeFromAST(node) {
  switch (node.kind) {
    case graphql_1.Kind.OBJECT_TYPE_DEFINITION:
      return makeObjectType(node);

    case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:
      return makeInterfaceType(node);

    case graphql_1.Kind.ENUM_TYPE_DEFINITION:
      return makeEnumType(node);

    case graphql_1.Kind.UNION_TYPE_DEFINITION:
      return makeUnionType(node);

    case graphql_1.Kind.SCALAR_TYPE_DEFINITION:
      return makeScalarType(node);

    case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:
      return makeInputObjectType(node);

    case graphql_1.Kind.DIRECTIVE_DEFINITION:
      return makeDirective(node);

    default:
      return null;
  }
}

exports.default = typeFromAST;

function makeObjectType(node) {
  return new graphql_1.GraphQLObjectType({
    name: node.name.value,
    fields: function fields() {
      return makeFields(node.fields);
    },
    interfaces: function interfaces() {
      return node.interfaces.map(function (iface) {
        return createNamedStub(iface.name.value, 'interface');
      });
    },
    description: graphql_1.getDescription(node, backcompatOptions)
  });
}

function makeInterfaceType(node) {
  return new graphql_1.GraphQLInterfaceType({
    name: node.name.value,
    fields: function fields() {
      return makeFields(node.fields);
    },
    description: graphql_1.getDescription(node, backcompatOptions),
    resolveType: function resolveType(parent, context, info) {
      return resolveFromParentTypename_1.default(parent, info.schema);
    }
  });
}

function makeEnumType(node) {
  var values = {};
  node.values.forEach(function (value) {
    values[value.name.value] = {
      description: graphql_1.getDescription(value, backcompatOptions)
    };
  });
  return new graphql_1.GraphQLEnumType({
    name: node.name.value,
    values: values,
    description: graphql_1.getDescription(node, backcompatOptions)
  });
}

function makeUnionType(node) {
  return new graphql_1.GraphQLUnionType({
    name: node.name.value,
    types: function types() {
      return node.types.map(function (type) {
        return resolveType(type, 'object');
      });
    },
    description: graphql_1.getDescription(node, backcompatOptions),
    resolveType: function resolveType(parent, context, info) {
      return resolveFromParentTypename_1.default(parent, info.schema);
    }
  });
}

function makeScalarType(node) {
  return new graphql_1.GraphQLScalarType({
    name: node.name.value,
    description: graphql_1.getDescription(node, backcompatOptions),
    serialize: function serialize() {
      return null;
    },
    // Note: validation calls the parse functions to determine if a
    // literal value is correct. Returning null would cause use of custom
    // scalars to always fail validation. Returning false causes them to
    // always pass validation.
    parseValue: function parseValue() {
      return false;
    },
    parseLiteral: function parseLiteral() {
      return false;
    }
  });
}

function makeInputObjectType(node) {
  return new graphql_1.GraphQLInputObjectType({
    name: node.name.value,
    fields: function fields() {
      return makeValues(node.fields);
    },
    description: graphql_1.getDescription(node, backcompatOptions)
  });
}

function makeFields(nodes) {
  var result = {};
  nodes.forEach(function (node) {
    var deprecatedDirective = node.directives.find(function (directive) {
      return directive && directive.name && directive.name.value === 'deprecated';
    });
    var deprecatedArgument = deprecatedDirective && deprecatedDirective.arguments && deprecatedDirective.arguments.find(function (arg) {
      return arg && arg.name && arg.name.value === 'reason';
    });
    var deprecationReason = deprecatedArgument && deprecatedArgument.value && deprecatedArgument.value.value;
    result[node.name.value] = {
      type: resolveType(node.type, 'object'),
      args: makeValues(node.arguments),
      description: graphql_1.getDescription(node, backcompatOptions),
      deprecationReason: deprecationReason
    };
  });
  return result;
}

function makeValues(nodes) {
  var result = {};
  nodes.forEach(function (node) {
    var type = resolveType(node.type, 'input');
    result[node.name.value] = {
      type: type,
      defaultValue: graphql_1.valueFromAST(node.defaultValue, type),
      description: graphql_1.getDescription(node, backcompatOptions)
    };
  });
  return result;
}

function resolveType(node, type) {
  switch (node.kind) {
    case graphql_1.Kind.LIST_TYPE:
      return new graphql_1.GraphQLList(resolveType(node.type, type));

    case graphql_1.Kind.NON_NULL_TYPE:
      return new graphql_1.GraphQLNonNull(resolveType(node.type, type));

    default:
      return createNamedStub(node.name.value, type);
  }
}

function createNamedStub(name, type) {
  var constructor;

  if (type === 'object') {
    constructor = graphql_1.GraphQLObjectType;
  } else if (type === 'interface') {
    constructor = graphql_1.GraphQLInterfaceType;
  } else {
    constructor = graphql_1.GraphQLInputObjectType;
  }

  return new constructor({
    name: name,
    fields: {
      __fake: {
        type: graphql_1.GraphQLString
      }
    }
  });
}

function makeDirective(node) {
  var locations = [];
  node.locations.forEach(function (location) {
    if (location.value in graphql_1.DirectiveLocation) {
      locations.push(location.value);
    }
  });
  return new graphql_1.GraphQLDirective({
    name: node.name.value,
    description: node.description ? node.description.value : null,
    args: makeValues(node.arguments),
    locations: locations
  });
}

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var makeExecutableSchema_1 = __webpack_require__(59);

var visitSchema_1 = __webpack_require__(61);

var transforms_1 = __webpack_require__(77);

var resolvers_1 = __webpack_require__(199);

function transformSchema(targetSchema, transforms) {
  var schema = visitSchema_1.visitSchema(targetSchema, {}, true);
  var mapping = resolvers_1.generateSimpleMapping(targetSchema);
  var resolvers = resolvers_1.generateProxyingResolvers(targetSchema, transforms, mapping);
  schema = makeExecutableSchema_1.addResolveFunctionsToSchema({
    schema: schema,
    resolvers: resolvers,
    resolverValidationOptions: {
      allowResolversNotInSchema: true
    }
  });
  schema = transforms_1.applySchemaTransforms(schema, transforms);
  schema.transforms = transforms;
  return schema;
}

exports.default = transformSchema;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var delegateToSchema_1 = __webpack_require__(82);

function generateProxyingResolvers(targetSchema, transforms, mapping) {
  var result = {};
  Object.keys(mapping).forEach(function (name) {
    result[name] = {};
    var innerMapping = mapping[name];
    Object.keys(innerMapping).forEach(function (from) {
      var _a;

      var to = innerMapping[from];
      var resolverType = to.operation === 'subscription' ? 'subscribe' : 'resolve';
      result[name][from] = (_a = {}, _a[resolverType] = createProxyingResolver(targetSchema, to.operation, to.name, transforms), _a);
    });
  });
  return result;
}

exports.generateProxyingResolvers = generateProxyingResolvers;

function generateSimpleMapping(targetSchema) {
  var query = targetSchema.getQueryType();
  var mutation = targetSchema.getMutationType();
  var subscription = targetSchema.getSubscriptionType();
  var result = {};

  if (query) {
    result[query.name] = generateMappingFromObjectType(query, 'query');
  }

  if (mutation) {
    result[mutation.name] = generateMappingFromObjectType(mutation, 'mutation');
  }

  if (subscription) {
    result[subscription.name] = generateMappingFromObjectType(subscription, 'subscription');
  }

  return result;
}

exports.generateSimpleMapping = generateSimpleMapping;

function generateMappingFromObjectType(type, operation) {
  var result = {};
  var fields = type.getFields();
  Object.keys(fields).forEach(function (fieldName) {
    result[fieldName] = {
      name: fieldName,
      operation: operation
    };
  });
  return result;
}

exports.generateMappingFromObjectType = generateMappingFromObjectType;

function createProxyingResolver(schema, operation, fieldName, transforms) {
  return function (parent, args, context, info) {
    return delegateToSchema_1.default({
      schema: schema,
      operation: operation,
      fieldName: fieldName,
      args: {},
      context: context,
      info: info,
      transforms: transforms
    });
  };
}

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var isSpecifiedScalarType_1 = __webpack_require__(109);

var visitSchema_1 = __webpack_require__(61);

var RenameTypes =
/** @class */
function () {
  function RenameTypes(renamer, options) {
    this.renamer = renamer;
    this.reverseMap = {};

    var _a = options || {},
        _b = _a.renameBuiltins,
        renameBuiltins = _b === void 0 ? false : _b,
        _c = _a.renameScalars,
        renameScalars = _c === void 0 ? true : _c;

    this.renameBuiltins = renameBuiltins;
    this.renameScalars = renameScalars;
  }

  RenameTypes.prototype.transformSchema = function (originalSchema) {
    var _a;

    var _this = this;

    return visitSchema_1.visitSchema(originalSchema, (_a = {}, _a[visitSchema_1.VisitSchemaKind.TYPE] = function (type) {
      if (isSpecifiedScalarType_1.default(type) && !_this.renameBuiltins) {
        return undefined;
      }

      if (type instanceof graphql_1.GraphQLScalarType && !_this.renameScalars) {
        return undefined;
      }

      var newName = _this.renamer(type.name);

      if (newName && newName !== type.name) {
        _this.reverseMap[newName] = type.name;
        var newType = Object.assign(Object.create(type), type);
        newType.name = newName;
        return newType;
      }
    }, _a[visitSchema_1.VisitSchemaKind.ROOT_OBJECT] = function (type) {
      return undefined;
    }, _a));
  };

  RenameTypes.prototype.transformRequest = function (originalRequest) {
    var _a;

    var _this = this;

    var newDocument = graphql_1.visit(originalRequest.document, (_a = {}, _a[graphql_1.Kind.NAMED_TYPE] = function (node) {
      var name = node.name.value;

      if (name in _this.reverseMap) {
        return __assign(__assign({}, node), {
          name: {
            kind: graphql_1.Kind.NAME,
            value: _this.reverseMap[name]
          }
        });
      }
    }, _a));
    return {
      document: newDocument,
      variables: originalRequest.variables
    };
  };

  RenameTypes.prototype.transformResult = function (result) {
    if (result.data) {
      var data = this.renameTypes(result.data, 'data');

      if (data !== result.data) {
        return __assign(__assign({}, result), {
          data: data
        });
      }
    }

    return result;
  };

  RenameTypes.prototype.renameTypes = function (value, name) {
    var _this = this;

    if (name === '__typename') {
      return this.renamer(value);
    }

    if (value && typeof value === 'object') {
      var newValue_1 = Array.isArray(value) ? [] // Create a new object with the same prototype.
      : Object.create(Object.getPrototypeOf(value));
      var returnNewValue_1 = false;
      Object.keys(value).forEach(function (key) {
        var oldChild = value[key];

        var newChild = _this.renameTypes(oldChild, key);

        newValue_1[key] = newChild;

        if (newChild !== oldChild) {
          returnNewValue_1 = true;
        }
      });

      if (returnNewValue_1) {
        return newValue_1;
      }
    }

    return value;
  };

  return RenameTypes;
}();

exports.default = RenameTypes;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

/* tslint:disable:no-unused-expression */
Object.defineProperty(exports, "__esModule", {
  value: true
});

var visitSchema_1 = __webpack_require__(61);

var FilterTypes =
/** @class */
function () {
  function FilterTypes(filter) {
    this.filter = filter;
  }

  FilterTypes.prototype.transformSchema = function (schema) {
    var _a;

    var _this = this;

    return visitSchema_1.visitSchema(schema, (_a = {}, _a[visitSchema_1.VisitSchemaKind.TYPE] = function (type) {
      if (_this.filter(type)) {
        return undefined;
      } else {
        return null;
      }
    }, _a));
  };

  return FilterTypes;
}();

exports.default = FilterTypes;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var schemaRecreation_1 = __webpack_require__(62);

var TransformRootFields_1 = __webpack_require__(83);

var RenameRootFields =
/** @class */
function () {
  function RenameRootFields(renamer) {
    var resolveType = schemaRecreation_1.createResolveType(function (name, type) {
      return type;
    });
    this.transformer = new TransformRootFields_1.default(function (operation, fieldName, field) {
      return {
        name: renamer(operation, fieldName, field),
        field: schemaRecreation_1.fieldToFieldConfig(field, resolveType, true)
      };
    });
  }

  RenameRootFields.prototype.transformSchema = function (originalSchema) {
    return this.transformer.transformSchema(originalSchema);
  };

  return RenameRootFields;
}();

exports.default = RenameRootFields;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var TransformRootFields_1 = __webpack_require__(83);

var FilterRootFields =
/** @class */
function () {
  function FilterRootFields(filter) {
    this.transformer = new TransformRootFields_1.default(function (operation, fieldName, field) {
      if (filter(operation, fieldName, field)) {
        return undefined;
      } else {
        return null;
      }
    });
  }

  FilterRootFields.prototype.transformSchema = function (originalSchema) {
    return this.transformer.transformSchema(originalSchema);
  };

  return FilterRootFields;
}();

exports.default = FilterRootFields;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var ExtractField =
/** @class */
function () {
  function ExtractField(_a) {
    var from = _a.from,
        to = _a.to;
    this.from = from;
    this.to = to;
  }

  ExtractField.prototype.transformRequest = function (originalRequest) {
    var _a, _b;

    var fromSelection;
    var ourPathFrom = JSON.stringify(this.from);
    var ourPathTo = JSON.stringify(this.to);
    var fieldPath = [];
    graphql_1.visit(originalRequest.document, (_a = {}, _a[graphql_1.Kind.FIELD] = {
      enter: function enter(node) {
        fieldPath.push(node.name.value);

        if (ourPathFrom === JSON.stringify(fieldPath)) {
          fromSelection = node.selectionSet;
          return graphql_1.BREAK;
        }
      },
      leave: function leave(node) {
        fieldPath.pop();
      }
    }, _a));
    fieldPath = [];
    var newDocument = graphql_1.visit(originalRequest.document, (_b = {}, _b[graphql_1.Kind.FIELD] = {
      enter: function enter(node) {
        fieldPath.push(node.name.value);

        if (ourPathTo === JSON.stringify(fieldPath) && fromSelection) {
          return __assign(__assign({}, node), {
            selectionSet: fromSelection
          });
        }
      },
      leave: function leave(node) {
        fieldPath.pop();
      }
    }, _b));
    return __assign(__assign({}, originalRequest), {
      document: newDocument
    });
  };

  return ExtractField;
}();

exports.default = ExtractField;

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var __spreadArrays = this && this.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var graphql_1 = __webpack_require__(11);

var WrapQuery =
/** @class */
function () {
  function WrapQuery(path, wrapper, extractor) {
    this.path = path;
    this.wrapper = wrapper;
    this.extractor = extractor;
  }

  WrapQuery.prototype.transformRequest = function (originalRequest) {
    var _a;

    var _this = this;

    var document = originalRequest.document;
    var fieldPath = [];
    var ourPath = JSON.stringify(this.path);
    var newDocument = graphql_1.visit(document, (_a = {}, _a[graphql_1.Kind.FIELD] = {
      enter: function enter(node) {
        fieldPath.push(node.name.value);

        if (ourPath === JSON.stringify(fieldPath)) {
          var wrapResult = _this.wrapper(node.selectionSet); // Selection can be either a single selection or a selection set. If it's just one selection,
          // let's wrap it in a selection set. Otherwise, keep it as is.


          var selectionSet = wrapResult.kind === graphql_1.Kind.SELECTION_SET ? wrapResult : {
            kind: graphql_1.Kind.SELECTION_SET,
            selections: [wrapResult]
          };
          return __assign(__assign({}, node), {
            selectionSet: selectionSet
          });
        }
      },
      leave: function leave(node) {
        fieldPath.pop();
      }
    }, _a));
    return __assign(__assign({}, originalRequest), {
      document: newDocument
    });
  };

  WrapQuery.prototype.transformResult = function (originalResult) {
    var rootData = originalResult.data;

    if (rootData) {
      var data = rootData;

      var path = __spreadArrays(this.path);

      while (path.length > 1) {
        var next = path.shift();

        if (data[next]) {
          data = data[next];
        }
      }

      data[path[0]] = this.extractor(data[path[0]]);
    }

    return {
      data: rootData,
      errors: originalResult.errors
    };
  };

  return WrapQuery;
}();

exports.default = WrapQuery;

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(84);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Client = void 0;

var _websocket = _interopRequireDefault(__webpack_require__(207));

var _client = _interopRequireDefault(__webpack_require__(210));

var Client = (0, _client["default"])(_websocket["default"]);
exports.Client = Client;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * WebSocket implements a browser-side WebSocket specification.
 * @module Client
 */


var _interopRequireDefault = __webpack_require__(84);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(125));

var _createClass2 = _interopRequireDefault(__webpack_require__(126));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(127));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(129));

var _inherits2 = _interopRequireDefault(__webpack_require__(130));

var _eventemitter = _interopRequireDefault(__webpack_require__(131));

var WebSocket =
/*#__PURE__*/
function (_EventEmitter) {
  (0, _inherits2["default"])(WebSocket, _EventEmitter);
  /** Instantiate a WebSocket class
   * @constructor
   * @param {String} address - url to a websocket server
   * @param {(Object)} options - websocket options
   * @param {(String|Array)} protocols - a list of protocols
   * @return {WebSocket} - returns a WebSocket instance
   */

  function WebSocket(address, options, protocols) {
    var _this;

    (0, _classCallCheck2["default"])(this, WebSocket);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(WebSocket).call(this));
    _this.socket = new window.WebSocket(address, protocols);

    _this.socket.onopen = function () {
      return _this.emit("open");
    };

    _this.socket.onmessage = function (event) {
      return _this.emit("message", event.data);
    };

    _this.socket.onerror = function (error) {
      return _this.emit("error", error);
    };

    _this.socket.onclose = function (event) {
      _this.emit("close", event.code, event.reason);
    };

    return _this;
  }
  /**
   * Sends data through a websocket connection
   * @method
   * @param {(String|Object)} data - data to be sent via websocket
   * @param {Object} options - ws options
   * @param {Function} callback - a callback called once the data is sent
   * @return {Undefined}
   */


  (0, _createClass2["default"])(WebSocket, [{
    key: "send",
    value: function send(data, options, callback) {
      callback = callback || options;

      try {
        this.socket.send(data);
        callback();
      } catch (error) {
        callback(error);
      }
    }
    /**
     * Closes an underlying socket
     * @method
     * @param {Number} code - status code explaining why the connection is being closed
     * @param {String} reason - a description why the connection is closing
     * @return {Undefined}
     * @throws {Error}
     */

  }, {
    key: "close",
    value: function close(code, reason) {
      this.socket.close(code, reason);
    }
  }]);
  return WebSocket;
}(_eventemitter["default"]);

exports["default"] = WebSocket;

/***/ }),
/* 208 */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),
/* 209 */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * "Client" wraps "ws" or a browser-implemented "WebSocket" library
 * according to the environment providing JSON RPC 2.0 support on top.
 * @module Client
 */


var _interopRequireDefault = __webpack_require__(84);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(__webpack_require__(211));

var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(213));

var _typeof2 = _interopRequireDefault(__webpack_require__(128));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(125));

var _createClass2 = _interopRequireDefault(__webpack_require__(126));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(127));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(129));

var _inherits2 = _interopRequireDefault(__webpack_require__(130));

var _assertArgs = _interopRequireDefault(__webpack_require__(214));

var _eventemitter = _interopRequireDefault(__webpack_require__(131));

var _circularJson = _interopRequireDefault(__webpack_require__(227));

var _default = function _default(WebSocket) {
  return (
    /*#__PURE__*/
    function (_EventEmitter) {
      (0, _inherits2["default"])(Client, _EventEmitter);
      /**
       * Instantiate a Client class.
       * @constructor
       * @param {String} address - url to a websocket server
       * @param {Object} options - ws options object with reconnect parameters
       * @param {Function} generate_request_id - custom generation request Id
       * @return {Client}
       */

      function Client() {
        var _this;

        var address = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ws://localhost:8080";

        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref$autoconnect = _ref.autoconnect,
            autoconnect = _ref$autoconnect === void 0 ? true : _ref$autoconnect,
            _ref$reconnect = _ref.reconnect,
            reconnect = _ref$reconnect === void 0 ? true : _ref$reconnect,
            _ref$reconnect_interv = _ref.reconnect_interval,
            reconnect_interval = _ref$reconnect_interv === void 0 ? 1000 : _ref$reconnect_interv,
            _ref$max_reconnects = _ref.max_reconnects,
            max_reconnects = _ref$max_reconnects === void 0 ? 5 : _ref$max_reconnects;

        var generate_request_id = arguments.length > 2 ? arguments[2] : undefined;
        (0, _classCallCheck2["default"])(this, Client);
        _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Client).call(this));
        _this.queue = {};
        _this.rpc_id = 0;
        _this.address = address;
        _this.options = arguments[1];
        _this.autoconnect = autoconnect;
        _this.ready = false;
        _this.reconnect = reconnect;
        _this.reconnect_interval = reconnect_interval;
        _this.max_reconnects = max_reconnects;
        _this.current_reconnects = 0;

        _this.generate_request_id = generate_request_id || function () {
          return ++_this.rpc_id;
        };

        if (_this.autoconnect) _this._connect(_this.address, _this.options);
        return _this;
      }
      /**
       * Connects to a defined server if not connected already.
       * @method
       * @return {Undefined}
       */


      (0, _createClass2["default"])(Client, [{
        key: "connect",
        value: function connect() {
          if (this.socket) return;

          this._connect(this.address, this.options);
        }
        /**
         * Calls a registered RPC method on server.
         * @method
         * @param {String} method - RPC method name
         * @param {Object|Array} params - optional method parameters
         * @param {Number} timeout - RPC reply timeout value
         * @param {Object} ws_opts - options passed to ws
         * @return {Promise}
         */

      }, {
        key: "call",
        value: function call(method, params, timeout, ws_opts) {
          var _this2 = this;

          (0, _assertArgs["default"])(arguments, {
            "method": "string",
            "[params]": ["object", Array],
            "[timeout]": "number",
            "[ws_opts]": "object"
          });

          if (!ws_opts && "object" === (0, _typeof2["default"])(timeout)) {
            ws_opts = timeout;
            timeout = null;
          }

          return new Promise(function (resolve, reject) {
            if (!_this2.ready) return reject(new Error("socket not ready"));

            var rpc_id = _this2.generate_request_id(method, params);

            var message = {
              jsonrpc: "2.0",
              method: method,
              params: params || null,
              id: rpc_id
            };

            _this2.socket.send(JSON.stringify(message), ws_opts, function (error) {
              if (error) return reject(error);
              _this2.queue[rpc_id] = {
                promise: [resolve, reject]
              };

              if (timeout) {
                _this2.queue[rpc_id].timeout = setTimeout(function () {
                  _this2.queue[rpc_id] = null;
                  reject(new Error("reply timeout"));
                }, timeout);
              }
            });
          });
        }
        /**
         * Logins with the other side of the connection.
         * @method
         * @param {Object} params - Login credentials object
         * @return {Promise}
         */

      }, {
        key: "login",
        value: function () {
          var _login = (0, _asyncToGenerator2["default"])(
          /*#__PURE__*/
          _regenerator["default"].mark(function _callee(params) {
            return _regenerator["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.call("rpc.login", params);

                  case 2:
                    return _context.abrupt("return", _context.sent);

                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function login(_x) {
            return _login.apply(this, arguments);
          }

          return login;
        }()
        /**
         * Fetches a list of client's methods registered on server.
         * @method
         * @return {Array}
         */

      }, {
        key: "listMethods",
        value: function () {
          var _listMethods = (0, _asyncToGenerator2["default"])(
          /*#__PURE__*/
          _regenerator["default"].mark(function _callee2() {
            return _regenerator["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.call("__listMethods");

                  case 2:
                    return _context2.abrupt("return", _context2.sent);

                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function listMethods() {
            return _listMethods.apply(this, arguments);
          }

          return listMethods;
        }()
        /**
         * Sends a JSON-RPC 2.0 notification to server.
         * @method
         * @param {String} method - RPC method name
         * @param {Object} params - optional method parameters
         * @return {Promise}
         */

      }, {
        key: "notify",
        value: function notify(method, params) {
          var _this3 = this;

          (0, _assertArgs["default"])(arguments, {
            "method": "string",
            "[params]": ["object", Array]
          });
          return new Promise(function (resolve, reject) {
            if (!_this3.ready) return reject(new Error("socket not ready"));
            var message = {
              jsonrpc: "2.0",
              method: method,
              params: params || null
            };

            _this3.socket.send(JSON.stringify(message), function (error) {
              if (error) return reject(error);
              resolve();
            });
          });
        }
        /**
         * Subscribes for a defined event.
         * @method
         * @param {String|Array} event - event name
         * @return {Undefined}
         * @throws {Error}
         */

      }, {
        key: "subscribe",
        value: function () {
          var _subscribe = (0, _asyncToGenerator2["default"])(
          /*#__PURE__*/
          _regenerator["default"].mark(function _callee3(event) {
            var result,
                _args3 = arguments;
            return _regenerator["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    (0, _assertArgs["default"])(_args3, {
                      event: ["string", Array]
                    });
                    if (typeof event === "string") event = [event];
                    _context3.next = 4;
                    return this.call("rpc.on", event);

                  case 4:
                    result = _context3.sent;

                    if (!(typeof event === "string" && result[event] !== "ok")) {
                      _context3.next = 7;
                      break;
                    }

                    throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);

                  case 7:
                    return _context3.abrupt("return", result);

                  case 8:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function subscribe(_x2) {
            return _subscribe.apply(this, arguments);
          }

          return subscribe;
        }()
        /**
         * Unsubscribes from a defined event.
         * @method
         * @param {String} event - event name
         * @return {Undefined}
         * @throws {Error}
         */

      }, {
        key: "unsubscribe",
        value: function () {
          var _unsubscribe = (0, _asyncToGenerator2["default"])(
          /*#__PURE__*/
          _regenerator["default"].mark(function _callee4(event) {
            var result,
                _args4 = arguments;
            return _regenerator["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    (0, _assertArgs["default"])(_args4, {
                      event: ["string", Array]
                    });
                    if (typeof event === "string") event = [event];
                    _context4.next = 4;
                    return this.call("rpc.off", event);

                  case 4:
                    result = _context4.sent;

                    if (!(typeof event === "string" && result[event] !== "ok")) {
                      _context4.next = 7;
                      break;
                    }

                    throw new Error("Failed unsubscribing from an event with: " + result);

                  case 7:
                    return _context4.abrupt("return", result);

                  case 8:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function unsubscribe(_x3) {
            return _unsubscribe.apply(this, arguments);
          }

          return unsubscribe;
        }()
        /**
         * Closes a WebSocket connection gracefully.
         * @method
         * @param {Number} code - socket close code
         * @param {String} data - optional data to be sent before closing
         * @return {Undefined}
         */

      }, {
        key: "close",
        value: function close(code, data) {
          this.socket.close(code || 1000, data);
        }
        /**
         * Connection/Message handler.
         * @method
         * @private
         * @param {String} address - WebSocket API address
         * @param {Object} options - ws options object
         * @return {Undefined}
         */

      }, {
        key: "_connect",
        value: function _connect(address, options) {
          var _this4 = this;

          this.socket = new WebSocket(address, options);
          this.socket.on("open", function () {
            _this4.ready = true;

            _this4.emit("open");

            _this4.current_reconnects = 0;
          });
          this.socket.on("message", function (message) {
            if (message instanceof ArrayBuffer) message = Buffer.from(message).toString();

            try {
              message = _circularJson["default"].parse(message);
            } catch (error) {
              return;
            } // check if any listeners are attached and forward event


            if (message.notification && _this4.listeners(message.notification).length) {
              if (!Object.keys(message.params).length) return _this4.emit(message.notification);
              var args = [message.notification];
              if (message.params.constructor === Object) args.push(message.params);else // using for-loop instead of unshift/spread because performance is better
                for (var i = 0; i < message.params.length; i++) {
                  args.push(message.params[i]);
                }
              return _this4.emit.apply(_this4, args);
            }

            if (!_this4.queue[message.id]) {
              // general JSON RPC 2.0 events
              if (message.method && message.params) return _this4.emit(message.method, message.params);else return;
            }

            if (_this4.queue[message.id].timeout) clearTimeout(_this4.queue[message.id].timeout);
            if (message.error) _this4.queue[message.id].promise[1](message.error);else _this4.queue[message.id].promise[0](message.result);
            _this4.queue[message.id] = null;
          });
          this.socket.on("error", function (error) {
            return _this4.emit("error", error);
          });
          this.socket.on("close", function (code, message) {
            if (_this4.ready) _this4.emit("close", code, message);
            _this4.ready = false;
            if (code === 1000) return;
            _this4.current_reconnects++;
            if (_this4.reconnect && (_this4.max_reconnects > _this4.current_reconnects || _this4.max_reconnects === 0)) setTimeout(function () {
              return _this4._connect(address, options);
            }, _this4.reconnect_interval);
          });
        }
      }]);
      return Client;
    }(_eventemitter["default"])
  );
};

exports["default"] = _default;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(212);

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
 true ? module.exports : undefined);

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

/***/ }),
/* 213 */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

var debug = __webpack_require__(215)('assert-args');

var exists = __webpack_require__(132);

var isObject = __webpack_require__(85);

var not = __webpack_require__(218);

var isOptionalKey = __webpack_require__(219);

var isSpreadKey = __webpack_require__(220);

var validate = __webpack_require__(133);

var isRequiredKey = not(isOptionalKey);
module.exports = assertArgs;

function assertArgs(args, validation) {
  if (typeof args !== 'object' || !exists(args.length)) {
    throw new TypeError('"args" must be an array or array-like object (arguments)');
  }

  if (!isObject(validation)) {
    // strict object
    throw new TypeError('"validation" must be an object');
  } // copy args


  var argsLeft = Array.prototype.slice.call(args);
  var firstOptionalErr;
  var ret = {};
  var argKeys = Object.keys(validation);
  var outKey;

  if (argKeys.filter(isSpreadKey).length > 1) {
    throw new Error('assert-args only supports a single spread argument');
  }

  argKeys.forEach(function (key, i) {
    var spreadArgs;
    var validator = validation[key];
    var arg = argsLeft[0];

    if (isSpreadKey(key)) {
      debug('is spread key: ' + key);
      debug('argKeys.length', argKeys.length);
      debug('argsLeft.length', argsLeft.length);
      var requiredKeysLeft = argKeys.slice(i + 1).filter(isRequiredKey);
      debug('requiredKeysLeft', requiredKeysLeft);
      spreadArgs = argsLeft.slice(0, argsLeft.length - requiredKeysLeft.length); // copy

      debug('spreadArgs', spreadArgs);
      debug('spreadArgs.length', spreadArgs.length);

      if (isOptionalKey(key)) {
        debug('is optional spread key: ' + key);
        outKey = key.slice(4, -1);
        ret[outKey] = [];
        spreadArgs.forEach(function (arg) {
          if (!exists(arg)) {
            // non-existant args pass as optional args
            firstOptionalErr = null; // reset after a pass

            argsLeft.shift(); // pass, remains [...]

            return;
          }

          try {
            validate(key.slice(1, -1), arg, validator, true); // optional arg passes validator

            firstOptionalErr = null;
            ret[outKey].push(arg); // pass

            argsLeft.shift();
          } catch (err) {
            debug('spread validate err: ' + err.message);
            debug('spread validate argsLeft: ' + argsLeft);

            if (firstOptionalErr) {
              // other optional error already occurred, throw first.
              throw firstOptionalErr;
            } else {
              firstOptionalErr = err;
            }
          }
        });
      } else {
        // isSpreadKey && isRequiredKey
        debug('is required spread key: ' + key);
        outKey = key.slice(3);
        ret[outKey] = [];

        if (spreadArgs.length === 0) {
          // missing trailing required arg, fail
          throw new TypeError('"' + key + '" is required');
        }

        spreadArgs.forEach(function (arg) {
          try {
            validate(key, arg, validator, true); // optional arg passes validator

            firstOptionalErr = null;
            ret[outKey].push(arg); // pass

            argsLeft.shift();
          } catch (err) {
            debug('spread validate err: ' + err.message);
            debug('spread validate argsLeft: ' + argsLeft);
            debug('spread validate argKeys: ' + argKeys);

            if (i === argKeys.length - 1) {
              // spread is last arg.
              // spread assumes all args passed are used.
              // there are no args left. and this failed for spread. throw it.
              if (firstOptionalErr) {
                if (argsLeft.length - 1 > requiredKeysLeft.length) {
                  throw firstOptionalErr;
                } else {
                  throw err;
                }
              } else {
                throw err;
              }
            } else {
              // leading/middle spread arg
              if (firstOptionalErr) {
                // other optional error already occurred, throw first.
                throw firstOptionalErr;
              } else {
                // set optional err
                firstOptionalErr = err;
              }
            }
          }
        });
      }

      return;
    } else if (isOptionalKey(key)) {
      debug('is optional key: ' + key);
      key = key.slice(1, -1);

      if (argsLeft.length === 0) {
        // missing trailing optional arg, pass
        ret[key] = undefined;
        return;
      } else if (!exists(arg)) {
        // non-existant args pass as optional args
        firstOptionalErr = null;
        ret[key] = argsLeft.shift(); // pass

        return;
      }

      try {
        validate(key, arg, validator); // optional arg passes validator

        firstOptionalErr = null;
        ret[key] = argsLeft.shift();
        return;
      } catch (err) {
        // optional arg failed validator
        // * set as undefined and pass for now
        // * save the error in case there are no more required args
        firstOptionalErr = firstOptionalErr || err;
        ret[key] = undefined;
        return;
      }
    } else {
      // isRequiredKey
      debug('is required key: ' + key);

      if (argsLeft.length === 0) {
        // missing trailing required arg, fail
        throw new TypeError('"' + key + '" is required');
      }

      try {
        validate(key, arg, validator); // required arg passes validator, pass

        firstOptionalErr = null;
        ret[key] = argsLeft.shift();
      } catch (err) {
        if (firstOptionalErr && argsLeft.length > 1) {
          // optional err was thrown before and this is not the last arg
          throw firstOptionalErr;
        }

        throw err;
      }

      return;
    }
  });

  if (firstOptionalErr) {
    throw firstOptionalErr;
  }

  return ret;
}

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */
exports = module.exports = __webpack_require__(216);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
/**
 * Colors.
 */

exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  } // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */


exports.formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  var useColors = this.useColors;
  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
  if (!useColors) return;
  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if ('%%' === match) return;
    index++;

    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch (e) {}
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.debug;
  } catch (e) {} // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */


exports.enable(load());
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */
exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(217);
/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];
/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};
/**
 * Previous log timestamp.
 */

var prevTime;
/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0,
      i;

  for (i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}
/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */


function createDebug(namespace) {
  function debug() {
    // disabled?
    if (!debug.enabled) return;
    var self = debug; // set `diff` timestamp

    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr; // turn the `arguments` into a proper Array

    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    } // apply any `formatters` transformations


    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];

      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val); // now we need to remove `args[index]` since it's inlined in the `format`

        args.splice(index, 1);
        index--;
      }

      return match;
    }); // apply env-specific formatting (colors, etc.)

    exports.formatArgs.call(self, args);
    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace); // env-specific initialization logic for debug instances

  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}
/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */


function enable(namespaces) {
  exports.save(namespaces);
  exports.names = [];
  exports.skips = [];
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings

    namespaces = split[i].replace(/\*/g, '.*?');

    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}
/**
 * Disable debug output.
 *
 * @api public
 */


function disable() {
  exports.enable('');
}
/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */


function enabled(name) {
  var i, len;

  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }

  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }

  return false;
}
/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */


function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

/***/ }),
/* 217 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, n, name) {
  if (ms < n) {
    return;
  }

  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }

  return Math.ceil(ms / n) + ' ' + name + 's';
}

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @module 101/not
 */
var isFunction = __webpack_require__(71);
/**
 * Functional version of !
 * @function module:101/not
 * @param {*} val - value to inverse
 * @return {function} - function whose arguments and context are applied to fn and result is inversed
 */


module.exports = not;

function not(val) {
  if (isFunction(val)) {
    return function ()
    /* args */
    {
      return not(val.apply(this, arguments));
    };
  } else {
    return !val;
  }
}

/***/ }),
/* 219 */
/***/ (function(module, exports) {

module.exports = isOptionalKey;

function isOptionalKey(key) {
  return /^\[.+\]$/.test(key);
}

/***/ }),
/* 220 */
/***/ (function(module, exports) {

module.exports = isSpreadKey;

function isSpreadKey(key) {
  return /^[.]{3}.+/.test(key) || /^\[[.]{3}[^\]]+\]$/.test(key);
}

/***/ }),
/* 221 */
/***/ (function(module, exports) {

/** 
 * @module 101/is-integer
 */

/**
 * Returns true if n is an integer.
 * @function module:101/is-integer
 * @param {*} val - value checked to be a string
 * @return {boolean} Whether the value is an integer or not
 */
module.exports = isInteger;

function isInteger(val) {
  return typeof val === 'number' && isFinite(val) && Math.floor(val) === val;
}

/***/ }),
/* 222 */
/***/ (function(module, exports) {

var capitalized = /^[A-Z]/;
var strictCapitalilized = /^[A-Z]([a-z]|$)/;
module.exports = isCapitalized;

function isCapitalized(str, strict) {
  return strict ? strictCapitalilized.test(str) : capitalized.test(str);
}

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

(function (root) {
  var toString = Function.prototype.toString;

  function fnBody(fn) {
    return toString.call(fn).replace(/^[^{]*{\s*/, '').replace(/\s*}[^}]*$/, '');
  }

  function isClass(fn) {
    return typeof fn === 'function' && (/^class\s/.test(toString.call(fn)) || /^.*classCallCheck\(/.test(fnBody(fn))) // babel.js
    ;
  }

  if (true) {
    if ( true && module.exports) {
      exports = module.exports = isClass;
    }

    exports.isClass = isClass;
  } else {}
})(this);

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

var compoundSubject = __webpack_require__(225);

var isEmpty = __webpack_require__(226);

var isString = __webpack_require__(86);

var isFunction = __webpack_require__(71);

var assertType = __webpack_require__(134);

var isClass = __webpack_require__(135);

var validate = __webpack_require__(133);

var startsWithVowel = __webpack_require__(136);

module.exports = multiValidate;
/**
 * validate an argument against multiple validators
 * @param  {string} key argument name
 * @param  {*} arg  argument value
 * @param  {array} validators array of validators
 */

function multiValidate(key, arg, validators) {
  var errMessage = '"' + key + '" must be ';
  assertType(!isEmpty(validators), '"validators" cannot be empty');
  var typeArr = validators.map(function (validator) {
    if (isString(validator)) {
      return validator;
    } else if (isClass(validator)) {
      return '"' + validator.name + '"';
    } else if (isFunction(validator)) {
      return 'pass "' + (validator.name || 'anonymous') + '"';
    } else {
      throw new TypeError('"validators" must be an array containing only strings, classes, or functions');
    }
  });
  var typeStr = compoundSubject(typeArr).endWith('or').make();
  var article = startsWithVowel(typeStr) ? 'an' : 'a';
  errMessage += article + ' ' + typeStr;
  var passedAnyValidator = validators.some(function (validator) {
    try {
      validate(key, arg, validator);
      return true;
    } catch (e) {
      return false;
    }
  });

  if (!passedAnyValidator) {
    throw new TypeError(errMessage);
  }
}

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

(function () {
  'use strict';

  var compoundSubject = function compoundSubject(arrayOfStrings) {
    var wrapperObject = {},
        endWith = 'and',
        delimitAll = false,
        delimitWith = ',';

    wrapperObject.endWith = function (newEndWith) {
      if (typeof newEndWith !== 'string') {
        return wrapperObject;
      }

      endWith = newEndWith;
      return wrapperObject;
    };

    wrapperObject.delimitAll = function ()
    /*newDelimitAll*/
    {
      var newDelimitAll = arguments[0];

      if (typeof newDelimitAll === 'boolean') {
        delimitAll = newDelimitAll;
      } else {
        delimitAll = true;
      }

      return wrapperObject;
    };

    wrapperObject.delimitWith = function (newDelimitWith) {
      if (typeof newDelimitWith !== 'string') {
        return wrapperObject;
      }

      delimitWith = newDelimitWith;
      return wrapperObject;
    };

    wrapperObject.make = function () {
      var combinedEndWith = delimitAll ? delimitWith + ' ' + endWith + ' ' : ' ' + endWith + ' ',
          upToLastTwo,
          lastTwo;

      if (typeof arrayOfStrings === 'undefined' || !arrayOfStrings instanceof Array) {
        return '';
      }

      upToLastTwo = arrayOfStrings.slice(0, -2).join(delimitWith + ' ');
      lastTwo = arrayOfStrings.slice(arrayOfStrings.length - 2).join(combinedEndWith);

      if (!upToLastTwo.length) {
        return lastTwo;
      }

      return upToLastTwo + delimitWith + ' ' + lastTwo;
    };

    return wrapperObject;
  }; // Node


  if (true) {
    module.exports = compoundSubject;
  } // Browser
  else {}
})();

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @module 101/is-empty
 */
var isString = __webpack_require__(86);

var isObject = __webpack_require__(85);

var isArray = Array.isArray;
/**
 * Functional version of val empty object, array or object
 * @function module:101/is-empty
 * @param {string|array|object} val - value checked to be a empty
 * @return {boolean} Whether the value is an empty or not
 */

module.exports = isEmpty;

function isEmpty(val) {
  if (isString(val) || isArray(val)) {
    return val.length === 0;
  } else if (isObject(val)) {
    for (var name in val) {
      return false;
    }

    return true;
  } else {
    throw new TypeError('Val must be a string, array or object');
  }
}

/***/ }),
/* 227 */
/***/ (function(module, exports) {

/*!
Copyright (C) 2013-2017 by Andrea Giammarchi - @WebReflection

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
var // should be a not so common char
// possibly one JSON does not encode
// possibly one encodeURIComponent does not encode
// right now this char is '~' but this might change in the future
specialChar = '~',
    safeSpecialChar = '\\x' + ('0' + specialChar.charCodeAt(0).toString(16)).slice(-2),
    escapedSafeSpecialChar = '\\' + safeSpecialChar,
    specialCharRG = new RegExp(safeSpecialChar, 'g'),
    safeSpecialCharRG = new RegExp(escapedSafeSpecialChar, 'g'),
    safeStartWithSpecialCharRG = new RegExp('(?:^|([^\\\\]))' + escapedSafeSpecialChar),
    indexOf = [].indexOf || function (v) {
  for (var i = this.length; i-- && this[i] !== v;);

  return i;
},
    $String = String // there's no way to drop warnings in JSHint
// about new String ... well, I need that here!
// faked, and happy linter!
;

function generateReplacer(value, replacer, resolve) {
  var doNotIgnore = false,
      inspect = !!replacer,
      path = [],
      all = [value],
      seen = [value],
      mapp = [resolve ? specialChar : '[Circular]'],
      last = value,
      lvl = 1,
      i,
      fn;

  if (inspect) {
    fn = typeof replacer === 'object' ? function (key, value) {
      return key !== '' && replacer.indexOf(key) < 0 ? void 0 : value;
    } : replacer;
  }

  return function (key, value) {
    // the replacer has rights to decide
    // if a new object should be returned
    // or if there's some key to drop
    // let's call it here rather than "too late"
    if (inspect) value = fn.call(this, key, value); // first pass should be ignored, since it's just the initial object

    if (doNotIgnore) {
      if (last !== this) {
        i = lvl - indexOf.call(all, this) - 1;
        lvl -= i;
        all.splice(lvl, all.length);
        path.splice(lvl - 1, path.length);
        last = this;
      } // console.log(lvl, key, path);


      if (typeof value === 'object' && value) {
        // if object isn't referring to parent object, add to the
        // object path stack. Otherwise it is already there.
        if (indexOf.call(all, value) < 0) {
          all.push(last = value);
        }

        lvl = all.length;
        i = indexOf.call(seen, value);

        if (i < 0) {
          i = seen.push(value) - 1;

          if (resolve) {
            // key cannot contain specialChar but could be not a string
            path.push(('' + key).replace(specialCharRG, safeSpecialChar));
            mapp[i] = specialChar + path.join(specialChar);
          } else {
            mapp[i] = mapp[0];
          }
        } else {
          value = mapp[i];
        }
      } else {
        if (typeof value === 'string' && resolve) {
          // ensure no special char involved on deserialization
          // in this case only first char is important
          // no need to replace all value (better performance)
          value = value.replace(safeSpecialChar, escapedSafeSpecialChar).replace(specialChar, safeSpecialChar);
        }
      }
    } else {
      doNotIgnore = true;
    }

    return value;
  };
}

function retrieveFromPath(current, keys) {
  for (var i = 0, length = keys.length; i < length; current = current[// keys should be normalized back here
  keys[i++].replace(safeSpecialCharRG, specialChar)]);

  return current;
}

function generateReviver(reviver) {
  return function (key, value) {
    var isString = typeof value === 'string';

    if (isString && value.charAt(0) === specialChar) {
      return new $String(value.slice(1));
    }

    if (key === '') value = regenerate(value, value, {}); // again, only one needed, do not use the RegExp for this replacement
    // only keys need the RegExp

    if (isString) value = value.replace(safeStartWithSpecialCharRG, '$1' + specialChar).replace(escapedSafeSpecialChar, safeSpecialChar);
    return reviver ? reviver.call(this, key, value) : value;
  };
}

function regenerateArray(root, current, retrieve) {
  for (var i = 0, length = current.length; i < length; i++) {
    current[i] = regenerate(root, current[i], retrieve);
  }

  return current;
}

function regenerateObject(root, current, retrieve) {
  for (var key in current) {
    if (current.hasOwnProperty(key)) {
      current[key] = regenerate(root, current[key], retrieve);
    }
  }

  return current;
}

function regenerate(root, current, retrieve) {
  return current instanceof Array ? // fast Array reconstruction
  regenerateArray(root, current, retrieve) : current instanceof $String ? // root is an empty string
  current.length ? retrieve.hasOwnProperty(current) ? retrieve[current] : retrieve[current] = retrieveFromPath(root, current.split(specialChar)) : root : current instanceof Object ? // dedicated Object parser
  regenerateObject(root, current, retrieve) : // value as it is
  current;
}

var CircularJSON = {
  stringify: function stringify(value, replacer, space, doNotResolve) {
    return CircularJSON.parser.stringify(value, generateReplacer(value, replacer, !doNotResolve), space);
  },
  parse: function parse(text, reviver) {
    return CircularJSON.parser.parse(text, generateReviver(reviver));
  },
  // A parser should be an API 1:1 compatible with JSON
  // it should expose stringify and parse methods.
  // The default parser is the native JSON.
  parser: JSON
};
module.exports = CircularJSON;

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.
__webpack_require__(229);

module.exports = self.fetch.bind(self);

/***/ }),
/* 229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Headers", function() { return Headers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return Request; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Response", function() { return Response; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMException", function() { return DOMException; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetch", function() { return fetch; });
var support = {
  searchParams: 'URLSearchParams' in self,
  iterable: 'Symbol' in self && 'iterator' in Symbol,
  blob: 'FileReader' in self && 'Blob' in self && function () {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: 'FormData' in self,
  arrayBuffer: 'ArrayBuffer' in self
};

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}

if (support.arrayBuffer) {
  var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

  var isArrayBufferView = ArrayBuffer.isView || function (obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }

  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name');
  }

  return name.toLowerCase();
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }

  return value;
} // Build a destructive iterator for the value list


function iteratorFor(items) {
  var iterator = {
    next: function next() {
      var value = items.shift();
      return {
        done: value === undefined,
        value: value
      };
    }
  };

  if (support.iterable) {
    iterator[Symbol.iterator] = function () {
      return iterator;
    };
  }

  return iterator;
}

function Headers(headers) {
  this.map = {};

  if (headers instanceof Headers) {
    headers.forEach(function (value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function (header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function (name) {
      this.append(name, headers[name]);
    }, this);
  }
}

Headers.prototype.append = function (name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};

Headers.prototype['delete'] = function (name) {
  delete this.map[normalizeName(name)];
};

Headers.prototype.get = function (name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};

Headers.prototype.has = function (name) {
  return this.map.hasOwnProperty(normalizeName(name));
};

Headers.prototype.set = function (name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};

Headers.prototype.forEach = function (callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};

Headers.prototype.keys = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};

Headers.prototype.values = function () {
  var items = [];
  this.forEach(function (value) {
    items.push(value);
  });
  return iteratorFor(items);
};

Headers.prototype.entries = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'));
  }

  body.bodyUsed = true;
}

function fileReaderReady(reader) {
  return new Promise(function (resolve, reject) {
    reader.onload = function () {
      resolve(reader.result);
    };

    reader.onerror = function () {
      reject(reader.error);
    };
  });
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}

function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsText(blob);
  return promise;
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }

  return chars.join('');
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}

function Body() {
  this.bodyUsed = false;

  this._initBody = function (body) {
    this._bodyInit = body;

    if (!body) {
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.

      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };

  if (support.blob) {
    this.blob = function () {
      var rejected = consumed(this);

      if (rejected) {
        return rejected;
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob');
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };

    this.arrayBuffer = function () {
      if (this._bodyArrayBuffer) {
        return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
      } else {
        return this.blob().then(readBlobAsArrayBuffer);
      }
    };
  }

  this.text = function () {
    var rejected = consumed(this);

    if (rejected) {
      return rejected;
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text');
    } else {
      return Promise.resolve(this._bodyText);
    }
  };

  if (support.formData) {
    this.formData = function () {
      return this.text().then(decode);
    };
  }

  this.json = function () {
    return this.text().then(JSON.parse);
  };

  return this;
} // HTTP methods whose capitalization should be normalized


var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}

function Request(input, options) {
  options = options || {};
  var body = options.body;

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read');
    }

    this.url = input.url;
    this.credentials = input.credentials;

    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }

    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;

    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }

  this.credentials = options.credentials || this.credentials || 'same-origin';

  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }

  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal;
  this.referrer = null;

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests');
  }

  this._initBody(body);
}

Request.prototype.clone = function () {
  return new Request(this, {
    body: this._bodyInit
  });
};

function decode(body) {
  var form = new FormData();
  body.trim().split('&').forEach(function (bytes) {
    if (bytes) {
      var split = bytes.split('=');
      var name = split.shift().replace(/\+/g, ' ');
      var value = split.join('=').replace(/\+/g, ' ');
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}

function parseHeaders(rawHeaders) {
  var headers = new Headers(); // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2

  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
    var parts = line.split(':');
    var key = parts.shift().trim();

    if (key) {
      var value = parts.join(':').trim();
      headers.append(key, value);
    }
  });
  return headers;
}

Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!options) {
    options = {};
  }

  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = 'statusText' in options ? options.statusText : 'OK';
  this.headers = new Headers(options.headers);
  this.url = options.url || '';

  this._initBody(bodyInit);
}
Body.call(Response.prototype);

Response.prototype.clone = function () {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};

Response.error = function () {
  var response = new Response(null, {
    status: 0,
    statusText: ''
  });
  response.type = 'error';
  return response;
};

var redirectStatuses = [301, 302, 303, 307, 308];

Response.redirect = function (url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code');
  }

  return new Response(null, {
    status: status,
    headers: {
      location: url
    }
  });
};

var DOMException = self.DOMException;

try {
  new DOMException();
} catch (err) {
  DOMException = function DOMException(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };

  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}

function fetch(input, init) {
  return new Promise(function (resolve, reject) {
    var request = new Request(input, init);

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'));
    }

    var xhr = new XMLHttpRequest();

    function abortXhr() {
      xhr.abort();
    }

    xhr.onload = function () {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      resolve(new Response(body, options));
    };

    xhr.onerror = function () {
      reject(new TypeError('Network request failed'));
    };

    xhr.ontimeout = function () {
      reject(new TypeError('Network request failed'));
    };

    xhr.onabort = function () {
      reject(new DOMException('Aborted', 'AbortError'));
    };

    xhr.open(request.method, request.url, true);

    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }

    if ('responseType' in xhr && support.blob) {
      xhr.responseType = 'blob';
    }

    request.headers.forEach(function (value, name) {
      xhr.setRequestHeader(name, value);
    });

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);

      xhr.onreadystatechange = function () {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  });
}
fetch.polyfill = true;

if (!self.fetch) {
  self.fetch = fetch;
  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;
}

/***/ }),
/* 230 */
/***/ (function(module, exports) {

module.exports = function (originalModule) {
  if (!originalModule.webpackPolyfill) {
    var module = Object.create(originalModule); // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    Object.defineProperty(module, "exports", {
      enumerable: true
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// load material icons font

const fontEl = document.createElement('link');
fontEl.rel = 'stylesheet';
fontEl.href = 'https://fonts.googleapis.com/icon?family=Material+Icons';
document.head.appendChild(fontEl);

/***/ }),
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/lit-html/lib/directive.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const directive_directives = new WeakMap();
/**
 * Brands a function as a directive factory function so that lit-html will call
 * the function during template rendering, rather than passing as a value.
 *
 * A _directive_ is a function that takes a Part as an argument. It has the
 * signature: `(part: Part) => void`.
 *
 * A directive _factory_ is a function that takes arguments for data and
 * configuration and returns a directive. Users of directive usually refer to
 * the directive factory as the directive. For example, "The repeat directive".
 *
 * Usually a template author will invoke a directive factory in their template
 * with relevant arguments, which will then return a directive function.
 *
 * Here's an example of using the `repeat()` directive factory that takes an
 * array and a function to render an item:
 *
 * ```js
 * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`
 * ```
 *
 * When `repeat` is invoked, it returns a directive function that closes over
 * `items` and the template function. When the outer template is rendered, the
 * return directive function is called with the Part for the expression.
 * `repeat` then performs it's custom logic to render multiple items.
 *
 * @param f The directive factory function. Must be a function that returns a
 * function of the signature `(part: Part) => void`. The returned function will
 * be called with the part object.
 *
 * @example
 *
 * import {directive, html} from 'lit-html';
 *
 * const immutable = directive((v) => (part) => {
 *   if (part.value !== v) {
 *     part.setValue(v)
 *   }
 * });
 */

const directive_directive = f => (...args) => {
  const d = f(...args);
  directive_directives.set(d, true);
  return d;
};
const isDirective = o => {
  return typeof o === 'function' && directive_directives.has(o);
};
// CONCATENATED MODULE: ./node_modules/lit-html/lib/dom.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * True if the custom elements polyfill is in use.
 */
const isCEPolyfill = window.customElements !== undefined && window.customElements.polyfillWrapFlushCallback !== undefined;
/**
 * Reparents nodes, starting from `start` (inclusive) to `end` (exclusive),
 * into another container (could be the same container), before `before`. If
 * `before` is null, it appends the nodes to the container.
 */

const reparentNodes = (container, start, end = null, before = null) => {
  while (start !== end) {
    const n = start.nextSibling;
    container.insertBefore(start, before);
    start = n;
  }
};
/**
 * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
 * `container`.
 */

const removeNodes = (container, start, end = null) => {
  while (start !== end) {
    const n = start.nextSibling;
    container.removeChild(start);
    start = n;
  }
};
// CONCATENATED MODULE: ./node_modules/lit-html/lib/part.js
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * A sentinel value that signals that a value was handled by a directive and
 * should not be written to the DOM.
 */
const noChange = {};
/**
 * A sentinel value that signals a NodePart to fully clear its content.
 */

const nothing = {};
// CONCATENATED MODULE: ./node_modules/lit-html/lib/template.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * An expression marker with embedded unique key to avoid collision with
 * possible text in templates.
 */
const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
/**
 * An expression marker used text-positions, multi-binding attributes, and
 * attributes with markup-like text values.
 */

const nodeMarker = `<!--${marker}-->`;
const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
/**
 * Suffix appended to all bound attribute names.
 */

const boundAttributeSuffix = '$lit$';
/**
 * An updateable Template that tracks the location of dynamic parts.
 */

class Template {
  constructor(result, element) {
    this.parts = [];
    this.element = element;
    const nodesToRemove = [];
    const stack = []; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null

    const walker = document.createTreeWalker(element.content, 133
    /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
    , null, false); // Keeps track of the last index associated with a part. We try to delete
    // unnecessary nodes, but we never want to associate two different parts
    // to the same index. They must have a constant node between.

    let lastPartIndex = 0;
    let index = -1;
    let partIndex = 0;
    const {
      strings,
      values: {
        length
      }
    } = result;

    while (partIndex < length) {
      const node = walker.nextNode();

      if (node === null) {
        // We've exhausted the content inside a nested template element.
        // Because we still have parts (the outer for-loop), we know:
        // - There is a template in the stack
        // - The walker will find a nextNode outside the template
        walker.currentNode = stack.pop();
        continue;
      }

      index++;

      if (node.nodeType === 1
      /* Node.ELEMENT_NODE */
      ) {
          if (node.hasAttributes()) {
            const attributes = node.attributes;
            const {
              length
            } = attributes; // Per
            // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
            // attributes are not guaranteed to be returned in document order.
            // In particular, Edge/IE can return them out of order, so we cannot
            // assume a correspondence between part index and attribute index.

            let count = 0;

            for (let i = 0; i < length; i++) {
              if (endsWith(attributes[i].name, boundAttributeSuffix)) {
                count++;
              }
            }

            while (count-- > 0) {
              // Get the template literal section leading up to the first
              // expression in this attribute
              const stringForPart = strings[partIndex]; // Find the attribute name

              const name = lastAttributeNameRegex.exec(stringForPart)[2]; // Find the corresponding attribute
              // All bound attributes have had a suffix added in
              // TemplateResult#getHTML to opt out of special attribute
              // handling. To look up the attribute value we also need to add
              // the suffix.

              const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
              const attributeValue = node.getAttribute(attributeLookupName);
              node.removeAttribute(attributeLookupName);
              const statics = attributeValue.split(markerRegex);
              this.parts.push({
                type: 'attribute',
                index,
                name,
                strings: statics
              });
              partIndex += statics.length - 1;
            }
          }

          if (node.tagName === 'TEMPLATE') {
            stack.push(node);
            walker.currentNode = node.content;
          }
        } else if (node.nodeType === 3
      /* Node.TEXT_NODE */
      ) {
          const data = node.data;

          if (data.indexOf(marker) >= 0) {
            const parent = node.parentNode;
            const strings = data.split(markerRegex);
            const lastIndex = strings.length - 1; // Generate a new text node for each literal section
            // These nodes are also used as the markers for node parts

            for (let i = 0; i < lastIndex; i++) {
              let insert;
              let s = strings[i];

              if (s === '') {
                insert = createMarker();
              } else {
                const match = lastAttributeNameRegex.exec(s);

                if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                  s = s.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];
                }

                insert = document.createTextNode(s);
              }

              parent.insertBefore(insert, node);
              this.parts.push({
                type: 'node',
                index: ++index
              });
            } // If there's no text, we must insert a comment to mark our place.
            // Else, we can trust it will stick around after cloning.


            if (strings[lastIndex] === '') {
              parent.insertBefore(createMarker(), node);
              nodesToRemove.push(node);
            } else {
              node.data = strings[lastIndex];
            } // We have a part for each match found


            partIndex += lastIndex;
          }
        } else if (node.nodeType === 8
      /* Node.COMMENT_NODE */
      ) {
          if (node.data === marker) {
            const parent = node.parentNode; // Add a new marker node to be the startNode of the Part if any of
            // the following are true:
            //  * We don't have a previousSibling
            //  * The previousSibling is already the start of a previous part

            if (node.previousSibling === null || index === lastPartIndex) {
              index++;
              parent.insertBefore(createMarker(), node);
            }

            lastPartIndex = index;
            this.parts.push({
              type: 'node',
              index
            }); // If we don't have a nextSibling, keep this node so we have an end.
            // Else, we can remove it to save future costs.

            if (node.nextSibling === null) {
              node.data = '';
            } else {
              nodesToRemove.push(node);
              index--;
            }

            partIndex++;
          } else {
            let i = -1;

            while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
              // Comment node has a binding marker inside, make an inactive part
              // The binding won't work, but subsequent bindings will
              // TODO (justinfagnani): consider whether it's even worth it to
              // make bindings in comments work
              this.parts.push({
                type: 'node',
                index: -1
              });
              partIndex++;
            }
          }
        }
    } // Remove text binding nodes after the walk to not disturb the TreeWalker


    for (const n of nodesToRemove) {
      n.parentNode.removeChild(n);
    }
  }

}

const endsWith = (str, suffix) => {
  const index = str.length - suffix.length;
  return index >= 0 && str.slice(index) === suffix;
};

const isTemplatePartActive = part => part.index !== -1; // Allows `document.createComment('')` to be renamed for a
// small manual size-savings.

const createMarker = () => document.createComment('');
/**
 * This regex extracts the attribute name preceding an attribute-position
 * expression. It does this by matching the syntax allowed for attributes
 * against the string literal directly preceding the expression, assuming that
 * the expression is in an attribute-value position.
 *
 * See attributes in the HTML spec:
 * https://www.w3.org/TR/html5/syntax.html#elements-attributes
 *
 * " \x09\x0a\x0c\x0d" are HTML space characters:
 * https://www.w3.org/TR/html5/infrastructure.html#space-characters
 *
 * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
 * space character except " ".
 *
 * So an attribute is:
 *  * The name: any character except a control character, space character, ('),
 *    ("), ">", "=", or "/"
 *  * Followed by zero or more space characters
 *  * Followed by "="
 *  * Followed by zero or more space characters
 *  * Followed by:
 *    * Any character except space, ('), ("), "<", ">", "=", (`), or
 *    * (") then any non-("), or
 *    * (') then any non-(')
 */

const lastAttributeNameRegex = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
// CONCATENATED MODULE: ./node_modules/lit-html/lib/template-instance.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * @module lit-html
 */


/**
 * An instance of a `Template` that can be attached to the DOM and updated
 * with new values.
 */

class template_instance_TemplateInstance {
  constructor(template, processor, options) {
    this.__parts = [];
    this.template = template;
    this.processor = processor;
    this.options = options;
  }

  update(values) {
    let i = 0;

    for (const part of this.__parts) {
      if (part !== undefined) {
        part.setValue(values[i]);
      }

      i++;
    }

    for (const part of this.__parts) {
      if (part !== undefined) {
        part.commit();
      }
    }
  }

  _clone() {
    // There are a number of steps in the lifecycle of a template instance's
    // DOM fragment:
    //  1. Clone - create the instance fragment
    //  2. Adopt - adopt into the main document
    //  3. Process - find part markers and create parts
    //  4. Upgrade - upgrade custom elements
    //  5. Update - set node, attribute, property, etc., values
    //  6. Connect - connect to the document. Optional and outside of this
    //     method.
    //
    // We have a few constraints on the ordering of these steps:
    //  * We need to upgrade before updating, so that property values will pass
    //    through any property setters.
    //  * We would like to process before upgrading so that we're sure that the
    //    cloned fragment is inert and not disturbed by self-modifying DOM.
    //  * We want custom elements to upgrade even in disconnected fragments.
    //
    // Given these constraints, with full custom elements support we would
    // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
    //
    // But Safari dooes not implement CustomElementRegistry#upgrade, so we
    // can not implement that order and still have upgrade-before-update and
    // upgrade disconnected fragments. So we instead sacrifice the
    // process-before-upgrade constraint, since in Custom Elements v1 elements
    // must not modify their light DOM in the constructor. We still have issues
    // when co-existing with CEv0 elements like Polymer 1, and with polyfills
    // that don't strictly adhere to the no-modification rule because shadow
    // DOM, which may be created in the constructor, is emulated by being placed
    // in the light DOM.
    //
    // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
    // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
    // in one step.
    //
    // The Custom Elements v1 polyfill supports upgrade(), so the order when
    // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
    // Connect.
    const fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
    const stack = [];
    const parts = this.template.parts; // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null

    const walker = document.createTreeWalker(fragment, 133
    /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
    , null, false);
    let partIndex = 0;
    let nodeIndex = 0;
    let part;
    let node = walker.nextNode(); // Loop through all the nodes and parts of a template

    while (partIndex < parts.length) {
      part = parts[partIndex];

      if (!isTemplatePartActive(part)) {
        this.__parts.push(undefined);

        partIndex++;
        continue;
      } // Progress the tree walker until we find our next part's node.
      // Note that multiple parts may share the same node (attribute parts
      // on a single element), so this loop may not run at all.


      while (nodeIndex < part.index) {
        nodeIndex++;

        if (node.nodeName === 'TEMPLATE') {
          stack.push(node);
          walker.currentNode = node.content;
        }

        if ((node = walker.nextNode()) === null) {
          // We've exhausted the content inside a nested template element.
          // Because we still have parts (the outer for-loop), we know:
          // - There is a template in the stack
          // - The walker will find a nextNode outside the template
          walker.currentNode = stack.pop();
          node = walker.nextNode();
        }
      } // We've arrived at our part's node.


      if (part.type === 'node') {
        const part = this.processor.handleTextExpression(this.options);
        part.insertAfterNode(node.previousSibling);

        this.__parts.push(part);
      } else {
        this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
      }

      partIndex++;
    }

    if (isCEPolyfill) {
      document.adoptNode(fragment);
      customElements.upgrade(fragment);
    }

    return fragment;
  }

}
// CONCATENATED MODULE: ./node_modules/lit-html/lib/template-result.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * @module lit-html
 */


const commentMarker = ` ${marker} `;
/**
 * The return type of `html`, which holds a Template and the values from
 * interpolated expressions.
 */

class template_result_TemplateResult {
  constructor(strings, values, type, processor) {
    this.strings = strings;
    this.values = values;
    this.type = type;
    this.processor = processor;
  }
  /**
   * Returns a string of HTML used to create a `<template>` element.
   */


  getHTML() {
    const l = this.strings.length - 1;
    let html = '';
    let isCommentBinding = false;

    for (let i = 0; i < l; i++) {
      const s = this.strings[i]; // For each binding we want to determine the kind of marker to insert
      // into the template source before it's parsed by the browser's HTML
      // parser. The marker type is based on whether the expression is in an
      // attribute, text, or comment poisition.
      //   * For node-position bindings we insert a comment with the marker
      //     sentinel as its text content, like <!--{{lit-guid}}-->.
      //   * For attribute bindings we insert just the marker sentinel for the
      //     first binding, so that we support unquoted attribute bindings.
      //     Subsequent bindings can use a comment marker because multi-binding
      //     attributes must be quoted.
      //   * For comment bindings we insert just the marker sentinel so we don't
      //     close the comment.
      //
      // The following code scans the template source, but is *not* an HTML
      // parser. We don't need to track the tree structure of the HTML, only
      // whether a binding is inside a comment, and if not, if it appears to be
      // the first binding in an attribute.

      const commentOpen = s.lastIndexOf('<!--'); // We're in comment position if we have a comment open with no following
      // comment close. Because <-- can appear in an attribute value there can
      // be false positives.

      isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf('-->', commentOpen + 1) === -1; // Check to see if we have an attribute-like sequence preceeding the
      // expression. This can match "name=value" like structures in text,
      // comments, and attribute values, so there can be false-positives.

      const attributeMatch = lastAttributeNameRegex.exec(s);

      if (attributeMatch === null) {
        // We're only in this branch if we don't have a attribute-like
        // preceeding sequence. For comments, this guards against unusual
        // attribute values like <div foo="<!--${'bar'}">. Cases like
        // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
        // below.
        html += s + (isCommentBinding ? commentMarker : nodeMarker);
      } else {
        // For attributes we use just a marker sentinel, and also append a
        // $lit$ suffix to the name to opt-out of attribute-specific parsing
        // that IE and Edge do for style and certain SVG attributes.
        html += s.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;
      }
    }

    html += this.strings[l];
    return html;
  }

  getTemplateElement() {
    const template = document.createElement('template');
    template.innerHTML = this.getHTML();
    return template;
  }

}
/**
 * A TemplateResult for SVG fragments.
 *
 * This class wraps HTML in an `<svg>` tag in order to parse its contents in the
 * SVG namespace, then modifies the template to remove the `<svg>` tag so that
 * clones only container the original fragment.
 */

class template_result_SVGTemplateResult extends template_result_TemplateResult {
  getHTML() {
    return `<svg>${super.getHTML()}</svg>`;
  }

  getTemplateElement() {
    const template = super.getTemplateElement();
    const content = template.content;
    const svgElement = content.firstChild;
    content.removeChild(svgElement);
    reparentNodes(content, svgElement.firstChild);
    return template;
  }

}
// CONCATENATED MODULE: ./node_modules/lit-html/lib/parts.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * @module lit-html
 */






const isPrimitive = value => {
  return value === null || !(typeof value === 'object' || typeof value === 'function');
};
const isIterable = value => {
  return Array.isArray(value) || // tslint:disable-next-line:no-any
  !!(value && value[Symbol.iterator]);
};
/**
 * Writes attribute values to the DOM for a group of AttributeParts bound to a
 * single attibute. The value is only set once even if there are multiple parts
 * for an attribute.
 */

class AttributeCommitter {
  constructor(element, name, strings) {
    this.dirty = true;
    this.element = element;
    this.name = name;
    this.strings = strings;
    this.parts = [];

    for (let i = 0; i < strings.length - 1; i++) {
      this.parts[i] = this._createPart();
    }
  }
  /**
   * Creates a single part. Override this to create a differnt type of part.
   */


  _createPart() {
    return new parts_AttributePart(this);
  }

  _getValue() {
    const strings = this.strings;
    const l = strings.length - 1;
    let text = '';

    for (let i = 0; i < l; i++) {
      text += strings[i];
      const part = this.parts[i];

      if (part !== undefined) {
        const v = part.value;

        if (isPrimitive(v) || !isIterable(v)) {
          text += typeof v === 'string' ? v : String(v);
        } else {
          for (const t of v) {
            text += typeof t === 'string' ? t : String(t);
          }
        }
      }
    }

    text += strings[l];
    return text;
  }

  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element.setAttribute(this.name, this._getValue());
    }
  }

}
/**
 * A Part that controls all or part of an attribute value.
 */

class parts_AttributePart {
  constructor(committer) {
    this.value = undefined;
    this.committer = committer;
  }

  setValue(value) {
    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
      this.value = value; // If the value is a not a directive, dirty the committer so that it'll
      // call setAttribute. If the value is a directive, it'll dirty the
      // committer if it calls setValue().

      if (!isDirective(value)) {
        this.committer.dirty = true;
      }
    }
  }

  commit() {
    while (isDirective(this.value)) {
      const directive = this.value;
      this.value = noChange;
      directive(this);
    }

    if (this.value === noChange) {
      return;
    }

    this.committer.commit();
  }

}
/**
 * A Part that controls a location within a Node tree. Like a Range, NodePart
 * has start and end locations and can set and update the Nodes between those
 * locations.
 *
 * NodeParts support several value types: primitives, Nodes, TemplateResults,
 * as well as arrays and iterables of those types.
 */

class parts_NodePart {
  constructor(options) {
    this.value = undefined;
    this.__pendingValue = undefined;
    this.options = options;
  }
  /**
   * Appends this part into a container.
   *
   * This part must be empty, as its contents are not automatically moved.
   */


  appendInto(container) {
    this.startNode = container.appendChild(createMarker());
    this.endNode = container.appendChild(createMarker());
  }
  /**
   * Inserts this part after the `ref` node (between `ref` and `ref`'s next
   * sibling). Both `ref` and its next sibling must be static, unchanging nodes
   * such as those that appear in a literal section of a template.
   *
   * This part must be empty, as its contents are not automatically moved.
   */


  insertAfterNode(ref) {
    this.startNode = ref;
    this.endNode = ref.nextSibling;
  }
  /**
   * Appends this part into a parent part.
   *
   * This part must be empty, as its contents are not automatically moved.
   */


  appendIntoPart(part) {
    part.__insert(this.startNode = createMarker());

    part.__insert(this.endNode = createMarker());
  }
  /**
   * Inserts this part after the `ref` part.
   *
   * This part must be empty, as its contents are not automatically moved.
   */


  insertAfterPart(ref) {
    ref.__insert(this.startNode = createMarker());

    this.endNode = ref.endNode;
    ref.endNode = this.startNode;
  }

  setValue(value) {
    this.__pendingValue = value;
  }

  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive = this.__pendingValue;
      this.__pendingValue = noChange;
      directive(this);
    }

    const value = this.__pendingValue;

    if (value === noChange) {
      return;
    }

    if (isPrimitive(value)) {
      if (value !== this.value) {
        this.__commitText(value);
      }
    } else if (value instanceof template_result_TemplateResult) {
      this.__commitTemplateResult(value);
    } else if (value instanceof Node) {
      this.__commitNode(value);
    } else if (isIterable(value)) {
      this.__commitIterable(value);
    } else if (value === nothing) {
      this.value = nothing;
      this.clear();
    } else {
      // Fallback, will render the string representation
      this.__commitText(value);
    }
  }

  __insert(node) {
    this.endNode.parentNode.insertBefore(node, this.endNode);
  }

  __commitNode(value) {
    if (this.value === value) {
      return;
    }

    this.clear();

    this.__insert(value);

    this.value = value;
  }

  __commitText(value) {
    const node = this.startNode.nextSibling;
    value = value == null ? '' : value; // If `value` isn't already a string, we explicitly convert it here in case
    // it can't be implicitly converted - i.e. it's a symbol.

    const valueAsString = typeof value === 'string' ? value : String(value);

    if (node === this.endNode.previousSibling && node.nodeType === 3
    /* Node.TEXT_NODE */
    ) {
        // If we only have a single text node between the markers, we can just
        // set its value, rather than replacing it.
        // TODO(justinfagnani): Can we just check if this.value is primitive?
        node.data = valueAsString;
      } else {
      this.__commitNode(document.createTextNode(valueAsString));
    }

    this.value = value;
  }

  __commitTemplateResult(value) {
    const template = this.options.templateFactory(value);

    if (this.value instanceof template_instance_TemplateInstance && this.value.template === template) {
      this.value.update(value.values);
    } else {
      // Make sure we propagate the template processor from the TemplateResult
      // so that we use its syntax extension, etc. The template factory comes
      // from the render function options so that it can control template
      // caching and preprocessing.
      const instance = new template_instance_TemplateInstance(template, value.processor, this.options);

      const fragment = instance._clone();

      instance.update(value.values);

      this.__commitNode(fragment);

      this.value = instance;
    }
  }

  __commitIterable(value) {
    // For an Iterable, we create a new InstancePart per item, then set its
    // value to the item. This is a little bit of overhead for every item in
    // an Iterable, but it lets us recurse easily and efficiently update Arrays
    // of TemplateResults that will be commonly returned from expressions like:
    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
    // If _value is an array, then the previous render was of an
    // iterable and _value will contain the NodeParts from the previous
    // render. If _value is not an array, clear this part and make a new
    // array for NodeParts.
    if (!Array.isArray(this.value)) {
      this.value = [];
      this.clear();
    } // Lets us keep track of how many items we stamped so we can clear leftover
    // items from a previous render


    const itemParts = this.value;
    let partIndex = 0;
    let itemPart;

    for (const item of value) {
      // Try to reuse an existing part
      itemPart = itemParts[partIndex]; // If no existing part, create a new one

      if (itemPart === undefined) {
        itemPart = new parts_NodePart(this.options);
        itemParts.push(itemPart);

        if (partIndex === 0) {
          itemPart.appendIntoPart(this);
        } else {
          itemPart.insertAfterPart(itemParts[partIndex - 1]);
        }
      }

      itemPart.setValue(item);
      itemPart.commit();
      partIndex++;
    }

    if (partIndex < itemParts.length) {
      // Truncate the parts array so _value reflects the current state
      itemParts.length = partIndex;
      this.clear(itemPart && itemPart.endNode);
    }
  }

  clear(startNode = this.startNode) {
    removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
  }

}
/**
 * Implements a boolean attribute, roughly as defined in the HTML
 * specification.
 *
 * If the value is truthy, then the attribute is present with a value of
 * ''. If the value is falsey, the attribute is removed.
 */

class parts_BooleanAttributePart {
  constructor(element, name, strings) {
    this.value = undefined;
    this.__pendingValue = undefined;

    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
      throw new Error('Boolean attributes can only contain a single expression');
    }

    this.element = element;
    this.name = name;
    this.strings = strings;
  }

  setValue(value) {
    this.__pendingValue = value;
  }

  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive = this.__pendingValue;
      this.__pendingValue = noChange;
      directive(this);
    }

    if (this.__pendingValue === noChange) {
      return;
    }

    const value = !!this.__pendingValue;

    if (this.value !== value) {
      if (value) {
        this.element.setAttribute(this.name, '');
      } else {
        this.element.removeAttribute(this.name);
      }

      this.value = value;
    }

    this.__pendingValue = noChange;
  }

}
/**
 * Sets attribute values for PropertyParts, so that the value is only set once
 * even if there are multiple parts for a property.
 *
 * If an expression controls the whole property value, then the value is simply
 * assigned to the property under control. If there are string literals or
 * multiple expressions, then the strings are expressions are interpolated into
 * a string first.
 */

class PropertyCommitter extends AttributeCommitter {
  constructor(element, name, strings) {
    super(element, name, strings);
    this.single = strings.length === 2 && strings[0] === '' && strings[1] === '';
  }

  _createPart() {
    return new PropertyPart(this);
  }

  _getValue() {
    if (this.single) {
      return this.parts[0].value;
    }

    return super._getValue();
  }

  commit() {
    if (this.dirty) {
      this.dirty = false; // tslint:disable-next-line:no-any

      this.element[this.name] = this._getValue();
    }
  }

}
class PropertyPart extends parts_AttributePart {} // Detect event listener options support. If the `capture` property is read
// from the options object, then options are supported. If not, then the thrid
// argument to add/removeEventListener is interpreted as the boolean capture
// value so we should only pass the `capture` property.

let eventOptionsSupported = false;

try {
  const options = {
    get capture() {
      eventOptionsSupported = true;
      return false;
    }

  }; // tslint:disable-next-line:no-any

  window.addEventListener('test', options, options); // tslint:disable-next-line:no-any

  window.removeEventListener('test', options, options);
} catch (_e) {}

class parts_EventPart {
  constructor(element, eventName, eventContext) {
    this.value = undefined;
    this.__pendingValue = undefined;
    this.element = element;
    this.eventName = eventName;
    this.eventContext = eventContext;

    this.__boundHandleEvent = e => this.handleEvent(e);
  }

  setValue(value) {
    this.__pendingValue = value;
  }

  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive = this.__pendingValue;
      this.__pendingValue = noChange;
      directive(this);
    }

    if (this.__pendingValue === noChange) {
      return;
    }

    const newListener = this.__pendingValue;
    const oldListener = this.value;
    const shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
    const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);

    if (shouldRemoveListener) {
      this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }

    if (shouldAddListener) {
      this.__options = getOptions(newListener);
      this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }

    this.value = newListener;
    this.__pendingValue = noChange;
  }

  handleEvent(event) {
    if (typeof this.value === 'function') {
      this.value.call(this.eventContext || this.element, event);
    } else {
      this.value.handleEvent(event);
    }
  }

} // We copy options because of the inconsistent behavior of browsers when reading
// the third argument of add/removeEventListener. IE11 doesn't support options
// at all. Chrome 41 only reads `capture` if the argument is an object.

const getOptions = o => o && (eventOptionsSupported ? {
  capture: o.capture,
  passive: o.passive,
  once: o.once
} : o.capture);
// CONCATENATED MODULE: ./node_modules/lit-html/lib/default-template-processor.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * Creates Parts when a template is instantiated.
 */

class default_template_processor_DefaultTemplateProcessor {
  /**
   * Create parts for an attribute-position binding, given the event, attribute
   * name, and string literals.
   *
   * @param element The element containing the binding
   * @param name  The attribute name
   * @param strings The string literals. There are always at least two strings,
   *   event for fully-controlled bindings with a single expression.
   */
  handleAttributeExpressions(element, name, strings, options) {
    const prefix = name[0];

    if (prefix === '.') {
      const committer = new PropertyCommitter(element, name.slice(1), strings);
      return committer.parts;
    }

    if (prefix === '@') {
      return [new parts_EventPart(element, name.slice(1), options.eventContext)];
    }

    if (prefix === '?') {
      return [new parts_BooleanAttributePart(element, name.slice(1), strings)];
    }

    const committer = new AttributeCommitter(element, name, strings);
    return committer.parts;
  }
  /**
   * Create parts for a text-position binding.
   * @param templateFactory
   */


  handleTextExpression(options) {
    return new parts_NodePart(options);
  }

}
const defaultTemplateProcessor = new default_template_processor_DefaultTemplateProcessor();
// CONCATENATED MODULE: ./node_modules/lit-html/lib/template-factory.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * The default TemplateFactory which caches Templates keyed on
 * result.type and result.strings.
 */

function templateFactory(result) {
  let templateCache = templateCaches.get(result.type);

  if (templateCache === undefined) {
    templateCache = {
      stringsArray: new WeakMap(),
      keyString: new Map()
    };
    templateCaches.set(result.type, templateCache);
  }

  let template = templateCache.stringsArray.get(result.strings);

  if (template !== undefined) {
    return template;
  } // If the TemplateStringsArray is new, generate a key from the strings
  // This key is shared between all templates with identical content


  const key = result.strings.join(marker); // Check if we already have a Template for this key

  template = templateCache.keyString.get(key);

  if (template === undefined) {
    // If we have not seen this key before, create a new Template
    template = new Template(result, result.getTemplateElement()); // Cache the Template for this key

    templateCache.keyString.set(key, template);
  } // Cache all future queries for this TemplateStringsArray


  templateCache.stringsArray.set(result.strings, template);
  return template;
}
const templateCaches = new Map();
// CONCATENATED MODULE: ./node_modules/lit-html/lib/render.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * @module lit-html
 */



const render_parts = new WeakMap();
/**
 * Renders a template result or other value to a container.
 *
 * To update a container with new values, reevaluate the template literal and
 * call `render` with the new result.
 *
 * @param result Any value renderable by NodePart - typically a TemplateResult
 *     created by evaluating a template tag like `html` or `svg`.
 * @param container A DOM parent to render to. The entire contents are either
 *     replaced, or efficiently updated if the same result type was previous
 *     rendered there.
 * @param options RenderOptions for the entire render tree rendered to this
 *     container. Render options must *not* change between renders to the same
 *     container, as those changes will not effect previously rendered DOM.
 */

const render = (result, container, options) => {
  let part = render_parts.get(container);

  if (part === undefined) {
    removeNodes(container, container.firstChild);
    render_parts.set(container, part = new parts_NodePart(Object.assign({
      templateFactory: templateFactory
    }, options)));
    part.appendInto(container);
  }

  part.setValue(result);
  part.commit();
};
// CONCATENATED MODULE: ./node_modules/lit-html/lit-html.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 *
 * Main lit-html module.
 *
 * Main exports:
 *
 * -  [[html]]
 * -  [[svg]]
 * -  [[render]]
 *
 * @module lit-html
 * @preferred
 */

/**
 * Do not remove this comment; it keeps typedoc from misplacing the module
 * docs.
 */



 // TODO(justinfagnani): remove line when we get NodePart moving methods








 // IMPORTANT: do not change the property name or the assignment expression.
// This line will be used in regexes to search for lit-html usage.
// TODO(justinfagnani): inject version number at build time

(window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.1.2');
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 */

const lit_html_html = (strings, ...values) => new template_result_TemplateResult(strings, values, 'html', defaultTemplateProcessor);
/**
 * Interprets a template literal as an SVG template that can efficiently
 * render to and update a container.
 */

const svg = (strings, ...values) => new template_result_SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);
// CONCATENATED MODULE: ./node_modules/lit-html/lib/modify-template.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * @module shady-render
 */

const walkerNodeFilter = 133
/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */
;
/**
 * Removes the list of nodes from a Template safely. In addition to removing
 * nodes from the Template, the Template part indices are updated to match
 * the mutated Template DOM.
 *
 * As the template is walked the removal state is tracked and
 * part indices are adjusted as needed.
 *
 * div
 *   div#1 (remove) <-- start removing (removing node is div#1)
 *     div
 *       div#2 (remove)  <-- continue removing (removing node is still div#1)
 *         div
 * div <-- stop removing since previous sibling is the removing node (div#1,
 * removed 4 nodes)
 */

function removeNodesFromTemplate(template, nodesToRemove) {
  const {
    element: {
      content
    },
    parts
  } = template;
  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts);
  let part = parts[partIndex];
  let nodeIndex = -1;
  let removeCount = 0;
  const nodesToRemoveInTemplate = [];
  let currentRemovingNode = null;

  while (walker.nextNode()) {
    nodeIndex++;
    const node = walker.currentNode; // End removal if stepped past the removing node

    if (node.previousSibling === currentRemovingNode) {
      currentRemovingNode = null;
    } // A node to remove was found in the template


    if (nodesToRemove.has(node)) {
      nodesToRemoveInTemplate.push(node); // Track node we're removing

      if (currentRemovingNode === null) {
        currentRemovingNode = node;
      }
    } // When removing, increment count by which to adjust subsequent part indices


    if (currentRemovingNode !== null) {
      removeCount++;
    }

    while (part !== undefined && part.index === nodeIndex) {
      // If part is in a removed node deactivate it by setting index to -1 or
      // adjust the index as needed.
      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount; // go to the next active part.

      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
      part = parts[partIndex];
    }
  }

  nodesToRemoveInTemplate.forEach(n => n.parentNode.removeChild(n));
}

const countNodes = node => {
  let count = node.nodeType === 11
  /* Node.DOCUMENT_FRAGMENT_NODE */
  ? 0 : 1;
  const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);

  while (walker.nextNode()) {
    count++;
  }

  return count;
};

const nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {
  for (let i = startIndex + 1; i < parts.length; i++) {
    const part = parts[i];

    if (isTemplatePartActive(part)) {
      return i;
    }
  }

  return -1;
};
/**
 * Inserts the given node into the Template, optionally before the given
 * refNode. In addition to inserting the node into the Template, the Template
 * part indices are updated to match the mutated Template DOM.
 */


function insertNodeIntoTemplate(template, node, refNode = null) {
  const {
    element: {
      content
    },
    parts
  } = template; // If there's no refNode, then put node at end of template.
  // No part indices need to be shifted in this case.

  if (refNode === null || refNode === undefined) {
    content.appendChild(node);
    return;
  }

  const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);
  let partIndex = nextActiveIndexInTemplateParts(parts);
  let insertCount = 0;
  let walkerIndex = -1;

  while (walker.nextNode()) {
    walkerIndex++;
    const walkerNode = walker.currentNode;

    if (walkerNode === refNode) {
      insertCount = countNodes(node);
      refNode.parentNode.insertBefore(node, refNode);
    }

    while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {
      // If we've inserted the node, simply adjust all subsequent parts
      if (insertCount > 0) {
        while (partIndex !== -1) {
          parts[partIndex].index += insertCount;
          partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
        }

        return;
      }

      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);
    }
  }
}
// CONCATENATED MODULE: ./node_modules/lit-html/lib/shady-render.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * Module to add shady DOM/shady CSS polyfill support to lit-html template
 * rendering. See the [[render]] method for details.
 *
 * @module shady-render
 * @preferred
 */

/**
 * Do not remove this comment; it keeps typedoc from misplacing the module
 * docs.
 */






 // Get a key to lookup in `templateCaches`.

const getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;

let compatibleShadyCSSVersion = true;

if (typeof window.ShadyCSS === 'undefined') {
  compatibleShadyCSSVersion = false;
} else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {
  console.warn(`Incompatible ShadyCSS version detected. ` + `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` + `@webcomponents/shadycss@1.3.1.`);
  compatibleShadyCSSVersion = false;
}
/**
 * Template factory which scopes template DOM using ShadyCSS.
 * @param scopeName {string}
 */


const shadyTemplateFactory = scopeName => result => {
  const cacheKey = getTemplateCacheKey(result.type, scopeName);
  let templateCache = templateCaches.get(cacheKey);

  if (templateCache === undefined) {
    templateCache = {
      stringsArray: new WeakMap(),
      keyString: new Map()
    };
    templateCaches.set(cacheKey, templateCache);
  }

  let template = templateCache.stringsArray.get(result.strings);

  if (template !== undefined) {
    return template;
  }

  const key = result.strings.join(marker);
  template = templateCache.keyString.get(key);

  if (template === undefined) {
    const element = result.getTemplateElement();

    if (compatibleShadyCSSVersion) {
      window.ShadyCSS.prepareTemplateDom(element, scopeName);
    }

    template = new Template(result, element);
    templateCache.keyString.set(key, template);
  }

  templateCache.stringsArray.set(result.strings, template);
  return template;
};

const TEMPLATE_TYPES = ['html', 'svg'];
/**
 * Removes all style elements from Templates for the given scopeName.
 */

const removeStylesFromLitTemplates = scopeName => {
  TEMPLATE_TYPES.forEach(type => {
    const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));

    if (templates !== undefined) {
      templates.keyString.forEach(template => {
        const {
          element: {
            content
          }
        } = template; // IE 11 doesn't support the iterable param Set constructor

        const styles = new Set();
        Array.from(content.querySelectorAll('style')).forEach(s => {
          styles.add(s);
        });
        removeNodesFromTemplate(template, styles);
      });
    }
  });
};

const shadyRenderSet = new Set();
/**
 * For the given scope name, ensures that ShadyCSS style scoping is performed.
 * This is done just once per scope name so the fragment and template cannot
 * be modified.
 * (1) extracts styles from the rendered fragment and hands them to ShadyCSS
 * to be scoped and appended to the document
 * (2) removes style elements from all lit-html Templates for this scope name.
 *
 * Note, <style> elements can only be placed into templates for the
 * initial rendering of the scope. If <style> elements are included in templates
 * dynamically rendered to the scope (after the first scope render), they will
 * not be scoped and the <style> will be left in the template and rendered
 * output.
 */

const prepareTemplateStyles = (scopeName, renderedDOM, template) => {
  shadyRenderSet.add(scopeName); // If `renderedDOM` is stamped from a Template, then we need to edit that
  // Template's underlying template element. Otherwise, we create one here
  // to give to ShadyCSS, which still requires one while scoping.

  const templateElement = !!template ? template.element : document.createElement('template'); // Move styles out of rendered DOM and store.

  const styles = renderedDOM.querySelectorAll('style');
  const {
    length
  } = styles; // If there are no styles, skip unnecessary work

  if (length === 0) {
    // Ensure prepareTemplateStyles is called to support adding
    // styles via `prepareAdoptedCssText` since that requires that
    // `prepareTemplateStyles` is called.
    //
    // ShadyCSS will only update styles containing @apply in the template
    // given to `prepareTemplateStyles`. If no lit Template was given,
    // ShadyCSS will not be able to update uses of @apply in any relevant
    // template. However, this is not a problem because we only create the
    // template for the purpose of supporting `prepareAdoptedCssText`,
    // which doesn't support @apply at all.
    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
    return;
  }

  const condensedStyle = document.createElement('style'); // Collect styles into a single style. This helps us make sure ShadyCSS
  // manipulations will not prevent us from being able to fix up template
  // part indices.
  // NOTE: collecting styles is inefficient for browsers but ShadyCSS
  // currently does this anyway. When it does not, this should be changed.

  for (let i = 0; i < length; i++) {
    const style = styles[i];
    style.parentNode.removeChild(style);
    condensedStyle.textContent += style.textContent;
  } // Remove styles from nested templates in this scope.


  removeStylesFromLitTemplates(scopeName); // And then put the condensed style into the "root" template passed in as
  // `template`.

  const content = templateElement.content;

  if (!!template) {
    insertNodeIntoTemplate(template, condensedStyle, content.firstChild);
  } else {
    content.insertBefore(condensedStyle, content.firstChild);
  } // Note, it's important that ShadyCSS gets the template that `lit-html`
  // will actually render so that it can update the style inside when
  // needed (e.g. @apply native Shadow DOM case).


  window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);
  const style = content.querySelector('style');

  if (window.ShadyCSS.nativeShadow && style !== null) {
    // When in native Shadow DOM, ensure the style created by ShadyCSS is
    // included in initially rendered output (`renderedDOM`).
    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);
  } else if (!!template) {
    // When no style is left in the template, parts will be broken as a
    // result. To fix this, we put back the style node ShadyCSS removed
    // and then tell lit to remove that node from the template.
    // There can be no style in the template in 2 cases (1) when Shady DOM
    // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM
    // is in use ShadyCSS removes the style if it contains no content.
    // NOTE, ShadyCSS creates its own style so we can safely add/remove
    // `condensedStyle` here.
    content.insertBefore(condensedStyle, content.firstChild);
    const removes = new Set();
    removes.add(condensedStyle);
    removeNodesFromTemplate(template, removes);
  }
};
/**
 * Extension to the standard `render` method which supports rendering
 * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)
 * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used
 * or when the webcomponentsjs
 * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.
 *
 * Adds a `scopeName` option which is used to scope element DOM and stylesheets
 * when native ShadowDOM is unavailable. The `scopeName` will be added to
 * the class attribute of all rendered DOM. In addition, any style elements will
 * be automatically re-written with this `scopeName` selector and moved out
 * of the rendered DOM and into the document `<head>`.
 *
 * It is common to use this render method in conjunction with a custom element
 * which renders a shadowRoot. When this is done, typically the element's
 * `localName` should be used as the `scopeName`.
 *
 * In addition to DOM scoping, ShadyCSS also supports a basic shim for css
 * custom properties (needed only on older browsers like IE11) and a shim for
 * a deprecated feature called `@apply` that supports applying a set of css
 * custom properties to a given location.
 *
 * Usage considerations:
 *
 * * Part values in `<style>` elements are only applied the first time a given
 * `scopeName` renders. Subsequent changes to parts in style elements will have
 * no effect. Because of this, parts in style elements should only be used for
 * values that will never change, for example parts that set scope-wide theme
 * values or parts which render shared style elements.
 *
 * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a
 * custom element's `constructor` is not supported. Instead rendering should
 * either done asynchronously, for example at microtask timing (for example
 * `Promise.resolve()`), or be deferred until the first time the element's
 * `connectedCallback` runs.
 *
 * Usage considerations when using shimmed custom properties or `@apply`:
 *
 * * Whenever any dynamic changes are made which affect
 * css custom properties, `ShadyCSS.styleElement(element)` must be called
 * to update the element. There are two cases when this is needed:
 * (1) the element is connected to a new parent, (2) a class is added to the
 * element that causes it to match different custom properties.
 * To address the first case when rendering a custom element, `styleElement`
 * should be called in the element's `connectedCallback`.
 *
 * * Shimmed custom properties may only be defined either for an entire
 * shadowRoot (for example, in a `:host` rule) or via a rule that directly
 * matches an element with a shadowRoot. In other words, instead of flowing from
 * parent to child as do native css custom properties, shimmed custom properties
 * flow only from shadowRoots to nested shadowRoots.
 *
 * * When using `@apply` mixing css shorthand property names with
 * non-shorthand names (for example `border` and `border-width`) is not
 * supported.
 */


const shady_render_render = (result, container, options) => {
  if (!options || typeof options !== 'object' || !options.scopeName) {
    throw new Error('The `scopeName` option is required.');
  }

  const scopeName = options.scopeName;
  const hasRendered = render_parts.has(container);
  const needsScoping = compatibleShadyCSSVersion && container.nodeType === 11
  /* Node.DOCUMENT_FRAGMENT_NODE */
  && !!container.host; // Handle first render to a scope specially...

  const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName); // On first scope render, render into a fragment; this cannot be a single
  // fragment that is reused since nested renders can occur synchronously.

  const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;
  render(result, renderContainer, Object.assign({
    templateFactory: shadyTemplateFactory(scopeName)
  }, options)); // When performing first scope render,
  // (1) We've rendered into a fragment so that there's a chance to
  // `prepareTemplateStyles` before sub-elements hit the DOM
  // (which might cause them to render based on a common pattern of
  // rendering in a custom element's `connectedCallback`);
  // (2) Scope the template with ShadyCSS one time only for this scope.
  // (3) Render the fragment into the container and make sure the
  // container knows its `part` is the one we just rendered. This ensures
  // DOM will be re-used on subsequent renders.

  if (firstScopeRender) {
    const part = render_parts.get(renderContainer);
    render_parts.delete(renderContainer); // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)
    // that should apply to `renderContainer` even if the rendered value is
    // not a TemplateInstance. However, it will only insert scoped styles
    // into the document if `prepareTemplateStyles` has already been called
    // for the given scope name.

    const template = part.value instanceof template_instance_TemplateInstance ? part.value.template : undefined;
    prepareTemplateStyles(scopeName, renderContainer, template);
    removeNodes(container, container.firstChild);
    container.appendChild(renderContainer);
    render_parts.set(container, part);
  } // After elements have hit the DOM, update styling if this is the
  // initial render to this container.
  // This is needed whenever dynamic changes are made so it would be
  // safest to do every render; however, this would regress performance
  // so we leave it up to the user to call `ShadyCSS.styleElement`
  // for dynamic changes.


  if (!hasRendered && needsScoping) {
    window.ShadyCSS.styleElement(container.host);
  }
};
// CONCATENATED MODULE: ./node_modules/lit-element/lib/updating-element.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var updating_element_a;
/**
 * When using Closure Compiler, JSCompiler_renameProperty(property, object) is
 * replaced at compile time by the munged name for object[property]. We cannot
 * alias this function, so we have to use a small shim that has the same
 * behavior when not compiling.
 */


window.JSCompiler_renameProperty = (prop, _obj) => prop;

const defaultConverter = {
  toAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value ? '' : null;

      case Object:
      case Array:
        // if the value is `null` or `undefined` pass this through
        // to allow removing/no change behavior.
        return value == null ? value : JSON.stringify(value);
    }

    return value;
  },

  fromAttribute(value, type) {
    switch (type) {
      case Boolean:
        return value !== null;

      case Number:
        return value === null ? null : Number(value);

      case Object:
      case Array:
        return JSON.parse(value);
    }

    return value;
  }

};
/**
 * Change function that returns true if `value` is different from `oldValue`.
 * This method is used as the default for a property's `hasChanged` function.
 */

const notEqual = (value, old) => {
  // This ensures (old==NaN, value==NaN) always returns false
  return old !== value && (old === old || value === value);
};
const defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
const microtaskPromise = Promise.resolve(true);
const STATE_HAS_UPDATED = 1;
const STATE_UPDATE_REQUESTED = 1 << 2;
const STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;
const STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;
const STATE_HAS_CONNECTED = 1 << 5;
/**
 * The Closure JS Compiler doesn't currently have good support for static
 * property semantics where "this" is dynamic (e.g.
 * https://github.com/google/closure-compiler/issues/3177 and others) so we use
 * this hack to bypass any rewriting by the compiler.
 */

const finalized = 'finalized';
/**
 * Base element class which manages element properties and attributes. When
 * properties change, the `update` method is asynchronously called. This method
 * should be supplied by subclassers to render updates as desired.
 */

class UpdatingElement extends HTMLElement {
  constructor() {
    super();
    this._updateState = 0;
    this._instanceProperties = undefined;
    this._updatePromise = microtaskPromise;
    this._hasConnectedResolver = undefined;
    /**
     * Map with keys for any properties that have changed since the last
     * update cycle with previous values.
     */

    this._changedProperties = new Map();
    /**
     * Map with keys of properties that should be reflected when updated.
     */

    this._reflectingProperties = undefined;
    this.initialize();
  }
  /**
   * Returns a list of attributes corresponding to the registered properties.
   * @nocollapse
   */


  static get observedAttributes() {
    // note: piggy backing on this to ensure we're finalized.
    this.finalize();
    const attributes = []; // Use forEach so this works even if for/of loops are compiled to for loops
    // expecting arrays

    this._classProperties.forEach((v, p) => {
      const attr = this._attributeNameForProperty(p, v);

      if (attr !== undefined) {
        this._attributeToPropertyMap.set(attr, p);

        attributes.push(attr);
      }
    });

    return attributes;
  }
  /**
   * Ensures the private `_classProperties` property metadata is created.
   * In addition to `finalize` this is also called in `createProperty` to
   * ensure the `@property` decorator can add property metadata.
   */

  /** @nocollapse */


  static _ensureClassProperties() {
    // ensure private storage for property declarations.
    if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {
      this._classProperties = new Map(); // NOTE: Workaround IE11 not supporting Map constructor argument.

      const superProperties = Object.getPrototypeOf(this)._classProperties;

      if (superProperties !== undefined) {
        superProperties.forEach((v, k) => this._classProperties.set(k, v));
      }
    }
  }
  /**
   * Creates a property accessor on the element prototype if one does not exist.
   * The property setter calls the property's `hasChanged` property option
   * or uses a strict identity check to determine whether or not to request
   * an update.
   * @nocollapse
   */


  static createProperty(name, options = defaultPropertyDeclaration) {
    // Note, since this can be called by the `@property` decorator which
    // is called before `finalize`, we ensure storage exists for property
    // metadata.
    this._ensureClassProperties();

    this._classProperties.set(name, options); // Do not generate an accessor if the prototype already has one, since
    // it would be lost otherwise and that would never be the user's intention;
    // Instead, we expect users to call `requestUpdate` themselves from
    // user-defined accessors. Note that if the super has an accessor we will
    // still overwrite it


    if (options.noAccessor || this.prototype.hasOwnProperty(name)) {
      return;
    }

    const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
    Object.defineProperty(this.prototype, name, {
      // tslint:disable-next-line:no-any no symbol in index
      get() {
        return this[key];
      },

      set(value) {
        const oldValue = this[name];
        this[key] = value;

        this._requestUpdate(name, oldValue);
      },

      configurable: true,
      enumerable: true
    });
  }
  /**
   * Creates property accessors for registered properties and ensures
   * any superclasses are also finalized.
   * @nocollapse
   */


  static finalize() {
    // finalize any superclasses
    const superCtor = Object.getPrototypeOf(this);

    if (!superCtor.hasOwnProperty(finalized)) {
      superCtor.finalize();
    }

    this[finalized] = true;

    this._ensureClassProperties(); // initialize Map populated in observedAttributes


    this._attributeToPropertyMap = new Map(); // make any properties
    // Note, only process "own" properties since this element will inherit
    // any properties defined on the superClass, and finalization ensures
    // the entire prototype chain is finalized.

    if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {
      const props = this.properties; // support symbols in properties (IE11 does not support this)

      const propKeys = [...Object.getOwnPropertyNames(props), ...(typeof Object.getOwnPropertySymbols === 'function' ? Object.getOwnPropertySymbols(props) : [])]; // This for/of is ok because propKeys is an array

      for (const p of propKeys) {
        // note, use of `any` is due to TypeSript lack of support for symbol in
        // index types
        // tslint:disable-next-line:no-any no symbol in index
        this.createProperty(p, props[p]);
      }
    }
  }
  /**
   * Returns the property name for the given attribute `name`.
   * @nocollapse
   */


  static _attributeNameForProperty(name, options) {
    const attribute = options.attribute;
    return attribute === false ? undefined : typeof attribute === 'string' ? attribute : typeof name === 'string' ? name.toLowerCase() : undefined;
  }
  /**
   * Returns true if a property should request an update.
   * Called when a property value is set and uses the `hasChanged`
   * option for the property if present or a strict identity check.
   * @nocollapse
   */


  static _valueHasChanged(value, old, hasChanged = notEqual) {
    return hasChanged(value, old);
  }
  /**
   * Returns the property value for the given attribute value.
   * Called via the `attributeChangedCallback` and uses the property's
   * `converter` or `converter.fromAttribute` property option.
   * @nocollapse
   */


  static _propertyValueFromAttribute(value, options) {
    const type = options.type;
    const converter = options.converter || defaultConverter;
    const fromAttribute = typeof converter === 'function' ? converter : converter.fromAttribute;
    return fromAttribute ? fromAttribute(value, type) : value;
  }
  /**
   * Returns the attribute value for the given property value. If this
   * returns undefined, the property will *not* be reflected to an attribute.
   * If this returns null, the attribute will be removed, otherwise the
   * attribute will be set to the value.
   * This uses the property's `reflect` and `type.toAttribute` property options.
   * @nocollapse
   */


  static _propertyValueToAttribute(value, options) {
    if (options.reflect === undefined) {
      return;
    }

    const type = options.type;
    const converter = options.converter;
    const toAttribute = converter && converter.toAttribute || defaultConverter.toAttribute;
    return toAttribute(value, type);
  }
  /**
   * Performs element initialization. By default captures any pre-set values for
   * registered properties.
   */


  initialize() {
    this._saveInstanceProperties(); // ensures first update will be caught by an early access of
    // `updateComplete`


    this._requestUpdate();
  }
  /**
   * Fixes any properties set on the instance before upgrade time.
   * Otherwise these would shadow the accessor and break these properties.
   * The properties are stored in a Map which is played back after the
   * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
   * (<=41), properties created for native platform properties like (`id` or
   * `name`) may not have default values set in the element constructor. On
   * these browsers native properties appear on instances and therefore their
   * default value will overwrite any element default (e.g. if the element sets
   * this.id = 'id' in the constructor, the 'id' will become '' since this is
   * the native platform default).
   */


  _saveInstanceProperties() {
    // Use forEach so this works even if for/of loops are compiled to for loops
    // expecting arrays
    this.constructor._classProperties.forEach((_v, p) => {
      if (this.hasOwnProperty(p)) {
        const value = this[p];
        delete this[p];

        if (!this._instanceProperties) {
          this._instanceProperties = new Map();
        }

        this._instanceProperties.set(p, value);
      }
    });
  }
  /**
   * Applies previously saved instance properties.
   */


  _applyInstanceProperties() {
    // Use forEach so this works even if for/of loops are compiled to for loops
    // expecting arrays
    // tslint:disable-next-line:no-any
    this._instanceProperties.forEach((v, p) => this[p] = v);

    this._instanceProperties = undefined;
  }

  connectedCallback() {
    this._updateState = this._updateState | STATE_HAS_CONNECTED; // Ensure first connection completes an update. Updates cannot complete
    // before connection and if one is pending connection the
    // `_hasConnectionResolver` will exist. If so, resolve it to complete the
    // update, otherwise requestUpdate.

    if (this._hasConnectedResolver) {
      this._hasConnectedResolver();

      this._hasConnectedResolver = undefined;
    }
  }
  /**
   * Allows for `super.disconnectedCallback()` in extensions while
   * reserving the possibility of making non-breaking feature additions
   * when disconnecting at some point in the future.
   */


  disconnectedCallback() {}
  /**
   * Synchronizes property values when attributes change.
   */


  attributeChangedCallback(name, old, value) {
    if (old !== value) {
      this._attributeToProperty(name, value);
    }
  }

  _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {
    const ctor = this.constructor;

    const attr = ctor._attributeNameForProperty(name, options);

    if (attr !== undefined) {
      const attrValue = ctor._propertyValueToAttribute(value, options); // an undefined value does not change the attribute.


      if (attrValue === undefined) {
        return;
      } // Track if the property is being reflected to avoid
      // setting the property again via `attributeChangedCallback`. Note:
      // 1. this takes advantage of the fact that the callback is synchronous.
      // 2. will behave incorrectly if multiple attributes are in the reaction
      // stack at time of calling. However, since we process attributes
      // in `update` this should not be possible (or an extreme corner case
      // that we'd like to discover).
      // mark state reflecting


      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;

      if (attrValue == null) {
        this.removeAttribute(attr);
      } else {
        this.setAttribute(attr, attrValue);
      } // mark state not reflecting


      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;
    }
  }

  _attributeToProperty(name, value) {
    // Use tracking info to avoid deserializing attribute value if it was
    // just set from a property setter.
    if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {
      return;
    }

    const ctor = this.constructor;

    const propName = ctor._attributeToPropertyMap.get(name);

    if (propName !== undefined) {
      const options = ctor._classProperties.get(propName) || defaultPropertyDeclaration; // mark state reflecting

      this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;
      this[propName] = // tslint:disable-next-line:no-any
      ctor._propertyValueFromAttribute(value, options); // mark state not reflecting

      this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;
    }
  }
  /**
   * This private version of `requestUpdate` does not access or return the
   * `updateComplete` promise. This promise can be overridden and is therefore
   * not free to access.
   */


  _requestUpdate(name, oldValue) {
    let shouldRequestUpdate = true; // If we have a property key, perform property update steps.

    if (name !== undefined) {
      const ctor = this.constructor;
      const options = ctor._classProperties.get(name) || defaultPropertyDeclaration;

      if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {
        if (!this._changedProperties.has(name)) {
          this._changedProperties.set(name, oldValue);
        } // Add to reflecting properties set.
        // Note, it's important that every change has a chance to add the
        // property to `_reflectingProperties`. This ensures setting
        // attribute + property reflects correctly.


        if (options.reflect === true && !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {
          if (this._reflectingProperties === undefined) {
            this._reflectingProperties = new Map();
          }

          this._reflectingProperties.set(name, options);
        }
      } else {
        // Abort the request if the property should not be considered changed.
        shouldRequestUpdate = false;
      }
    }

    if (!this._hasRequestedUpdate && shouldRequestUpdate) {
      this._enqueueUpdate();
    }
  }
  /**
   * Requests an update which is processed asynchronously. This should
   * be called when an element should update based on some state not triggered
   * by setting a property. In this case, pass no arguments. It should also be
   * called when manually implementing a property setter. In this case, pass the
   * property `name` and `oldValue` to ensure that any configured property
   * options are honored. Returns the `updateComplete` Promise which is resolved
   * when the update completes.
   *
   * @param name {PropertyKey} (optional) name of requesting property
   * @param oldValue {any} (optional) old value of requesting property
   * @returns {Promise} A Promise that is resolved when the update completes.
   */


  requestUpdate(name, oldValue) {
    this._requestUpdate(name, oldValue);

    return this.updateComplete;
  }
  /**
   * Sets up the element to asynchronously update.
   */


  async _enqueueUpdate() {
    // Mark state updating...
    this._updateState = this._updateState | STATE_UPDATE_REQUESTED;
    let resolve;
    let reject;
    const previousUpdatePromise = this._updatePromise;
    this._updatePromise = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });

    try {
      // Ensure any previous update has resolved before updating.
      // This `await` also ensures that property changes are batched.
      await previousUpdatePromise;
    } catch (e) {} // Ignore any previous errors. We only care that the previous cycle is
    // done. Any error should have been handled in the previous update.
    // Make sure the element has connected before updating.


    if (!this._hasConnected) {
      await new Promise(res => this._hasConnectedResolver = res);
    }

    try {
      const result = this.performUpdate(); // If `performUpdate` returns a Promise, we await it. This is done to
      // enable coordinating updates with a scheduler. Note, the result is
      // checked to avoid delaying an additional microtask unless we need to.

      if (result != null) {
        await result;
      }
    } catch (e) {
      reject(e);
    }

    resolve(!this._hasRequestedUpdate);
  }

  get _hasConnected() {
    return this._updateState & STATE_HAS_CONNECTED;
  }

  get _hasRequestedUpdate() {
    return this._updateState & STATE_UPDATE_REQUESTED;
  }

  get hasUpdated() {
    return this._updateState & STATE_HAS_UPDATED;
  }
  /**
   * Performs an element update. Note, if an exception is thrown during the
   * update, `firstUpdated` and `updated` will not be called.
   *
   * You can override this method to change the timing of updates. If this
   * method is overridden, `super.performUpdate()` must be called.
   *
   * For instance, to schedule updates to occur just before the next frame:
   *
   * ```
   * protected async performUpdate(): Promise<unknown> {
   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
   *   super.performUpdate();
   * }
   * ```
   */


  performUpdate() {
    // Mixin instance properties once, if they exist.
    if (this._instanceProperties) {
      this._applyInstanceProperties();
    }

    let shouldUpdate = false;
    const changedProperties = this._changedProperties;

    try {
      shouldUpdate = this.shouldUpdate(changedProperties);

      if (shouldUpdate) {
        this.update(changedProperties);
      }
    } catch (e) {
      // Prevent `firstUpdated` and `updated` from running when there's an
      // update exception.
      shouldUpdate = false;
      throw e;
    } finally {
      // Ensure element can accept additional updates after an exception.
      this._markUpdated();
    }

    if (shouldUpdate) {
      if (!(this._updateState & STATE_HAS_UPDATED)) {
        this._updateState = this._updateState | STATE_HAS_UPDATED;
        this.firstUpdated(changedProperties);
      }

      this.updated(changedProperties);
    }
  }

  _markUpdated() {
    this._changedProperties = new Map();
    this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;
  }
  /**
   * Returns a Promise that resolves when the element has completed updating.
   * The Promise value is a boolean that is `true` if the element completed the
   * update without triggering another update. The Promise result is `false` if
   * a property was set inside `updated()`. If the Promise is rejected, an
   * exception was thrown during the update.
   *
   * To await additional asynchronous work, override the `_getUpdateComplete`
   * method. For example, it is sometimes useful to await a rendered element
   * before fulfilling this Promise. To do this, first await
   * `super._getUpdateComplete()`, then any subsequent state.
   *
   * @returns {Promise} The Promise returns a boolean that indicates if the
   * update resolved without triggering another update.
   */


  get updateComplete() {
    return this._getUpdateComplete();
  }
  /**
   * Override point for the `updateComplete` promise.
   *
   * It is not safe to override the `updateComplete` getter directly due to a
   * limitation in TypeScript which means it is not possible to call a
   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
   * This method should be overridden instead. For example:
   *
   *   class MyElement extends LitElement {
   *     async _getUpdateComplete() {
   *       await super._getUpdateComplete();
   *       await this._myChild.updateComplete;
   *     }
   *   }
   */


  _getUpdateComplete() {
    return this._updatePromise;
  }
  /**
   * Controls whether or not `update` should be called when the element requests
   * an update. By default, this method always returns `true`, but this can be
   * customized to control when to update.
   *
   * * @param _changedProperties Map of changed properties with old values
   */


  shouldUpdate(_changedProperties) {
    return true;
  }
  /**
   * Updates the element. This method reflects property values to attributes.
   * It can be overridden to render and keep updated element DOM.
   * Setting properties inside this method will *not* trigger
   * another update.
   *
   * * @param _changedProperties Map of changed properties with old values
   */


  update(_changedProperties) {
    if (this._reflectingProperties !== undefined && this._reflectingProperties.size > 0) {
      // Use forEach so this works even if for/of loops are compiled to for
      // loops expecting arrays
      this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));

      this._reflectingProperties = undefined;
    }
  }
  /**
   * Invoked whenever the element is updated. Implement to perform
   * post-updating tasks via DOM APIs, for example, focusing an element.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * * @param _changedProperties Map of changed properties with old values
   */


  updated(_changedProperties) {}
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * * @param _changedProperties Map of changed properties with old values
   */


  firstUpdated(_changedProperties) {}

}
updating_element_a = finalized;
/**
 * Marks class as having finished creating properties.
 */

UpdatingElement[updating_element_a] = true;
// CONCATENATED MODULE: ./node_modules/lit-element/lib/decorators.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
const legacyCustomElement = (tagName, clazz) => {
  window.customElements.define(tagName, clazz); // Cast as any because TS doesn't recognize the return type as being a
  // subtype of the decorated class when clazz is typed as
  // `Constructor<HTMLElement>` for some reason.
  // `Constructor<HTMLElement>` is helpful to make sure the decorator is
  // applied to elements however.
  // tslint:disable-next-line:no-any

  return clazz;
};

const standardCustomElement = (tagName, descriptor) => {
  const {
    kind,
    elements
  } = descriptor;
  return {
    kind,
    elements,

    // This callback is called once the class is otherwise fully defined
    finisher(clazz) {
      window.customElements.define(tagName, clazz);
    }

  };
};
/**
 * Class decorator factory that defines the decorated class as a custom element.
 *
 * @param tagName the name of the custom element to define
 */


const customElement = tagName => classOrDescriptor => typeof classOrDescriptor === 'function' ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);

const standardProperty = (options, element) => {
  // When decorating an accessor, pass it through and add property metadata.
  // Note, the `hasOwnProperty` check in `createProperty` ensures we don't
  // stomp over the user's accessor.
  if (element.kind === 'method' && element.descriptor && !('value' in element.descriptor)) {
    return Object.assign({}, element, {
      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }

    });
  } else {
    // createProperty() takes care of defining the property, but we still
    // must return some kind of descriptor, so return a descriptor for an
    // unused prototype field. The finisher calls createProperty().
    return {
      kind: 'field',
      key: Symbol(),
      placement: 'own',
      descriptor: {},

      // When @babel/plugin-proposal-decorators implements initializers,
      // do this instead of the initializer below. See:
      // https://github.com/babel/babel/issues/9260 extras: [
      //   {
      //     kind: 'initializer',
      //     placement: 'own',
      //     initializer: descriptor.initializer,
      //   }
      // ],
      initializer() {
        if (typeof element.initializer === 'function') {
          this[element.key] = element.initializer.call(this);
        }
      },

      finisher(clazz) {
        clazz.createProperty(element.key, options);
      }

    };
  }
};

const legacyProperty = (options, proto, name) => {
  proto.constructor.createProperty(name, options);
};
/**
 * A property decorator which creates a LitElement property which reflects a
 * corresponding attribute value. A `PropertyDeclaration` may optionally be
 * supplied to configure property features.
 *
 * @ExportDecoratedItems
 */


function property(options) {
  // tslint:disable-next-line:no-any decorator
  return (protoOrDescriptor, name) => name !== undefined ? legacyProperty(options, protoOrDescriptor, name) : standardProperty(options, protoOrDescriptor);
}
/**
 * A property decorator that converts a class property into a getter that
 * executes a querySelector on the element's renderRoot.
 *
 * @ExportDecoratedItems
 */

function decorators_query(selector) {
  return (protoOrDescriptor, // tslint:disable-next-line:no-any decorator
  name) => {
    const descriptor = {
      get() {
        return this.renderRoot.querySelector(selector);
      },

      enumerable: true,
      configurable: true
    };
    return name !== undefined ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
  };
}
/**
 * A property decorator that converts a class property into a getter
 * that executes a querySelectorAll on the element's renderRoot.
 *
 * @ExportDecoratedItems
 */

function queryAll(selector) {
  return (protoOrDescriptor, // tslint:disable-next-line:no-any decorator
  name) => {
    const descriptor = {
      get() {
        return this.renderRoot.querySelectorAll(selector);
      },

      enumerable: true,
      configurable: true
    };
    return name !== undefined ? legacyQuery(descriptor, protoOrDescriptor, name) : standardQuery(descriptor, protoOrDescriptor);
  };
}

const legacyQuery = (descriptor, proto, name) => {
  Object.defineProperty(proto, name, descriptor);
};

const standardQuery = (descriptor, element) => ({
  kind: 'method',
  placement: 'prototype',
  key: element.key,
  descriptor
});

const standardEventOptions = (options, element) => {
  return Object.assign({}, element, {
    finisher(clazz) {
      Object.assign(clazz.prototype[element.key], options);
    }

  });
};

const legacyEventOptions = // tslint:disable-next-line:no-any legacy decorator
(options, proto, name) => {
  Object.assign(proto[name], options);
};
/**
 * Adds event listener options to a method used as an event listener in a
 * lit-html template.
 *
 * @param options An object that specifis event listener options as accepted by
 * `EventTarget#addEventListener` and `EventTarget#removeEventListener`.
 *
 * Current browsers support the `capture`, `passive`, and `once` options. See:
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters
 *
 * @example
 *
 *     class MyElement {
 *
 *       clicked = false;
 *
 *       render() {
 *         return html`<div @click=${this._onClick}`><button></button></div>`;
 *       }
 *
 *       @eventOptions({capture: true})
 *       _onClick(e) {
 *         this.clicked = true;
 *       }
 *     }
 */


const eventOptions = options => // Return value typed as any to prevent TypeScript from complaining that
// standard decorator function signature does not match TypeScript decorator
// signature
// TODO(kschaaf): unclear why it was only failing on this decorator and not
// the others
(protoOrDescriptor, name) => name !== undefined ? legacyEventOptions(options, protoOrDescriptor, name) : standardEventOptions(options, protoOrDescriptor);
// CONCATENATED MODULE: ./node_modules/lit-element/lib/css-tag.js
/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
const supportsAdoptingStyleSheets = 'adoptedStyleSheets' in Document.prototype && 'replace' in CSSStyleSheet.prototype;
const constructionToken = Symbol();
class CSSResult {
  constructor(cssText, safeToken) {
    if (safeToken !== constructionToken) {
      throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');
    }

    this.cssText = cssText;
  } // Note, this is a getter so that it's lazy. In practice, this means
  // stylesheets are not created until the first element instance is made.


  get styleSheet() {
    if (this._styleSheet === undefined) {
      // Note, if `adoptedStyleSheets` is supported then we assume CSSStyleSheet
      // is constructable.
      if (supportsAdoptingStyleSheets) {
        this._styleSheet = new CSSStyleSheet();

        this._styleSheet.replaceSync(this.cssText);
      } else {
        this._styleSheet = null;
      }
    }

    return this._styleSheet;
  }

  toString() {
    return this.cssText;
  }

}
/**
 * Wrap a value for interpolation in a css tagged template literal.
 *
 * This is unsafe because untrusted CSS text can be used to phone home
 * or exfiltrate data to an attacker controlled site. Take care to only use
 * this with trusted input.
 */

const unsafeCSS = value => {
  return new CSSResult(String(value), constructionToken);
};

const textFromCSSResult = value => {
  if (value instanceof CSSResult) {
    return value.cssText;
  } else if (typeof value === 'number') {
    return value;
  } else {
    throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but
            take care to ensure page security.`);
  }
};
/**
 * Template tag which which can be used with LitElement's `style` property to
 * set element styles. For security reasons, only literal string values may be
 * used. To incorporate non-literal values `unsafeCSS` may be used inside a
 * template string part.
 */


const css = (strings, ...values) => {
  const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);
  return new CSSResult(cssText, constructionToken);
};
// CONCATENATED MODULE: ./node_modules/lit-element/lit-element.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */







 // IMPORTANT: do not change the property name or the assignment expression.
// This line will be used in regexes to search for LitElement usage.
// TODO(justinfagnani): inject version number at build time

(window['litElementVersions'] || (window['litElementVersions'] = [])).push('2.2.1');
/**
 * Minimal implementation of Array.prototype.flat
 * @param arr the array to flatten
 * @param result the accumlated result
 */

function arrayFlat(styles, result = []) {
  for (let i = 0, length = styles.length; i < length; i++) {
    const value = styles[i];

    if (Array.isArray(value)) {
      arrayFlat(value, result);
    } else {
      result.push(value);
    }
  }

  return result;
}
/** Deeply flattens styles array. Uses native flat if available. */


const flattenStyles = styles => styles.flat ? styles.flat(Infinity) : arrayFlat(styles);

class lit_element_LitElement extends UpdatingElement {
  /** @nocollapse */
  static finalize() {
    // The Closure JS Compiler does not always preserve the correct "this"
    // when calling static super methods (b/137460243), so explicitly bind.
    super.finalize.call(this); // Prepare styling that is stamped at first render time. Styling
    // is built from user provided `styles` or is inherited from the superclass.

    this._styles = this.hasOwnProperty(JSCompiler_renameProperty('styles', this)) ? this._getUniqueStyles() : this._styles || [];
  }
  /** @nocollapse */


  static _getUniqueStyles() {
    // Take care not to call `this.styles` multiple times since this generates
    // new CSSResults each time.
    // TODO(sorvell): Since we do not cache CSSResults by input, any
    // shared styles will generate new stylesheet objects, which is wasteful.
    // This should be addressed when a browser ships constructable
    // stylesheets.
    const userStyles = this.styles;
    const styles = [];

    if (Array.isArray(userStyles)) {
      const flatStyles = flattenStyles(userStyles); // As a performance optimization to avoid duplicated styling that can
      // occur especially when composing via subclassing, de-duplicate styles
      // preserving the last item in the list. The last item is kept to
      // try to preserve cascade order with the assumption that it's most
      // important that last added styles override previous styles.

      const styleSet = flatStyles.reduceRight((set, s) => {
        set.add(s); // on IE set.add does not return the set.

        return set;
      }, new Set()); // Array.from does not work on Set in IE

      styleSet.forEach(v => styles.unshift(v));
    } else if (userStyles) {
      styles.push(userStyles);
    }

    return styles;
  }
  /**
   * Performs element initialization. By default this calls `createRenderRoot`
   * to create the element `renderRoot` node and captures any pre-set values for
   * registered properties.
   */


  initialize() {
    super.initialize();
    this.renderRoot = this.createRenderRoot(); // Note, if renderRoot is not a shadowRoot, styles would/could apply to the
    // element's getRootNode(). While this could be done, we're choosing not to
    // support this now since it would require different logic around de-duping.

    if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {
      this.adoptStyles();
    }
  }
  /**
   * Returns the node into which the element should render and by default
   * creates and returns an open shadowRoot. Implement to customize where the
   * element's DOM is rendered. For example, to render into the element's
   * childNodes, return `this`.
   * @returns {Element|DocumentFragment} Returns a node into which to render.
   */


  createRenderRoot() {
    return this.attachShadow({
      mode: 'open'
    });
  }
  /**
   * Applies styling to the element shadowRoot using the `static get styles`
   * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
   * available and will fallback otherwise. When Shadow DOM is polyfilled,
   * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
   * is available but `adoptedStyleSheets` is not, styles are appended to the
   * end of the `shadowRoot` to [mimic spec
   * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
   */


  adoptStyles() {
    const styles = this.constructor._styles;

    if (styles.length === 0) {
      return;
    } // There are three separate cases here based on Shadow DOM support.
    // (1) shadowRoot polyfilled: use ShadyCSS
    // (2) shadowRoot.adoptedStyleSheets available: use it.
    // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
    // rendering


    if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {
      window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map(s => s.cssText), this.localName);
    } else if (supportsAdoptingStyleSheets) {
      this.renderRoot.adoptedStyleSheets = styles.map(s => s.styleSheet);
    } else {
      // This must be done after rendering so the actual style insertion is done
      // in `update`.
      this._needsShimAdoptedStyleSheets = true;
    }
  }

  connectedCallback() {
    super.connectedCallback(); // Note, first update/render handles styleElement so we only call this if
    // connected after first update.

    if (this.hasUpdated && window.ShadyCSS !== undefined) {
      window.ShadyCSS.styleElement(this);
    }
  }
  /**
   * Updates the element. This method reflects property values to attributes
   * and calls `render` to render DOM via lit-html. Setting properties inside
   * this method will *not* trigger another update.
   * * @param _changedProperties Map of changed properties with old values
   */


  update(changedProperties) {
    super.update(changedProperties);
    const templateResult = this.render();

    if (templateResult instanceof template_result_TemplateResult) {
      this.constructor.render(templateResult, this.renderRoot, {
        scopeName: this.localName,
        eventContext: this
      });
    } // When native Shadow DOM is used but adoptedStyles are not supported,
    // insert styling after rendering to ensure adoptedStyles have highest
    // priority.


    if (this._needsShimAdoptedStyleSheets) {
      this._needsShimAdoptedStyleSheets = false;

      this.constructor._styles.forEach(s => {
        const style = document.createElement('style');
        style.textContent = s.cssText;
        this.renderRoot.appendChild(style);
      });
    }
  }
  /**
   * Invoked on each update to perform rendering tasks. This method must return
   * a lit-html TemplateResult. Setting properties inside this method will *not*
   * trigger the element to update.
   */


  render() {}

}
/**
 * Ensure this class is marked as `finalized` as an optimization ensuring
 * it will not needlessly try to `finalize`.
 *
 * Note this property name is a string to prevent breaking Closure JS Compiler
 * optimizations. See updating-element.ts for more information.
 */

lit_element_LitElement['finalized'] = true;
/**
 * Render method used to render the lit-html TemplateResult to the element's
 * DOM.
 * @param {TemplateResult} Template to render.
 * @param {Element|DocumentFragment} Node into which to render.
 * @param {String} Element name.
 * @nocollapse
 */

lit_element_LitElement.render = shady_render_render;
// CONCATENATED MODULE: ./src/config.js
const INSTANCE_NAME = '__learning-pathways';
const ZOME_NAME = 'courses';
const HOST_URL = undefined;
const USERNAME = undefined;
// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(1);

// CONCATENATED MODULE: ./node_modules/@material/top-app-bar/constants.js
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses = {
  FIXED_CLASS: 'mdc-top-app-bar--fixed',
  FIXED_SCROLLED_CLASS: 'mdc-top-app-bar--fixed-scrolled',
  SHORT_CLASS: 'mdc-top-app-bar--short',
  SHORT_COLLAPSED_CLASS: 'mdc-top-app-bar--short-collapsed',
  SHORT_HAS_ACTION_ITEM_CLASS: 'mdc-top-app-bar--short-has-action-item'
};
var numbers = {
  DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
  MAX_TOP_APP_BAR_HEIGHT: 128
};
var constants_strings = {
  ACTION_ITEM_SELECTOR: '.mdc-top-app-bar__action-item',
  NAVIGATION_EVENT: 'MDCTopAppBar:nav',
  NAVIGATION_ICON_SELECTOR: '.mdc-top-app-bar__navigation-icon',
  ROOT_SELECTOR: '.mdc-top-app-bar',
  TITLE_SELECTOR: '.mdc-top-app-bar__title'
};

// CONCATENATED MODULE: ./node_modules/@material/top-app-bar/node_modules/@material/base/foundation.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFoundation =
/** @class */
function () {
  function MDCFoundation(adapter) {
    if (adapter === void 0) {
      adapter = {};
    }

    this.adapter_ = adapter;
  }

  Object.defineProperty(MDCFoundation, "cssClasses", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "strings", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "numbers", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "defaultAdapter", {
    get: function get() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    },
    enumerable: true,
    configurable: true
  });

  MDCFoundation.prototype.init = function () {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  };

  MDCFoundation.prototype.destroy = function () {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  };

  return MDCFoundation;
}();

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var base_foundation = (MDCFoundation);
// CONCATENATED MODULE: ./node_modules/@material/top-app-bar/foundation.js
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */




var foundation_MDCTopAppBarBaseFoundation =
/** @class */
function (_super) {
  tslib_es6["d" /* __extends */](MDCTopAppBarBaseFoundation, _super);
  /* istanbul ignore next: optional argument is not a branch statement */


  function MDCTopAppBarBaseFoundation(adapter) {
    return _super.call(this, tslib_es6["a" /* __assign */]({}, MDCTopAppBarBaseFoundation.defaultAdapter, adapter)) || this;
  }

  Object.defineProperty(MDCTopAppBarBaseFoundation, "strings", {
    get: function get() {
      return constants_strings;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCTopAppBarBaseFoundation, "cssClasses", {
    get: function get() {
      return cssClasses;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCTopAppBarBaseFoundation, "numbers", {
    get: function get() {
      return numbers;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCTopAppBarBaseFoundation, "defaultAdapter", {
    /**
     * See {@link MDCTopAppBarAdapter} for typing information on parameters and return types.
     */
    get: function get() {
      // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
      return {
        addClass: function addClass() {
          return undefined;
        },
        removeClass: function removeClass() {
          return undefined;
        },
        hasClass: function hasClass() {
          return false;
        },
        setStyle: function setStyle() {
          return undefined;
        },
        getTopAppBarHeight: function getTopAppBarHeight() {
          return 0;
        },
        notifyNavigationIconClicked: function notifyNavigationIconClicked() {
          return undefined;
        },
        getViewportScrollY: function getViewportScrollY() {
          return 0;
        },
        getTotalActionItems: function getTotalActionItems() {
          return 0;
        }
      }; // tslint:enable:object-literal-sort-keys
    },
    enumerable: true,
    configurable: true
  });
  /** Other variants of TopAppBar foundation overrides this method */

  MDCTopAppBarBaseFoundation.prototype.handleTargetScroll = function () {}; // tslint:disable-line:no-empty

  /** Other variants of TopAppBar foundation overrides this method */


  MDCTopAppBarBaseFoundation.prototype.handleWindowResize = function () {}; // tslint:disable-line:no-empty


  MDCTopAppBarBaseFoundation.prototype.handleNavigationClick = function () {
    this.adapter_.notifyNavigationIconClicked();
  };

  return MDCTopAppBarBaseFoundation;
}(MDCFoundation);

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var top_app_bar_foundation = (foundation_MDCTopAppBarBaseFoundation);
// CONCATENATED MODULE: ./node_modules/@material/top-app-bar/standard/foundation.js
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



var INITIAL_VALUE = 0;

var foundation_MDCTopAppBarFoundation =
/** @class */
function (_super) {
  tslib_es6["d" /* __extends */](MDCTopAppBarFoundation, _super);
  /* istanbul ignore next: optional argument is not a branch statement */


  function MDCTopAppBarFoundation(adapter) {
    var _this = _super.call(this, adapter) || this;
    /**
     * Indicates if the top app bar was docked in the previous scroll handler iteration.
     */


    _this.wasDocked_ = true;
    /**
     * Indicates if the top app bar is docked in the fully shown position.
     */

    _this.isDockedShowing_ = true;
    /**
     * Variable for current scroll position of the top app bar
     */

    _this.currentAppBarOffsetTop_ = 0;
    /**
     * Used to prevent the top app bar from being scrolled out of view during resize events
     */

    _this.isCurrentlyBeingResized_ = false;
    /**
     * The timeout that's used to throttle the resize events
     */

    _this.resizeThrottleId_ = INITIAL_VALUE;
    /**
     * The timeout that's used to debounce toggling the isCurrentlyBeingResized_ variable after a resize
     */

    _this.resizeDebounceId_ = INITIAL_VALUE;
    _this.lastScrollPosition_ = _this.adapter_.getViewportScrollY();
    _this.topAppBarHeight_ = _this.adapter_.getTopAppBarHeight();
    return _this;
  }

  MDCTopAppBarFoundation.prototype.destroy = function () {
    _super.prototype.destroy.call(this);

    this.adapter_.setStyle('top', '');
  };
  /**
   * Scroll handler for the default scroll behavior of the top app bar.
   * @override
   */


  MDCTopAppBarFoundation.prototype.handleTargetScroll = function () {
    var currentScrollPosition = Math.max(this.adapter_.getViewportScrollY(), 0);
    var diff = currentScrollPosition - this.lastScrollPosition_;
    this.lastScrollPosition_ = currentScrollPosition; // If the window is being resized the lastScrollPosition_ needs to be updated but the
    // current scroll of the top app bar should stay in the same position.

    if (!this.isCurrentlyBeingResized_) {
      this.currentAppBarOffsetTop_ -= diff;

      if (this.currentAppBarOffsetTop_ > 0) {
        this.currentAppBarOffsetTop_ = 0;
      } else if (Math.abs(this.currentAppBarOffsetTop_) > this.topAppBarHeight_) {
        this.currentAppBarOffsetTop_ = -this.topAppBarHeight_;
      }

      this.moveTopAppBar_();
    }
  };
  /**
   * Top app bar resize handler that throttle/debounce functions that execute updates.
   * @override
   */


  MDCTopAppBarFoundation.prototype.handleWindowResize = function () {
    var _this = this; // Throttle resize events 10 p/s


    if (!this.resizeThrottleId_) {
      this.resizeThrottleId_ = setTimeout(function () {
        _this.resizeThrottleId_ = INITIAL_VALUE;

        _this.throttledResizeHandler_();
      }, numbers.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
    }

    this.isCurrentlyBeingResized_ = true;

    if (this.resizeDebounceId_) {
      clearTimeout(this.resizeDebounceId_);
    }

    this.resizeDebounceId_ = setTimeout(function () {
      _this.handleTargetScroll();

      _this.isCurrentlyBeingResized_ = false;
      _this.resizeDebounceId_ = INITIAL_VALUE;
    }, numbers.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
  };
  /**
   * Function to determine if the DOM needs to update.
   */


  MDCTopAppBarFoundation.prototype.checkForUpdate_ = function () {
    var offscreenBoundaryTop = -this.topAppBarHeight_;
    var hasAnyPixelsOffscreen = this.currentAppBarOffsetTop_ < 0;
    var hasAnyPixelsOnscreen = this.currentAppBarOffsetTop_ > offscreenBoundaryTop;
    var partiallyShowing = hasAnyPixelsOffscreen && hasAnyPixelsOnscreen; // If it's partially showing, it can't be docked.

    if (partiallyShowing) {
      this.wasDocked_ = false;
    } else {
      // Not previously docked and not partially showing, it's now docked.
      if (!this.wasDocked_) {
        this.wasDocked_ = true;
        return true;
      } else if (this.isDockedShowing_ !== hasAnyPixelsOnscreen) {
        this.isDockedShowing_ = hasAnyPixelsOnscreen;
        return true;
      }
    }

    return partiallyShowing;
  };
  /**
   * Function to move the top app bar if needed.
   */


  MDCTopAppBarFoundation.prototype.moveTopAppBar_ = function () {
    if (this.checkForUpdate_()) {
      // Once the top app bar is fully hidden we use the max potential top app bar height as our offset
      // so the top app bar doesn't show if the window resizes and the new height > the old height.
      var offset = this.currentAppBarOffsetTop_;

      if (Math.abs(offset) >= this.topAppBarHeight_) {
        offset = -numbers.MAX_TOP_APP_BAR_HEIGHT;
      }

      this.adapter_.setStyle('top', offset + 'px');
    }
  };
  /**
   * Throttled function that updates the top app bar scrolled values if the
   * top app bar height changes.
   */


  MDCTopAppBarFoundation.prototype.throttledResizeHandler_ = function () {
    var currentHeight = this.adapter_.getTopAppBarHeight();

    if (this.topAppBarHeight_ !== currentHeight) {
      this.wasDocked_ = false; // Since the top app bar has a different height depending on the screen width, this
      // will ensure that the top app bar remains in the correct location if
      // completely hidden and a resize makes the top app bar a different height.

      this.currentAppBarOffsetTop_ -= this.topAppBarHeight_ - currentHeight;
      this.topAppBarHeight_ = currentHeight;
    }

    this.handleTargetScroll();
  };

  return MDCTopAppBarFoundation;
}(foundation_MDCTopAppBarBaseFoundation);

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var standard_foundation = (foundation_MDCTopAppBarFoundation);
// CONCATENATED MODULE: ./node_modules/@material/mwc-base/observer.js
const observer_observer = observer => // eslint-disable-next-line @typescript-eslint/no-explicit-any
(proto, propName) => {
  // if we haven't wrapped `updated` in this class, do so
  if (!proto.constructor._observers) {
    proto.constructor._observers = new Map();
    const userUpdated = proto.updated;

    proto.updated = function (changedProperties) {
      userUpdated.call(this, changedProperties);
      changedProperties.forEach((v, k) => {
        const observer = this.constructor._observers.get(k);

        if (observer !== undefined) {
          observer.call(this, this[k], v);
        }
      });
    }; // clone any existing observers (superclasses)

  } else if (!proto.constructor.hasOwnProperty('_observers')) {
    const observers = proto.constructor._observers;
    proto.constructor._observers = new Map();
    observers.forEach( // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (v, k) => proto.constructor._observers.set(k, v));
  } // set this method


  proto.constructor._observers.set(propName, observer);
};
// CONCATENATED MODULE: ./node_modules/@material/mwc-base/node_modules/@material/dom/ponyfill.js
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
 * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
 */
function closest(element, selector) {
  if (element.closest) {
    return element.closest(selector);
  }

  var el = element;

  while (el) {
    if (ponyfill_matches(el, selector)) {
      return el;
    }

    el = el.parentElement;
  }

  return null;
}
function ponyfill_matches(element, selector) {
  var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
  return nativeMatches.call(element, selector);
}
/**
 * Used to compute the estimated scroll width of elements. When an element is
 * hidden due to display: none; being applied to a parent element, the width is
 * returned as 0. However, the element will have a true width once no longer
 * inside a display: none context. This method computes an estimated width when
 * the element is hidden or returns the true width when the element is visble.
 * @param {Element} element the element whose width to estimate
 */

function estimateScrollWidth(element) {
  // Check the offsetParent. If the element inherits display: none from any
  // parent, the offsetParent property will be null (see
  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent).
  // This check ensures we only clone the node when necessary.
  var htmlEl = element;

  if (htmlEl.offsetParent !== null) {
    return htmlEl.scrollWidth;
  }

  var clone = htmlEl.cloneNode(true);
  clone.style.setProperty('position', 'absolute');
  clone.style.setProperty('transform', 'translate(-9999px, -9999px)');
  document.documentElement.appendChild(clone);
  var scrollWidth = clone.scrollWidth;
  document.documentElement.removeChild(clone);
  return scrollWidth;
}
// CONCATENATED MODULE: ./node_modules/@material/mwc-base/utils.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * Return an element assigned to a given slot that matches the given selector
 */

/**
 * Determines whether a node is an element.
 *
 * @param node Node to check
 */

const isNodeElement = node => {
  return node.nodeType === Node.ELEMENT_NODE;
};
function findAssignedElement(slot, selector) {
  for (const node of slot.assignedNodes({
    flatten: true
  })) {
    if (isNodeElement(node)) {
      const el = node;

      if (ponyfill_matches(el, selector)) {
        return el;
      }
    }
  }

  return null;
}
function addHasRemoveClass(element) {
  return {
    addClass: className => {
      element.classList.add(className);
    },
    removeClass: className => {
      element.classList.remove(className);
    },
    hasClass: className => element.classList.contains(className)
  };
}
let supportsPassive = false;

const fn = () => {};

const optionsBlock = {
  get passive() {
    supportsPassive = true;
    return false;
  }

};
document.addEventListener('x', fn, optionsBlock);
document.removeEventListener('x', fn);
/**
 * Do event listeners suport the `passive` option?
 */

const supportsPassiveEventListener = supportsPassive;
const deepActiveElementPath = (doc = window.document) => {
  let activeElement = doc.activeElement;
  const path = [];

  if (!activeElement) {
    return path;
  }

  while (activeElement) {
    path.push(activeElement);

    if (activeElement.shadowRoot) {
      activeElement = activeElement.shadowRoot.activeElement;
    } else {
      break;
    }
  }

  return path;
};
const doesElementContainFocus = element => {
  const activePath = deepActiveElementPath();

  if (!activePath.length) {
    return false;
  }

  const deepActiveElement = activePath[activePath.length - 1];
  const focusEv = new Event('check-if-focused', {
    bubbles: true,
    composed: true
  });
  let composedPath = [];

  const listener = ev => {
    composedPath = ev.composedPath();
  };

  document.body.addEventListener('check-if-focused', listener);
  deepActiveElement.dispatchEvent(focusEv);
  document.body.removeEventListener('check-if-focused', listener);
  return composedPath.indexOf(element) !== -1;
};
// CONCATENATED MODULE: ./node_modules/@material/mwc-base/base-element.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/



class base_element_BaseElement extends lit_element_LitElement {
  /**
   * Create and attach the MDC Foundation to the instance
   */
  createFoundation() {
    if (this.mdcFoundation !== undefined) {
      this.mdcFoundation.destroy();
    }

    this.mdcFoundation = new this.mdcFoundationClass(this.createAdapter());
    this.mdcFoundation.init();
  }

  firstUpdated() {
    this.createFoundation();
  }

}
// CONCATENATED MODULE: ./node_modules/lit-html/directives/class-map.js
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * Stores the ClassInfo object applied to a given AttributePart.
 * Used to unset existing values when a new ClassInfo object is applied.
 */

const classMapCache = new WeakMap();
/**
 * A directive that applies CSS classes. This must be used in the `class`
 * attribute and must be the only part used in the attribute. It takes each
 * property in the `classInfo` argument and adds the property name to the
 * element's `classList` if the property value is truthy; if the property value
 * is falsey, the property name is removed from the element's `classList`. For
 * example
 * `{foo: bar}` applies the class `foo` if the value of `bar` is truthy.
 * @param classInfo {ClassInfo}
 */

const classMap = directive_directive(classInfo => part => {
  if (!(part instanceof parts_AttributePart) || part instanceof PropertyPart || part.committer.name !== 'class' || part.committer.parts.length > 1) {
    throw new Error('The `classMap` directive must be used in the `class` attribute ' + 'and must be the only part in the attribute.');
  }

  const {
    committer
  } = part;
  const {
    element
  } = committer; // handle static classes

  if (!classMapCache.has(part)) {
    element.className = committer.strings.join(' ');
  }

  const {
    classList
  } = element; // remove old classes that no longer apply

  const oldInfo = classMapCache.get(part);

  for (const name in oldInfo) {
    if (!(name in classInfo)) {
      classList.remove(name);
    }
  } // add new classes


  for (const name in classInfo) {
    const value = classInfo[name];

    if (!oldInfo || value !== oldInfo[name]) {
      // We explicitly want a loose truthy check here because
      // it seems more convenient that '' and 0 are skipped.
      const method = value ? 'add' : 'remove';
      classList[method](name);
    }
  }

  classMapCache.set(part, classInfo);
});
// CONCATENATED MODULE: ./node_modules/@material/mwc-top-app-bar/mwc-top-app-bar-base-base.js

/**
@license
Copyright 2019 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/







const passiveEventOptionsIfSupported = supportsPassiveEventListener ? {
  passive: true
} : undefined;
class mwc_top_app_bar_base_base_TopAppBarBaseBase extends base_element_BaseElement {
  constructor() {
    super(...arguments);
    this.mdcFoundationClass = top_app_bar_foundation;
    this.centerTitle = false;

    this.handleTargetScroll = () => {
      this.mdcFoundation.handleTargetScroll();
    };

    this.handleNavigationClick = () => {
      this.mdcFoundation.handleNavigationClick();
    };
  }

  get scrollTarget() {
    return this._scrollTarget || window;
  }

  set scrollTarget(value) {
    const old = this.scrollTarget;
    this._scrollTarget = value;
    this.updateRootPosition();
    this.requestUpdate('scrollTarget', old);
  }

  updateRootPosition() {
    if (this.mdcRoot) {
      const windowScroller = this.scrollTarget === window; // we add support for top-app-bar's tied to an element scroller.

      this.mdcRoot.style.position = windowScroller ? '' : 'absolute';
    }
  }

  render() {
    // clang-format off
    let title = lit_html_html`<span class="mdc-top-app-bar__title"><slot name="title"></slot></span>`;

    if (this.centerTitle) {
      title = lit_html_html`<section class="mdc-top-app-bar__section mdc-top-app-bar__section--align-center">${title}</section>`;
    } // clang-format on


    return lit_html_html`
      <header class="mdc-top-app-bar ${classMap(this.barClasses())}">
      <div class="mdc-top-app-bar__row">
        <section class="mdc-top-app-bar__section mdc-top-app-bar__section--align-start" id="navigation">
          <slot name="navigationIcon"
            @click=${this.handleNavigationClick}></slot>
          ${this.centerTitle ? null : title}
        </section>
        ${this.centerTitle ? title : null}
        <section class="mdc-top-app-bar__section mdc-top-app-bar__section--align-end" id="actions" role="toolbar">
          <slot name="actionItems"></slot>
        </section>
      </div>
    </header>
    <div class="${classMap(this.contentClasses())}">
      <slot></slot>
    </div>
    `;
  }

  createAdapter() {
    return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), {
      setStyle: (property, value) => this.mdcRoot.style.setProperty(property, value),
      getTopAppBarHeight: () => this.mdcRoot.clientHeight,
      notifyNavigationIconClicked: () => {
        this.dispatchEvent(new Event(constants_strings.NAVIGATION_EVENT, {
          bubbles: true,
          cancelable: true
        }));
      },
      getViewportScrollY: () => this.scrollTarget instanceof Window ? this.scrollTarget.pageYOffset : this.scrollTarget.scrollTop,
      getTotalActionItems: () => this._actionItemsSlot.assignedNodes({
        flatten: true
      }).length
    });
  }

  registerListeners() {
    this.scrollTarget.addEventListener('scroll', this.handleTargetScroll, passiveEventOptionsIfSupported);
  }

  unregisterListeners() {
    this.scrollTarget.removeEventListener('scroll', this.handleTargetScroll);
  }

  firstUpdated() {
    super.firstUpdated();
    this.updateRootPosition();
    this.registerListeners();
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this.unregisterListeners();
  }

}

Object(tslib_es6["c" /* __decorate */])([decorators_query('.mdc-top-app-bar')], mwc_top_app_bar_base_base_TopAppBarBaseBase.prototype, "mdcRoot", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('slot[name="actionItems"]')], mwc_top_app_bar_base_base_TopAppBarBaseBase.prototype, "_actionItemsSlot", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_top_app_bar_base_base_TopAppBarBaseBase.prototype, "centerTitle", void 0);

Object(tslib_es6["c" /* __decorate */])([property()], mwc_top_app_bar_base_base_TopAppBarBaseBase.prototype, "scrollTarget", null);
// CONCATENATED MODULE: ./node_modules/@material/mwc-top-app-bar/mwc-top-app-bar-base.js

/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




class mwc_top_app_bar_base_TopAppBarBase extends mwc_top_app_bar_base_base_TopAppBarBaseBase {
  constructor() {
    super(...arguments);
    this.mdcFoundationClass = standard_foundation;
    this.prominent = false;
    this.dense = false;

    this.handleResize = () => {
      this.mdcFoundation.handleWindowResize();
    };
  }

  barClasses() {
    return {
      'mdc-top-app-bar--dense': this.dense,
      'mdc-top-app-bar--prominent': this.prominent,
      'center-title': this.centerTitle
    };
  }

  contentClasses() {
    return {
      'mdc-top-app-bar--fixed-adjust': !this.dense && !this.prominent,
      'mdc-top-app-bar--dense-fixed-adjust': this.dense && !this.prominent,
      'mdc-top-app-bar--prominent-fixed-adjust': !this.dense && this.prominent,
      'mdc-top-app-bar--dense-prominent-fixed-adjust': this.dense && this.prominent
    };
  }

  registerListeners() {
    super.registerListeners();
    window.addEventListener('resize', this.handleResize, passiveEventOptionsIfSupported);
  }

  unregisterListeners() {
    super.unregisterListeners();
    window.removeEventListener('resize', this.handleResize);
  }

}

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
})], mwc_top_app_bar_base_TopAppBarBase.prototype, "prominent", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
})], mwc_top_app_bar_base_TopAppBarBase.prototype, "dense", void 0);
// CONCATENATED MODULE: ./node_modules/@material/mwc-top-app-bar/mwc-top-app-bar-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_top_app_bar_css_style = css`.mdc-top-app-bar{background-color:#6200ee;background-color:var(--mdc-theme-primary, #6200ee);color:#fff;display:flex;position:fixed;flex-direction:column;justify-content:space-between;box-sizing:border-box;width:100%;z-index:4}.mdc-top-app-bar .mdc-top-app-bar__action-item,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon{color:#fff;color:var(--mdc-theme-on-primary, #fff)}.mdc-top-app-bar .mdc-top-app-bar__action-item::before,.mdc-top-app-bar .mdc-top-app-bar__action-item::after,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon::before,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon::after{background-color:#fff;background-color:var(--mdc-theme-on-primary, #fff)}.mdc-top-app-bar .mdc-top-app-bar__action-item:hover::before,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon:hover::before{opacity:.08}.mdc-top-app-bar .mdc-top-app-bar__action-item.mdc-ripple-upgraded--background-focused::before,.mdc-top-app-bar .mdc-top-app-bar__action-item:not(.mdc-ripple-upgraded):focus::before,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon.mdc-ripple-upgraded--background-focused::before,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:.24}.mdc-top-app-bar .mdc-top-app-bar__action-item:not(.mdc-ripple-upgraded)::after,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-top-app-bar .mdc-top-app-bar__action-item:not(.mdc-ripple-upgraded):active::after,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:.24}.mdc-top-app-bar .mdc-top-app-bar__action-item.mdc-ripple-upgraded,.mdc-top-app-bar .mdc-top-app-bar__navigation-icon.mdc-ripple-upgraded{--mdc-ripple-fg-opacity: 0.24}.mdc-top-app-bar__row{display:flex;position:relative;box-sizing:border-box;width:100%;height:64px}.mdc-top-app-bar__section{display:inline-flex;flex:1 1 auto;align-items:center;min-width:0;padding:8px 12px;z-index:1}.mdc-top-app-bar__section--align-start{justify-content:flex-start;order:-1}.mdc-top-app-bar__section--align-end{justify-content:flex-end;order:1}.mdc-top-app-bar__title{font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:1.25rem;line-height:2rem;font-weight:500;letter-spacing:.0125em;text-decoration:inherit;text-transform:inherit;padding-left:20px;padding-right:0;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;z-index:1}[dir=rtl] .mdc-top-app-bar__title,.mdc-top-app-bar__title[dir=rtl]{padding-left:0;padding-right:20px}.mdc-top-app-bar--short-collapsed{border-radius:0 0 24px 0}[dir=rtl] .mdc-top-app-bar--short-collapsed,.mdc-top-app-bar--short-collapsed[dir=rtl]{border-radius:0 0 0 24px}.mdc-top-app-bar--short{top:0;right:auto;left:0;width:100%;transition:width 250ms cubic-bezier(0.4, 0, 0.2, 1)}[dir=rtl] .mdc-top-app-bar--short,.mdc-top-app-bar--short[dir=rtl]{right:0;left:auto}.mdc-top-app-bar--short .mdc-top-app-bar__row{height:56px}.mdc-top-app-bar--short .mdc-top-app-bar__section{padding:4px}.mdc-top-app-bar--short .mdc-top-app-bar__title{transition:opacity 200ms cubic-bezier(0.4, 0, 0.2, 1);opacity:1}.mdc-top-app-bar--short-collapsed{box-shadow:0px 2px 4px -1px rgba(0, 0, 0, 0.2),0px 4px 5px 0px rgba(0, 0, 0, 0.14),0px 1px 10px 0px rgba(0,0,0,.12);width:56px;transition:width 300ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-top-app-bar--short-collapsed .mdc-top-app-bar__title{display:none}.mdc-top-app-bar--short-collapsed .mdc-top-app-bar__action-item{transition:padding 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-top-app-bar--short-collapsed.mdc-top-app-bar--short-has-action-item{width:112px}.mdc-top-app-bar--short-collapsed.mdc-top-app-bar--short-has-action-item .mdc-top-app-bar__section--align-end{padding-left:0;padding-right:12px}[dir=rtl] .mdc-top-app-bar--short-collapsed.mdc-top-app-bar--short-has-action-item .mdc-top-app-bar__section--align-end,.mdc-top-app-bar--short-collapsed.mdc-top-app-bar--short-has-action-item .mdc-top-app-bar__section--align-end[dir=rtl]{padding-left:12px;padding-right:0}.mdc-top-app-bar--dense .mdc-top-app-bar__row{height:48px}.mdc-top-app-bar--dense .mdc-top-app-bar__section{padding:0 4px}.mdc-top-app-bar--dense .mdc-top-app-bar__title{padding-left:12px;padding-right:0}[dir=rtl] .mdc-top-app-bar--dense .mdc-top-app-bar__title,.mdc-top-app-bar--dense .mdc-top-app-bar__title[dir=rtl]{padding-left:0;padding-right:12px}.mdc-top-app-bar--prominent .mdc-top-app-bar__row{height:128px}.mdc-top-app-bar--prominent .mdc-top-app-bar__title{align-self:flex-end;padding-bottom:2px}.mdc-top-app-bar--prominent .mdc-top-app-bar__action-item,.mdc-top-app-bar--prominent .mdc-top-app-bar__navigation-icon{align-self:flex-start}.mdc-top-app-bar--fixed{transition:box-shadow 200ms linear}.mdc-top-app-bar--fixed-scrolled{box-shadow:0px 2px 4px -1px rgba(0, 0, 0, 0.2),0px 4px 5px 0px rgba(0, 0, 0, 0.14),0px 1px 10px 0px rgba(0,0,0,.12);transition:box-shadow 200ms linear}.mdc-top-app-bar--dense.mdc-top-app-bar--prominent .mdc-top-app-bar__row{height:96px}.mdc-top-app-bar--dense.mdc-top-app-bar--prominent .mdc-top-app-bar__section{padding:0 12px}.mdc-top-app-bar--dense.mdc-top-app-bar--prominent .mdc-top-app-bar__title{padding-left:20px;padding-right:0;padding-bottom:9px}[dir=rtl] .mdc-top-app-bar--dense.mdc-top-app-bar--prominent .mdc-top-app-bar__title,.mdc-top-app-bar--dense.mdc-top-app-bar--prominent .mdc-top-app-bar__title[dir=rtl]{padding-left:0;padding-right:20px}.mdc-top-app-bar--fixed-adjust{padding-top:64px}.mdc-top-app-bar--dense-fixed-adjust{padding-top:48px}.mdc-top-app-bar--short-fixed-adjust{padding-top:56px}.mdc-top-app-bar--prominent-fixed-adjust{padding-top:128px}.mdc-top-app-bar--dense-prominent-fixed-adjust{padding-top:96px}@media(max-width: 599px){.mdc-top-app-bar__row{height:56px}.mdc-top-app-bar__section{padding:4px}.mdc-top-app-bar--short{transition:width 200ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-top-app-bar--short-collapsed{transition:width 250ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-top-app-bar--short-collapsed .mdc-top-app-bar__section--align-end{padding-left:0;padding-right:12px}[dir=rtl] .mdc-top-app-bar--short-collapsed .mdc-top-app-bar__section--align-end,.mdc-top-app-bar--short-collapsed .mdc-top-app-bar__section--align-end[dir=rtl]{padding-left:12px;padding-right:0}.mdc-top-app-bar--prominent .mdc-top-app-bar__title{padding-bottom:6px}.mdc-top-app-bar--fixed-adjust{padding-top:56px}}:host{display:block}.mdc-top-app-bar{color:#fff;color:var(--mdc-theme-on-primary, #fff)}.mdc-top-app-bar--prominent #navigation ::slotted(*),.mdc-top-app-bar--prominent #actions ::slotted(*){align-self:flex-start}#navigation ::slotted(*),#actions ::slotted(*){--mdc-icon-button-ripple-opacity: 0.24}.mdc-top-app-bar--short-collapsed #actions ::slotted(*){transition:padding 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-top-app-bar__section--align-center{justify-content:center}.mdc-top-app-bar__section--align-center .mdc-top-app-bar__title{padding-left:0;padding-right:0}.center-title .mdc-top-app-bar__section--align-start,.center-title .mdc-top-app-bar__section--align-end{flex-basis:0}.mdc-top-app-bar--dense.mdc-top-app-bar--prominent .mdc-top-app-bar__section--align-center .mdc-top-app-bar__title{padding-left:0;padding-right:0}.mdc-top-app-bar--fixed-scrolled{box-shadow:var(--mdc-top-app-bar-fixed-box-shadow, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}`;
// CONCATENATED MODULE: ./node_modules/@material/mwc-top-app-bar/mwc-top-app-bar.js

/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




let mwc_top_app_bar_TopAppBar = class TopAppBar extends mwc_top_app_bar_base_TopAppBarBase {};
mwc_top_app_bar_TopAppBar.styles = mwc_top_app_bar_css_style;
mwc_top_app_bar_TopAppBar = Object(tslib_es6["c" /* __decorate */])([customElement('mwc-top-app-bar')], mwc_top_app_bar_TopAppBar);

// EXTERNAL MODULE: ./node_modules/blocking-elements/dist/blocking-elements.js
var blocking_elements = __webpack_require__(167);

// EXTERNAL MODULE: ./node_modules/wicg-inert/src/inert.js
var inert = __webpack_require__(168);

// CONCATENATED MODULE: ./node_modules/@material/mwc-dialog/node_modules/@material/dialog/constants.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var constants_cssClasses = {
  CLOSING: 'mdc-dialog--closing',
  OPEN: 'mdc-dialog--open',
  OPENING: 'mdc-dialog--opening',
  SCROLLABLE: 'mdc-dialog--scrollable',
  SCROLL_LOCK: 'mdc-dialog-scroll-lock',
  STACKED: 'mdc-dialog--stacked'
};
var dialog_constants_strings = {
  ACTION_ATTRIBUTE: 'data-mdc-dialog-action',
  BUTTON_DEFAULT_ATTRIBUTE: 'data-mdc-dialog-button-default',
  BUTTON_SELECTOR: '.mdc-dialog__button',
  CLOSED_EVENT: 'MDCDialog:closed',
  CLOSE_ACTION: 'close',
  CLOSING_EVENT: 'MDCDialog:closing',
  CONTAINER_SELECTOR: '.mdc-dialog__container',
  CONTENT_SELECTOR: '.mdc-dialog__content',
  DESTROY_ACTION: 'destroy',
  INITIAL_FOCUS_ATTRIBUTE: 'data-mdc-dialog-initial-focus',
  OPENED_EVENT: 'MDCDialog:opened',
  OPENING_EVENT: 'MDCDialog:opening',
  SCRIM_SELECTOR: '.mdc-dialog__scrim',
  SUPPRESS_DEFAULT_PRESS_SELECTOR: ['textarea', '.mdc-menu .mdc-list-item'].join(', '),
  SURFACE_SELECTOR: '.mdc-dialog__surface'
};
var constants_numbers = {
  DIALOG_ANIMATION_CLOSE_TIME_MS: 75,
  DIALOG_ANIMATION_OPEN_TIME_MS: 150
};
// CONCATENATED MODULE: ./node_modules/@material/mwc-dialog/node_modules/@material/base/foundation.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var foundation_MDCFoundation =
/** @class */
function () {
  function MDCFoundation(adapter) {
    if (adapter === void 0) {
      adapter = {};
    }

    this.adapter_ = adapter;
  }

  Object.defineProperty(MDCFoundation, "cssClasses", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "strings", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "numbers", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "defaultAdapter", {
    get: function get() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    },
    enumerable: true,
    configurable: true
  });

  MDCFoundation.prototype.init = function () {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  };

  MDCFoundation.prototype.destroy = function () {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  };

  return MDCFoundation;
}();

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var _material_base_foundation = (foundation_MDCFoundation);
// CONCATENATED MODULE: ./node_modules/@material/mwc-dialog/node_modules/@material/dialog/foundation.js
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */




var foundation_MDCDialogFoundation =
/** @class */
function (_super) {
  tslib_es6["d" /* __extends */](MDCDialogFoundation, _super);

  function MDCDialogFoundation(adapter) {
    var _this = _super.call(this, tslib_es6["a" /* __assign */]({}, MDCDialogFoundation.defaultAdapter, adapter)) || this;

    _this.isOpen_ = false;
    _this.animationFrame_ = 0;
    _this.animationTimer_ = 0;
    _this.layoutFrame_ = 0;
    _this.escapeKeyAction_ = dialog_constants_strings.CLOSE_ACTION;
    _this.scrimClickAction_ = dialog_constants_strings.CLOSE_ACTION;
    _this.autoStackButtons_ = true;
    _this.areButtonsStacked_ = false;
    return _this;
  }

  Object.defineProperty(MDCDialogFoundation, "cssClasses", {
    get: function get() {
      return constants_cssClasses;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCDialogFoundation, "strings", {
    get: function get() {
      return dialog_constants_strings;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCDialogFoundation, "numbers", {
    get: function get() {
      return constants_numbers;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCDialogFoundation, "defaultAdapter", {
    get: function get() {
      return {
        addBodyClass: function addBodyClass() {
          return undefined;
        },
        addClass: function addClass() {
          return undefined;
        },
        areButtonsStacked: function areButtonsStacked() {
          return false;
        },
        clickDefaultButton: function clickDefaultButton() {
          return undefined;
        },
        eventTargetMatches: function eventTargetMatches() {
          return false;
        },
        getActionFromEvent: function getActionFromEvent() {
          return '';
        },
        getInitialFocusEl: function getInitialFocusEl() {
          return null;
        },
        hasClass: function hasClass() {
          return false;
        },
        isContentScrollable: function isContentScrollable() {
          return false;
        },
        notifyClosed: function notifyClosed() {
          return undefined;
        },
        notifyClosing: function notifyClosing() {
          return undefined;
        },
        notifyOpened: function notifyOpened() {
          return undefined;
        },
        notifyOpening: function notifyOpening() {
          return undefined;
        },
        releaseFocus: function releaseFocus() {
          return undefined;
        },
        removeBodyClass: function removeBodyClass() {
          return undefined;
        },
        removeClass: function removeClass() {
          return undefined;
        },
        reverseButtons: function reverseButtons() {
          return undefined;
        },
        trapFocus: function trapFocus() {
          return undefined;
        }
      };
    },
    enumerable: true,
    configurable: true
  });

  MDCDialogFoundation.prototype.init = function () {
    if (this.adapter_.hasClass(constants_cssClasses.STACKED)) {
      this.setAutoStackButtons(false);
    }
  };

  MDCDialogFoundation.prototype.destroy = function () {
    if (this.isOpen_) {
      this.close(dialog_constants_strings.DESTROY_ACTION);
    }

    if (this.animationTimer_) {
      clearTimeout(this.animationTimer_);
      this.handleAnimationTimerEnd_();
    }

    if (this.layoutFrame_) {
      cancelAnimationFrame(this.layoutFrame_);
      this.layoutFrame_ = 0;
    }
  };

  MDCDialogFoundation.prototype.open = function () {
    var _this = this;

    this.isOpen_ = true;
    this.adapter_.notifyOpening();
    this.adapter_.addClass(constants_cssClasses.OPENING); // Wait a frame once display is no longer "none", to establish basis for animation

    this.runNextAnimationFrame_(function () {
      _this.adapter_.addClass(constants_cssClasses.OPEN);

      _this.adapter_.addBodyClass(constants_cssClasses.SCROLL_LOCK);

      _this.layout();

      _this.animationTimer_ = setTimeout(function () {
        _this.handleAnimationTimerEnd_();

        _this.adapter_.trapFocus(_this.adapter_.getInitialFocusEl());

        _this.adapter_.notifyOpened();
      }, constants_numbers.DIALOG_ANIMATION_OPEN_TIME_MS);
    });
  };

  MDCDialogFoundation.prototype.close = function (action) {
    var _this = this;

    if (action === void 0) {
      action = '';
    }

    if (!this.isOpen_) {
      // Avoid redundant close calls (and events), e.g. from keydown on elements that inherently emit click
      return;
    }

    this.isOpen_ = false;
    this.adapter_.notifyClosing(action);
    this.adapter_.addClass(constants_cssClasses.CLOSING);
    this.adapter_.removeClass(constants_cssClasses.OPEN);
    this.adapter_.removeBodyClass(constants_cssClasses.SCROLL_LOCK);
    cancelAnimationFrame(this.animationFrame_);
    this.animationFrame_ = 0;
    clearTimeout(this.animationTimer_);
    this.animationTimer_ = setTimeout(function () {
      _this.adapter_.releaseFocus();

      _this.handleAnimationTimerEnd_();

      _this.adapter_.notifyClosed(action);
    }, constants_numbers.DIALOG_ANIMATION_CLOSE_TIME_MS);
  };

  MDCDialogFoundation.prototype.isOpen = function () {
    return this.isOpen_;
  };

  MDCDialogFoundation.prototype.getEscapeKeyAction = function () {
    return this.escapeKeyAction_;
  };

  MDCDialogFoundation.prototype.setEscapeKeyAction = function (action) {
    this.escapeKeyAction_ = action;
  };

  MDCDialogFoundation.prototype.getScrimClickAction = function () {
    return this.scrimClickAction_;
  };

  MDCDialogFoundation.prototype.setScrimClickAction = function (action) {
    this.scrimClickAction_ = action;
  };

  MDCDialogFoundation.prototype.getAutoStackButtons = function () {
    return this.autoStackButtons_;
  };

  MDCDialogFoundation.prototype.setAutoStackButtons = function (autoStack) {
    this.autoStackButtons_ = autoStack;
  };

  MDCDialogFoundation.prototype.layout = function () {
    var _this = this;

    if (this.layoutFrame_) {
      cancelAnimationFrame(this.layoutFrame_);
    }

    this.layoutFrame_ = requestAnimationFrame(function () {
      _this.layoutInternal_();

      _this.layoutFrame_ = 0;
    });
  };
  /** Handles click on the dialog root element. */


  MDCDialogFoundation.prototype.handleClick = function (evt) {
    var isScrim = this.adapter_.eventTargetMatches(evt.target, dialog_constants_strings.SCRIM_SELECTOR); // Check for scrim click first since it doesn't require querying ancestors.

    if (isScrim && this.scrimClickAction_ !== '') {
      this.close(this.scrimClickAction_);
    } else {
      var action = this.adapter_.getActionFromEvent(evt);

      if (action) {
        this.close(action);
      }
    }
  };
  /** Handles keydown on the dialog root element. */


  MDCDialogFoundation.prototype.handleKeydown = function (evt) {
    var isEnter = evt.key === 'Enter' || evt.keyCode === 13;

    if (!isEnter) {
      return;
    }

    var action = this.adapter_.getActionFromEvent(evt);

    if (action) {
      // Action button callback is handled in `handleClick`,
      // since space/enter keydowns on buttons trigger click events.
      return;
    }

    var isDefault = !this.adapter_.eventTargetMatches(evt.target, dialog_constants_strings.SUPPRESS_DEFAULT_PRESS_SELECTOR);

    if (isEnter && isDefault) {
      this.adapter_.clickDefaultButton();
    }
  };
  /** Handles keydown on the document. */


  MDCDialogFoundation.prototype.handleDocumentKeydown = function (evt) {
    var isEscape = evt.key === 'Escape' || evt.keyCode === 27;

    if (isEscape && this.escapeKeyAction_ !== '') {
      this.close(this.escapeKeyAction_);
    }
  };

  MDCDialogFoundation.prototype.layoutInternal_ = function () {
    if (this.autoStackButtons_) {
      this.detectStackedButtons_();
    }

    this.detectScrollableContent_();
  };

  MDCDialogFoundation.prototype.handleAnimationTimerEnd_ = function () {
    this.animationTimer_ = 0;
    this.adapter_.removeClass(constants_cssClasses.OPENING);
    this.adapter_.removeClass(constants_cssClasses.CLOSING);
  };
  /**
   * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
   */


  MDCDialogFoundation.prototype.runNextAnimationFrame_ = function (callback) {
    var _this = this;

    cancelAnimationFrame(this.animationFrame_);
    this.animationFrame_ = requestAnimationFrame(function () {
      _this.animationFrame_ = 0;
      clearTimeout(_this.animationTimer_);
      _this.animationTimer_ = setTimeout(callback, 0);
    });
  };

  MDCDialogFoundation.prototype.detectStackedButtons_ = function () {
    // Remove the class first to let us measure the buttons' natural positions.
    this.adapter_.removeClass(constants_cssClasses.STACKED);
    var areButtonsStacked = this.adapter_.areButtonsStacked();

    if (areButtonsStacked) {
      this.adapter_.addClass(constants_cssClasses.STACKED);
    }

    if (areButtonsStacked !== this.areButtonsStacked_) {
      this.adapter_.reverseButtons();
      this.areButtonsStacked_ = areButtonsStacked;
    }
  };

  MDCDialogFoundation.prototype.detectScrollableContent_ = function () {
    // Remove the class first to let us measure the natural height of the content.
    this.adapter_.removeClass(constants_cssClasses.SCROLLABLE);

    if (this.adapter_.isContentScrollable()) {
      this.adapter_.addClass(constants_cssClasses.SCROLLABLE);
    }
  };

  return MDCDialogFoundation;
}(foundation_MDCFoundation);

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var dialog_foundation = (foundation_MDCDialogFoundation);
// CONCATENATED MODULE: ./node_modules/@material/mwc-dialog/node_modules/@material/dom/events.js
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Determine whether the current browser supports passive event listeners, and
 * if so, use them.
 */
function applyPassive(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }

  return supportsPassiveOption(globalObj) ? {
    passive: true
  } : false;
}

function supportsPassiveOption(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  } // See
  // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener


  var passiveSupported = false;

  try {
    var options = {
      // This function will be called when the browser
      // attempts to access the passive property.
      get passive() {
        passiveSupported = true;
        return false;
      }

    };

    var handler = function handler() {};

    globalObj.document.addEventListener('test', handler, options);
    globalObj.document.removeEventListener('test', handler, options);
  } catch (err) {
    passiveSupported = false;
  }

  return passiveSupported;
}
// CONCATENATED MODULE: ./node_modules/@material/mwc-dialog/node_modules/@material/dom/ponyfill.js
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
 * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
 */
function ponyfill_closest(element, selector) {
  if (element.closest) {
    return element.closest(selector);
  }

  var el = element;

  while (el) {
    if (dom_ponyfill_matches(el, selector)) {
      return el;
    }

    el = el.parentElement;
  }

  return null;
}
function dom_ponyfill_matches(element, selector) {
  var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
  return nativeMatches.call(element, selector);
}
/**
 * Used to compute the estimated scroll width of elements. When an element is
 * hidden due to display: none; being applied to a parent element, the width is
 * returned as 0. However, the element will have a true width once no longer
 * inside a display: none context. This method computes an estimated width when
 * the element is hidden or returns the true width when the element is visble.
 * @param {Element} element the element whose width to estimate
 */

function ponyfill_estimateScrollWidth(element) {
  // Check the offsetParent. If the element inherits display: none from any
  // parent, the offsetParent property will be null (see
  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent).
  // This check ensures we only clone the node when necessary.
  var htmlEl = element;

  if (htmlEl.offsetParent !== null) {
    return htmlEl.scrollWidth;
  }

  var clone = htmlEl.cloneNode(true);
  clone.style.setProperty('position', 'absolute');
  clone.style.setProperty('transform', 'translate(-9999px, -9999px)');
  document.documentElement.appendChild(clone);
  var scrollWidth = clone.scrollWidth;
  document.documentElement.removeChild(clone);
  return scrollWidth;
}
// CONCATENATED MODULE: ./node_modules/@material/mwc-dialog/mwc-dialog-base.js

/**
@license
Copyright 2019 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/










const blockingElements = document.$blockingElements;
class mwc_dialog_base_DialogBase extends base_element_BaseElement {
  constructor() {
    super(...arguments);
    this.hideActions = false;
    this.stacked = false;
    this.heading = '';
    this.scrimClickAction = 'close';
    this.escapeKeyAction = 'close';
    this.open = false;
    this.defaultAction = 'close';
    this.actionAttribute = 'dialogAction';
    this.initialFocusAttribute = 'dialogInitialFocus';
    this.mdcFoundationClass = dialog_foundation;
    this.boundLayout = null;
    this.boundHandleClick = null;
    this.boundHandleKeydown = null;
    this.boundHandleDocumentKeydown = null;
  }

  get primaryButton() {
    let assignedNodes = this.primarySlot.assignedNodes();
    assignedNodes = assignedNodes.filter(node => node instanceof HTMLElement);
    const button = assignedNodes[0];
    return button ? button : null;
  }

  emitNotification(name, action) {
    const init = {
      detail: action ? {
        action
      } : {}
    };
    const ev = new CustomEvent(name, init);
    this.dispatchEvent(ev);
  }

  getInitialFocusEl() {
    const initFocusSelector = `[${this.initialFocusAttribute}]`; // only search light DOM. This typically handles all the cases

    const lightDomQs = this.querySelector(initFocusSelector);

    if (lightDomQs) {
      return lightDomQs;
    } // if not in light dom, search each flattened distributed node.


    const primarySlot = this.primarySlot;
    const primaryNodes = primarySlot.assignedNodes({
      flatten: true
    });
    const primaryFocusElement = this.searchNodeTreesForAttribute(primaryNodes, this.initialFocusAttribute);

    if (primaryFocusElement) {
      return primaryFocusElement;
    }

    const secondarySlot = this.secondarySlot;
    const secondaryNodes = secondarySlot.assignedNodes({
      flatten: true
    });
    const secondaryFocusElement = this.searchNodeTreesForAttribute(secondaryNodes, this.initialFocusAttribute);

    if (secondaryFocusElement) {
      return secondaryFocusElement;
    }

    const contentSlot = this.contentSlot;
    const contentNodes = contentSlot.assignedNodes({
      flatten: true
    });
    const initFocusElement = this.searchNodeTreesForAttribute(contentNodes, this.initialFocusAttribute);
    return initFocusElement;
  }

  searchNodeTreesForAttribute(nodes, attribute) {
    for (const node of nodes) {
      if (!(node instanceof HTMLElement)) {
        continue;
      }

      if (node.hasAttribute(attribute)) {
        return node;
      } else {
        const selection = node.querySelector(`[${attribute}]`);

        if (selection) {
          return selection;
        }
      }
    }

    return null;
  }

  createAdapter() {
    return Object.assign(Object.assign({}, addHasRemoveClass(this.mdcRoot)), {
      addBodyClass: () => document.body.style.overflow = 'hidden',
      removeBodyClass: () => document.body.style.overflow = '',
      areButtonsStacked: () => this.stacked,
      clickDefaultButton: () => {
        const primary = this.primaryButton;

        if (primary) {
          primary.click();
        }
      },
      eventTargetMatches: (target, selector) => target ? dom_ponyfill_matches(target, selector) : false,
      getActionFromEvent: e => {
        if (!e.target) {
          return '';
        }

        const element = ponyfill_closest(e.target, `[${this.actionAttribute}]`);
        const action = element && element.getAttribute(this.actionAttribute);
        return action;
      },
      getInitialFocusEl: () => {
        return this.getInitialFocusEl();
      },
      isContentScrollable: () => {
        const el = this.contentElement;
        return el ? el.scrollHeight > el.offsetHeight : false;
      },
      notifyClosed: action => this.emitNotification('closed', action),
      notifyClosing: action => {
        if (!this.closingDueToDisconnect) {
          // Don't set our open state to closed just because we were
          // disconnected. That way if we get reconnected, we'll know to
          // re-open.
          this.open = false;
        }

        this.emitNotification('closing', action);
      },
      notifyOpened: () => this.emitNotification('opened'),
      notifyOpening: () => {
        this.open = true;
        this.emitNotification('opening');
      },
      reverseButtons: () => {},
      releaseFocus: () => {
        blockingElements.remove(this);
      },
      trapFocus: el => {
        blockingElements.push(this);

        if (el) {
          el.focus();
        }
      }
    });
  }

  render() {
    const classes = {
      [constants_cssClasses.STACKED]: this.stacked
    };
    let heading = lit_html_html``;

    if (this.heading) {
      heading = lit_html_html`
        <h2 id="title" class="mdc-dialog__title">${this.heading}</h2>`;
    }

    const actionsClasses = {
      'mdc-dialog__actions': !this.hideActions
    };
    return lit_html_html`
    <div class="mdc-dialog ${classMap(classes)}"
        role="alertdialog"
        aria-modal="true"
        aria-labelledby="title"
        aria-describedby="content">
      <div class="mdc-dialog__container">
        <div class="mdc-dialog__surface">
          ${heading}
          <div id="content" class="mdc-dialog__content">
            <slot id="contentSlot"></slot>
          </div>
          <footer
              id="actions"
              class="${classMap(actionsClasses)}">
            <span>
              <slot name="secondaryAction"></slot>
            </span>
            <span>
             <slot name="primaryAction"></slot>
            </span>
          </footer>
        </div>
      </div>
      <div class="mdc-dialog__scrim"></div>
    </div>`;
  }

  firstUpdated() {
    super.firstUpdated();
    this.mdcFoundation.setAutoStackButtons(true);
  }

  connectedCallback() {
    super.connectedCallback();

    if (this.open && this.mdcFoundation && !this.mdcFoundation.isOpen()) {
      // We probably got disconnected while we were still open. Re-open,
      // matching the behavior of native <dialog>.
      this.setEventListeners();
      this.mdcFoundation.open();
    }
  }

  disconnectedCallback() {
    super.disconnectedCallback();

    if (this.open && this.mdcFoundation) {
      // If this dialog is opened and then disconnected, we want to close
      // the foundation, so that 1) any pending timers are cancelled
      // (in particular for trapFocus), and 2) if we reconnect, we can open
      // the foundation again to retrigger animations and focus.
      this.removeEventListeners();
      this.closingDueToDisconnect = true;
      this.mdcFoundation.close(this.currentAction || this.defaultAction);
      this.closingDueToDisconnect = false;
      this.currentAction = undefined; // When we close normally, the releaseFocus callback handles removing
      // ourselves from the blocking elements stack. However, that callback
      // happens on a delay, and when we are closing due to a disconnect we
      // need to remove ourselves before the blocking element polyfill's
      // mutation observer notices and logs a warning, since it's not valid to
      // be in the blocking elements stack while disconnected.

      blockingElements.remove(this);
    }
  }

  forceLayout() {
    this.mdcFoundation.layout();
  }

  focus() {
    const initialFocusEl = this.getInitialFocusEl();
    initialFocusEl && initialFocusEl.focus();
  }

  blur() {
    if (!this.shadowRoot) {
      return;
    }

    const activeEl = this.shadowRoot.activeElement;

    if (activeEl) {
      if (activeEl instanceof HTMLElement) {
        activeEl.blur();
      }
    } else {
      const root = this.getRootNode();
      const activeEl = root instanceof Document ? root.activeElement : null;

      if (activeEl instanceof HTMLElement) {
        activeEl.blur();
      }
    }
  }

  setEventListeners() {
    this.boundHandleClick = this.mdcFoundation.handleClick.bind(this.mdcFoundation);

    this.boundLayout = () => {
      if (this.open) {
        this.mdcFoundation.layout.bind(this.mdcFoundation);
      }
    };

    this.boundHandleKeydown = this.mdcFoundation.handleKeydown.bind(this.mdcFoundation);
    this.boundHandleDocumentKeydown = this.mdcFoundation.handleDocumentKeydown.bind(this.mdcFoundation);
    this.mdcRoot.addEventListener('click', this.boundHandleClick);
    window.addEventListener('resize', this.boundLayout, applyPassive());
    window.addEventListener('orientationchange', this.boundLayout, applyPassive());
    this.mdcRoot.addEventListener('keydown', this.boundHandleKeydown, applyPassive());
    document.addEventListener('keydown', this.boundHandleDocumentKeydown, applyPassive());
  }

  removeEventListeners() {
    if (this.boundHandleClick) {
      this.mdcRoot.removeEventListener('click', this.boundHandleClick);
    }

    if (this.boundLayout) {
      window.removeEventListener('resize', this.boundLayout);
      window.removeEventListener('orientationchange', this.boundLayout);
    }

    if (this.boundHandleKeydown) {
      this.mdcRoot.removeEventListener('keydown', this.boundHandleKeydown);
    }

    if (this.boundHandleDocumentKeydown) {
      this.mdcRoot.removeEventListener('keydown', this.boundHandleDocumentKeydown);
    }
  }

  close() {
    this.open = false;
  }

  show() {
    this.open = true;
  }

}

Object(tslib_es6["c" /* __decorate */])([decorators_query('.mdc-dialog')], mwc_dialog_base_DialogBase.prototype, "mdcRoot", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('slot[name="primaryAction"]')], mwc_dialog_base_DialogBase.prototype, "primarySlot", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('slot[name="secondaryAction"]')], mwc_dialog_base_DialogBase.prototype, "secondarySlot", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('#contentSlot')], mwc_dialog_base_DialogBase.prototype, "contentSlot", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('.mdc-dialog__content')], mwc_dialog_base_DialogBase.prototype, "contentElement", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('.mdc-container')], mwc_dialog_base_DialogBase.prototype, "conatinerElement", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_dialog_base_DialogBase.prototype, "hideActions", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
}), observer_observer(function () {
  this.forceLayout();
})], mwc_dialog_base_DialogBase.prototype, "stacked", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
})], mwc_dialog_base_DialogBase.prototype, "heading", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
}), observer_observer(function (newAction) {
  this.mdcFoundation.setScrimClickAction(newAction);
})], mwc_dialog_base_DialogBase.prototype, "scrimClickAction", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
}), observer_observer(function (newAction) {
  this.mdcFoundation.setEscapeKeyAction(newAction);
})], mwc_dialog_base_DialogBase.prototype, "escapeKeyAction", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
}), observer_observer(function (isOpen) {
  // Check isConnected because we could have been disconnected before first
  // update. If we're now closed, then we shouldn't start the MDC foundation
  // opening animation. If we're now closed, then we've already closed the
  // foundation in disconnectedCallback.
  if (this.mdcFoundation && this.isConnected) {
    if (isOpen) {
      this.setEventListeners();
      this.mdcFoundation.open();
    } else {
      this.removeEventListeners();
      this.mdcFoundation.close(this.currentAction || this.defaultAction);
      this.currentAction = undefined;
    }
  }
})], mwc_dialog_base_DialogBase.prototype, "open", void 0);

Object(tslib_es6["c" /* __decorate */])([property()], mwc_dialog_base_DialogBase.prototype, "defaultAction", void 0);

Object(tslib_es6["c" /* __decorate */])([property()], mwc_dialog_base_DialogBase.prototype, "actionAttribute", void 0);

Object(tslib_es6["c" /* __decorate */])([property()], mwc_dialog_base_DialogBase.prototype, "initialFocusAttribute", void 0);
// CONCATENATED MODULE: ./node_modules/@material/mwc-dialog/mwc-dialog-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_dialog_css_style = css`.mdc-elevation-overlay{position:absolute;border-radius:inherit;opacity:0;pointer-events:none;transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:#fff}.mdc-dialog,.mdc-dialog__scrim{position:fixed;top:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;width:100%;height:100%}.mdc-dialog{display:none;z-index:7}.mdc-dialog .mdc-dialog__surface{background-color:#fff;background-color:var(--mdc-theme-surface, #fff)}.mdc-dialog .mdc-dialog__scrim{background-color:rgba(0,0,0,.32)}.mdc-dialog .mdc-dialog__title{color:rgba(0,0,0,.87)}.mdc-dialog .mdc-dialog__content{color:rgba(0,0,0,.6)}.mdc-dialog.mdc-dialog--scrollable .mdc-dialog__title,.mdc-dialog.mdc-dialog--scrollable .mdc-dialog__actions{border-color:rgba(0,0,0,.12)}.mdc-dialog .mdc-dialog__surface{min-width:280px}@media(max-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:calc(100vw - 32px)}}@media(min-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:560px}}.mdc-dialog .mdc-dialog__surface{max-height:calc(100% - 32px)}.mdc-dialog .mdc-dialog__surface{border-radius:4px}.mdc-dialog__scrim{opacity:0;z-index:-1}.mdc-dialog__container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;transform:scale(0.8);opacity:0;pointer-events:none}.mdc-dialog__surface{position:relative;box-shadow:0px 11px 15px -7px rgba(0, 0, 0, 0.2),0px 24px 38px 3px rgba(0, 0, 0, 0.14),0px 9px 46px 8px rgba(0,0,0,.12);display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;max-width:100%;max-height:100%;pointer-events:auto;overflow-y:auto}.mdc-dialog__surface .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-dialog[dir=rtl] .mdc-dialog__surface,[dir=rtl] .mdc-dialog .mdc-dialog__surface{text-align:right}.mdc-dialog__title{display:block;margin-top:0;line-height:normal;font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:1.25rem;line-height:2rem;font-weight:500;letter-spacing:.0125em;text-decoration:inherit;text-transform:inherit;display:block;position:relative;flex-shrink:0;box-sizing:border-box;margin:0;padding:0 24px 9px;border-bottom:1px solid transparent}.mdc-dialog__title::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}.mdc-dialog[dir=rtl] .mdc-dialog__title,[dir=rtl] .mdc-dialog .mdc-dialog__title{text-align:right}.mdc-dialog--scrollable .mdc-dialog__title{padding-bottom:15px}.mdc-dialog__content{font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:1rem;line-height:1.5rem;font-weight:400;letter-spacing:.03125em;text-decoration:inherit;text-transform:inherit;flex-grow:1;box-sizing:border-box;margin:0;padding:20px 24px;overflow:auto;-webkit-overflow-scrolling:touch}.mdc-dialog__content>:first-child{margin-top:0}.mdc-dialog__content>:last-child{margin-bottom:0}.mdc-dialog__title+.mdc-dialog__content{padding-top:0}.mdc-dialog--scrollable .mdc-dialog__content{padding-top:8px;padding-bottom:8px}.mdc-dialog__content .mdc-list:first-child:last-child{padding:6px 0 0}.mdc-dialog--scrollable .mdc-dialog__content .mdc-list:first-child:last-child{padding:0}.mdc-dialog__actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid transparent}.mdc-dialog--stacked .mdc-dialog__actions{flex-direction:column;align-items:flex-end}.mdc-dialog__button{margin-left:8px;margin-right:0;max-width:100%;text-align:right}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{margin-left:0;margin-right:8px}.mdc-dialog__button:first-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button:first-child,.mdc-dialog__button:first-child[dir=rtl]{margin-left:0;margin-right:0}.mdc-dialog[dir=rtl] .mdc-dialog__button,[dir=rtl] .mdc-dialog .mdc-dialog__button{text-align:left}.mdc-dialog--stacked .mdc-dialog__button:not(:first-child){margin-top:12px}.mdc-dialog--open,.mdc-dialog--opening,.mdc-dialog--closing{display:flex}.mdc-dialog--opening .mdc-dialog__scrim{transition:opacity 150ms linear}.mdc-dialog--opening .mdc-dialog__container{transition:opacity 75ms linear,transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-dialog--closing .mdc-dialog__scrim,.mdc-dialog--closing .mdc-dialog__container{transition:opacity 75ms linear}.mdc-dialog--closing .mdc-dialog__container{transform:scale(1)}.mdc-dialog--open .mdc-dialog__scrim{opacity:1}.mdc-dialog--open .mdc-dialog__container{transform:scale(1);opacity:1}.mdc-dialog-scroll-lock{overflow:hidden}#actions:not(.mdc-dialog__actions){display:none}.mdc-dialog__surface{box-shadow:var(--mdc-dialog-box-shadow, 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12))}@media(min-width: 560px){.mdc-dialog .mdc-dialog__surface{max-width:560px;max-width:var(--mdc-dialog-max-width, 560px)}}.mdc-dialog .mdc-dialog__scrim{background-color:rgba(0,0,0,.32);background-color:var(--mdc-dialog-scrim-color, rgba(0, 0, 0, 0.32))}.mdc-dialog .mdc-dialog__title{color:rgba(0,0,0,.87);color:var(--mdc-dialog-heading-ink-color, rgba(0, 0, 0, 0.87))}.mdc-dialog .mdc-dialog__content{color:rgba(0,0,0,.6);color:var(--mdc-dialog-content-ink-color, rgba(0, 0, 0, 0.6))}.mdc-dialog.mdc-dialog--scrollable .mdc-dialog__title,.mdc-dialog.mdc-dialog--scrollable .mdc-dialog__actions{border-color:rgba(0,0,0,.12);border-color:var(--mdc-dialog-scroll-divider-color, rgba(0, 0, 0, 0.12))}.mdc-dialog .mdc-dialog__surface{min-width:280px;min-width:var(--mdc-dialog-min-width, 280px)}.mdc-dialog .mdc-dialog__surface{max-height:var(--mdc-dialog-max-height, calc(100% - 32px));border-radius:4px;border-radius:var(--mdc-dialog-shape-radius, 4px)}#actions ::slotted(*){margin-left:8px;margin-right:0;max-width:100%;text-align:right}[dir=rtl] #actions ::slotted(*),#actions ::slotted(*)[dir=rtl]{margin-left:0;margin-right:8px}.mdc-dialog[dir=rtl] #actions ::slotted(*),[dir=rtl] .mdc-dialog #actions ::slotted(*){text-align:left}.mdc-dialog--stacked #actions{flex-direction:column-reverse}.mdc-dialog--stacked #actions *:not(:last-child) ::slotted(*){flex-basis:1e-9px;margin-top:12px}`;
// CONCATENATED MODULE: ./node_modules/@material/mwc-dialog/mwc-dialog.js

/**
@license
Copyright 2019 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




let mwc_dialog_Dialog = class Dialog extends mwc_dialog_base_DialogBase {};
mwc_dialog_Dialog.styles = mwc_dialog_css_style;
mwc_dialog_Dialog = Object(tslib_es6["c" /* __decorate */])([customElement('mwc-dialog')], mwc_dialog_Dialog);

// CONCATENATED MODULE: ./node_modules/@material/mwc-base/form-element.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


class form_element_FormElement extends base_element_BaseElement {
  createRenderRoot() {
    return this.attachShadow({
      mode: 'open',
      delegatesFocus: true
    });
  }

  click() {
    if (this.formElement) {
      this.formElement.focus();
      this.formElement.click();
    }
  }

  setAriaLabel(label) {
    if (this.formElement) {
      this.formElement.setAttribute('aria-label', label);
    }
  }

  firstUpdated() {
    super.firstUpdated();
    this.mdcRoot.addEventListener('change', e => {
      this.dispatchEvent(new Event('change', e));
    });
  }

}
// CONCATENATED MODULE: ./node_modules/@material/notched-outline/node_modules/@material/base/foundation.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var base_foundation_MDCFoundation =
/** @class */
function () {
  function MDCFoundation(adapter) {
    if (adapter === void 0) {
      adapter = {};
    }

    this.adapter_ = adapter;
  }

  Object.defineProperty(MDCFoundation, "cssClasses", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "strings", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "numbers", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "defaultAdapter", {
    get: function get() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    },
    enumerable: true,
    configurable: true
  });

  MDCFoundation.prototype.init = function () {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  };

  MDCFoundation.prototype.destroy = function () {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  };

  return MDCFoundation;
}();

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var node_modules_material_base_foundation = (base_foundation_MDCFoundation);
// CONCATENATED MODULE: ./node_modules/@material/notched-outline/constants.js
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var notched_outline_constants_strings = {
  NOTCH_ELEMENT_SELECTOR: '.mdc-notched-outline__notch'
};
var notched_outline_constants_numbers = {
  // This should stay in sync with $mdc-notched-outline-padding * 2.
  NOTCH_ELEMENT_PADDING: 8
};
var notched_outline_constants_cssClasses = {
  NO_LABEL: 'mdc-notched-outline--no-label',
  OUTLINE_NOTCHED: 'mdc-notched-outline--notched',
  OUTLINE_UPGRADED: 'mdc-notched-outline--upgraded'
};

// CONCATENATED MODULE: ./node_modules/@material/notched-outline/foundation.js
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */




var foundation_MDCNotchedOutlineFoundation =
/** @class */
function (_super) {
  tslib_es6["d" /* __extends */](MDCNotchedOutlineFoundation, _super);

  function MDCNotchedOutlineFoundation(adapter) {
    return _super.call(this, tslib_es6["a" /* __assign */]({}, MDCNotchedOutlineFoundation.defaultAdapter, adapter)) || this;
  }

  Object.defineProperty(MDCNotchedOutlineFoundation, "strings", {
    get: function get() {
      return notched_outline_constants_strings;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCNotchedOutlineFoundation, "cssClasses", {
    get: function get() {
      return notched_outline_constants_cssClasses;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCNotchedOutlineFoundation, "numbers", {
    get: function get() {
      return notched_outline_constants_numbers;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCNotchedOutlineFoundation, "defaultAdapter", {
    /**
     * See {@link MDCNotchedOutlineAdapter} for typing information on parameters and return types.
     */
    get: function get() {
      // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
      return {
        addClass: function addClass() {
          return undefined;
        },
        removeClass: function removeClass() {
          return undefined;
        },
        setNotchWidthProperty: function setNotchWidthProperty() {
          return undefined;
        },
        removeNotchWidthProperty: function removeNotchWidthProperty() {
          return undefined;
        }
      }; // tslint:enable:object-literal-sort-keys
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Adds the outline notched selector and updates the notch width calculated based off of notchWidth.
   */

  MDCNotchedOutlineFoundation.prototype.notch = function (notchWidth) {
    var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;

    if (notchWidth > 0) {
      notchWidth += notched_outline_constants_numbers.NOTCH_ELEMENT_PADDING; // Add padding from left/right.
    }

    this.adapter_.setNotchWidthProperty(notchWidth);
    this.adapter_.addClass(OUTLINE_NOTCHED);
  };
  /**
   * Removes notched outline selector to close the notch in the outline.
   */


  MDCNotchedOutlineFoundation.prototype.closeNotch = function () {
    var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
    this.adapter_.removeClass(OUTLINE_NOTCHED);
    this.adapter_.removeNotchWidthProperty();
  };

  return MDCNotchedOutlineFoundation;
}(base_foundation_MDCFoundation);

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var notched_outline_foundation = (foundation_MDCNotchedOutlineFoundation);
// CONCATENATED MODULE: ./node_modules/@material/mwc-notched-outline/mwc-notched-outline-base.js

/**
@license
Copyright 2019 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




class mwc_notched_outline_base_NotchedOutlineBase extends base_element_BaseElement {
  constructor() {
    super(...arguments);
    this.mdcFoundationClass = foundation_MDCNotchedOutlineFoundation;
    this.width = 0;
    this.open = false;
    this.lastOpen = this.open;
  }

  createAdapter() {
    return {
      addClass: className => this.mdcRoot.classList.add(className),
      removeClass: className => this.mdcRoot.classList.remove(className),
      setNotchWidthProperty: width => this.notchElement.style.setProperty('width', `${width}px`),
      removeNotchWidthProperty: () => this.notchElement.style.removeProperty('width')
    };
  }

  openOrClose(shouldOpen, width) {
    if (!this.mdcFoundation) {
      return;
    }

    if (shouldOpen && width !== undefined) {
      this.mdcFoundation.notch(width);
    } else {
      this.mdcFoundation.closeNotch();
    }
  }

  render() {
    this.openOrClose(this.open, this.width);
    return lit_html_html`
      <div class="mdc-notched-outline">
        <div class="mdc-notched-outline__leading"></div>
        <div class="mdc-notched-outline__notch">
          <slot></slot>
        </div>
        <div class="mdc-notched-outline__trailing"></div>
      </div>`;
  }

}

Object(tslib_es6["c" /* __decorate */])([decorators_query('.mdc-notched-outline')], mwc_notched_outline_base_NotchedOutlineBase.prototype, "mdcRoot", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Number
})], mwc_notched_outline_base_NotchedOutlineBase.prototype, "width", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
})], mwc_notched_outline_base_NotchedOutlineBase.prototype, "open", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('.mdc-notched-outline__notch')], mwc_notched_outline_base_NotchedOutlineBase.prototype, "notchElement", void 0);
// CONCATENATED MODULE: ./node_modules/@material/mwc-notched-outline/mwc-notched-outline-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_notched_outline_css_style = css`.mdc-notched-outline{display:flex;position:absolute;right:0;left:0;box-sizing:border-box;width:100%;max-width:100%;height:100%;text-align:left;pointer-events:none}[dir=rtl] .mdc-notched-outline,.mdc-notched-outline[dir=rtl]{text-align:right}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{box-sizing:border-box;height:100%;border-top:1px solid;border-bottom:1px solid;pointer-events:none}.mdc-notched-outline__leading{border-left:1px solid;border-right:none;width:12px}[dir=rtl] .mdc-notched-outline__leading,.mdc-notched-outline__leading[dir=rtl]{border-left:none;border-right:1px solid}.mdc-notched-outline__trailing{border-left:none;border-right:1px solid;flex-grow:1}[dir=rtl] .mdc-notched-outline__trailing,.mdc-notched-outline__trailing[dir=rtl]{border-left:1px solid;border-right:none}.mdc-notched-outline__notch{flex:0 0 auto;width:auto;max-width:calc(100% - 12px * 2)}.mdc-notched-outline .mdc-floating-label{display:inline-block;position:relative;max-width:100%}.mdc-notched-outline .mdc-floating-label--float-above{text-overflow:clip}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:calc(100% / .75)}.mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:0;padding-right:8px;border-top:none}[dir=rtl] .mdc-notched-outline--notched .mdc-notched-outline__notch,.mdc-notched-outline--notched .mdc-notched-outline__notch[dir=rtl]{padding-left:8px;padding-right:0}.mdc-notched-outline--no-label .mdc-notched-outline__notch{padding:0}:host{display:block;position:absolute;right:0;left:0;box-sizing:border-box;width:100%;max-width:100%;height:100%;text-align:left;pointer-events:none}[dir=rtl] :host,:host[dir=rtl]{text-align:right}::slotted(.mdc-floating-label){display:inline-block;position:relative;top:17px;bottom:auto;max-width:100%}::slotted(.mdc-floating-label--float-above){text-overflow:clip}.mdc-notched-outline--upgraded ::slotted(.mdc-floating-label--float-above){max-width:calc(100% / .75)}.mdc-notched-outline__leading{width:12px;width:var(--mdc-notched-outline-leading-width, 12px);border-radius:4px 0 0 4px;border-radius:var(--mdc-notched-outline-leading-border-radius, 4px 0 0 4px)}.mdc-notched-outline__trailing{border-radius:0 4px 4px 0;border-radius:var(--mdc-notched-outline-trailing-border-radius, 0 4px 4px 0)}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{border-color:var(--mdc-notched-outline-border-color, var(--mdc-theme-primary, #6200ee));border-width:1px;border-width:var(--mdc-notched-outline-stroke-width, 1px)}`;
// CONCATENATED MODULE: ./node_modules/@material/mwc-notched-outline/mwc-notched-outline.js

/**
@license
Copyright 2019 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




let mwc_notched_outline_NotchedOutline = class NotchedOutline extends mwc_notched_outline_base_NotchedOutlineBase {};
mwc_notched_outline_NotchedOutline.styles = mwc_notched_outline_css_style;
mwc_notched_outline_NotchedOutline = Object(tslib_es6["c" /* __decorate */])([customElement('mwc-notched-outline')], mwc_notched_outline_NotchedOutline);

// CONCATENATED MODULE: ./node_modules/@material/floating-label/node_modules/@material/base/foundation.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var _material_base_foundation_MDCFoundation =
/** @class */
function () {
  function MDCFoundation(adapter) {
    if (adapter === void 0) {
      adapter = {};
    }

    this.adapter_ = adapter;
  }

  Object.defineProperty(MDCFoundation, "cssClasses", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "strings", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "numbers", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "defaultAdapter", {
    get: function get() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    },
    enumerable: true,
    configurable: true
  });

  MDCFoundation.prototype.init = function () {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  };

  MDCFoundation.prototype.destroy = function () {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  };

  return MDCFoundation;
}();

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var floating_label_node_modules_material_base_foundation = (_material_base_foundation_MDCFoundation);
// CONCATENATED MODULE: ./node_modules/@material/floating-label/constants.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var floating_label_constants_cssClasses = {
  LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
  LABEL_SHAKE: 'mdc-floating-label--shake',
  ROOT: 'mdc-floating-label'
};
// CONCATENATED MODULE: ./node_modules/@material/floating-label/foundation.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */




var foundation_MDCFloatingLabelFoundation =
/** @class */
function (_super) {
  tslib_es6["d" /* __extends */](MDCFloatingLabelFoundation, _super);

  function MDCFloatingLabelFoundation(adapter) {
    var _this = _super.call(this, tslib_es6["a" /* __assign */]({}, MDCFloatingLabelFoundation.defaultAdapter, adapter)) || this;

    _this.shakeAnimationEndHandler_ = function () {
      return _this.handleShakeAnimationEnd_();
    };

    return _this;
  }

  Object.defineProperty(MDCFloatingLabelFoundation, "cssClasses", {
    get: function get() {
      return floating_label_constants_cssClasses;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFloatingLabelFoundation, "defaultAdapter", {
    /**
     * See {@link MDCFloatingLabelAdapter} for typing information on parameters and return types.
     */
    get: function get() {
      // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
      return {
        addClass: function addClass() {
          return undefined;
        },
        removeClass: function removeClass() {
          return undefined;
        },
        getWidth: function getWidth() {
          return 0;
        },
        registerInteractionHandler: function registerInteractionHandler() {
          return undefined;
        },
        deregisterInteractionHandler: function deregisterInteractionHandler() {
          return undefined;
        }
      }; // tslint:enable:object-literal-sort-keys
    },
    enumerable: true,
    configurable: true
  });

  MDCFloatingLabelFoundation.prototype.init = function () {
    this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
  };

  MDCFloatingLabelFoundation.prototype.destroy = function () {
    this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
  };
  /**
   * Returns the width of the label element.
   */


  MDCFloatingLabelFoundation.prototype.getWidth = function () {
    return this.adapter_.getWidth();
  };
  /**
   * Styles the label to produce a shake animation to indicate an error.
   * @param shouldShake If true, adds the shake CSS class; otherwise, removes shake class.
   */


  MDCFloatingLabelFoundation.prototype.shake = function (shouldShake) {
    var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

    if (shouldShake) {
      this.adapter_.addClass(LABEL_SHAKE);
    } else {
      this.adapter_.removeClass(LABEL_SHAKE);
    }
  };
  /**
   * Styles the label to float or dock.
   * @param shouldFloat If true, adds the float CSS class; otherwise, removes float and shake classes to dock the label.
   */


  MDCFloatingLabelFoundation.prototype.float = function (shouldFloat) {
    var _a = MDCFloatingLabelFoundation.cssClasses,
        LABEL_FLOAT_ABOVE = _a.LABEL_FLOAT_ABOVE,
        LABEL_SHAKE = _a.LABEL_SHAKE;

    if (shouldFloat) {
      this.adapter_.addClass(LABEL_FLOAT_ABOVE);
    } else {
      this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
      this.adapter_.removeClass(LABEL_SHAKE);
    }
  };

  MDCFloatingLabelFoundation.prototype.handleShakeAnimationEnd_ = function () {
    var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
    this.adapter_.removeClass(LABEL_SHAKE);
  };

  return MDCFloatingLabelFoundation;
}(_material_base_foundation_MDCFoundation);

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var floating_label_foundation = (foundation_MDCFloatingLabelFoundation);
// CONCATENATED MODULE: ./node_modules/@material/mwc-floating-label/mwc-floating-label-directive.js



const createAdapter = labelElement => {
  return {
    addClass: className => labelElement.classList.add(className),
    removeClass: className => labelElement.classList.remove(className),
    getWidth: () => labelElement.scrollWidth,
    registerInteractionHandler: (evtType, handler) => {
      labelElement.addEventListener(evtType, handler);
    },
    deregisterInteractionHandler: (evtType, handler) => {
      labelElement.removeEventListener(evtType, handler);
    }
  };
};

const partToFoundationMap = new WeakMap();
const floatingLabel = directive_directive(label => part => {
  const lastFoundation = partToFoundationMap.get(part);

  if (!lastFoundation) {
    const labelElement = part.committer.element;
    labelElement.classList.add('mdc-floating-label');
    const adapter = createAdapter(labelElement);
    const foundation = new foundation_MDCFloatingLabelFoundation(adapter);
    foundation.init();
    part.setValue(foundation);
    partToFoundationMap.set(part, {
      label,
      foundation
    });
  } else if (lastFoundation.label !== label) {
    const labelElement = part.committer.element;
    const labelChangeEvent = new Event('labelchange');
    labelElement.dispatchEvent(labelChangeEvent);
  }
});
// CONCATENATED MODULE: ./node_modules/@material/line-ripple/node_modules/@material/base/foundation.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var node_modules_material_base_foundation_MDCFoundation =
/** @class */
function () {
  function MDCFoundation(adapter) {
    if (adapter === void 0) {
      adapter = {};
    }

    this.adapter_ = adapter;
  }

  Object.defineProperty(MDCFoundation, "cssClasses", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "strings", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "numbers", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "defaultAdapter", {
    get: function get() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    },
    enumerable: true,
    configurable: true
  });

  MDCFoundation.prototype.init = function () {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  };

  MDCFoundation.prototype.destroy = function () {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  };

  return MDCFoundation;
}();

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var line_ripple_node_modules_material_base_foundation = (node_modules_material_base_foundation_MDCFoundation);
// CONCATENATED MODULE: ./node_modules/@material/line-ripple/constants.js
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var line_ripple_constants_cssClasses = {
  LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
  LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
};

// CONCATENATED MODULE: ./node_modules/@material/line-ripple/foundation.js
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */




var foundation_MDCLineRippleFoundation =
/** @class */
function (_super) {
  tslib_es6["d" /* __extends */](MDCLineRippleFoundation, _super);

  function MDCLineRippleFoundation(adapter) {
    var _this = _super.call(this, tslib_es6["a" /* __assign */]({}, MDCLineRippleFoundation.defaultAdapter, adapter)) || this;

    _this.transitionEndHandler_ = function (evt) {
      return _this.handleTransitionEnd(evt);
    };

    return _this;
  }

  Object.defineProperty(MDCLineRippleFoundation, "cssClasses", {
    get: function get() {
      return line_ripple_constants_cssClasses;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCLineRippleFoundation, "defaultAdapter", {
    /**
     * See {@link MDCLineRippleAdapter} for typing information on parameters and return types.
     */
    get: function get() {
      // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
      return {
        addClass: function addClass() {
          return undefined;
        },
        removeClass: function removeClass() {
          return undefined;
        },
        hasClass: function hasClass() {
          return false;
        },
        setStyle: function setStyle() {
          return undefined;
        },
        registerEventHandler: function registerEventHandler() {
          return undefined;
        },
        deregisterEventHandler: function deregisterEventHandler() {
          return undefined;
        }
      }; // tslint:enable:object-literal-sort-keys
    },
    enumerable: true,
    configurable: true
  });

  MDCLineRippleFoundation.prototype.init = function () {
    this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
  };

  MDCLineRippleFoundation.prototype.destroy = function () {
    this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
  };

  MDCLineRippleFoundation.prototype.activate = function () {
    this.adapter_.removeClass(line_ripple_constants_cssClasses.LINE_RIPPLE_DEACTIVATING);
    this.adapter_.addClass(line_ripple_constants_cssClasses.LINE_RIPPLE_ACTIVE);
  };

  MDCLineRippleFoundation.prototype.setRippleCenter = function (xCoordinate) {
    this.adapter_.setStyle('transform-origin', xCoordinate + "px center");
  };

  MDCLineRippleFoundation.prototype.deactivate = function () {
    this.adapter_.addClass(line_ripple_constants_cssClasses.LINE_RIPPLE_DEACTIVATING);
  };

  MDCLineRippleFoundation.prototype.handleTransitionEnd = function (evt) {
    // Wait for the line ripple to be either transparent or opaque
    // before emitting the animation end event
    var isDeactivating = this.adapter_.hasClass(line_ripple_constants_cssClasses.LINE_RIPPLE_DEACTIVATING);

    if (evt.propertyName === 'opacity') {
      if (isDeactivating) {
        this.adapter_.removeClass(line_ripple_constants_cssClasses.LINE_RIPPLE_ACTIVE);
        this.adapter_.removeClass(line_ripple_constants_cssClasses.LINE_RIPPLE_DEACTIVATING);
      }
    }
  };

  return MDCLineRippleFoundation;
}(node_modules_material_base_foundation_MDCFoundation);

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var line_ripple_foundation = (foundation_MDCLineRippleFoundation);
// CONCATENATED MODULE: ./node_modules/@material/mwc-line-ripple/mwc-line-ripple-directive.js



const mwc_line_ripple_directive_createAdapter = lineElement => {
  return {
    addClass: className => lineElement.classList.add(className),
    removeClass: className => lineElement.classList.remove(className),
    hasClass: className => lineElement.classList.contains(className),
    setStyle: (propertyName, value) => lineElement.style.setProperty(propertyName, value),
    registerEventHandler: (evtType, handler) => {
      lineElement.addEventListener(evtType, handler);
    },
    deregisterEventHandler: (evtType, handler) => {
      lineElement.removeEventListener(evtType, handler);
    }
  };
};

const mwc_line_ripple_directive_partToFoundationMap = new WeakMap();
const lineRipple = directive_directive(() => part => {
  const lastFoundation = mwc_line_ripple_directive_partToFoundationMap.get(part);

  if (!lastFoundation) {
    const lineElement = part.committer.element;
    lineElement.classList.add('mdc-line-ripple');
    const adapter = mwc_line_ripple_directive_createAdapter(lineElement);
    const foundation = new foundation_MDCLineRippleFoundation(adapter);
    foundation.init();
    part.setValue(foundation);
    mwc_line_ripple_directive_partToFoundationMap.set(part, foundation);
  }
});
// CONCATENATED MODULE: ./node_modules/@material/textfield/node_modules/@material/base/foundation.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var textfield_node_modules_material_base_foundation_MDCFoundation =
/** @class */
function () {
  function MDCFoundation(adapter) {
    if (adapter === void 0) {
      adapter = {};
    }

    this.adapter_ = adapter;
  }

  Object.defineProperty(MDCFoundation, "cssClasses", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "strings", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "numbers", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "defaultAdapter", {
    get: function get() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    },
    enumerable: true,
    configurable: true
  });

  MDCFoundation.prototype.init = function () {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  };

  MDCFoundation.prototype.destroy = function () {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  };

  return MDCFoundation;
}();

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var textfield_node_modules_material_base_foundation = (textfield_node_modules_material_base_foundation_MDCFoundation);
// CONCATENATED MODULE: ./node_modules/@material/textfield/constants.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var textfield_constants_strings = {
  ARIA_CONTROLS: 'aria-controls',
  INPUT_SELECTOR: '.mdc-text-field__input',
  LABEL_SELECTOR: '.mdc-floating-label',
  LEADING_ICON_SELECTOR: '.mdc-text-field__icon--leading',
  LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
  OUTLINE_SELECTOR: '.mdc-notched-outline',
  TRAILING_ICON_SELECTOR: '.mdc-text-field__icon--trailing'
};
var textfield_constants_cssClasses = {
  DENSE: 'mdc-text-field--dense',
  DISABLED: 'mdc-text-field--disabled',
  FOCUSED: 'mdc-text-field--focused',
  FULLWIDTH: 'mdc-text-field--fullwidth',
  HELPER_LINE: 'mdc-text-field-helper-line',
  INVALID: 'mdc-text-field--invalid',
  NO_LABEL: 'mdc-text-field--no-label',
  OUTLINED: 'mdc-text-field--outlined',
  ROOT: 'mdc-text-field',
  TEXTAREA: 'mdc-text-field--textarea',
  WITH_LEADING_ICON: 'mdc-text-field--with-leading-icon',
  WITH_TRAILING_ICON: 'mdc-text-field--with-trailing-icon'
};
var textfield_constants_numbers = {
  DENSE_LABEL_SCALE: 0.923,
  LABEL_SCALE: 0.75
};
/**
 * Whitelist based off of https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
 * under the "Validation-related attributes" section.
 */

var VALIDATION_ATTR_WHITELIST = ['pattern', 'min', 'max', 'required', 'step', 'minlength', 'maxlength'];
/**
 * Label should always float for these types as they show some UI even if value is empty.
 */

var ALWAYS_FLOAT_TYPES = ['color', 'date', 'datetime-local', 'month', 'range', 'time', 'week'];

// CONCATENATED MODULE: ./node_modules/@material/textfield/foundation.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



var POINTERDOWN_EVENTS = ['mousedown', 'touchstart'];
var INTERACTION_EVENTS = ['click', 'keydown'];

var foundation_MDCTextFieldFoundation =
/** @class */
function (_super) {
  tslib_es6["d" /* __extends */](MDCTextFieldFoundation, _super);
  /**
   * @param adapter
   * @param foundationMap Map from subcomponent names to their subfoundations.
   */


  function MDCTextFieldFoundation(adapter, foundationMap) {
    if (foundationMap === void 0) {
      foundationMap = {};
    }

    var _this = _super.call(this, tslib_es6["a" /* __assign */]({}, MDCTextFieldFoundation.defaultAdapter, adapter)) || this;

    _this.isFocused_ = false;
    _this.receivedUserInput_ = false;
    _this.isValid_ = true;
    _this.useNativeValidation_ = true;
    _this.helperText_ = foundationMap.helperText;
    _this.characterCounter_ = foundationMap.characterCounter;
    _this.leadingIcon_ = foundationMap.leadingIcon;
    _this.trailingIcon_ = foundationMap.trailingIcon;

    _this.inputFocusHandler_ = function () {
      return _this.activateFocus();
    };

    _this.inputBlurHandler_ = function () {
      return _this.deactivateFocus();
    };

    _this.inputInputHandler_ = function () {
      return _this.handleInput();
    };

    _this.setPointerXOffset_ = function (evt) {
      return _this.setTransformOrigin(evt);
    };

    _this.textFieldInteractionHandler_ = function () {
      return _this.handleTextFieldInteraction();
    };

    _this.validationAttributeChangeHandler_ = function (attributesList) {
      return _this.handleValidationAttributeChange(attributesList);
    };

    return _this;
  }

  Object.defineProperty(MDCTextFieldFoundation, "cssClasses", {
    get: function get() {
      return textfield_constants_cssClasses;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation, "strings", {
    get: function get() {
      return textfield_constants_strings;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation, "numbers", {
    get: function get() {
      return textfield_constants_numbers;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldAlwaysFloat_", {
    get: function get() {
      var type = this.getNativeInput_().type;
      return ALWAYS_FLOAT_TYPES.indexOf(type) >= 0;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldFloat", {
    get: function get() {
      return this.shouldAlwaysFloat_ || this.isFocused_ || !!this.getValue() || this.isBadInput_();
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldShake", {
    get: function get() {
      return !this.isFocused_ && !this.isValid() && !!this.getValue();
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldFoundation, "defaultAdapter", {
    /**
     * See {@link MDCTextFieldAdapter} for typing information on parameters and return types.
     */
    get: function get() {
      // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
      return {
        addClass: function addClass() {
          return undefined;
        },
        removeClass: function removeClass() {
          return undefined;
        },
        hasClass: function hasClass() {
          return true;
        },
        registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler() {
          return undefined;
        },
        deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler() {
          return undefined;
        },
        registerInputInteractionHandler: function registerInputInteractionHandler() {
          return undefined;
        },
        deregisterInputInteractionHandler: function deregisterInputInteractionHandler() {
          return undefined;
        },
        registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler() {
          return new MutationObserver(function () {
            return undefined;
          });
        },
        deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler() {
          return undefined;
        },
        getNativeInput: function getNativeInput() {
          return null;
        },
        isFocused: function isFocused() {
          return false;
        },
        activateLineRipple: function activateLineRipple() {
          return undefined;
        },
        deactivateLineRipple: function deactivateLineRipple() {
          return undefined;
        },
        setLineRippleTransformOrigin: function setLineRippleTransformOrigin() {
          return undefined;
        },
        shakeLabel: function shakeLabel() {
          return undefined;
        },
        floatLabel: function floatLabel() {
          return undefined;
        },
        hasLabel: function hasLabel() {
          return false;
        },
        getLabelWidth: function getLabelWidth() {
          return 0;
        },
        hasOutline: function hasOutline() {
          return false;
        },
        notchOutline: function notchOutline() {
          return undefined;
        },
        closeOutline: function closeOutline() {
          return undefined;
        }
      }; // tslint:enable:object-literal-sort-keys
    },
    enumerable: true,
    configurable: true
  });

  MDCTextFieldFoundation.prototype.init = function () {
    var _this = this;

    if (this.adapter_.isFocused()) {
      this.inputFocusHandler_();
    } else if (this.adapter_.hasLabel() && this.shouldFloat) {
      this.notchOutline(true);
      this.adapter_.floatLabel(true);
    }

    this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
    this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
    this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
    POINTERDOWN_EVENTS.forEach(function (evtType) {
      _this.adapter_.registerInputInteractionHandler(evtType, _this.setPointerXOffset_);
    });
    INTERACTION_EVENTS.forEach(function (evtType) {
      _this.adapter_.registerTextFieldInteractionHandler(evtType, _this.textFieldInteractionHandler_);
    });
    this.validationObserver_ = this.adapter_.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
    this.setCharacterCounter_(this.getValue().length);
  };

  MDCTextFieldFoundation.prototype.destroy = function () {
    var _this = this;

    this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
    this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
    this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
    POINTERDOWN_EVENTS.forEach(function (evtType) {
      _this.adapter_.deregisterInputInteractionHandler(evtType, _this.setPointerXOffset_);
    });
    INTERACTION_EVENTS.forEach(function (evtType) {
      _this.adapter_.deregisterTextFieldInteractionHandler(evtType, _this.textFieldInteractionHandler_);
    });
    this.adapter_.deregisterValidationAttributeChangeHandler(this.validationObserver_);
  };
  /**
   * Handles user interactions with the Text Field.
   */


  MDCTextFieldFoundation.prototype.handleTextFieldInteraction = function () {
    var nativeInput = this.adapter_.getNativeInput();

    if (nativeInput && nativeInput.disabled) {
      return;
    }

    this.receivedUserInput_ = true;
  };
  /**
   * Handles validation attribute changes
   */


  MDCTextFieldFoundation.prototype.handleValidationAttributeChange = function (attributesList) {
    var _this = this;

    attributesList.some(function (attributeName) {
      if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
        _this.styleValidity_(true);

        return true;
      }

      return false;
    });

    if (attributesList.indexOf('maxlength') > -1) {
      this.setCharacterCounter_(this.getValue().length);
    }
  };
  /**
   * Opens/closes the notched outline.
   */


  MDCTextFieldFoundation.prototype.notchOutline = function (openNotch) {
    if (!this.adapter_.hasOutline()) {
      return;
    }

    if (openNotch) {
      var isDense = this.adapter_.hasClass(textfield_constants_cssClasses.DENSE);
      var labelScale = isDense ? textfield_constants_numbers.DENSE_LABEL_SCALE : textfield_constants_numbers.LABEL_SCALE;
      var labelWidth = this.adapter_.getLabelWidth() * labelScale;
      this.adapter_.notchOutline(labelWidth);
    } else {
      this.adapter_.closeOutline();
    }
  };
  /**
   * Activates the text field focus state.
   */


  MDCTextFieldFoundation.prototype.activateFocus = function () {
    this.isFocused_ = true;
    this.styleFocused_(this.isFocused_);
    this.adapter_.activateLineRipple();

    if (this.adapter_.hasLabel()) {
      this.notchOutline(this.shouldFloat);
      this.adapter_.floatLabel(this.shouldFloat);
      this.adapter_.shakeLabel(this.shouldShake);
    }

    if (this.helperText_) {
      this.helperText_.showToScreenReader();
    }
  };
  /**
   * Sets the line ripple's transform origin, so that the line ripple activate
   * animation will animate out from the user's click location.
   */


  MDCTextFieldFoundation.prototype.setTransformOrigin = function (evt) {
    var touches = evt.touches;
    var targetEvent = touches ? touches[0] : evt;
    var targetClientRect = targetEvent.target.getBoundingClientRect();
    var normalizedX = targetEvent.clientX - targetClientRect.left;
    this.adapter_.setLineRippleTransformOrigin(normalizedX);
  };
  /**
   * Handles input change of text input and text area.
   */


  MDCTextFieldFoundation.prototype.handleInput = function () {
    this.autoCompleteFocus();
    this.setCharacterCounter_(this.getValue().length);
  };
  /**
   * Activates the Text Field's focus state in cases when the input value
   * changes without user input (e.g. programmatically).
   */


  MDCTextFieldFoundation.prototype.autoCompleteFocus = function () {
    if (!this.receivedUserInput_) {
      this.activateFocus();
    }
  };
  /**
   * Deactivates the Text Field's focus state.
   */


  MDCTextFieldFoundation.prototype.deactivateFocus = function () {
    this.isFocused_ = false;
    this.adapter_.deactivateLineRipple();
    var isValid = this.isValid();
    this.styleValidity_(isValid);
    this.styleFocused_(this.isFocused_);

    if (this.adapter_.hasLabel()) {
      this.notchOutline(this.shouldFloat);
      this.adapter_.floatLabel(this.shouldFloat);
      this.adapter_.shakeLabel(this.shouldShake);
    }

    if (!this.shouldFloat) {
      this.receivedUserInput_ = false;
    }
  };

  MDCTextFieldFoundation.prototype.getValue = function () {
    return this.getNativeInput_().value;
  };
  /**
   * @param value The value to set on the input Element.
   */


  MDCTextFieldFoundation.prototype.setValue = function (value) {
    // Prevent Safari from moving the caret to the end of the input when the value has not changed.
    if (this.getValue() !== value) {
      this.getNativeInput_().value = value;
    }

    this.setCharacterCounter_(value.length);
    var isValid = this.isValid();
    this.styleValidity_(isValid);

    if (this.adapter_.hasLabel()) {
      this.notchOutline(this.shouldFloat);
      this.adapter_.floatLabel(this.shouldFloat);
      this.adapter_.shakeLabel(this.shouldShake);
    }
  };
  /**
   * @return The custom validity state, if set; otherwise, the result of a native validity check.
   */


  MDCTextFieldFoundation.prototype.isValid = function () {
    return this.useNativeValidation_ ? this.isNativeInputValid_() : this.isValid_;
  };
  /**
   * @param isValid Sets the custom validity state of the Text Field.
   */


  MDCTextFieldFoundation.prototype.setValid = function (isValid) {
    this.isValid_ = isValid;
    this.styleValidity_(isValid);
    var shouldShake = !isValid && !this.isFocused_ && !!this.getValue();

    if (this.adapter_.hasLabel()) {
      this.adapter_.shakeLabel(shouldShake);
    }
  };
  /**
   * Enables or disables the use of native validation. Use this for custom validation.
   * @param useNativeValidation Set this to false to ignore native input validation.
   */


  MDCTextFieldFoundation.prototype.setUseNativeValidation = function (useNativeValidation) {
    this.useNativeValidation_ = useNativeValidation;
  };

  MDCTextFieldFoundation.prototype.isDisabled = function () {
    return this.getNativeInput_().disabled;
  };
  /**
   * @param disabled Sets the text-field disabled or enabled.
   */


  MDCTextFieldFoundation.prototype.setDisabled = function (disabled) {
    this.getNativeInput_().disabled = disabled;
    this.styleDisabled_(disabled);
  };
  /**
   * @param content Sets the content of the helper text.
   */


  MDCTextFieldFoundation.prototype.setHelperTextContent = function (content) {
    if (this.helperText_) {
      this.helperText_.setContent(content);
    }
  };
  /**
   * Sets the aria label of the leading icon.
   */


  MDCTextFieldFoundation.prototype.setLeadingIconAriaLabel = function (label) {
    if (this.leadingIcon_) {
      this.leadingIcon_.setAriaLabel(label);
    }
  };
  /**
   * Sets the text content of the leading icon.
   */


  MDCTextFieldFoundation.prototype.setLeadingIconContent = function (content) {
    if (this.leadingIcon_) {
      this.leadingIcon_.setContent(content);
    }
  };
  /**
   * Sets the aria label of the trailing icon.
   */


  MDCTextFieldFoundation.prototype.setTrailingIconAriaLabel = function (label) {
    if (this.trailingIcon_) {
      this.trailingIcon_.setAriaLabel(label);
    }
  };
  /**
   * Sets the text content of the trailing icon.
   */


  MDCTextFieldFoundation.prototype.setTrailingIconContent = function (content) {
    if (this.trailingIcon_) {
      this.trailingIcon_.setContent(content);
    }
  };
  /**
   * Sets character counter values that shows characters used and the total character limit.
   */


  MDCTextFieldFoundation.prototype.setCharacterCounter_ = function (currentLength) {
    if (!this.characterCounter_) {
      return;
    }

    var maxLength = this.getNativeInput_().maxLength;

    if (maxLength === -1) {
      throw new Error('MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.');
    }

    this.characterCounter_.setCounterValue(currentLength, maxLength);
  };
  /**
   * @return True if the Text Field input fails in converting the user-supplied value.
   */


  MDCTextFieldFoundation.prototype.isBadInput_ = function () {
    // The badInput property is not supported in IE 11 .
    return this.getNativeInput_().validity.badInput || false;
  };
  /**
   * @return The result of native validity checking (ValidityState.valid).
   */


  MDCTextFieldFoundation.prototype.isNativeInputValid_ = function () {
    return this.getNativeInput_().validity.valid;
  };
  /**
   * Styles the component based on the validity state.
   */


  MDCTextFieldFoundation.prototype.styleValidity_ = function (isValid) {
    var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;

    if (isValid) {
      this.adapter_.removeClass(INVALID);
    } else {
      this.adapter_.addClass(INVALID);
    }

    if (this.helperText_) {
      this.helperText_.setValidity(isValid);
    }
  };
  /**
   * Styles the component based on the focused state.
   */


  MDCTextFieldFoundation.prototype.styleFocused_ = function (isFocused) {
    var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;

    if (isFocused) {
      this.adapter_.addClass(FOCUSED);
    } else {
      this.adapter_.removeClass(FOCUSED);
    }
  };
  /**
   * Styles the component based on the disabled state.
   */


  MDCTextFieldFoundation.prototype.styleDisabled_ = function (isDisabled) {
    var _a = MDCTextFieldFoundation.cssClasses,
        DISABLED = _a.DISABLED,
        INVALID = _a.INVALID;

    if (isDisabled) {
      this.adapter_.addClass(DISABLED);
      this.adapter_.removeClass(INVALID);
    } else {
      this.adapter_.removeClass(DISABLED);
    }

    if (this.leadingIcon_) {
      this.leadingIcon_.setDisabled(isDisabled);
    }

    if (this.trailingIcon_) {
      this.trailingIcon_.setDisabled(isDisabled);
    }
  };
  /**
   * @return The native text input element from the host environment, or an object with the same shape for unit tests.
   */


  MDCTextFieldFoundation.prototype.getNativeInput_ = function () {
    // this.adapter_ may be undefined in foundation unit tests. This happens when testdouble is creating a mock object
    // and invokes the shouldShake/shouldFloat getters (which in turn call getValue(), which calls this method) before
    // init() has been called from the MDCTextField constructor. To work around that issue, we return a dummy object.
    var nativeInput = this.adapter_ ? this.adapter_.getNativeInput() : null;
    return nativeInput || {
      disabled: false,
      maxLength: -1,
      type: 'input',
      validity: {
        badInput: false,
        valid: true
      },
      value: ''
    };
  };

  return MDCTextFieldFoundation;
}(textfield_node_modules_material_base_foundation_MDCFoundation);

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var textfield_foundation = (foundation_MDCTextFieldFoundation);
// CONCATENATED MODULE: ./node_modules/lit-html/directives/if-defined.js
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */

/**
 * For AttributeParts, sets the attribute if the value is defined and removes
 * the attribute if the value is undefined.
 *
 * For other part types, this directive is a no-op.
 */

const ifDefined = directive_directive(value => part => {
  if (value === undefined && part instanceof parts_AttributePart) {
    if (value !== part.value) {
      const name = part.committer.name;
      part.committer.element.removeAttribute(name);
    }
  } else {
    part.setValue(value);
  }
});
// CONCATENATED MODULE: ./node_modules/@material/textfield/character-counter/constants.js
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var character_counter_constants_cssClasses = {
  ROOT: 'mdc-text-field-character-counter'
};
var character_counter_constants_strings = {
  ROOT_SELECTOR: "." + character_counter_constants_cssClasses.ROOT
};

// CONCATENATED MODULE: ./node_modules/@material/textfield/character-counter/foundation.js
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */




var foundation_MDCTextFieldCharacterCounterFoundation =
/** @class */
function (_super) {
  tslib_es6["d" /* __extends */](MDCTextFieldCharacterCounterFoundation, _super);

  function MDCTextFieldCharacterCounterFoundation(adapter) {
    return _super.call(this, tslib_es6["a" /* __assign */]({}, MDCTextFieldCharacterCounterFoundation.defaultAdapter, adapter)) || this;
  }

  Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "cssClasses", {
    get: function get() {
      return character_counter_constants_cssClasses;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "strings", {
    get: function get() {
      return character_counter_constants_strings;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCTextFieldCharacterCounterFoundation, "defaultAdapter", {
    /**
     * See {@link MDCTextFieldCharacterCounterAdapter} for typing information on parameters and return types.
     */
    get: function get() {
      return {
        setContent: function setContent() {
          return undefined;
        }
      };
    },
    enumerable: true,
    configurable: true
  });

  MDCTextFieldCharacterCounterFoundation.prototype.setCounterValue = function (currentLength, maxLength) {
    currentLength = Math.min(currentLength, maxLength);
    this.adapter_.setContent(currentLength + " / " + maxLength);
  };

  return MDCTextFieldCharacterCounterFoundation;
}(textfield_node_modules_material_base_foundation_MDCFoundation);

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var character_counter_foundation = (foundation_MDCTextFieldCharacterCounterFoundation);
// CONCATENATED MODULE: ./node_modules/@material/mwc-textfield/mwc-character-counter-directive.js



const mwc_character_counter_directive_createAdapter = hostElement => {
  return {
    setContent: content => hostElement.textContent = content
  };
};

const mwc_character_counter_directive_partToFoundationMap = new WeakMap();
const characterCounter = directive_directive(() => part => {
  const lastFoundation = mwc_character_counter_directive_partToFoundationMap.get(part);

  if (!lastFoundation) {
    const hostElement = part.committer.element;
    hostElement.classList.add('mdc-text-field-character-counter');
    const adapter = mwc_character_counter_directive_createAdapter(hostElement);
    const foundation = new foundation_MDCTextFieldCharacterCounterFoundation(adapter);
    foundation.init();
    part.setValue(foundation);
    mwc_character_counter_directive_partToFoundationMap.set(part, foundation);
  }
});
// CONCATENATED MODULE: ./node_modules/@material/mwc-textfield/mwc-textfield-base.js

/**
@license
Copyright 2019 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/










const passiveEvents = ['touchstart', 'touchmove', 'scroll', 'mousewheel'];

const createValidityObj = (customValidity = {}) => {
  /*
   * We need to make ValidityState an object because it is readonly and
   * we cannot use the spread operator. Also, we don't export
   * `CustomValidityState` because it is a leaky implementation and the user
   * already has access to `ValidityState` in lib.dom.ts. Also an interface
   * {a: Type} can be casted to {readonly a: Type} so passing any object
   * should be fine.
   */
  const objectifiedCustomValidity = {}; // eslint-disable-next-line guard-for-in

  for (const propName in customValidity) {
    /*
     * Casting is needed because ValidityState's props are all readonly and
     * thus cannot be set on `onjectifiedCustomValidity`. In the end, the
     * interface is the same as ValidityState (but not readonly), but the
     * function signature casts the output to ValidityState (thus readonly).
     */
    objectifiedCustomValidity[propName] = customValidity[propName];
  }

  return Object.assign({
    badInput: false,
    customError: false,
    patternMismatch: false,
    rangeOverflow: false,
    rangeUnderflow: false,
    stepMismatch: false,
    tooLong: false,
    tooShort: false,
    typeMismatch: false,
    valid: true,
    valueMissing: false
  }, objectifiedCustomValidity);
};

class mwc_textfield_base_TextFieldBase extends form_element_FormElement {
  constructor() {
    super(...arguments);
    this.mdcFoundationClass = textfield_foundation;
    this.value = '';
    this.type = 'text';
    this.placeholder = '';
    this.label = '';
    this.icon = '';
    this.iconTrailing = '';
    this.disabled = false;
    this.required = false;
    this.maxLength = -1;
    this.outlined = false;
    this.fullWidth = false;
    this.helper = '';
    this.validateOnInitialRender = false;
    this.validationMessage = '';
    this.pattern = '';
    this.min = '';
    this.max = '';
    this.step = null;
    this.helperPersistent = false;
    this.charCounter = false;
    this.endAligned = false;
    this.outlineOpen = false;
    this.outlineWidth = 0;
    this.isUiValid = true;
    this._validity = createValidityObj();
    this._outlineUpdateComplete = null;
    this.validityTransform = null;
  }

  get validity() {
    this._checkValidity(this.value);

    return this._validity;
  }

  get willValidate() {
    return this.formElement.willValidate;
  }

  get selectionStart() {
    return this.formElement.selectionStart;
  }

  get selectionEnd() {
    return this.formElement.selectionEnd;
  }

  get shouldRenderHelperText() {
    return !!this.helper || !!this.validationMessage || this.charCounterVisible;
  }

  get charCounterVisible() {
    return this.charCounter && this.maxLength !== -1;
  }

  focus() {
    const focusEvt = new CustomEvent('focus');
    this.formElement.dispatchEvent(focusEvt);
    this.formElement.focus();
  }

  blur() {
    const blurEvt = new CustomEvent('blur');
    this.formElement.dispatchEvent(blurEvt);
    this.formElement.blur();
  }

  select() {
    this.formElement.select();
  }

  setSelectionRange(selectionStart, selectionEnd, selectionDirection) {
    this.formElement.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
  }

  render() {
    const classes = {
      'mdc-text-field--disabled': this.disabled,
      'mdc-text-field--no-label': !this.label,
      'mdc-text-field--outlined': this.outlined,
      'mdc-text-field--fullwidth': this.fullWidth,
      'mdc-text-field--with-leading-icon': this.icon,
      'mdc-text-field--with-trailing-icon': this.iconTrailing,
      'mdc-text-field--end-aligned': this.endAligned
    };
    return lit_html_html`
      <label class="mdc-text-field ${classMap(classes)}">
        ${this.icon ? this.renderIcon(this.icon) : ''}
        ${this.renderInput()}
        ${this.iconTrailing ? this.renderIcon(this.iconTrailing, true) : ''}
        ${this.outlined ? this.renderOutlined() : this.renderLabelText()}
      </label>
      ${this.renderHelperText(this.renderCharCounter())}
    `;
  }

  updated(changedProperties) {
    const maxLength = changedProperties.get('maxLength');
    const maxLengthBecameDefined = maxLength === -1 && this.maxLength !== -1;
    const maxLengthBecameUndefined = maxLength !== undefined && maxLength !== -1 && this.maxLength === -1;
    /* We want to recreate the foundation if maxLength changes to defined or
     * undefined, because the textfield foundation needs to be instantiated with
     * the char counter's foundation, and the char counter's foundation needs
     * to have maxLength defined to be instantiated. Additionally, there is no
     * exposed API on the MdcTextFieldFoundation to dynamically add a char
     * counter foundation, so we must recreate it.
     */

    if (maxLengthBecameDefined || maxLengthBecameUndefined) {
      this.createFoundation();
    }

    if (changedProperties.has('value') && changedProperties.get('value') !== undefined) {
      this.mdcFoundation.setValue(this.value);
    }
  }

  renderInput() {
    const maxOrUndef = this.maxLength === -1 ? undefined : this.maxLength;
    return lit_html_html`
      <input
          aria-labelledby="label"
          class="mdc-text-field__input"
          type="${this.type}"
          .value="${this.value}"
          ?disabled="${this.disabled}"
          placeholder="${this.placeholder}"
          ?required="${this.required}"
          maxlength="${ifDefined(maxOrUndef)}"
          pattern="${ifDefined(this.pattern ? this.pattern : undefined)}"
          min="${ifDefined(this.min === '' ? undefined : this.min)}"
          max="${ifDefined(this.max === '' ? undefined : this.max)}"
          step="${ifDefined(this.step === null ? undefined : this.step)}"
          @input="${this.handleInputChange}"
          @blur="${this.onInputBlur}">`;
  }

  renderIcon(icon, isTrailingIcon = false) {
    const classes = {
      'mdc-text-field__icon--leading': !isTrailingIcon,
      'mdc-text-field__icon--trailing': isTrailingIcon
    };
    return lit_html_html`<i class="material-icons mdc-text-field__icon ${classMap(classes)}">${icon}</i>`;
  }

  renderOutlined() {
    let labelTemplate = '';

    if (this.label) {
      labelTemplate = lit_html_html`
        <span
            .floatingLabelFoundation=${floatingLabel(this.label)}
            @labelchange=${this.onLabelChange}
            id="label">
          ${this.label}
        </span>
      `;
    }

    return lit_html_html`
      <mwc-notched-outline
          .width=${this.outlineWidth}
          .open=${this.outlineOpen}
          class="mdc-notched-outline">
        ${labelTemplate}
      </mwc-notched-outline>`;
  }

  renderLabelText() {
    let labelTemplate = '';

    if (this.label && !this.fullWidth) {
      labelTemplate = lit_html_html`
      <span
          .floatingLabelFoundation=${floatingLabel(this.label)}
          id="label">
        ${this.label}
      </span>`;
    }

    return lit_html_html`
      ${labelTemplate}
      <div .lineRippleFoundation=${lineRipple()}></div>
    `;
  }

  renderHelperText(charCounterTemplate) {
    const showValidationMessage = this.validationMessage && !this.isUiValid;
    const classes = {
      'mdc-text-field-helper-text--persistent': this.helperPersistent,
      'mdc-text-field-helper-text--validation-msg': showValidationMessage
    };
    const rootClasses = {
      hidden: !this.shouldRenderHelperText
    };
    return lit_html_html`
      <div class="mdc-text-field-helper-line ${classMap(rootClasses)}">
        <div class="mdc-text-field-helper-text ${classMap(classes)}">
          ${showValidationMessage ? this.validationMessage : this.helper}
        </div>
        ${charCounterTemplate}
      </div>
    `;
  }

  renderCharCounter() {
    const counterClasses = {
      hidden: !this.charCounterVisible
    };
    return lit_html_html`
      <div
          class="${classMap(counterClasses)}"
          .charCounterFoundation=${characterCounter()}>
      </div>`;
  }

  onInputBlur() {
    this.reportValidity();
  }

  checkValidity() {
    const isValid = this._checkValidity(this.value);

    if (!isValid) {
      const invalidEvent = new Event('invalid', {
        bubbles: false,
        cancelable: true
      });
      this.dispatchEvent(invalidEvent);
    }

    return isValid;
  }

  reportValidity() {
    const isValid = this.checkValidity();
    this.mdcFoundation.setValid(isValid);
    this.isUiValid = isValid;
    return isValid;
  }

  _checkValidity(value) {
    const nativeValidity = this.formElement.validity;
    let validity = createValidityObj(nativeValidity);

    if (this.validityTransform) {
      const customValidity = this.validityTransform(value, validity);
      validity = Object.assign(Object.assign({}, validity), customValidity);
      this.mdcFoundation.setUseNativeValidation(false);
    } else {
      this.mdcFoundation.setUseNativeValidation(true);
    }

    this._validity = validity;
    return this._validity.valid;
  }

  setCustomValidity(message) {
    this.validationMessage = message;
    this.formElement.setCustomValidity(message);
  }

  handleInputChange() {
    this.value = this.formElement.value;
  }

  createFoundation() {
    if (this.mdcFoundation !== undefined) {
      this.mdcFoundation.destroy();
    }

    this.mdcFoundation = new this.mdcFoundationClass(this.createAdapter(), {
      characterCounter: this.maxLength !== -1 ? this.charCounterElement.charCounterFoundation : undefined
    });
    this.mdcFoundation.init();
  }

  createAdapter() {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.getRootAdapterMethods()), this.getInputAdapterMethods()), this.getLabelAdapterMethods()), this.getLineRippleAdapterMethods()), this.getOutlineAdapterMethods());
  }

  getRootAdapterMethods() {
    return Object.assign({
      registerTextFieldInteractionHandler: (evtType, handler) => this.addEventListener(evtType, handler),
      deregisterTextFieldInteractionHandler: (evtType, handler) => this.removeEventListener(evtType, handler),
      registerValidationAttributeChangeHandler: () => {
        const getAttributesList = mutationsList => {
          return mutationsList.map(mutation => mutation.attributeName).filter(attributeName => attributeName);
        };

        const observer = new MutationObserver(mutationsList => {
          const attributes = getAttributesList(mutationsList);

          if (attributes.indexOf('maxlength') !== -1 && this.maxLength !== -1) {
            this.charCounterElement.charCounterFoundation.setCounterValue(this.value.length, this.maxLength);
          }
        });
        const config = {
          attributes: true
        };
        observer.observe(this.formElement, config);
        return observer;
      },
      deregisterValidationAttributeChangeHandler: observer => observer.disconnect()
    }, addHasRemoveClass(this.mdcRoot));
  }

  getInputAdapterMethods() {
    return {
      getNativeInput: () => this.formElement,
      isFocused: () => this.shadowRoot ? this.shadowRoot.activeElement === this.formElement : false,
      registerInputInteractionHandler: (evtType, handler) => this.formElement.addEventListener(evtType, handler, {
        passive: evtType in passiveEvents
      }),
      deregisterInputInteractionHandler: (evtType, handler) => this.formElement.removeEventListener(evtType, handler)
    };
  }

  getLabelAdapterMethods() {
    return {
      floatLabel: shouldFloat => this.labelElement && this.labelElement.floatingLabelFoundation.float(shouldFloat),
      getLabelWidth: () => {
        return this.labelElement ? this.labelElement.floatingLabelFoundation.getWidth() : 0;
      },
      hasLabel: () => Boolean(this.labelElement),
      shakeLabel: shouldShake => this.labelElement && this.labelElement.floatingLabelFoundation.shake(shouldShake)
    };
  }

  getLineRippleAdapterMethods() {
    return {
      activateLineRipple: () => {
        if (this.lineRippleElement) {
          this.lineRippleElement.lineRippleFoundation.activate();
        }
      },
      deactivateLineRipple: () => {
        if (this.lineRippleElement) {
          this.lineRippleElement.lineRippleFoundation.deactivate();
        }
      },
      setLineRippleTransformOrigin: normalizedX => {
        if (this.lineRippleElement) {
          this.lineRippleElement.lineRippleFoundation.setRippleCenter(normalizedX);
        }
      }
    };
  }

  async _getUpdateComplete() {
    await super._getUpdateComplete();
    await this._outlineUpdateComplete;
  }

  async firstUpdated() {
    const outlineElement = this.outlineElement;

    if (outlineElement) {
      this._outlineUpdateComplete = outlineElement.updateComplete;
      await this._outlineUpdateComplete;
    }

    super.firstUpdated();

    if (this.validateOnInitialRender) {
      this.reportValidity();
    }
  }

  getOutlineAdapterMethods() {
    return {
      closeOutline: () => this.outlineElement && (this.outlineOpen = false),
      hasOutline: () => Boolean(this.outlineElement),
      notchOutline: labelWidth => {
        const outlineElement = this.outlineElement;

        if (outlineElement && !this.outlineOpen) {
          this.outlineWidth = labelWidth;
          this.outlineOpen = true;
        }
      }
    };
  }

  async onLabelChange() {
    if (this.label) {
      await this.layout();
    }
  }

  async layout() {
    await this.updateComplete;

    if (this.labelElement && this.outlineElement) {
      /* When the textfield automatically notches due to a value and label
       * being defined, the textfield may be set to `display: none` by the user.
       * this means that the notch is of size 0px. We provide this function so
       * that the user may manually resize the notch to the floated label's
       * width.
       */
      const labelWidth = this.labelElement.floatingLabelFoundation.getWidth();

      if (this.outlineOpen) {
        this.outlineWidth = labelWidth;
      }
    }
  }

}

Object(tslib_es6["c" /* __decorate */])([decorators_query('.mdc-text-field')], mwc_textfield_base_TextFieldBase.prototype, "mdcRoot", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('input')], mwc_textfield_base_TextFieldBase.prototype, "formElement", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('.mdc-floating-label')], mwc_textfield_base_TextFieldBase.prototype, "labelElement", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('.mdc-line-ripple')], mwc_textfield_base_TextFieldBase.prototype, "lineRippleElement", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('mwc-notched-outline')], mwc_textfield_base_TextFieldBase.prototype, "outlineElement", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('.mdc-notched-outline__notch')], mwc_textfield_base_TextFieldBase.prototype, "notchElement", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('.mdc-text-field-character-counter')], mwc_textfield_base_TextFieldBase.prototype, "charCounterElement", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
})], mwc_textfield_base_TextFieldBase.prototype, "value", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
})], mwc_textfield_base_TextFieldBase.prototype, "type", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
})], mwc_textfield_base_TextFieldBase.prototype, "placeholder", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
})], mwc_textfield_base_TextFieldBase.prototype, "label", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
})], mwc_textfield_base_TextFieldBase.prototype, "icon", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
})], mwc_textfield_base_TextFieldBase.prototype, "iconTrailing", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
})], mwc_textfield_base_TextFieldBase.prototype, "disabled", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_textfield_base_TextFieldBase.prototype, "required", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Number
})], mwc_textfield_base_TextFieldBase.prototype, "maxLength", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
})], mwc_textfield_base_TextFieldBase.prototype, "outlined", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
})], mwc_textfield_base_TextFieldBase.prototype, "fullWidth", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
})], mwc_textfield_base_TextFieldBase.prototype, "helper", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_textfield_base_TextFieldBase.prototype, "validateOnInitialRender", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
})], mwc_textfield_base_TextFieldBase.prototype, "validationMessage", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
})], mwc_textfield_base_TextFieldBase.prototype, "pattern", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Number
})], mwc_textfield_base_TextFieldBase.prototype, "min", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Number
})], mwc_textfield_base_TextFieldBase.prototype, "max", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Number
})], mwc_textfield_base_TextFieldBase.prototype, "step", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_textfield_base_TextFieldBase.prototype, "helperPersistent", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_textfield_base_TextFieldBase.prototype, "charCounter", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_textfield_base_TextFieldBase.prototype, "endAligned", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_textfield_base_TextFieldBase.prototype, "outlineOpen", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Number
})], mwc_textfield_base_TextFieldBase.prototype, "outlineWidth", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_textfield_base_TextFieldBase.prototype, "isUiValid", void 0);

Object(tslib_es6["c" /* __decorate */])([eventOptions({
  passive: true
})], mwc_textfield_base_TextFieldBase.prototype, "handleInputChange", null);
// CONCATENATED MODULE: ./node_modules/@material/mwc-textfield/mwc-textfield-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_textfield_css_style = css`.mdc-floating-label{font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:1rem;font-weight:400;letter-spacing:.009375em;text-decoration:inherit;text-transform:inherit;position:absolute;left:0;transform-origin:left top;line-height:1.15rem;text-align:left;text-overflow:ellipsis;white-space:nowrap;cursor:text;overflow:hidden;will-change:transform;transition:transform 150ms cubic-bezier(0.4, 0, 0.2, 1),color 150ms cubic-bezier(0.4, 0, 0.2, 1)}[dir=rtl] .mdc-floating-label,.mdc-floating-label[dir=rtl]{right:0;left:auto;transform-origin:right top;text-align:right}.mdc-floating-label--float-above{cursor:auto}.mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-standard 250ms 1}@keyframes mdc-floating-label-shake-float-above-standard{0%{transform:translateX(calc(0 - 0%)) translateY(-106%) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-106%) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-106%) scale(0.75)}100%{transform:translateX(calc(0 - 0%)) translateY(-106%) scale(0.75)}}.mdc-line-ripple{position:absolute;bottom:0;left:0;width:100%;height:2px;transform:scaleX(0);opacity:0;z-index:2;transition:transform 180ms cubic-bezier(0.4, 0, 0.2, 1),opacity 180ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-line-ripple--active{transform:scaleX(1);opacity:1}.mdc-line-ripple--deactivating{opacity:0}.mdc-notched-outline{display:flex;position:absolute;right:0;left:0;box-sizing:border-box;width:100%;max-width:100%;height:100%;text-align:left;pointer-events:none}[dir=rtl] .mdc-notched-outline,.mdc-notched-outline[dir=rtl]{text-align:right}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{box-sizing:border-box;height:100%;border-top:1px solid;border-bottom:1px solid;pointer-events:none}.mdc-notched-outline__leading{border-left:1px solid;border-right:none;width:12px}[dir=rtl] .mdc-notched-outline__leading,.mdc-notched-outline__leading[dir=rtl]{border-left:none;border-right:1px solid}.mdc-notched-outline__trailing{border-left:none;border-right:1px solid;flex-grow:1}[dir=rtl] .mdc-notched-outline__trailing,.mdc-notched-outline__trailing[dir=rtl]{border-left:1px solid;border-right:none}.mdc-notched-outline__notch{flex:0 0 auto;width:auto;max-width:calc(100% - 12px * 2)}.mdc-notched-outline .mdc-floating-label{display:inline-block;position:relative;max-width:100%}.mdc-notched-outline .mdc-floating-label--float-above{text-overflow:clip}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:calc(100% / .75)}.mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:0;padding-right:8px;border-top:none}[dir=rtl] .mdc-notched-outline--notched .mdc-notched-outline__notch,.mdc-notched-outline--notched .mdc-notched-outline__notch[dir=rtl]{padding-left:8px;padding-right:0}.mdc-notched-outline--no-label .mdc-notched-outline__notch{padding:0}.mdc-text-field-helper-text{font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:.75rem;line-height:1.25rem;font-weight:400;letter-spacing:.0333333333em;text-decoration:inherit;text-transform:inherit;display:block;margin-top:0;line-height:normal;margin:0;opacity:0;will-change:opacity;transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-text-field-helper-text::before{display:inline-block;width:0;height:16px;content:"";vertical-align:0}.mdc-text-field-helper-text--persistent{transition:none;opacity:1;will-change:initial}.mdc-text-field-character-counter{font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:.75rem;line-height:1.25rem;font-weight:400;letter-spacing:.0333333333em;text-decoration:inherit;text-transform:inherit;display:block;margin-top:0;line-height:normal;margin-left:auto;margin-right:0;padding-left:16px;padding-right:0;white-space:nowrap}.mdc-text-field-character-counter::before{display:inline-block;width:0;height:16px;content:"";vertical-align:0}[dir=rtl] .mdc-text-field-character-counter,.mdc-text-field-character-counter[dir=rtl]{margin-left:0;margin-right:auto}[dir=rtl] .mdc-text-field-character-counter,.mdc-text-field-character-counter[dir=rtl]{padding-left:0;padding-right:16px}.mdc-text-field__icon{position:absolute;top:50%;transform:translateY(-50%);cursor:pointer}.mdc-text-field__icon:not([tabindex]),.mdc-text-field__icon[tabindex="-1"]{cursor:default;pointer-events:none}@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}.mdc-text-field{--mdc-ripple-fg-size: 0;--mdc-ripple-left: 0;--mdc-ripple-top: 0;--mdc-ripple-fg-scale: 1;--mdc-ripple-fg-translate-end: 0;--mdc-ripple-fg-translate-start: 0;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mdc-text-field::before,.mdc-text-field::after{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:""}.mdc-text-field::before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1}.mdc-text-field.mdc-ripple-upgraded::before{transform:scale(var(--mdc-ripple-fg-scale, 1))}.mdc-text-field.mdc-ripple-upgraded::after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-text-field.mdc-ripple-upgraded--unbounded::after{top:var(--mdc-ripple-top, 0);left:var(--mdc-ripple-left, 0)}.mdc-text-field.mdc-ripple-upgraded--foreground-activation::after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-text-field.mdc-ripple-upgraded--foreground-deactivation::after{animation:mdc-ripple-fg-opacity-out 150ms;transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}.mdc-text-field::before,.mdc-text-field::after{top:calc(50% - 100%);left:calc(50% - 100%);width:200%;height:200%}.mdc-text-field.mdc-ripple-upgraded::after{width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-text-field{height:56px;border-radius:4px 4px 0 0;display:inline-flex;position:relative;box-sizing:border-box;overflow:hidden;will-change:opacity,transform,color}.mdc-text-field::before,.mdc-text-field::after{background-color:rgba(0,0,0,.87)}.mdc-text-field:hover::before{opacity:.04}.mdc-text-field.mdc-ripple-upgraded--background-focused::before,.mdc-text-field:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:.12}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-floating-label{color:rgba(0,0,0,.6)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input{color:rgba(0,0,0,.87)}@media all{.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:rgba(0,0,0,.54)}}@media all{.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:rgba(0,0,0,.54)}}.mdc-text-field .mdc-text-field__input{caret-color:#6200ee;caret-color:var(--mdc-theme-primary, #6200ee)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input{border-bottom-color:rgba(0,0,0,.42)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input:hover{border-bottom-color:rgba(0,0,0,.87)}.mdc-text-field .mdc-line-ripple{background-color:#6200ee;background-color:var(--mdc-theme-primary, #6200ee)}.mdc-text-field:not(.mdc-text-field--disabled)+.mdc-text-field-helper-line .mdc-text-field-helper-text{color:rgba(0,0,0,.6)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field-character-counter,.mdc-text-field:not(.mdc-text-field--disabled)+.mdc-text-field-helper-line .mdc-text-field-character-counter{color:rgba(0,0,0,.6)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__icon--leading{color:rgba(0,0,0,.54)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__icon--trailing{color:rgba(0,0,0,.54)}.mdc-text-field:not(.mdc-text-field--disabled){background-color:#f5f5f5}.mdc-text-field .mdc-floating-label{left:16px;right:initial;top:50%;transform:translateY(-50%);pointer-events:none}[dir=rtl] .mdc-text-field .mdc-floating-label,.mdc-text-field .mdc-floating-label[dir=rtl]{left:initial;right:16px}.mdc-text-field .mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-text-field--textarea .mdc-floating-label{left:4px;right:initial}[dir=rtl] .mdc-text-field--textarea .mdc-floating-label,.mdc-text-field--textarea .mdc-floating-label[dir=rtl]{left:initial;right:4px}.mdc-text-field--outlined .mdc-floating-label{left:4px;right:initial}[dir=rtl] .mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:4px}.mdc-text-field--outlined--with-leading-icon .mdc-floating-label{left:36px;right:initial}[dir=rtl] .mdc-text-field--outlined--with-leading-icon .mdc-floating-label,.mdc-text-field--outlined--with-leading-icon .mdc-floating-label[dir=rtl]{left:initial;right:36px}.mdc-text-field--outlined--with-leading-icon .mdc-floating-label--float-above{left:40px;right:initial}[dir=rtl] .mdc-text-field--outlined--with-leading-icon .mdc-floating-label--float-above,.mdc-text-field--outlined--with-leading-icon .mdc-floating-label--float-above[dir=rtl]{left:initial;right:40px}.mdc-text-field__input{font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:1rem;font-weight:400;letter-spacing:.009375em;text-decoration:inherit;text-transform:inherit;align-self:flex-end;box-sizing:border-box;width:100%;height:100%;padding:20px 16px 6px;border:none;border-bottom:1px solid;border-radius:0;background:none;appearance:none;transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-text-field__input::placeholder{transition:opacity 67ms cubic-bezier(0.4, 0, 0.2, 1);opacity:0}.mdc-text-field--fullwidth .mdc-text-field__input::placeholder,.mdc-text-field--no-label .mdc-text-field__input::placeholder,.mdc-text-field--focused .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms;opacity:1}.mdc-text-field__input:focus{outline:none}.mdc-text-field__input:invalid{box-shadow:none}.mdc-text-field__input:-webkit-autofill{z-index:auto !important}.mdc-text-field--no-label:not(.mdc-text-field--outlined):not(.mdc-text-field--textarea) .mdc-text-field__input{padding-top:16px;padding-bottom:16px}.mdc-text-field__input:-webkit-autofill+.mdc-floating-label{transform:translateY(-50%) scale(0.75);cursor:auto}.mdc-text-field--outlined{border:none;overflow:visible}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.38)}.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.87)}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:#6200ee;border-color:var(--mdc-theme-primary, #6200ee)}.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined 250ms 1}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-radius:4px 0 0 4px}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl]{border-radius:0 4px 4px 0}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-radius:0 4px 4px 0}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl]{border-radius:4px 0 0 4px}.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) scale(1)}.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) scale(0.75)}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:1px}.mdc-text-field--outlined::before,.mdc-text-field--outlined::after{content:none}.mdc-text-field--outlined:not(.mdc-text-field--disabled){background-color:transparent}.mdc-text-field--outlined .mdc-text-field__input{display:flex;padding:12px 16px 14px;border:none !important;background-color:transparent;z-index:1}.mdc-text-field--outlined .mdc-text-field__icon{z-index:2}.mdc-text-field--outlined.mdc-text-field--focused .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:2px}.mdc-text-field--outlined.mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--focused .mdc-notched-outline__trailing{border-width:2px}.mdc-text-field--outlined.mdc-text-field--disabled{background-color:transparent}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.06)}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-text-field__input{border-bottom:none}.mdc-text-field--outlined.mdc-text-field--dense{height:48px}.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--float-above{transform:translateY(-134%) scale(1)}.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--float-above{font-size:.8rem}.mdc-text-field--outlined.mdc-text-field--dense.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined.mdc-text-field--dense .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-120%) scale(0.8)}.mdc-text-field--outlined.mdc-text-field--dense.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined.mdc-text-field--dense .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-dense 250ms 1}.mdc-text-field--outlined.mdc-text-field--dense .mdc-text-field__input{padding:12px 12px 7px}.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label{top:14px}.mdc-text-field--outlined.mdc-text-field--dense .mdc-text-field__icon{top:12px}.mdc-text-field--with-leading-icon .mdc-text-field__icon--leading{left:16px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon .mdc-text-field__icon--leading,.mdc-text-field--with-leading-icon .mdc-text-field__icon--leading[dir=rtl]{left:initial;right:16px}.mdc-text-field--with-leading-icon .mdc-text-field__input{padding-left:48px;padding-right:16px}[dir=rtl] .mdc-text-field--with-leading-icon .mdc-text-field__input,.mdc-text-field--with-leading-icon .mdc-text-field__input[dir=rtl]{padding-left:16px;padding-right:48px}.mdc-text-field--with-leading-icon .mdc-floating-label{left:48px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon .mdc-floating-label,.mdc-text-field--with-leading-icon .mdc-floating-label[dir=rtl]{left:initial;right:48px}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-text-field__icon--leading{left:16px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-text-field__icon--leading,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-text-field__icon--leading[dir=rtl]{left:initial;right:16px}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) translateX(-32px) scale(1)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-37.25px) translateX(32px) scale(1)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) translateX(-32px) scale(0.75)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-34.75px) translateX(32px) scale(0.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon 250ms 1}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake,.mdc-text-field--with-leading-icon.mdc-text-field--outlined[dir=rtl] .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-rtl 250ms 1}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label{left:36px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:36px}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--float-above{transform:translateY(-134%) translateX(-21px) scale(1)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-134%) translateX(21px) scale(1)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--float-above{font-size:.8rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-120%) translateX(-21px) scale(0.8)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense.mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-120%) translateX(21px) scale(0.8)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-dense 250ms 1}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--shake,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense[dir=rtl] .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-dense-rtl 250ms 1}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label{left:32px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label[dir=rtl]{left:initial;right:32px}.mdc-text-field--with-trailing-icon .mdc-text-field__icon--trailing{left:initial;right:12px}[dir=rtl] .mdc-text-field--with-trailing-icon .mdc-text-field__icon--trailing,.mdc-text-field--with-trailing-icon .mdc-text-field__icon--trailing[dir=rtl]{left:12px;right:initial}.mdc-text-field--with-trailing-icon .mdc-text-field__input{padding-left:16px;padding-right:48px}[dir=rtl] .mdc-text-field--with-trailing-icon .mdc-text-field__input,.mdc-text-field--with-trailing-icon .mdc-text-field__input[dir=rtl]{padding-left:48px;padding-right:16px}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon .mdc-text-field__icon--leading{left:16px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon .mdc-text-field__icon--leading,.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon .mdc-text-field__icon--leading[dir=rtl]{left:initial;right:16px}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon .mdc-text-field__icon--trailing{left:initial;right:12px}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon .mdc-text-field__icon--trailing,.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon .mdc-text-field__icon--trailing[dir=rtl]{left:12px;right:initial}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon .mdc-text-field__input{padding-right:48px;padding-left:48px}.mdc-text-field--dense .mdc-text-field__icon{bottom:16px;transform:scale(0.8)}.mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-text-field__icon--leading{left:12px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-text-field__icon--leading,.mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-text-field__icon--leading[dir=rtl]{left:initial;right:12px}.mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-text-field__input{padding-left:44px;padding-right:16px}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-text-field__input,.mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-text-field__input[dir=rtl]{padding-left:16px;padding-right:44px}.mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-floating-label{left:44px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-floating-label[dir=rtl]{left:initial;right:44px}.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--trailing{left:initial;right:12px}[dir=rtl] .mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--trailing,.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--trailing[dir=rtl]{left:12px;right:initial}.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__input{padding-left:16px;padding-right:44px}[dir=rtl] .mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__input,.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__input[dir=rtl]{padding-left:44px;padding-right:16px}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--leading{left:12px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--leading,.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--leading[dir=rtl]{left:initial;right:12px}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--trailing{left:initial;right:12px}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--trailing,.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--trailing[dir=rtl]{left:12px;right:initial}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__input{padding-right:44px;padding-left:44px}.mdc-text-field--dense .mdc-floating-label--float-above{transform:translateY(-70%) scale(0.8)}.mdc-text-field--dense .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-dense 250ms 1}.mdc-text-field--dense .mdc-text-field__input{padding:12px 12px 0}.mdc-text-field--dense .mdc-floating-label{font-size:.813rem}.mdc-text-field--dense .mdc-floating-label--float-above{font-size:.813rem}.mdc-text-field__input:required~.mdc-floating-label::after,.mdc-text-field__input:required~.mdc-notched-outline .mdc-floating-label::after{margin-left:1px;content:"*"}.mdc-text-field--textarea{display:inline-flex;width:auto;height:auto;overflow:visible;transition:none}.mdc-text-field--textarea:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--textarea:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--textarea:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.38)}.mdc-text-field--textarea:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--textarea:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--textarea:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--textarea:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--textarea:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--textarea:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.87)}.mdc-text-field--textarea:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--textarea:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--textarea:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:#6200ee;border-color:var(--mdc-theme-primary, #6200ee)}.mdc-text-field--textarea .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea 250ms 1}.mdc-text-field--textarea .mdc-notched-outline .mdc-notched-outline__leading{border-radius:4px 0 0 4px}[dir=rtl] .mdc-text-field--textarea .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--textarea .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl]{border-radius:0 4px 4px 0}.mdc-text-field--textarea .mdc-notched-outline .mdc-notched-outline__trailing{border-radius:0 4px 4px 0}[dir=rtl] .mdc-text-field--textarea .mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--textarea .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl]{border-radius:4px 0 0 4px}.mdc-text-field--textarea::before,.mdc-text-field--textarea::after{content:none}.mdc-text-field--textarea:not(.mdc-text-field--disabled){background-color:transparent}.mdc-text-field--textarea .mdc-floating-label--float-above{transform:translateY(-144%) scale(1)}.mdc-text-field--textarea .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--textarea.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-130%) scale(0.75)}.mdc-text-field--textarea.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--textarea .mdc-text-field-character-counter{left:initial;right:16px;position:absolute;bottom:13px}[dir=rtl] .mdc-text-field--textarea .mdc-text-field-character-counter,.mdc-text-field--textarea .mdc-text-field-character-counter[dir=rtl]{left:16px;right:initial}.mdc-text-field--textarea .mdc-text-field__input{align-self:auto;box-sizing:border-box;height:auto;margin:8px 1px 1px 0;padding:0 16px 16px;border:none;line-height:1.75rem}.mdc-text-field--textarea .mdc-text-field-character-counter+.mdc-text-field__input{margin-bottom:28px;padding-bottom:0}.mdc-text-field--textarea .mdc-floating-label{top:17px;width:auto;pointer-events:none}.mdc-text-field--textarea .mdc-floating-label:not(.mdc-floating-label--float-above){transform:none}.mdc-text-field--textarea.mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--textarea.mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--textarea.mdc-text-field--focused .mdc-notched-outline__trailing{border-width:2px}.mdc-text-field--fullwidth{width:100%}.mdc-text-field--fullwidth:not(.mdc-text-field--disabled) .mdc-text-field__input{border-bottom-color:rgba(0,0,0,.42)}.mdc-text-field--fullwidth.mdc-text-field--disabled .mdc-text-field__input{border-bottom-color:rgba(0,0,0,.42)}.mdc-text-field--fullwidth:not(.mdc-text-field--textarea){display:block}.mdc-text-field--fullwidth:not(.mdc-text-field--textarea)::before,.mdc-text-field--fullwidth:not(.mdc-text-field--textarea)::after{content:none}.mdc-text-field--fullwidth:not(.mdc-text-field--textarea):not(.mdc-text-field--disabled){background-color:transparent}.mdc-text-field--fullwidth:not(.mdc-text-field--textarea) .mdc-text-field__input{padding:0}.mdc-text-field--fullwidth.mdc-text-field--textarea .mdc-text-field__input{resize:vertical}.mdc-text-field--fullwidth.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error, #b00020)}.mdc-text-field-helper-line{display:flex;justify-content:space-between;box-sizing:border-box}.mdc-text-field--dense+.mdc-text-field-helper-line{margin-bottom:4px}.mdc-text-field+.mdc-text-field-helper-line{padding-right:16px;padding-left:16px}.mdc-form-field>.mdc-text-field+label{align-self:flex-start}.mdc-text-field--focused:not(.mdc-text-field--disabled) .mdc-floating-label{color:rgba(98,0,238,.87)}.mdc-text-field--focused+.mdc-text-field-helper-line .mdc-text-field-helper-text:not(.mdc-text-field-helper-text--validation-msg){opacity:1}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input:hover{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple{background-color:#b00020;background-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label{color:#b00020;color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{color:#b00020;color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid .mdc-text-field__input{caret-color:#b00020;caret-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__icon--trailing{color:#b00020;color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{opacity:1}.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--disabled{background-color:#fafafa;border-bottom:none;pointer-events:none}.mdc-text-field--disabled .mdc-text-field__input{border-bottom-color:rgba(0,0,0,.06)}.mdc-text-field--disabled .mdc-text-field__input{color:rgba(0,0,0,.38)}@media all{.mdc-text-field--disabled .mdc-text-field__input::placeholder{color:rgba(0,0,0,.38)}}@media all{.mdc-text-field--disabled .mdc-text-field__input:-ms-input-placeholder{color:rgba(0,0,0,.38)}}.mdc-text-field--disabled .mdc-floating-label{color:rgba(0,0,0,.38)}.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-helper-text{color:rgba(0,0,0,.38)}.mdc-text-field--disabled .mdc-text-field-character-counter,.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-character-counter{color:rgba(0,0,0,.38)}.mdc-text-field--disabled .mdc-text-field__icon--leading{color:rgba(0,0,0,.3)}.mdc-text-field--disabled .mdc-text-field__icon--trailing{color:rgba(0,0,0,.3)}.mdc-text-field--disabled .mdc-floating-label{cursor:default}.mdc-text-field--textarea.mdc-text-field--disabled{background-color:transparent;background-color:#f9f9f9}.mdc-text-field--textarea.mdc-text-field--disabled .mdc-notched-outline__leading,.mdc-text-field--textarea.mdc-text-field--disabled .mdc-notched-outline__notch,.mdc-text-field--textarea.mdc-text-field--disabled .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.06)}.mdc-text-field--textarea.mdc-text-field--disabled .mdc-text-field__input{border-bottom:none}.mdc-text-field--end-aligned .mdc-text-field__input{text-align:right}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__input,.mdc-text-field--end-aligned .mdc-text-field__input[dir=rtl]{text-align:left}@keyframes mdc-floating-label-shake-float-above-text-field-dense{0%{transform:translateX(calc(0 - 0%)) translateY(-70%) scale(0.8)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-70%) scale(0.8)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-70%) scale(0.8)}100%{transform:translateX(calc(0 - 0%)) translateY(-70%) scale(0.8)}}@keyframes mdc-floating-label-shake-float-above-text-field-outlined{0%{transform:translateX(calc(0 - 0%)) translateY(-34.75px) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-34.75px) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-34.75px) scale(0.75)}100%{transform:translateX(calc(0 - 0%)) translateY(-34.75px) scale(0.75)}}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-dense{0%{transform:translateX(calc(0 - 0%)) translateY(-120%) scale(0.8)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-120%) scale(0.8)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-120%) scale(0.8)}100%{transform:translateX(calc(0 - 0%)) translateY(-120%) scale(0.8)}}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon{0%{transform:translateX(calc(0 - 0)) translateY(-34.75px) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0)) translateY(-34.75px) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0)) translateY(-34.75px) scale(0.75)}100%{transform:translateX(calc(0 - 0)) translateY(-34.75px) scale(0.75)}}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-dense{0%{transform:translateX(calc(0 - 21px)) translateY(-120%) scale(0.8)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 21px)) translateY(-120%) scale(0.8)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 21px)) translateY(-120%) scale(0.8)}100%{transform:translateX(calc(0 - 21px)) translateY(-120%) scale(0.8)}}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-rtl{0%{transform:translateX(calc(0 - 0)) translateY(-34.75px) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0)) translateY(-34.75px) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0)) translateY(-34.75px) scale(0.75)}100%{transform:translateX(calc(0 - 0)) translateY(-34.75px) scale(0.75)}}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-dense-rtl{0%{transform:translateX(calc(0 - -21px)) translateY(-120%) scale(0.8)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - -21px)) translateY(-120%) scale(0.8)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - -21px)) translateY(-120%) scale(0.8)}100%{transform:translateX(calc(0 - -21px)) translateY(-120%) scale(0.8)}}@keyframes mdc-floating-label-shake-float-above-textarea{0%{transform:translateX(calc(0 - 0%)) translateY(-130%) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-130%) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-130%) scale(0.75)}100%{transform:translateX(calc(0 - 0%)) translateY(-130%) scale(0.75)}}.material-icons{font-family:var(--mdc-icon-font, "Material Icons");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:"liga"}.hidden,.hidden::before,.hidden::after{display:none}:host{display:inline-block;outline:none}:host([fullwidth]){display:block}.mdc-text-field{display:flex;width:100%;border-radius:4px 4px 0 0;border-radius:var(--mdc-text-field-filled-border-radius, 4px 4px 0 0)}mwc-notched-outline{--mdc-notched-outline-border-color: var(--mdc-text-field-outlined-idle-border-color, rgba(0, 0, 0, 0.38))}:host(:not([disabled]):hover) :not(.mdc-text-field--invalid):not(.mdc-text-field--focused) mwc-notched-outline{--mdc-notched-outline-border-color: var(--mdc-text-field-outlined-hover-border-color, rgba(0, 0, 0, 0.87))}:host(:not([disabled])) .mdc-text-field:not(.mdc-text-field--outlined){background-color:var(--mdc-text-field-fill-color, whitesmoke)}:host(:not([disabled])) .mdc-text-field:not(.mdc-text-field--outlined):not(.mdc-text-field--invalid) .mdc-text-field__input{border-bottom-color:var(--mdc-text-field-idle-line-color, black)}:host(:not([disabled])) .mdc-text-field:not(.mdc-text-field--outlined):not(.mdc-text-field--invalid) .mdc-text-field__input:hover{border-bottom-color:var(--mdc-text-field-hover-line-color, #000001)}:host(:not([disabled])) .mdc-text-field.mdc-text-field--invalid mwc-notched-outline{--mdc-notched-outline-border-color: var(--mdc-text-field-error-color, var(--mdc-theme-error, #b00020))}:host(:not([disabled])) .mdc-text-field.mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-character-counter,:host(:not([disabled])) .mdc-text-field.mdc-text-field--invalid .mdc-text-field__icon{color:var(--mdc-text-field-error-color, var(--mdc-theme-error, #b00020))}:host(:not([disabled])) .mdc-text-field:not(.mdc-text-field--invalid):not(.mdc-text-field--focused) .mdc-floating-label,:host(:not([disabled])) .mdc-text-field:not(.mdc-text-field--invalid):not(.mdc-text-field--focused) .mdc-floating-label::after{color:var(--mdc-text-field-label-ink-color, rgba(0, 0, 0, 0.6))}:host(:not([disabled])) .mdc-text-field.mdc-text-field--focused mwc-notched-outline{--mdc-notched-outline-stroke-width: 2px}:host(:not([disabled])) .mdc-text-field.mdc-text-field--focused:not(.mdc-text-field--invalid) mwc-notched-outline{--mdc-notched-outline-border-color: var(--mdc-text-field-focused-label-color, var(--mdc-theme-primary, rgba(98, 0, 238, 0.87)))}:host(:not([disabled])) .mdc-text-field.mdc-text-field--focused:not(.mdc-text-field--invalid) .mdc-floating-label{color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}:host(:not([disabled])) .mdc-text-field.mdc-text-field--focused:not(.mdc-text-field--invalid) .mdc-text-field__input:required~.mdc-floating-label::after,:host(:not([disabled])) .mdc-text-field.mdc-text-field--focused:not(.mdc-text-field--invalid) .mdc-text-field__input:required~.mdc-notched-outline .mdc-floating-label::after{color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}:host(:not([disabled])) .mdc-text-field .mdc-text-field__input{color:var(--mdc-text-field-ink-color, rgba(0, 0, 0, 0.87))}:host(:not([disabled])) .mdc-text-field .mdc-text-field__input::placeholder{color:var(--mdc-text-field-label-ink-color, rgba(0, 0, 0, 0.6))}:host(:not([disabled])) .mdc-text-field-helper-line .mdc-text-field-helper-text:not(.mdc-text-field-helper-text--validation-msg),:host(:not([disabled])) .mdc-text-field-helper-line:not(.mdc-text-field--invalid) .mdc-text-field-character-counter{color:var(--mdc-text-field-label-ink-color, rgba(0, 0, 0, 0.6))}:host([disabled]) .mdc-text-field:not(.mdc-text-field--outlined){background-color:var(--mdc-text-field-disabled-fill-color, #fafafa)}:host([disabled]) .mdc-text-field.mdc-text-field--outlined mwc-notched-outline{--mdc-notched-outline-border-color: var(--mdc-text-field-outlined-disabled-border-color, rgba(0, 0, 0, 0.06))}:host([disabled]) .mdc-text-field:not(.mdc-text-field--invalid):not(.mdc-text-field--focused) .mdc-floating-label,:host([disabled]) .mdc-text-field:not(.mdc-text-field--invalid):not(.mdc-text-field--focused) .mdc-floating-label::after{color:var(--mdc-text-field-disabled-ink-color, rgba(0, 0, 0, 0.38))}:host([disabled]) .mdc-text-field .mdc-text-field__input,:host([disabled]) .mdc-text-field .mdc-text-field__input::placeholder{color:var(--mdc-text-field-disabled-ink-color, rgba(0, 0, 0, 0.38))}:host([disabled]) .mdc-text-field-helper-line .mdc-text-field-helper-text,:host([disabled]) .mdc-text-field-helper-line .mdc-text-field-character-counter{color:var(--mdc-text-field-disabled-ink-color, rgba(0, 0, 0, 0.38))}`;
// CONCATENATED MODULE: ./node_modules/@material/mwc-textfield/mwc-textfield.js
/**
@license
Copyright 2019 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




let mwc_textfield_TextField = class TextField extends mwc_textfield_base_TextFieldBase {};
mwc_textfield_TextField.styles = mwc_textfield_css_style;
mwc_textfield_TextField = Object(tslib_es6["c" /* __decorate */])([customElement('mwc-textfield')], mwc_textfield_TextField);

// CONCATENATED MODULE: ./node_modules/@material/mwc-ripple/node_modules/@material/dom/events.js
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * Determine whether the current browser supports passive event listeners, and
 * if so, use them.
 */
function events_applyPassive(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }

  return events_supportsPassiveOption(globalObj) ? {
    passive: true
  } : false;
}

function events_supportsPassiveOption(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  } // See
  // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener


  var passiveSupported = false;

  try {
    var options = {
      // This function will be called when the browser
      // attempts to access the passive property.
      get passive() {
        passiveSupported = true;
        return false;
      }

    };

    var handler = function handler() {};

    globalObj.document.addEventListener('test', handler, options);
    globalObj.document.removeEventListener('test', handler, options);
  } catch (err) {
    passiveSupported = false;
  }

  return passiveSupported;
}
// CONCATENATED MODULE: ./node_modules/@material/mwc-ripple/node_modules/@material/dom/ponyfill.js
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
 * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
 */
function dom_ponyfill_closest(element, selector) {
  if (element.closest) {
    return element.closest(selector);
  }

  var el = element;

  while (el) {
    if (_material_dom_ponyfill_matches(el, selector)) {
      return el;
    }

    el = el.parentElement;
  }

  return null;
}
function _material_dom_ponyfill_matches(element, selector) {
  var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
  return nativeMatches.call(element, selector);
}
/**
 * Used to compute the estimated scroll width of elements. When an element is
 * hidden due to display: none; being applied to a parent element, the width is
 * returned as 0. However, the element will have a true width once no longer
 * inside a display: none context. This method computes an estimated width when
 * the element is hidden or returns the true width when the element is visble.
 * @param {Element} element the element whose width to estimate
 */

function dom_ponyfill_estimateScrollWidth(element) {
  // Check the offsetParent. If the element inherits display: none from any
  // parent, the offsetParent property will be null (see
  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent).
  // This check ensures we only clone the node when necessary.
  var htmlEl = element;

  if (htmlEl.offsetParent !== null) {
    return htmlEl.scrollWidth;
  }

  var clone = htmlEl.cloneNode(true);
  clone.style.setProperty('position', 'absolute');
  clone.style.setProperty('transform', 'translate(-9999px, -9999px)');
  document.documentElement.appendChild(clone);
  var scrollWidth = clone.scrollWidth;
  document.documentElement.removeChild(clone);
  return scrollWidth;
}
// CONCATENATED MODULE: ./node_modules/@material/mwc-ripple/node_modules/@material/base/foundation.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var mwc_ripple_node_modules_material_base_foundation_MDCFoundation =
/** @class */
function () {
  function MDCFoundation(adapter) {
    if (adapter === void 0) {
      adapter = {};
    }

    this.adapter_ = adapter;
  }

  Object.defineProperty(MDCFoundation, "cssClasses", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "strings", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "numbers", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "defaultAdapter", {
    get: function get() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    },
    enumerable: true,
    configurable: true
  });

  MDCFoundation.prototype.init = function () {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  };

  MDCFoundation.prototype.destroy = function () {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  };

  return MDCFoundation;
}();

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var mwc_ripple_node_modules_material_base_foundation = (mwc_ripple_node_modules_material_base_foundation_MDCFoundation);
// CONCATENATED MODULE: ./node_modules/@material/mwc-ripple/node_modules/@material/ripple/constants.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var ripple_constants_cssClasses = {
  // Ripple is a special case where the "root" component is really a "mixin" of sorts,
  // given that it's an 'upgrade' to an existing component. That being said it is the root
  // CSS class that all other CSS classes derive from.
  BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
  FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
  FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation',
  ROOT: 'mdc-ripple-upgraded',
  UNBOUNDED: 'mdc-ripple-upgraded--unbounded'
};
var ripple_constants_strings = {
  VAR_FG_SCALE: '--mdc-ripple-fg-scale',
  VAR_FG_SIZE: '--mdc-ripple-fg-size',
  VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end',
  VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
  VAR_LEFT: '--mdc-ripple-left',
  VAR_TOP: '--mdc-ripple-top'
};
var ripple_constants_numbers = {
  DEACTIVATION_TIMEOUT_MS: 225,
  FG_DEACTIVATION_MS: 150,
  INITIAL_ORIGIN_SCALE: 0.6,
  PADDING: 10,
  TAP_DELAY_MS: 300
};
// CONCATENATED MODULE: ./node_modules/@material/mwc-ripple/node_modules/@material/ripple/util.js
/**
 * Stores result from supportsCssVariables to avoid redundant processing to
 * detect CSS custom variable support.
 */
var supportsCssVariables_;
function supportsCssVariables(windowObj, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }

  var CSS = windowObj.CSS;
  var supportsCssVars = supportsCssVariables_;

  if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
    return supportsCssVariables_;
  }

  var supportsFunctionPresent = CSS && typeof CSS.supports === 'function';

  if (!supportsFunctionPresent) {
    return false;
  }

  var explicitlySupportsCssVars = CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
  // See: README section on Safari

  var weAreFeatureDetectingSafari10plus = CSS.supports('(--css-vars: yes)') && CSS.supports('color', '#00000000');
  supportsCssVars = explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;

  if (!forceRefresh) {
    supportsCssVariables_ = supportsCssVars;
  }

  return supportsCssVars;
}
function getNormalizedEventCoords(evt, pageOffset, clientRect) {
  if (!evt) {
    return {
      x: 0,
      y: 0
    };
  }

  var x = pageOffset.x,
      y = pageOffset.y;
  var documentX = x + clientRect.left;
  var documentY = y + clientRect.top;
  var normalizedX;
  var normalizedY; // Determine touch point relative to the ripple container.

  if (evt.type === 'touchstart') {
    var touchEvent = evt;
    normalizedX = touchEvent.changedTouches[0].pageX - documentX;
    normalizedY = touchEvent.changedTouches[0].pageY - documentY;
  } else {
    var mouseEvent = evt;
    normalizedX = mouseEvent.pageX - documentX;
    normalizedY = mouseEvent.pageY - documentY;
  }

  return {
    x: normalizedX,
    y: normalizedY
  };
}
// CONCATENATED MODULE: ./node_modules/@material/mwc-ripple/node_modules/@material/ripple/foundation.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



 // Activation events registered on the root element of each instance for activation

var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // simultaneous nested activations

var activatedTargets = [];

var foundation_MDCRippleFoundation =
/** @class */
function (_super) {
  tslib_es6["d" /* __extends */](MDCRippleFoundation, _super);

  function MDCRippleFoundation(adapter) {
    var _this = _super.call(this, tslib_es6["a" /* __assign */]({}, MDCRippleFoundation.defaultAdapter, adapter)) || this;

    _this.activationAnimationHasEnded_ = false;
    _this.activationTimer_ = 0;
    _this.fgDeactivationRemovalTimer_ = 0;
    _this.fgScale_ = '0';
    _this.frame_ = {
      width: 0,
      height: 0
    };
    _this.initialSize_ = 0;
    _this.layoutFrame_ = 0;
    _this.maxRadius_ = 0;
    _this.unboundedCoords_ = {
      left: 0,
      top: 0
    };
    _this.activationState_ = _this.defaultActivationState_();

    _this.activationTimerCallback_ = function () {
      _this.activationAnimationHasEnded_ = true;

      _this.runDeactivationUXLogicIfReady_();
    };

    _this.activateHandler_ = function (e) {
      return _this.activate_(e);
    };

    _this.deactivateHandler_ = function () {
      return _this.deactivate_();
    };

    _this.focusHandler_ = function () {
      return _this.handleFocus();
    };

    _this.blurHandler_ = function () {
      return _this.handleBlur();
    };

    _this.resizeHandler_ = function () {
      return _this.layout();
    };

    return _this;
  }

  Object.defineProperty(MDCRippleFoundation, "cssClasses", {
    get: function get() {
      return ripple_constants_cssClasses;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation, "strings", {
    get: function get() {
      return ripple_constants_strings;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation, "numbers", {
    get: function get() {
      return ripple_constants_numbers;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation, "defaultAdapter", {
    get: function get() {
      return {
        addClass: function addClass() {
          return undefined;
        },
        browserSupportsCssVars: function browserSupportsCssVars() {
          return true;
        },
        computeBoundingRect: function computeBoundingRect() {
          return {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            width: 0,
            height: 0
          };
        },
        containsEventTarget: function containsEventTarget() {
          return true;
        },
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() {
          return undefined;
        },
        deregisterInteractionHandler: function deregisterInteractionHandler() {
          return undefined;
        },
        deregisterResizeHandler: function deregisterResizeHandler() {
          return undefined;
        },
        getWindowPageOffset: function getWindowPageOffset() {
          return {
            x: 0,
            y: 0
          };
        },
        isSurfaceActive: function isSurfaceActive() {
          return true;
        },
        isSurfaceDisabled: function isSurfaceDisabled() {
          return true;
        },
        isUnbounded: function isUnbounded() {
          return true;
        },
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler() {
          return undefined;
        },
        registerInteractionHandler: function registerInteractionHandler() {
          return undefined;
        },
        registerResizeHandler: function registerResizeHandler() {
          return undefined;
        },
        removeClass: function removeClass() {
          return undefined;
        },
        updateCssVariable: function updateCssVariable() {
          return undefined;
        }
      };
    },
    enumerable: true,
    configurable: true
  });

  MDCRippleFoundation.prototype.init = function () {
    var _this = this;

    var supportsPressRipple = this.supportsPressRipple_();
    this.registerRootHandlers_(supportsPressRipple);

    if (supportsPressRipple) {
      var _a = MDCRippleFoundation.cssClasses,
          ROOT_1 = _a.ROOT,
          UNBOUNDED_1 = _a.UNBOUNDED;
      requestAnimationFrame(function () {
        _this.adapter_.addClass(ROOT_1);

        if (_this.adapter_.isUnbounded()) {
          _this.adapter_.addClass(UNBOUNDED_1); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


          _this.layoutInternal_();
        }
      });
    }
  };

  MDCRippleFoundation.prototype.destroy = function () {
    var _this = this;

    if (this.supportsPressRipple_()) {
      if (this.activationTimer_) {
        clearTimeout(this.activationTimer_);
        this.activationTimer_ = 0;
        this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
      }

      if (this.fgDeactivationRemovalTimer_) {
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.fgDeactivationRemovalTimer_ = 0;
        this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
      }

      var _a = MDCRippleFoundation.cssClasses,
          ROOT_2 = _a.ROOT,
          UNBOUNDED_2 = _a.UNBOUNDED;
      requestAnimationFrame(function () {
        _this.adapter_.removeClass(ROOT_2);

        _this.adapter_.removeClass(UNBOUNDED_2);

        _this.removeCssVars_();
      });
    }

    this.deregisterRootHandlers_();
    this.deregisterDeactivationHandlers_();
  };
  /**
   * @param evt Optional event containing position information.
   */


  MDCRippleFoundation.prototype.activate = function (evt) {
    this.activate_(evt);
  };

  MDCRippleFoundation.prototype.deactivate = function () {
    this.deactivate_();
  };

  MDCRippleFoundation.prototype.layout = function () {
    var _this = this;

    if (this.layoutFrame_) {
      cancelAnimationFrame(this.layoutFrame_);
    }

    this.layoutFrame_ = requestAnimationFrame(function () {
      _this.layoutInternal_();

      _this.layoutFrame_ = 0;
    });
  };

  MDCRippleFoundation.prototype.setUnbounded = function (unbounded) {
    var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

    if (unbounded) {
      this.adapter_.addClass(UNBOUNDED);
    } else {
      this.adapter_.removeClass(UNBOUNDED);
    }
  };

  MDCRippleFoundation.prototype.handleFocus = function () {
    var _this = this;

    requestAnimationFrame(function () {
      return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
    });
  };

  MDCRippleFoundation.prototype.handleBlur = function () {
    var _this = this;

    requestAnimationFrame(function () {
      return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
    });
  };
  /**
   * We compute this property so that we are not querying information about the client
   * until the point in time where the foundation requests it. This prevents scenarios where
   * client-side feature-detection may happen too early, such as when components are rendered on the server
   * and then initialized at mount time on the client.
   */


  MDCRippleFoundation.prototype.supportsPressRipple_ = function () {
    return this.adapter_.browserSupportsCssVars();
  };

  MDCRippleFoundation.prototype.defaultActivationState_ = function () {
    return {
      activationEvent: undefined,
      hasDeactivationUXRun: false,
      isActivated: false,
      isProgrammatic: false,
      wasActivatedByPointer: false,
      wasElementMadeActive: false
    };
  };
  /**
   * supportsPressRipple Passed from init to save a redundant function call
   */


  MDCRippleFoundation.prototype.registerRootHandlers_ = function (supportsPressRipple) {
    var _this = this;

    if (supportsPressRipple) {
      ACTIVATION_EVENT_TYPES.forEach(function (evtType) {
        _this.adapter_.registerInteractionHandler(evtType, _this.activateHandler_);
      });

      if (this.adapter_.isUnbounded()) {
        this.adapter_.registerResizeHandler(this.resizeHandler_);
      }
    }

    this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
    this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
  };

  MDCRippleFoundation.prototype.registerDeactivationHandlers_ = function (evt) {
    var _this = this;

    if (evt.type === 'keydown') {
      this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
    } else {
      POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (evtType) {
        _this.adapter_.registerDocumentInteractionHandler(evtType, _this.deactivateHandler_);
      });
    }
  };

  MDCRippleFoundation.prototype.deregisterRootHandlers_ = function () {
    var _this = this;

    ACTIVATION_EVENT_TYPES.forEach(function (evtType) {
      _this.adapter_.deregisterInteractionHandler(evtType, _this.activateHandler_);
    });
    this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
    this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

    if (this.adapter_.isUnbounded()) {
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    }
  };

  MDCRippleFoundation.prototype.deregisterDeactivationHandlers_ = function () {
    var _this = this;

    this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
    POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (evtType) {
      _this.adapter_.deregisterDocumentInteractionHandler(evtType, _this.deactivateHandler_);
    });
  };

  MDCRippleFoundation.prototype.removeCssVars_ = function () {
    var _this = this;

    var rippleStrings = MDCRippleFoundation.strings;
    var keys = Object.keys(rippleStrings);
    keys.forEach(function (key) {
      if (key.indexOf('VAR_') === 0) {
        _this.adapter_.updateCssVariable(rippleStrings[key], null);
      }
    });
  };

  MDCRippleFoundation.prototype.activate_ = function (evt) {
    var _this = this;

    if (this.adapter_.isSurfaceDisabled()) {
      return;
    }

    var activationState = this.activationState_;

    if (activationState.isActivated) {
      return;
    } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


    var previousActivationEvent = this.previousActivationEvent_;
    var isSameInteraction = previousActivationEvent && evt !== undefined && previousActivationEvent.type !== evt.type;

    if (isSameInteraction) {
      return;
    }

    activationState.isActivated = true;
    activationState.isProgrammatic = evt === undefined;
    activationState.activationEvent = evt;
    activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== undefined && (evt.type === 'mousedown' || evt.type === 'touchstart' || evt.type === 'pointerdown');
    var hasActivatedChild = evt !== undefined && activatedTargets.length > 0 && activatedTargets.some(function (target) {
      return _this.adapter_.containsEventTarget(target);
    });

    if (hasActivatedChild) {
      // Immediately reset activation state, while preserving logic that prevents touch follow-on events
      this.resetActivationState_();
      return;
    }

    if (evt !== undefined) {
      activatedTargets.push(evt.target);
      this.registerDeactivationHandlers_(evt);
    }

    activationState.wasElementMadeActive = this.checkElementMadeActive_(evt);

    if (activationState.wasElementMadeActive) {
      this.animateActivation_();
    }

    requestAnimationFrame(function () {
      // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
      activatedTargets = [];

      if (!activationState.wasElementMadeActive && evt !== undefined && (evt.key === ' ' || evt.keyCode === 32)) {
        // If space was pressed, try again within an rAF call to detect :active, because different UAs report
        // active states inconsistently when they're called within event handling code:
        // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
        // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
        // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
        // variable is set within a rAF callback for a submit button interaction (#2241).
        activationState.wasElementMadeActive = _this.checkElementMadeActive_(evt);

        if (activationState.wasElementMadeActive) {
          _this.animateActivation_();
        }
      }

      if (!activationState.wasElementMadeActive) {
        // Reset activation state immediately if element was not made active.
        _this.activationState_ = _this.defaultActivationState_();
      }
    });
  };

  MDCRippleFoundation.prototype.checkElementMadeActive_ = function (evt) {
    return evt !== undefined && evt.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
  };

  MDCRippleFoundation.prototype.animateActivation_ = function () {
    var _this = this;

    var _a = MDCRippleFoundation.strings,
        VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START,
        VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;
    var _b = MDCRippleFoundation.cssClasses,
        FG_DEACTIVATION = _b.FG_DEACTIVATION,
        FG_ACTIVATION = _b.FG_ACTIVATION;
    var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
    this.layoutInternal_();
    var translateStart = '';
    var translateEnd = '';

    if (!this.adapter_.isUnbounded()) {
      var _c = this.getFgTranslationCoordinates_(),
          startPoint = _c.startPoint,
          endPoint = _c.endPoint;

      translateStart = startPoint.x + "px, " + startPoint.y + "px";
      translateEnd = endPoint.x + "px, " + endPoint.y + "px";
    }

    this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
    this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

    clearTimeout(this.activationTimer_);
    clearTimeout(this.fgDeactivationRemovalTimer_);
    this.rmBoundedActivationClasses_();
    this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

    this.adapter_.computeBoundingRect();
    this.adapter_.addClass(FG_ACTIVATION);
    this.activationTimer_ = setTimeout(function () {
      return _this.activationTimerCallback_();
    }, DEACTIVATION_TIMEOUT_MS);
  };

  MDCRippleFoundation.prototype.getFgTranslationCoordinates_ = function () {
    var _a = this.activationState_,
        activationEvent = _a.activationEvent,
        wasActivatedByPointer = _a.wasActivatedByPointer;
    var startPoint;

    if (wasActivatedByPointer) {
      startPoint = getNormalizedEventCoords(activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
    } else {
      startPoint = {
        x: this.frame_.width / 2,
        y: this.frame_.height / 2
      };
    } // Center the element around the start point.


    startPoint = {
      x: startPoint.x - this.initialSize_ / 2,
      y: startPoint.y - this.initialSize_ / 2
    };
    var endPoint = {
      x: this.frame_.width / 2 - this.initialSize_ / 2,
      y: this.frame_.height / 2 - this.initialSize_ / 2
    };
    return {
      startPoint: startPoint,
      endPoint: endPoint
    };
  };

  MDCRippleFoundation.prototype.runDeactivationUXLogicIfReady_ = function () {
    var _this = this; // This method is called both when a pointing device is released, and when the activation animation ends.
    // The deactivation animation should only run after both of those occur.


    var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
    var _a = this.activationState_,
        hasDeactivationUXRun = _a.hasDeactivationUXRun,
        isActivated = _a.isActivated;
    var activationHasEnded = hasDeactivationUXRun || !isActivated;

    if (activationHasEnded && this.activationAnimationHasEnded_) {
      this.rmBoundedActivationClasses_();
      this.adapter_.addClass(FG_DEACTIVATION);
      this.fgDeactivationRemovalTimer_ = setTimeout(function () {
        _this.adapter_.removeClass(FG_DEACTIVATION);
      }, ripple_constants_numbers.FG_DEACTIVATION_MS);
    }
  };

  MDCRippleFoundation.prototype.rmBoundedActivationClasses_ = function () {
    var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
    this.adapter_.removeClass(FG_ACTIVATION);
    this.activationAnimationHasEnded_ = false;
    this.adapter_.computeBoundingRect();
  };

  MDCRippleFoundation.prototype.resetActivationState_ = function () {
    var _this = this;

    this.previousActivationEvent_ = this.activationState_.activationEvent;
    this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
    // Store the previous event until it's safe to assume that subsequent events are for new interactions.

    setTimeout(function () {
      return _this.previousActivationEvent_ = undefined;
    }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
  };

  MDCRippleFoundation.prototype.deactivate_ = function () {
    var _this = this;

    var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

    if (!activationState.isActivated) {
      return;
    }

    var state = tslib_es6["a" /* __assign */]({}, activationState);

    if (activationState.isProgrammatic) {
      requestAnimationFrame(function () {
        return _this.animateDeactivation_(state);
      });
      this.resetActivationState_();
    } else {
      this.deregisterDeactivationHandlers_();
      requestAnimationFrame(function () {
        _this.activationState_.hasDeactivationUXRun = true;

        _this.animateDeactivation_(state);

        _this.resetActivationState_();
      });
    }
  };

  MDCRippleFoundation.prototype.animateDeactivation_ = function (_a) {
    var wasActivatedByPointer = _a.wasActivatedByPointer,
        wasElementMadeActive = _a.wasElementMadeActive;

    if (wasActivatedByPointer || wasElementMadeActive) {
      this.runDeactivationUXLogicIfReady_();
    }
  };

  MDCRippleFoundation.prototype.layoutInternal_ = function () {
    var _this = this;

    this.frame_ = this.adapter_.computeBoundingRect();
    var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
    // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
    // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
    // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
    // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
    // `overflow: hidden`.

    var getBoundedRadius = function getBoundedRadius() {
      var hypotenuse = Math.sqrt(Math.pow(_this.frame_.width, 2) + Math.pow(_this.frame_.height, 2));
      return hypotenuse + MDCRippleFoundation.numbers.PADDING;
    };

    this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

    var initialSize = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE); // Unbounded ripple size should always be even number to equally center align.

    if (this.adapter_.isUnbounded() && initialSize % 2 !== 0) {
      this.initialSize_ = initialSize - 1;
    } else {
      this.initialSize_ = initialSize;
    }

    this.fgScale_ = "" + this.maxRadius_ / this.initialSize_;
    this.updateLayoutCssVars_();
  };

  MDCRippleFoundation.prototype.updateLayoutCssVars_ = function () {
    var _a = MDCRippleFoundation.strings,
        VAR_FG_SIZE = _a.VAR_FG_SIZE,
        VAR_LEFT = _a.VAR_LEFT,
        VAR_TOP = _a.VAR_TOP,
        VAR_FG_SCALE = _a.VAR_FG_SCALE;
    this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + "px");
    this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

    if (this.adapter_.isUnbounded()) {
      this.unboundedCoords_ = {
        left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
        top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
      };
      this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + "px");
      this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + "px");
    }
  };

  return MDCRippleFoundation;
}(mwc_ripple_node_modules_material_base_foundation_MDCFoundation);

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var ripple_foundation = (foundation_MDCRippleFoundation);
// CONCATENATED MODULE: ./node_modules/@material/mwc-ripple/mwc-ripple-global-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_ripple_global_css_style = css`@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}`;
// CONCATENATED MODULE: ./node_modules/@material/mwc-ripple/ripple-directive.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/






const supportsCssVariablesWin = supportsCssVariables(window); // NOTE: This is a workaround for
// https://bugs.webkit.org/show_bug.cgi?id=173027. Since keyframes on
// pseudo-elements (:after) are not supported in Shadow DOM, we put the keyframe
// style into the <head> element.

const isSafari = navigator.userAgent.match(/Safari/);
let didApplyRippleStyle = false;

const applyRippleStyle = () => {
  didApplyRippleStyle = true;
  const styleElement = document.createElement('style');
  const part = new parts_NodePart({
    templateFactory: templateFactory
  });
  part.appendInto(styleElement);
  part.setValue(mwc_ripple_global_css_style);
  part.commit(); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

  document.head.appendChild(styleElement);
};
/**
 * Applied a ripple to the node specified by {surfaceNode}.
 * @param options {RippleNodeOptions}
 */


const rippleNode = options => {
  if (isSafari && !didApplyRippleStyle) {
    applyRippleStyle();
  } // TODO(sorvell): This directive requires bringing css yourself. We probably
  // need to do this because of ShadyCSS, but on Safari, the keyframes styling
  // must be global. Perhaps this directive could fix that.


  const surfaceNode = options.surfaceNode;
  const interactionNode = options.interactionNode || surfaceNode; // only style interaction node if not in the same root

  if (interactionNode.getRootNode() !== surfaceNode.getRootNode()) {
    if (interactionNode.style.position === '') {
      interactionNode.style.position = 'relative';
    }
  }

  const adapter = {
    browserSupportsCssVars: () => supportsCssVariablesWin,
    isUnbounded: () => options.unbounded === undefined ? true : options.unbounded,
    isSurfaceActive: () => _material_dom_ponyfill_matches(interactionNode, ':active'),
    isSurfaceDisabled: () => Boolean(interactionNode.hasAttribute('disabled')),
    addClass: className => surfaceNode.classList.add(className),
    removeClass: className => surfaceNode.classList.remove(className),
    containsEventTarget: target => interactionNode.contains(target),
    registerInteractionHandler: (type, handler) => interactionNode.addEventListener(type, handler, events_applyPassive()),
    deregisterInteractionHandler: (type, handler) => interactionNode.removeEventListener(type, handler, events_applyPassive()),
    registerDocumentInteractionHandler: (evtType, handler) => // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    document.documentElement.addEventListener(evtType, handler, events_applyPassive()),
    deregisterDocumentInteractionHandler: (evtType, handler) => // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    document.documentElement.removeEventListener(evtType, handler, events_applyPassive()),
    registerResizeHandler: handler => window.addEventListener('resize', handler),
    deregisterResizeHandler: handler => window.removeEventListener('resize', handler),
    updateCssVariable: (varName, value) => surfaceNode.style.setProperty(varName, value),
    computeBoundingRect: () => surfaceNode.getBoundingClientRect(),
    getWindowPageOffset: () => ({
      x: window.pageXOffset,
      y: window.pageYOffset
    })
  };
  const rippleFoundation = new ripple_foundation(adapter);
  rippleFoundation.init();
  return rippleFoundation;
};
const rippleInteractionNodes = new WeakMap();
/**
 * A directive that applies a Material ripple to a part node. The directive
 * should be applied to a PropertyPart.
 * @param options {RippleOptions}
 */

const ripple = directive_directive((options = {}) => part => {
  const surfaceNode = part.committer.element;
  const interactionNode = options.interactionNode || surfaceNode;
  let rippleFoundation = part.value; // if the interaction node changes, destroy and invalidate the foundation.

  const existingInteractionNode = rippleInteractionNodes.get(rippleFoundation);

  if (existingInteractionNode !== undefined && existingInteractionNode !== interactionNode) {
    rippleFoundation.destroy();
    rippleFoundation = noChange;
  } // make the ripple, if needed


  if (rippleFoundation === noChange) {
    rippleFoundation = rippleNode(Object.assign({}, options, {
      surfaceNode
    }));
    rippleInteractionNodes.set(rippleFoundation, interactionNode);
    part.setValue(rippleFoundation); // otherwise update settings as needed.
  } else {
    if (options.unbounded !== undefined) {
      rippleFoundation.setUnbounded(options.unbounded);
    }

    if (options.disabled !== undefined) {
      rippleFoundation.setUnbounded(options.disabled);
    }
  }

  if (options.active === true) {
    rippleFoundation.activate();
  } else if (options.active === false) {
    rippleFoundation.deactivate();
  }
});
// CONCATENATED MODULE: ./node_modules/@material/mwc-button/mwc-button-base.js




class mwc_button_base_ButtonBase extends lit_element_LitElement {
  constructor() {
    super(...arguments);
    this.raised = false;
    this.unelevated = false;
    this.outlined = false;
    this.dense = false;
    this.disabled = false;
    this.trailingIcon = false;
    this.icon = '';
    this.label = '';
  }

  createRenderRoot() {
    return this.attachShadow({
      mode: 'open',
      delegatesFocus: true
    });
  }

  focus() {
    const buttonElement = this.buttonElement;

    if (buttonElement) {
      const ripple = buttonElement.ripple;

      if (ripple) {
        ripple.handleFocus();
      }

      buttonElement.focus();
    }
  }

  blur() {
    const buttonElement = this.buttonElement;

    if (buttonElement) {
      const ripple = buttonElement.ripple;

      if (ripple) {
        ripple.handleBlur();
      }

      buttonElement.blur();
    }
  }

  render() {
    const classes = {
      'mdc-button--raised': this.raised,
      'mdc-button--unelevated': this.unelevated,
      'mdc-button--outlined': this.outlined,
      'mdc-button--dense': this.dense
    };
    const mdcButtonIcon = lit_html_html`<span class="material-icons mdc-button__icon">${this.icon}</span>`;
    return lit_html_html`
      <button
          id="button"
          class="mdc-button ${classMap(classes)}"
          ?disabled="${this.disabled}"
          aria-label="${this.label || this.icon}">
        <div class="mdc-button__ripple"></div>
        ${this.icon && !this.trailingIcon ? mdcButtonIcon : ''}
        <span class="mdc-button__label">${this.label}</span>
        ${this.icon && this.trailingIcon ? mdcButtonIcon : ''}
        <slot></slot>
      </button>`;
  }

  firstUpdated() {
    this.buttonElement.ripple = rippleNode({
      surfaceNode: this.buttonElement,
      unbounded: false
    });
  }

}

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_button_base_ButtonBase.prototype, "raised", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_button_base_ButtonBase.prototype, "unelevated", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_button_base_ButtonBase.prototype, "outlined", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_button_base_ButtonBase.prototype, "dense", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
})], mwc_button_base_ButtonBase.prototype, "disabled", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_button_base_ButtonBase.prototype, "trailingIcon", void 0);

Object(tslib_es6["c" /* __decorate */])([property()], mwc_button_base_ButtonBase.prototype, "icon", void 0);

Object(tslib_es6["c" /* __decorate */])([property()], mwc_button_base_ButtonBase.prototype, "label", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('#button')], mwc_button_base_ButtonBase.prototype, "buttonElement", void 0);
// CONCATENATED MODULE: ./node_modules/@material/mwc-button/mwc-button-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_button_css_style = css`.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;opacity:0;pointer-events:none;transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:#fff}.mdc-button{font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:.875rem;line-height:2.25rem;font-weight:500;letter-spacing:.0892857143em;text-decoration:none;text-transform:uppercase;padding:0 8px 0 8px;position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;user-select:none;-webkit-appearance:none;overflow:visible;vertical-align:middle;border-radius:4px}.mdc-button .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button .mdc-button__ripple{border-radius:4px}.mdc-button:not(:disabled){background-color:transparent}.mdc-button:disabled{background-color:transparent}.mdc-button .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;width:18px;height:18px;font-size:18px;vertical-align:top}[dir=rtl] .mdc-button .mdc-button__icon,.mdc-button .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:0}.mdc-button .mdc-button__touch{position:absolute;top:50%;right:0;height:48px;left:0;transform:translateY(-50%)}.mdc-button:not(:disabled){color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}.mdc-button:disabled{color:rgba(0,0,0,.38)}.mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:0}[dir=rtl] .mdc-button__label+.mdc-button__icon,.mdc-button__label+.mdc-button__icon[dir=rtl]{margin-left:0;margin-right:8px}svg.mdc-button__icon{fill:currentColor}.mdc-button--raised .mdc-button__icon,.mdc-button--unelevated .mdc-button__icon,.mdc-button--outlined .mdc-button__icon{margin-left:-4px;margin-right:8px}[dir=rtl] .mdc-button--raised .mdc-button__icon,.mdc-button--raised .mdc-button__icon[dir=rtl],[dir=rtl] .mdc-button--unelevated .mdc-button__icon,.mdc-button--unelevated .mdc-button__icon[dir=rtl],[dir=rtl] .mdc-button--outlined .mdc-button__icon,.mdc-button--outlined .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:-4px}.mdc-button--raised .mdc-button__label+.mdc-button__icon,.mdc-button--unelevated .mdc-button__label+.mdc-button__icon,.mdc-button--outlined .mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:-4px}[dir=rtl] .mdc-button--raised .mdc-button__label+.mdc-button__icon,.mdc-button--raised .mdc-button__label+.mdc-button__icon[dir=rtl],[dir=rtl] .mdc-button--unelevated .mdc-button__label+.mdc-button__icon,.mdc-button--unelevated .mdc-button__label+.mdc-button__icon[dir=rtl],[dir=rtl] .mdc-button--outlined .mdc-button__label+.mdc-button__icon,.mdc-button--outlined .mdc-button__label+.mdc-button__icon[dir=rtl]{margin-left:-4px;margin-right:8px}.mdc-button--raised,.mdc-button--unelevated{padding:0 16px 0 16px}.mdc-button--raised:not(:disabled),.mdc-button--unelevated:not(:disabled){background-color:#6200ee;background-color:var(--mdc-theme-primary, #6200ee)}.mdc-button--raised:not(:disabled),.mdc-button--unelevated:not(:disabled){color:#fff;color:var(--mdc-theme-on-primary, #fff)}.mdc-button--raised:disabled,.mdc-button--unelevated:disabled{background-color:rgba(0,0,0,.12)}.mdc-button--raised:disabled,.mdc-button--unelevated:disabled{color:rgba(0,0,0,.38)}.mdc-button--raised{box-shadow:0px 3px 1px -2px rgba(0, 0, 0, 0.2),0px 2px 2px 0px rgba(0, 0, 0, 0.14),0px 1px 5px 0px rgba(0,0,0,.12);transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button--raised:hover,.mdc-button--raised:focus{box-shadow:0px 2px 4px -1px rgba(0, 0, 0, 0.2),0px 4px 5px 0px rgba(0, 0, 0, 0.14),0px 1px 10px 0px rgba(0,0,0,.12)}.mdc-button--raised:active{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2),0px 8px 10px 1px rgba(0, 0, 0, 0.14),0px 3px 14px 2px rgba(0,0,0,.12)}.mdc-button--raised:disabled{box-shadow:0px 0px 0px 0px rgba(0, 0, 0, 0.2),0px 0px 0px 0px rgba(0, 0, 0, 0.14),0px 0px 0px 0px rgba(0,0,0,.12)}.mdc-button--outlined{padding:0 15px 0 15px;border-width:1px;border-style:solid}.mdc-button--outlined .mdc-button__ripple{top:-1px;left:-1px;border:1px solid transparent}.mdc-button--outlined:not(:disabled){border-color:rgba(0,0,0,.12)}.mdc-button--outlined:disabled{border-color:rgba(0,0,0,.12)}.mdc-button--touch{margin-top:6px;margin-bottom:6px}@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}.mdc-button{--mdc-ripple-fg-size: 0;--mdc-ripple-left: 0;--mdc-ripple-top: 0;--mdc-ripple-fg-scale: 1;--mdc-ripple-fg-translate-end: 0;--mdc-ripple-fg-translate-start: 0;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mdc-button .mdc-button__ripple::before,.mdc-button .mdc-button__ripple::after{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:""}.mdc-button .mdc-button__ripple::before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1}.mdc-button.mdc-ripple-upgraded .mdc-button__ripple::before{transform:scale(var(--mdc-ripple-fg-scale, 1))}.mdc-button.mdc-ripple-upgraded .mdc-button__ripple::after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-button.mdc-ripple-upgraded--unbounded .mdc-button__ripple::after{top:var(--mdc-ripple-top, 0);left:var(--mdc-ripple-left, 0)}.mdc-button.mdc-ripple-upgraded--foreground-activation .mdc-button__ripple::after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-button.mdc-ripple-upgraded--foreground-deactivation .mdc-button__ripple::after{animation:mdc-ripple-fg-opacity-out 150ms;transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}.mdc-button .mdc-button__ripple::before,.mdc-button .mdc-button__ripple::after{top:calc(50% - 100%);left:calc(50% - 100%);width:200%;height:200%}.mdc-button.mdc-ripple-upgraded .mdc-button__ripple::after{width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-button .mdc-button__ripple::before,.mdc-button .mdc-button__ripple::after{background-color:#6200ee;background-color:var(--mdc-theme-primary, #6200ee)}.mdc-button:hover .mdc-button__ripple::before{opacity:.04}.mdc-button.mdc-ripple-upgraded--background-focused .mdc-button__ripple::before,.mdc-button:not(.mdc-ripple-upgraded):focus .mdc-button__ripple::before{transition-duration:75ms;opacity:.12}.mdc-button:not(.mdc-ripple-upgraded) .mdc-button__ripple::after{transition:opacity 150ms linear}.mdc-button:not(.mdc-ripple-upgraded):active .mdc-button__ripple::after{transition-duration:75ms;opacity:.12}.mdc-button.mdc-ripple-upgraded{--mdc-ripple-fg-opacity: 0.12}.mdc-button .mdc-button__ripple{position:absolute;box-sizing:content-box;width:100%;height:100%;overflow:hidden}.mdc-button:not(.mdc-button--outlined) .mdc-button__ripple{top:0;left:0}.mdc-button--raised .mdc-button__ripple::before,.mdc-button--raised .mdc-button__ripple::after,.mdc-button--unelevated .mdc-button__ripple::before,.mdc-button--unelevated .mdc-button__ripple::after{background-color:#fff;background-color:var(--mdc-theme-on-primary, #fff)}.mdc-button--raised:hover .mdc-button__ripple::before,.mdc-button--unelevated:hover .mdc-button__ripple::before{opacity:.08}.mdc-button--raised.mdc-ripple-upgraded--background-focused .mdc-button__ripple::before,.mdc-button--raised:not(.mdc-ripple-upgraded):focus .mdc-button__ripple::before,.mdc-button--unelevated.mdc-ripple-upgraded--background-focused .mdc-button__ripple::before,.mdc-button--unelevated:not(.mdc-ripple-upgraded):focus .mdc-button__ripple::before{transition-duration:75ms;opacity:.24}.mdc-button--raised:not(.mdc-ripple-upgraded) .mdc-button__ripple::after,.mdc-button--unelevated:not(.mdc-ripple-upgraded) .mdc-button__ripple::after{transition:opacity 150ms linear}.mdc-button--raised:not(.mdc-ripple-upgraded):active .mdc-button__ripple::after,.mdc-button--unelevated:not(.mdc-ripple-upgraded):active .mdc-button__ripple::after{transition-duration:75ms;opacity:.24}.mdc-button--raised.mdc-ripple-upgraded,.mdc-button--unelevated.mdc-ripple-upgraded{--mdc-ripple-fg-opacity: 0.24}.mdc-button{height:36px}.material-icons{font-family:var(--mdc-icon-font, "Material Icons");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:"liga"}.mdc-button--raised{box-shadow:var(--mdc-button-raised-box-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mdc-button--raised:hover,.mdc-button--raised:focus{box-shadow:var(--mdc-button-raised-box-shadow-hover, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mdc-button--raised:active{box-shadow:var(--mdc-button-raised-box-shadow-active, 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12))}.mdc-button--raised:disabled{box-shadow:var(--mdc-button-raised-box-shadow-disabled, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12))}:host{display:inline-flex;outline:none;vertical-align:top}:host([disabled]){pointer-events:none}.mdc-button{flex:auto;overflow:hidden;text-transform:var(--mdc-button-text-transform, uppercase);letter-spacing:var(--mdc-button-letter-spacing, 0.0892857143em);padding:0 var(--mdc-button-horizontal-padding, 8px) 0 var(--mdc-button-horizontal-padding, 8px)}.mdc-button.mdc-button--raised,.mdc-button.mdc-button--unelevated{padding:0 var(--mdc-button-horizontal-padding, 16px) 0 var(--mdc-button-horizontal-padding, 16px)}.mdc-button.mdc-button--outlined{padding:0 calc(var(--mdc-button-horizontal-padding, 16px) - var(--mdc-button-outline-width, 1px)) 0 calc(var(--mdc-button-horizontal-padding, 16px) - var(--mdc-button-outline-width, 1px));border-width:var(--mdc-button-outline-width, 1px);border-color:var(--mdc-button-outline-color, var(--mdc-theme-primary, #6200ee))}.mdc-button.mdc-button--dense{height:28px;margin-top:0;margin-bottom:0}.mdc-button.mdc-button--dense .mdc-button__touch{display:none}.mdc-button .mdc-button__ripple{border-radius:0}:host([disabled]) .mdc-button.mdc-button--raised,:host([disabled]) .mdc-button.mdc-button--unelevated{background-color:var(--mdc-button-disabled-fill-color, rgba(0, 0, 0, 0.12));color:var(--mdc-button-disabled-ink-color, rgba(0, 0, 0, 0.38))}:host([disabled]) .mdc-button:not(.mdc-button--raised):not(.mdc-button--unelevated){color:var(--mdc-button-disabled-ink-color, rgba(0, 0, 0, 0.38))}:host([disabled]) .mdc-button.mdc-button--outlined{border-color:var(--mdc-button-disabled-ink-color, rgba(0, 0, 0, 0.38));border-color:var(--mdc-button-disabled-outline-color, var(--mdc-button-disabled-ink-color, rgba(0, 0, 0, 0.38)))}`;
// CONCATENATED MODULE: ./node_modules/@material/mwc-button/mwc-button.js

/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




let mwc_button_Button = class Button extends mwc_button_base_ButtonBase {};
mwc_button_Button.styles = mwc_button_css_style;
mwc_button_Button = Object(tslib_es6["c" /* __decorate */])([customElement('mwc-button')], mwc_button_Button);

// CONCATENATED MODULE: ./node_modules/@material/mwc-fab/mwc-fab-base.js

/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




class mwc_fab_base_FabBase extends lit_element_LitElement {
  constructor() {
    super(...arguments);
    this.mini = false;
    this.exited = false;
    this.disabled = false;
    this.extended = false;
    this.showIconAtEnd = false;
    this.icon = '';
    this.label = '';
  }

  createRenderRoot() {
    return this.attachShadow({
      mode: 'open',
      delegatesFocus: true
    });
  }

  render() {
    const classes = {
      'mdc-fab--mini': this.mini,
      'mdc-fab--exited': this.exited,
      'mdc-fab--extended': this.extended
    };
    const showLabel = this.label !== '' && this.extended;
    let iconTemplate = '';

    if (this.icon) {
      iconTemplate = lit_html_html`
        <span class="material-icons mdc-fab__icon">${this.icon}</span>`;
    }

    let label = lit_html_html``;

    if (showLabel) {
      label = lit_html_html`<span class="mdc-fab__label">${this.label}</span>`;
    }

    return lit_html_html`
      <button
          class="mdc-fab ${classMap(classes)}"
          ?disabled="${this.disabled}"
          aria-label="${this.label || this.icon}"
          .ripple="${ripple()}">
        <div class="mdc-fab__ripple"></div>
        ${this.showIconAtEnd ? label : ''}
        ${iconTemplate}
        ${!this.showIconAtEnd ? label : ''}
      </button>`;
  }

}

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_fab_base_FabBase.prototype, "mini", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_fab_base_FabBase.prototype, "exited", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_fab_base_FabBase.prototype, "disabled", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_fab_base_FabBase.prototype, "extended", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_fab_base_FabBase.prototype, "showIconAtEnd", void 0);

Object(tslib_es6["c" /* __decorate */])([property()], mwc_fab_base_FabBase.prototype, "icon", void 0);

Object(tslib_es6["c" /* __decorate */])([property()], mwc_fab_base_FabBase.prototype, "label", void 0);
// CONCATENATED MODULE: ./node_modules/@material/mwc-fab/mwc-fab-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_fab_css_style = css`.material-icons{font-family:var(--mdc-icon-font, "Material Icons");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:"liga"}.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;opacity:0;pointer-events:none;transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:#fff}.mdc-fab{position:relative;box-shadow:0px 3px 5px -1px rgba(0, 0, 0, 0.2),0px 6px 10px 0px rgba(0, 0, 0, 0.14),0px 1px 18px 0px rgba(0,0,0,.12);display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;user-select:none;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1);background-color:#018786;background-color:var(--mdc-theme-secondary, #018786);color:#fff;color:var(--mdc-theme-on-secondary, #fff)}.mdc-fab .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-fab:not(.mdc-fab--extended){border-radius:50%}.mdc-fab:not(.mdc-fab--extended) .mdc-fab__ripple{border-radius:50%}.mdc-fab::-moz-focus-inner{padding:0;border:0}.mdc-fab:hover,.mdc-fab:focus{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2),0px 8px 10px 1px rgba(0, 0, 0, 0.14),0px 3px 14px 2px rgba(0,0,0,.12)}.mdc-fab:active{box-shadow:0px 7px 8px -4px rgba(0, 0, 0, 0.2),0px 12px 17px 2px rgba(0, 0, 0, 0.14),0px 5px 22px 4px rgba(0,0,0,.12)}.mdc-fab:active,.mdc-fab:focus{outline:none}.mdc-fab:hover{cursor:pointer}.mdc-fab>svg{width:100%}.mdc-fab .mdc-fab__icon{width:24px;height:24px;font-size:24px}.mdc-fab--mini{width:40px;height:40px}.mdc-fab--extended{font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:.875rem;line-height:2.25rem;font-weight:500;letter-spacing:.0892857143em;text-decoration:none;text-transform:uppercase;border-radius:24px;padding:0 20px;width:auto;max-width:100%;height:48px;line-height:normal}.mdc-fab--extended .mdc-fab__ripple{border-radius:24px}.mdc-fab--extended .mdc-fab__icon{margin-left:-8px;margin-right:12px}[dir=rtl] .mdc-fab--extended .mdc-fab__icon,.mdc-fab--extended .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:-8px}.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:-8px}[dir=rtl] .mdc-fab--extended .mdc-fab__label+.mdc-fab__icon,.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:-8px;margin-right:12px}.mdc-fab--touch{margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-fab--touch .mdc-fab__touch{position:absolute;top:50%;right:0;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mdc-fab__label{justify-content:flex-start;text-overflow:ellipsis;white-space:nowrap;overflow-x:hidden;overflow-y:visible}.mdc-fab__icon{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mdc-fab .mdc-fab__icon{display:inline-flex;align-items:center;justify-content:center}.mdc-fab--exited{transform:scale(0);opacity:0;transition:opacity 15ms linear 150ms,transform 180ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-fab--exited .mdc-fab__icon{transform:scale(0);transition:transform 135ms 0ms cubic-bezier(0.4, 0, 1, 1)}@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}.mdc-fab{--mdc-ripple-fg-size: 0;--mdc-ripple-left: 0;--mdc-ripple-top: 0;--mdc-ripple-fg-scale: 1;--mdc-ripple-fg-translate-end: 0;--mdc-ripple-fg-translate-start: 0;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mdc-fab .mdc-fab__ripple::before,.mdc-fab .mdc-fab__ripple::after{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:""}.mdc-fab .mdc-fab__ripple::before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1}.mdc-fab.mdc-ripple-upgraded .mdc-fab__ripple::before{transform:scale(var(--mdc-ripple-fg-scale, 1))}.mdc-fab.mdc-ripple-upgraded .mdc-fab__ripple::after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-fab.mdc-ripple-upgraded--unbounded .mdc-fab__ripple::after{top:var(--mdc-ripple-top, 0);left:var(--mdc-ripple-left, 0)}.mdc-fab.mdc-ripple-upgraded--foreground-activation .mdc-fab__ripple::after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-fab.mdc-ripple-upgraded--foreground-deactivation .mdc-fab__ripple::after{animation:mdc-ripple-fg-opacity-out 150ms;transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}.mdc-fab .mdc-fab__ripple::before,.mdc-fab .mdc-fab__ripple::after{top:calc(50% - 100%);left:calc(50% - 100%);width:200%;height:200%}.mdc-fab.mdc-ripple-upgraded .mdc-fab__ripple::after{width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-fab .mdc-fab__ripple::before,.mdc-fab .mdc-fab__ripple::after{background-color:#fff;background-color:var(--mdc-theme-on-secondary, #fff)}.mdc-fab:hover .mdc-fab__ripple::before{opacity:.08}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__ripple::before,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__ripple::before{transition-duration:75ms;opacity:.24}.mdc-fab:not(.mdc-ripple-upgraded) .mdc-fab__ripple::after{transition:opacity 150ms linear}.mdc-fab:not(.mdc-ripple-upgraded):active .mdc-fab__ripple::after{transition-duration:75ms;opacity:.24}.mdc-fab.mdc-ripple-upgraded{--mdc-ripple-fg-opacity: 0.24}.mdc-fab .mdc-fab__ripple{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;overflow:hidden}:host{outline:none}.mdc-fab{box-shadow:var(--mdc-fab-box-shadow, 0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12))}.mdc-fab:hover,.mdc-fab:focus{box-shadow:var(--mdc-fab-box-shadow-hover, 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12))}.mdc-fab:active{box-shadow:var(--mdc-fab-box-shadow-active, 0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 12px 17px 2px rgba(0, 0, 0, 0.14), 0px 5px 22px 4px rgba(0, 0, 0, 0.12))}`;
// CONCATENATED MODULE: ./node_modules/@material/mwc-fab/mwc-fab.js

/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




let mwc_fab_Fab = class Fab extends mwc_fab_base_FabBase {};
mwc_fab_Fab.styles = mwc_fab_css_style;
mwc_fab_Fab = Object(tslib_es6["c" /* __decorate */])([customElement('mwc-fab')], mwc_fab_Fab);

// CONCATENATED MODULE: ./src/shared-styles.js

const sharedStyles = css`
  .column {
    display: flex;
    flex-direction: column;
  }

  .row {
    display: flex;
    flex-direction: row;
  }

  .fill {
    flex: 1;
    height: 100%;
    width: 100%;
  }

  .center-content {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .fading {
    opacity: 0.7;
  }

  .medium-padding {
    padding: 16px;
  }

  .title {
    font-size: 20px;
    font-weight: bold;
  }

  .danger {
    --mdc-theme-primary: red;
  }
`;
// EXTERNAL MODULE: ./node_modules/graphql-tools/dist/index.js
var dist = __webpack_require__(74);

// EXTERNAL MODULE: ./node_modules/apollo-utilities/lib/bundle.esm.js
var bundle_esm = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/@wry/equality/lib/equality.esm.js
var equality_esm = __webpack_require__(114);

// EXTERNAL MODULE: ./node_modules/zen-observable-ts/lib/bundle.esm.js
var lib_bundle_esm = __webpack_require__(28);

// EXTERNAL MODULE: ./node_modules/apollo-link/lib/bundle.esm.js
var apollo_link_lib_bundle_esm = __webpack_require__(49);

// EXTERNAL MODULE: ./node_modules/symbol-observable/es/index.js
var es = __webpack_require__(165);

// EXTERNAL MODULE: ./node_modules/ts-invariant/lib/invariant.esm.js
var invariant_esm = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/graphql/language/visitor.mjs
var visitor = __webpack_require__(14);

// CONCATENATED MODULE: ./node_modules/apollo-client/bundle.esm.js






var NetworkStatus;

(function (NetworkStatus) {
  NetworkStatus[NetworkStatus["loading"] = 1] = "loading";
  NetworkStatus[NetworkStatus["setVariables"] = 2] = "setVariables";
  NetworkStatus[NetworkStatus["fetchMore"] = 3] = "fetchMore";
  NetworkStatus[NetworkStatus["refetch"] = 4] = "refetch";
  NetworkStatus[NetworkStatus["poll"] = 6] = "poll";
  NetworkStatus[NetworkStatus["ready"] = 7] = "ready";
  NetworkStatus[NetworkStatus["error"] = 8] = "error";
})(NetworkStatus || (NetworkStatus = {}));

function isNetworkRequestInFlight(networkStatus) {
  return networkStatus < 7;
}

var bundle_esm_Observable = function (_super) {
  Object(tslib_es6["d" /* __extends */])(Observable, _super);

  function Observable() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Observable.prototype[es["a" /* default */]] = function () {
    return this;
  };

  Observable.prototype['@@observable'] = function () {
    return this;
  };

  return Observable;
}(lib_bundle_esm["a" /* default */]);

function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}

function isApolloError(err) {
  return err.hasOwnProperty('graphQLErrors');
}

var generateErrorMessage = function generateErrorMessage(err) {
  var message = '';

  if (isNonEmptyArray(err.graphQLErrors)) {
    err.graphQLErrors.forEach(function (graphQLError) {
      var errorMessage = graphQLError ? graphQLError.message : 'Error message not found.';
      message += "GraphQL error: " + errorMessage + "\n";
    });
  }

  if (err.networkError) {
    message += 'Network error: ' + err.networkError.message + '\n';
  }

  message = message.replace(/\n$/, '');
  return message;
};

var bundle_esm_ApolloError = function (_super) {
  Object(tslib_es6["d" /* __extends */])(ApolloError, _super);

  function ApolloError(_a) {
    var graphQLErrors = _a.graphQLErrors,
        networkError = _a.networkError,
        errorMessage = _a.errorMessage,
        extraInfo = _a.extraInfo;

    var _this = _super.call(this, errorMessage) || this;

    _this.graphQLErrors = graphQLErrors || [];
    _this.networkError = networkError || null;

    if (!errorMessage) {
      _this.message = generateErrorMessage(_this);
    } else {
      _this.message = errorMessage;
    }

    _this.extraInfo = extraInfo;
    _this.__proto__ = ApolloError.prototype;
    return _this;
  }

  return ApolloError;
}(Error);

var FetchType;

(function (FetchType) {
  FetchType[FetchType["normal"] = 1] = "normal";
  FetchType[FetchType["refetch"] = 2] = "refetch";
  FetchType[FetchType["poll"] = 3] = "poll";
})(FetchType || (FetchType = {}));

var hasError = function hasError(storeValue, policy) {
  if (policy === void 0) {
    policy = 'none';
  }

  return storeValue && (storeValue.networkError || policy === 'none' && isNonEmptyArray(storeValue.graphQLErrors));
};

var bundle_esm_ObservableQuery = function (_super) {
  Object(tslib_es6["d" /* __extends */])(ObservableQuery, _super);

  function ObservableQuery(_a) {
    var queryManager = _a.queryManager,
        options = _a.options,
        _b = _a.shouldSubscribe,
        shouldSubscribe = _b === void 0 ? true : _b;

    var _this = _super.call(this, function (observer) {
      return _this.onSubscribe(observer);
    }) || this;

    _this.observers = new Set();
    _this.subscriptions = new Set();
    _this.isTornDown = false;
    _this.options = options;
    _this.variables = options.variables || {};
    _this.queryId = queryManager.generateQueryId();
    _this.shouldSubscribe = shouldSubscribe;
    var opDef = Object(bundle_esm["m" /* getOperationDefinition */])(options.query);
    _this.queryName = opDef && opDef.name && opDef.name.value;
    _this.queryManager = queryManager;
    return _this;
  }

  ObservableQuery.prototype.result = function () {
    var _this = this;

    return new Promise(function (resolve, reject) {
      var observer = {
        next: function next(result) {
          resolve(result);

          _this.observers.delete(observer);

          if (!_this.observers.size) {
            _this.queryManager.removeQuery(_this.queryId);
          }

          setTimeout(function () {
            subscription.unsubscribe();
          }, 0);
        },
        error: reject
      };

      var subscription = _this.subscribe(observer);
    });
  };

  ObservableQuery.prototype.currentResult = function () {
    var result = this.getCurrentResult();

    if (result.data === undefined) {
      result.data = {};
    }

    return result;
  };

  ObservableQuery.prototype.getCurrentResult = function () {
    if (this.isTornDown) {
      var lastResult = this.lastResult;
      return {
        data: !this.lastError && lastResult && lastResult.data || void 0,
        error: this.lastError,
        loading: false,
        networkStatus: NetworkStatus.error
      };
    }

    var _a = this.queryManager.getCurrentQueryResult(this),
        data = _a.data,
        partial = _a.partial;

    var queryStoreValue = this.queryManager.queryStore.get(this.queryId);
    var result;
    var fetchPolicy = this.options.fetchPolicy;
    var isNetworkFetchPolicy = fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';

    if (queryStoreValue) {
      var networkStatus = queryStoreValue.networkStatus;

      if (hasError(queryStoreValue, this.options.errorPolicy)) {
        return {
          data: void 0,
          loading: false,
          networkStatus: networkStatus,
          error: new bundle_esm_ApolloError({
            graphQLErrors: queryStoreValue.graphQLErrors,
            networkError: queryStoreValue.networkError
          })
        };
      }

      if (queryStoreValue.variables) {
        this.options.variables = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, this.options.variables), queryStoreValue.variables);
        this.variables = this.options.variables;
      }

      result = {
        data: data,
        loading: isNetworkRequestInFlight(networkStatus),
        networkStatus: networkStatus
      };

      if (queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {
        result.errors = queryStoreValue.graphQLErrors;
      }
    } else {
      var loading = isNetworkFetchPolicy || partial && fetchPolicy !== 'cache-only';
      result = {
        data: data,
        loading: loading,
        networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready
      };
    }

    if (!partial) {
      this.updateLastResult(Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, result), {
        stale: false
      }));
    }

    return Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, result), {
      partial: partial
    });
  };

  ObservableQuery.prototype.isDifferentFromLastResult = function (newResult) {
    var snapshot = this.lastResultSnapshot;
    return !(snapshot && newResult && snapshot.networkStatus === newResult.networkStatus && snapshot.stale === newResult.stale && Object(equality_esm["a" /* equal */])(snapshot.data, newResult.data));
  };

  ObservableQuery.prototype.getLastResult = function () {
    return this.lastResult;
  };

  ObservableQuery.prototype.getLastError = function () {
    return this.lastError;
  };

  ObservableQuery.prototype.resetLastResults = function () {
    delete this.lastResult;
    delete this.lastResultSnapshot;
    delete this.lastError;
    this.isTornDown = false;
  };

  ObservableQuery.prototype.resetQueryStoreErrors = function () {
    var queryStore = this.queryManager.queryStore.get(this.queryId);

    if (queryStore) {
      queryStore.networkError = null;
      queryStore.graphQLErrors = [];
    }
  };

  ObservableQuery.prototype.refetch = function (variables) {
    var fetchPolicy = this.options.fetchPolicy;

    if (fetchPolicy === 'cache-only') {
      return Promise.reject( true ? new invariant_esm["a" /* InvariantError */](3) : undefined);
    }

    if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'cache-and-network') {
      fetchPolicy = 'network-only';
    }

    if (!Object(equality_esm["a" /* equal */])(this.variables, variables)) {
      this.variables = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, this.variables), variables);
    }

    if (!Object(equality_esm["a" /* equal */])(this.options.variables, this.variables)) {
      this.options.variables = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, this.options.variables), this.variables);
    }

    return this.queryManager.fetchQuery(this.queryId, Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, this.options), {
      fetchPolicy: fetchPolicy
    }), FetchType.refetch);
  };

  ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {
    var _this = this;

     true ? Object(invariant_esm["b" /* invariant */])(fetchMoreOptions.updateQuery, 4) : undefined;

    var combinedOptions = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, fetchMoreOptions.query ? fetchMoreOptions : Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, this.options), fetchMoreOptions), {
      variables: Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, this.variables), fetchMoreOptions.variables)
    })), {
      fetchPolicy: 'network-only'
    });

    var qid = this.queryManager.generateQueryId();
    return this.queryManager.fetchQuery(qid, combinedOptions, FetchType.normal, this.queryId).then(function (fetchMoreResult) {
      _this.updateQuery(function (previousResult) {
        return fetchMoreOptions.updateQuery(previousResult, {
          fetchMoreResult: fetchMoreResult.data,
          variables: combinedOptions.variables
        });
      });

      _this.queryManager.stopQuery(qid);

      return fetchMoreResult;
    }, function (error) {
      _this.queryManager.stopQuery(qid);

      throw error;
    });
  };

  ObservableQuery.prototype.subscribeToMore = function (options) {
    var _this = this;

    var subscription = this.queryManager.startGraphQLSubscription({
      query: options.document,
      variables: options.variables
    }).subscribe({
      next: function next(subscriptionData) {
        var updateQuery = options.updateQuery;

        if (updateQuery) {
          _this.updateQuery(function (previous, _a) {
            var variables = _a.variables;
            return updateQuery(previous, {
              subscriptionData: subscriptionData,
              variables: variables
            });
          });
        }
      },
      error: function error(err) {
        if (options.onError) {
          options.onError(err);
          return;
        }

         true || false;
      }
    });
    this.subscriptions.add(subscription);
    return function () {
      if (_this.subscriptions.delete(subscription)) {
        subscription.unsubscribe();
      }
    };
  };

  ObservableQuery.prototype.setOptions = function (opts) {
    var oldFetchPolicy = this.options.fetchPolicy;
    this.options = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, this.options), opts);

    if (opts.pollInterval) {
      this.startPolling(opts.pollInterval);
    } else if (opts.pollInterval === 0) {
      this.stopPolling();
    }

    var fetchPolicy = opts.fetchPolicy;
    return this.setVariables(this.options.variables, oldFetchPolicy !== fetchPolicy && (oldFetchPolicy === 'cache-only' || oldFetchPolicy === 'standby' || fetchPolicy === 'network-only'), opts.fetchResults);
  };

  ObservableQuery.prototype.setVariables = function (variables, tryFetch, fetchResults) {
    if (tryFetch === void 0) {
      tryFetch = false;
    }

    if (fetchResults === void 0) {
      fetchResults = true;
    }

    this.isTornDown = false;
    variables = variables || this.variables;

    if (!tryFetch && Object(equality_esm["a" /* equal */])(variables, this.variables)) {
      return this.observers.size && fetchResults ? this.result() : Promise.resolve();
    }

    this.variables = this.options.variables = variables;

    if (!this.observers.size) {
      return Promise.resolve();
    }

    return this.queryManager.fetchQuery(this.queryId, this.options);
  };

  ObservableQuery.prototype.updateQuery = function (mapFn) {
    var queryManager = this.queryManager;

    var _a = queryManager.getQueryWithPreviousResult(this.queryId),
        previousResult = _a.previousResult,
        variables = _a.variables,
        document = _a.document;

    var newResult = Object(bundle_esm["I" /* tryFunctionOrLogError */])(function () {
      return mapFn(previousResult, {
        variables: variables
      });
    });

    if (newResult) {
      queryManager.dataStore.markUpdateQueryResult(document, variables, newResult);
      queryManager.broadcastQueries();
    }
  };

  ObservableQuery.prototype.stopPolling = function () {
    this.queryManager.stopPollingQuery(this.queryId);
    this.options.pollInterval = undefined;
  };

  ObservableQuery.prototype.startPolling = function (pollInterval) {
    assertNotCacheFirstOrOnly(this);
    this.options.pollInterval = pollInterval;
    this.queryManager.startPollingQuery(this.options, this.queryId);
  };

  ObservableQuery.prototype.updateLastResult = function (newResult) {
    var previousResult = this.lastResult;
    this.lastResult = newResult;
    this.lastResultSnapshot = this.queryManager.assumeImmutableResults ? newResult : Object(bundle_esm["f" /* cloneDeep */])(newResult);
    return previousResult;
  };

  ObservableQuery.prototype.onSubscribe = function (observer) {
    var _this = this;

    try {
      var subObserver = observer._subscription._observer;

      if (subObserver && !subObserver.error) {
        subObserver.error = defaultSubscriptionObserverErrorCallback;
      }
    } catch (_a) {}

    var first = !this.observers.size;
    this.observers.add(observer);
    if (observer.next && this.lastResult) observer.next(this.lastResult);
    if (observer.error && this.lastError) observer.error(this.lastError);

    if (first) {
      this.setUpQuery();
    }

    return function () {
      if (_this.observers.delete(observer) && !_this.observers.size) {
        _this.tearDownQuery();
      }
    };
  };

  ObservableQuery.prototype.setUpQuery = function () {
    var _this = this;

    var _a = this,
        queryManager = _a.queryManager,
        queryId = _a.queryId;

    if (this.shouldSubscribe) {
      queryManager.addObservableQuery(queryId, this);
    }

    if (this.options.pollInterval) {
      assertNotCacheFirstOrOnly(this);
      queryManager.startPollingQuery(this.options, queryId);
    }

    var onError = function onError(error) {
      _this.updateLastResult(Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, _this.lastResult), {
        errors: error.graphQLErrors,
        networkStatus: NetworkStatus.error,
        loading: false
      }));

      iterateObserversSafely(_this.observers, 'error', _this.lastError = error);
    };

    queryManager.observeQuery(queryId, this.options, {
      next: function next(result) {
        if (_this.lastError || _this.isDifferentFromLastResult(result)) {
          var previousResult_1 = _this.updateLastResult(result);

          var _a = _this.options,
              query_1 = _a.query,
              variables = _a.variables,
              fetchPolicy_1 = _a.fetchPolicy;

          if (queryManager.transform(query_1).hasClientExports) {
            queryManager.getLocalState().addExportedVariables(query_1, variables).then(function (variables) {
              var previousVariables = _this.variables;
              _this.variables = _this.options.variables = variables;

              if (!result.loading && previousResult_1 && fetchPolicy_1 !== 'cache-only' && queryManager.transform(query_1).serverQuery && !Object(equality_esm["a" /* equal */])(previousVariables, variables)) {
                _this.refetch();
              } else {
                iterateObserversSafely(_this.observers, 'next', result);
              }
            });
          } else {
            iterateObserversSafely(_this.observers, 'next', result);
          }
        }
      },
      error: onError
    }).catch(onError);
  };

  ObservableQuery.prototype.tearDownQuery = function () {
    var queryManager = this.queryManager;
    this.isTornDown = true;
    queryManager.stopPollingQuery(this.queryId);
    this.subscriptions.forEach(function (sub) {
      return sub.unsubscribe();
    });
    this.subscriptions.clear();
    queryManager.removeObservableQuery(this.queryId);
    queryManager.stopQuery(this.queryId);
    this.observers.clear();
  };

  return ObservableQuery;
}(bundle_esm_Observable);

function defaultSubscriptionObserverErrorCallback(error) {
   true || false;
}

function iterateObserversSafely(observers, method, argument) {
  var observersWithMethod = [];
  observers.forEach(function (obs) {
    return obs[method] && observersWithMethod.push(obs);
  });
  observersWithMethod.forEach(function (obs) {
    return obs[method](argument);
  });
}

function assertNotCacheFirstOrOnly(obsQuery) {
  var fetchPolicy = obsQuery.options.fetchPolicy;
   true ? Object(invariant_esm["b" /* invariant */])(fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only', 5) : undefined;
}

var MutationStore = function () {
  function MutationStore() {
    this.store = {};
  }

  MutationStore.prototype.getStore = function () {
    return this.store;
  };

  MutationStore.prototype.get = function (mutationId) {
    return this.store[mutationId];
  };

  MutationStore.prototype.initMutation = function (mutationId, mutation, variables) {
    this.store[mutationId] = {
      mutation: mutation,
      variables: variables || {},
      loading: true,
      error: null
    };
  };

  MutationStore.prototype.markMutationError = function (mutationId, error) {
    var mutation = this.store[mutationId];

    if (mutation) {
      mutation.loading = false;
      mutation.error = error;
    }
  };

  MutationStore.prototype.markMutationResult = function (mutationId) {
    var mutation = this.store[mutationId];

    if (mutation) {
      mutation.loading = false;
      mutation.error = null;
    }
  };

  MutationStore.prototype.reset = function () {
    this.store = {};
  };

  return MutationStore;
}();

var bundle_esm_QueryStore = function () {
  function QueryStore() {
    this.store = {};
  }

  QueryStore.prototype.getStore = function () {
    return this.store;
  };

  QueryStore.prototype.get = function (queryId) {
    return this.store[queryId];
  };

  QueryStore.prototype.initQuery = function (query) {
    var previousQuery = this.store[query.queryId];
     true ? Object(invariant_esm["b" /* invariant */])(!previousQuery || previousQuery.document === query.document || Object(equality_esm["a" /* equal */])(previousQuery.document, query.document), 19) : undefined;
    var isSetVariables = false;
    var previousVariables = null;

    if (query.storePreviousVariables && previousQuery && previousQuery.networkStatus !== NetworkStatus.loading) {
      if (!Object(equality_esm["a" /* equal */])(previousQuery.variables, query.variables)) {
        isSetVariables = true;
        previousVariables = previousQuery.variables;
      }
    }

    var networkStatus;

    if (isSetVariables) {
      networkStatus = NetworkStatus.setVariables;
    } else if (query.isPoll) {
      networkStatus = NetworkStatus.poll;
    } else if (query.isRefetch) {
      networkStatus = NetworkStatus.refetch;
    } else {
      networkStatus = NetworkStatus.loading;
    }

    var graphQLErrors = [];

    if (previousQuery && previousQuery.graphQLErrors) {
      graphQLErrors = previousQuery.graphQLErrors;
    }

    this.store[query.queryId] = {
      document: query.document,
      variables: query.variables,
      previousVariables: previousVariables,
      networkError: null,
      graphQLErrors: graphQLErrors,
      networkStatus: networkStatus,
      metadata: query.metadata
    };

    if (typeof query.fetchMoreForQueryId === 'string' && this.store[query.fetchMoreForQueryId]) {
      this.store[query.fetchMoreForQueryId].networkStatus = NetworkStatus.fetchMore;
    }
  };

  QueryStore.prototype.markQueryResult = function (queryId, result, fetchMoreForQueryId) {
    if (!this.store || !this.store[queryId]) return;
    this.store[queryId].networkError = null;
    this.store[queryId].graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];
    this.store[queryId].previousVariables = null;
    this.store[queryId].networkStatus = NetworkStatus.ready;

    if (typeof fetchMoreForQueryId === 'string' && this.store[fetchMoreForQueryId]) {
      this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;
    }
  };

  QueryStore.prototype.markQueryError = function (queryId, error, fetchMoreForQueryId) {
    if (!this.store || !this.store[queryId]) return;
    this.store[queryId].networkError = error;
    this.store[queryId].networkStatus = NetworkStatus.error;

    if (typeof fetchMoreForQueryId === 'string') {
      this.markQueryResultClient(fetchMoreForQueryId, true);
    }
  };

  QueryStore.prototype.markQueryResultClient = function (queryId, complete) {
    var storeValue = this.store && this.store[queryId];

    if (storeValue) {
      storeValue.networkError = null;
      storeValue.previousVariables = null;

      if (complete) {
        storeValue.networkStatus = NetworkStatus.ready;
      }
    }
  };

  QueryStore.prototype.stopQuery = function (queryId) {
    delete this.store[queryId];
  };

  QueryStore.prototype.reset = function (observableQueryIds) {
    var _this = this;

    Object.keys(this.store).forEach(function (queryId) {
      if (observableQueryIds.indexOf(queryId) < 0) {
        _this.stopQuery(queryId);
      } else {
        _this.store[queryId].networkStatus = NetworkStatus.loading;
      }
    });
  };

  return QueryStore;
}();

function capitalizeFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

var bundle_esm_LocalState = function () {
  function LocalState(_a) {
    var cache = _a.cache,
        client = _a.client,
        resolvers = _a.resolvers,
        fragmentMatcher = _a.fragmentMatcher;
    this.cache = cache;

    if (client) {
      this.client = client;
    }

    if (resolvers) {
      this.addResolvers(resolvers);
    }

    if (fragmentMatcher) {
      this.setFragmentMatcher(fragmentMatcher);
    }
  }

  LocalState.prototype.addResolvers = function (resolvers) {
    var _this = this;

    this.resolvers = this.resolvers || {};

    if (Array.isArray(resolvers)) {
      resolvers.forEach(function (resolverGroup) {
        _this.resolvers = Object(bundle_esm["A" /* mergeDeep */])(_this.resolvers, resolverGroup);
      });
    } else {
      this.resolvers = Object(bundle_esm["A" /* mergeDeep */])(this.resolvers, resolvers);
    }
  };

  LocalState.prototype.setResolvers = function (resolvers) {
    this.resolvers = {};
    this.addResolvers(resolvers);
  };

  LocalState.prototype.getResolvers = function () {
    return this.resolvers || {};
  };

  LocalState.prototype.runResolvers = function (_a) {
    var document = _a.document,
        remoteResult = _a.remoteResult,
        context = _a.context,
        variables = _a.variables,
        _b = _a.onlyRunForcedResolvers,
        onlyRunForcedResolvers = _b === void 0 ? false : _b;
    return Object(tslib_es6["b" /* __awaiter */])(this, void 0, void 0, function () {
      return Object(tslib_es6["e" /* __generator */])(this, function (_c) {
        if (document) {
          return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) {
            return Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, remoteResult), {
              data: localResult.result
            });
          })];
        }

        return [2, remoteResult];
      });
    });
  };

  LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {
    this.fragmentMatcher = fragmentMatcher;
  };

  LocalState.prototype.getFragmentMatcher = function () {
    return this.fragmentMatcher;
  };

  LocalState.prototype.clientQuery = function (document) {
    if (Object(bundle_esm["s" /* hasDirectives */])(['client'], document)) {
      if (this.resolvers) {
        return document;
      }

       true || false;
    }

    return null;
  };

  LocalState.prototype.serverQuery = function (document) {
    return this.resolvers ? Object(bundle_esm["C" /* removeClientSetsFromDocument */])(document) : document;
  };

  LocalState.prototype.prepareContext = function (context) {
    if (context === void 0) {
      context = {};
    }

    var cache = this.cache;

    var newContext = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, context), {
      cache: cache,
      getCacheKey: function getCacheKey(obj) {
        if (cache.config) {
          return cache.config.dataIdFromObject(obj);
        } else {
           true ? Object(invariant_esm["b" /* invariant */])(false, 6) : undefined;
        }
      }
    });

    return newContext;
  };

  LocalState.prototype.addExportedVariables = function (document, variables, context) {
    if (variables === void 0) {
      variables = {};
    }

    if (context === void 0) {
      context = {};
    }

    return Object(tslib_es6["b" /* __awaiter */])(this, void 0, void 0, function () {
      return Object(tslib_es6["e" /* __generator */])(this, function (_a) {
        if (document) {
          return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) {
            return Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, variables), data.exportedVariables);
          })];
        }

        return [2, Object(tslib_es6["a" /* __assign */])({}, variables)];
      });
    });
  };

  LocalState.prototype.shouldForceResolvers = function (document) {
    var forceResolvers = false;
    Object(visitor["c" /* visit */])(document, {
      Directive: {
        enter: function enter(node) {
          if (node.name.value === 'client' && node.arguments) {
            forceResolvers = node.arguments.some(function (arg) {
              return arg.name.value === 'always' && arg.value.kind === 'BooleanValue' && arg.value.value === true;
            });

            if (forceResolvers) {
              return visitor["a" /* BREAK */];
            }
          }
        }
      }
    });
    return forceResolvers;
  };

  LocalState.prototype.buildRootValueFromCache = function (document, variables) {
    return this.cache.diff({
      query: Object(bundle_esm["d" /* buildQueryFromSelectionSet */])(document),
      variables: variables,
      returnPartialData: true,
      optimistic: false
    }).result;
  };

  LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
    if (context === void 0) {
      context = {};
    }

    if (variables === void 0) {
      variables = {};
    }

    if (fragmentMatcher === void 0) {
      fragmentMatcher = function fragmentMatcher() {
        return true;
      };
    }

    if (onlyRunForcedResolvers === void 0) {
      onlyRunForcedResolvers = false;
    }

    return Object(tslib_es6["b" /* __awaiter */])(this, void 0, void 0, function () {
      var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache, client, execContext;

      return Object(tslib_es6["e" /* __generator */])(this, function (_b) {
        mainDefinition = Object(bundle_esm["l" /* getMainDefinition */])(document);
        fragments = Object(bundle_esm["j" /* getFragmentDefinitions */])(document);
        fragmentMap = Object(bundle_esm["g" /* createFragmentMap */])(fragments);
        definitionOperation = mainDefinition.operation;
        defaultOperationType = definitionOperation ? capitalizeFirstLetter(definitionOperation) : 'Query';
        _a = this, cache = _a.cache, client = _a.client;
        execContext = {
          fragmentMap: fragmentMap,
          context: Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, context), {
            cache: cache,
            client: client
          }),
          variables: variables,
          fragmentMatcher: fragmentMatcher,
          defaultOperationType: defaultOperationType,
          exportedVariables: {},
          onlyRunForcedResolvers: onlyRunForcedResolvers
        };
        return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function (result) {
          return {
            result: result,
            exportedVariables: execContext.exportedVariables
          };
        })];
      });
    });
  };

  LocalState.prototype.resolveSelectionSet = function (selectionSet, rootValue, execContext) {
    return Object(tslib_es6["b" /* __awaiter */])(this, void 0, void 0, function () {
      var fragmentMap, context, variables, resultsToMerge, execute;

      var _this = this;

      return Object(tslib_es6["e" /* __generator */])(this, function (_a) {
        fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
        resultsToMerge = [rootValue];

        execute = function execute(selection) {
          return Object(tslib_es6["b" /* __awaiter */])(_this, void 0, void 0, function () {
            var fragment, typeCondition;
            return Object(tslib_es6["e" /* __generator */])(this, function (_a) {
              if (!Object(bundle_esm["F" /* shouldInclude */])(selection, variables)) {
                return [2];
              }

              if (Object(bundle_esm["t" /* isField */])(selection)) {
                return [2, this.resolveField(selection, rootValue, execContext).then(function (fieldResult) {
                  var _a;

                  if (typeof fieldResult !== 'undefined') {
                    resultsToMerge.push((_a = {}, _a[Object(bundle_esm["E" /* resultKeyNameFromField */])(selection)] = fieldResult, _a));
                  }
                })];
              }

              if (Object(bundle_esm["v" /* isInlineFragment */])(selection)) {
                fragment = selection;
              } else {
                fragment = fragmentMap[selection.name.value];
                 true ? Object(invariant_esm["b" /* invariant */])(fragment, 7) : undefined;
              }

              if (fragment && fragment.typeCondition) {
                typeCondition = fragment.typeCondition.name.value;

                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                  return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function (fragmentResult) {
                    resultsToMerge.push(fragmentResult);
                  })];
                }
              }

              return [2];
            });
          });
        };

        return [2, Promise.all(selectionSet.selections.map(execute)).then(function () {
          return Object(bundle_esm["B" /* mergeDeepArray */])(resultsToMerge);
        })];
      });
    });
  };

  LocalState.prototype.resolveField = function (field, rootValue, execContext) {
    return Object(tslib_es6["b" /* __awaiter */])(this, void 0, void 0, function () {
      var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;

      var _this = this;

      return Object(tslib_es6["e" /* __generator */])(this, function (_a) {
        variables = execContext.variables;
        fieldName = field.name.value;
        aliasedFieldName = Object(bundle_esm["E" /* resultKeyNameFromField */])(field);
        aliasUsed = fieldName !== aliasedFieldName;
        defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
        resultPromise = Promise.resolve(defaultResult);

        if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
          resolverType = rootValue.__typename || execContext.defaultOperationType;
          resolverMap = this.resolvers && this.resolvers[resolverType];

          if (resolverMap) {
            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];

            if (resolve) {
              resultPromise = Promise.resolve(resolve(rootValue, Object(bundle_esm["b" /* argumentsObjectFromField */])(field, variables), execContext.context, {
                field: field,
                fragmentMap: execContext.fragmentMap
              }));
            }
          }
        }

        return [2, resultPromise.then(function (result) {
          if (result === void 0) {
            result = defaultResult;
          }

          if (field.directives) {
            field.directives.forEach(function (directive) {
              if (directive.name.value === 'export' && directive.arguments) {
                directive.arguments.forEach(function (arg) {
                  if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {
                    execContext.exportedVariables[arg.value.value] = result;
                  }
                });
              }
            });
          }

          if (!field.selectionSet) {
            return result;
          }

          if (result == null) {
            return result;
          }

          if (Array.isArray(result)) {
            return _this.resolveSubSelectedArray(field, result, execContext);
          }

          if (field.selectionSet) {
            return _this.resolveSelectionSet(field.selectionSet, result, execContext);
          }
        })];
      });
    });
  };

  LocalState.prototype.resolveSubSelectedArray = function (field, result, execContext) {
    var _this = this;

    return Promise.all(result.map(function (item) {
      if (item === null) {
        return null;
      }

      if (Array.isArray(item)) {
        return _this.resolveSubSelectedArray(field, item, execContext);
      }

      if (field.selectionSet) {
        return _this.resolveSelectionSet(field.selectionSet, item, execContext);
      }
    }));
  };

  return LocalState;
}();

function multiplex(inner) {
  var observers = new Set();
  var sub = null;
  return new bundle_esm_Observable(function (observer) {
    observers.add(observer);
    sub = sub || inner.subscribe({
      next: function next(value) {
        observers.forEach(function (obs) {
          return obs.next && obs.next(value);
        });
      },
      error: function error(_error) {
        observers.forEach(function (obs) {
          return obs.error && obs.error(_error);
        });
      },
      complete: function complete() {
        observers.forEach(function (obs) {
          return obs.complete && obs.complete();
        });
      }
    });
    return function () {
      if (observers.delete(observer) && !observers.size && sub) {
        sub.unsubscribe();
        sub = null;
      }
    };
  });
}

function asyncMap(observable, mapFn) {
  return new bundle_esm_Observable(function (observer) {
    var _next = observer.next,
        _error2 = observer.error,
        _complete = observer.complete;
    var activeNextCount = 0;
    var completed = false;
    var handler = {
      next: function next(value) {
        ++activeNextCount;
        new Promise(function (resolve) {
          resolve(mapFn(value));
        }).then(function (result) {
          --activeNextCount;
          _next && _next.call(observer, result);
          completed && handler.complete();
        }, function (e) {
          --activeNextCount;
          _error2 && _error2.call(observer, e);
        });
      },
      error: function error(e) {
        _error2 && _error2.call(observer, e);
      },
      complete: function complete() {
        completed = true;

        if (!activeNextCount) {
          _complete && _complete.call(observer);
        }
      }
    };
    var sub = observable.subscribe(handler);
    return function () {
      return sub.unsubscribe();
    };
  });
}

var bundle_esm_hasOwnProperty = Object.prototype.hasOwnProperty;

var bundle_esm_QueryManager = function () {
  function QueryManager(_a) {
    var link = _a.link,
        _b = _a.queryDeduplication,
        queryDeduplication = _b === void 0 ? false : _b,
        store = _a.store,
        _c = _a.onBroadcast,
        onBroadcast = _c === void 0 ? function () {
      return undefined;
    } : _c,
        _d = _a.ssrMode,
        ssrMode = _d === void 0 ? false : _d,
        _e = _a.clientAwareness,
        clientAwareness = _e === void 0 ? {} : _e,
        localState = _a.localState,
        assumeImmutableResults = _a.assumeImmutableResults;
    this.mutationStore = new MutationStore();
    this.queryStore = new bundle_esm_QueryStore();
    this.clientAwareness = {};
    this.idCounter = 1;
    this.queries = new Map();
    this.fetchQueryRejectFns = new Map();
    this.transformCache = new (bundle_esm["e" /* canUseWeakMap */] ? WeakMap : Map)();
    this.inFlightLinkObservables = new Map();
    this.pollingInfoByQueryId = new Map();
    this.link = link;
    this.queryDeduplication = queryDeduplication;
    this.dataStore = store;
    this.onBroadcast = onBroadcast;
    this.clientAwareness = clientAwareness;
    this.localState = localState || new bundle_esm_LocalState({
      cache: store.getCache()
    });
    this.ssrMode = ssrMode;
    this.assumeImmutableResults = !!assumeImmutableResults;
  }

  QueryManager.prototype.stop = function () {
    var _this = this;

    this.queries.forEach(function (_info, queryId) {
      _this.stopQueryNoBroadcast(queryId);
    });
    this.fetchQueryRejectFns.forEach(function (reject) {
      reject( true ? new invariant_esm["a" /* InvariantError */](8) : undefined);
    });
  };

  QueryManager.prototype.mutate = function (_a) {
    var mutation = _a.mutation,
        variables = _a.variables,
        optimisticResponse = _a.optimisticResponse,
        updateQueriesByName = _a.updateQueries,
        _b = _a.refetchQueries,
        refetchQueries = _b === void 0 ? [] : _b,
        _c = _a.awaitRefetchQueries,
        awaitRefetchQueries = _c === void 0 ? false : _c,
        updateWithProxyFn = _a.update,
        _d = _a.errorPolicy,
        errorPolicy = _d === void 0 ? 'none' : _d,
        fetchPolicy = _a.fetchPolicy,
        _e = _a.context,
        context = _e === void 0 ? {} : _e;
    return Object(tslib_es6["b" /* __awaiter */])(this, void 0, void 0, function () {
      var mutationId, generateUpdateQueriesInfo, self;

      var _this = this;

      return Object(tslib_es6["e" /* __generator */])(this, function (_f) {
        switch (_f.label) {
          case 0:
             true ? Object(invariant_esm["b" /* invariant */])(mutation, 9) : undefined;
             true ? Object(invariant_esm["b" /* invariant */])(!fetchPolicy || fetchPolicy === 'no-cache', 10) : undefined;
            mutationId = this.generateQueryId();
            mutation = this.transform(mutation).document;
            this.setQuery(mutationId, function () {
              return {
                document: mutation
              };
            });
            variables = this.getVariables(mutation, variables);
            if (!this.transform(mutation).hasClientExports) return [3, 2];
            return [4, this.localState.addExportedVariables(mutation, variables, context)];

          case 1:
            variables = _f.sent();
            _f.label = 2;

          case 2:
            generateUpdateQueriesInfo = function generateUpdateQueriesInfo() {
              var ret = {};

              if (updateQueriesByName) {
                _this.queries.forEach(function (_a, queryId) {
                  var observableQuery = _a.observableQuery;

                  if (observableQuery) {
                    var queryName = observableQuery.queryName;

                    if (queryName && bundle_esm_hasOwnProperty.call(updateQueriesByName, queryName)) {
                      ret[queryId] = {
                        updater: updateQueriesByName[queryName],
                        query: _this.queryStore.get(queryId)
                      };
                    }
                  }
                });
              }

              return ret;
            };

            this.mutationStore.initMutation(mutationId, mutation, variables);
            this.dataStore.markMutationInit({
              mutationId: mutationId,
              document: mutation,
              variables: variables,
              updateQueries: generateUpdateQueriesInfo(),
              update: updateWithProxyFn,
              optimisticResponse: optimisticResponse
            });
            this.broadcastQueries();
            self = this;
            return [2, new Promise(function (resolve, reject) {
              var storeResult;
              var error;
              self.getObservableFromLink(mutation, Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, context), {
                optimisticResponse: optimisticResponse
              }), variables, false).subscribe({
                next: function next(result) {
                  if (Object(bundle_esm["q" /* graphQLResultHasError */])(result) && errorPolicy === 'none') {
                    error = new bundle_esm_ApolloError({
                      graphQLErrors: result.errors
                    });
                    return;
                  }

                  self.mutationStore.markMutationResult(mutationId);

                  if (fetchPolicy !== 'no-cache') {
                    self.dataStore.markMutationResult({
                      mutationId: mutationId,
                      result: result,
                      document: mutation,
                      variables: variables,
                      updateQueries: generateUpdateQueriesInfo(),
                      update: updateWithProxyFn
                    });
                  }

                  storeResult = result;
                },
                error: function error(err) {
                  self.mutationStore.markMutationError(mutationId, err);
                  self.dataStore.markMutationComplete({
                    mutationId: mutationId,
                    optimisticResponse: optimisticResponse
                  });
                  self.broadcastQueries();
                  self.setQuery(mutationId, function () {
                    return {
                      document: null
                    };
                  });
                  reject(new bundle_esm_ApolloError({
                    networkError: err
                  }));
                },
                complete: function complete() {
                  if (error) {
                    self.mutationStore.markMutationError(mutationId, error);
                  }

                  self.dataStore.markMutationComplete({
                    mutationId: mutationId,
                    optimisticResponse: optimisticResponse
                  });
                  self.broadcastQueries();

                  if (error) {
                    reject(error);
                    return;
                  }

                  if (typeof refetchQueries === 'function') {
                    refetchQueries = refetchQueries(storeResult);
                  }

                  var refetchQueryPromises = [];

                  if (isNonEmptyArray(refetchQueries)) {
                    refetchQueries.forEach(function (refetchQuery) {
                      if (typeof refetchQuery === 'string') {
                        self.queries.forEach(function (_a) {
                          var observableQuery = _a.observableQuery;

                          if (observableQuery && observableQuery.queryName === refetchQuery) {
                            refetchQueryPromises.push(observableQuery.refetch());
                          }
                        });
                      } else {
                        var queryOptions = {
                          query: refetchQuery.query,
                          variables: refetchQuery.variables,
                          fetchPolicy: 'network-only'
                        };

                        if (refetchQuery.context) {
                          queryOptions.context = refetchQuery.context;
                        }

                        refetchQueryPromises.push(self.query(queryOptions));
                      }
                    });
                  }

                  Promise.all(awaitRefetchQueries ? refetchQueryPromises : []).then(function () {
                    self.setQuery(mutationId, function () {
                      return {
                        document: null
                      };
                    });

                    if (errorPolicy === 'ignore' && storeResult && Object(bundle_esm["q" /* graphQLResultHasError */])(storeResult)) {
                      delete storeResult.errors;
                    }

                    resolve(storeResult);
                  });
                }
              });
            })];
        }
      });
    });
  };

  QueryManager.prototype.fetchQuery = function (queryId, options, fetchType, fetchMoreForQueryId) {
    return Object(tslib_es6["b" /* __awaiter */])(this, void 0, void 0, function () {
      var _a, metadata, _b, fetchPolicy, _c, context, query, variables, storeResult, isNetworkOnly, needToFetch, _d, complete, result, shouldFetch, requestId, cancel, networkResult;

      var _this = this;

      return Object(tslib_es6["e" /* __generator */])(this, function (_e) {
        switch (_e.label) {
          case 0:
            _a = options.metadata, metadata = _a === void 0 ? null : _a, _b = options.fetchPolicy, fetchPolicy = _b === void 0 ? 'cache-first' : _b, _c = options.context, context = _c === void 0 ? {} : _c;
            query = this.transform(options.query).document;
            variables = this.getVariables(query, options.variables);
            if (!this.transform(query).hasClientExports) return [3, 2];
            return [4, this.localState.addExportedVariables(query, variables, context)];

          case 1:
            variables = _e.sent();
            _e.label = 2;

          case 2:
            options = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, options), {
              variables: variables
            });
            isNetworkOnly = fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';
            needToFetch = isNetworkOnly;

            if (!isNetworkOnly) {
              _d = this.dataStore.getCache().diff({
                query: query,
                variables: variables,
                returnPartialData: true,
                optimistic: false
              }), complete = _d.complete, result = _d.result;
              needToFetch = !complete || fetchPolicy === 'cache-and-network';
              storeResult = result;
            }

            shouldFetch = needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';
            if (Object(bundle_esm["s" /* hasDirectives */])(['live'], query)) shouldFetch = true;
            requestId = this.idCounter++;
            cancel = fetchPolicy !== 'no-cache' ? this.updateQueryWatch(queryId, query, options) : undefined;
            this.setQuery(queryId, function () {
              return {
                document: query,
                lastRequestId: requestId,
                invalidated: true,
                cancel: cancel
              };
            });
            this.invalidate(fetchMoreForQueryId);
            this.queryStore.initQuery({
              queryId: queryId,
              document: query,
              storePreviousVariables: shouldFetch,
              variables: variables,
              isPoll: fetchType === FetchType.poll,
              isRefetch: fetchType === FetchType.refetch,
              metadata: metadata,
              fetchMoreForQueryId: fetchMoreForQueryId
            });
            this.broadcastQueries();

            if (shouldFetch) {
              networkResult = this.fetchRequest({
                requestId: requestId,
                queryId: queryId,
                document: query,
                options: options,
                fetchMoreForQueryId: fetchMoreForQueryId
              }).catch(function (error) {
                if (isApolloError(error)) {
                  throw error;
                } else {
                  if (requestId >= _this.getQuery(queryId).lastRequestId) {
                    _this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);

                    _this.invalidate(queryId);

                    _this.invalidate(fetchMoreForQueryId);

                    _this.broadcastQueries();
                  }

                  throw new bundle_esm_ApolloError({
                    networkError: error
                  });
                }
              });

              if (fetchPolicy !== 'cache-and-network') {
                return [2, networkResult];
              }

              networkResult.catch(function () {});
            }

            this.queryStore.markQueryResultClient(queryId, !shouldFetch);
            this.invalidate(queryId);
            this.invalidate(fetchMoreForQueryId);

            if (this.transform(query).hasForcedResolvers) {
              return [2, this.localState.runResolvers({
                document: query,
                remoteResult: {
                  data: storeResult
                },
                context: context,
                variables: variables,
                onlyRunForcedResolvers: true
              }).then(function (result) {
                _this.markQueryResult(queryId, result, options, fetchMoreForQueryId);

                _this.broadcastQueries();

                return result;
              })];
            }

            this.broadcastQueries();
            return [2, {
              data: storeResult
            }];
        }
      });
    });
  };

  QueryManager.prototype.markQueryResult = function (queryId, result, _a, fetchMoreForQueryId) {
    var fetchPolicy = _a.fetchPolicy,
        variables = _a.variables,
        errorPolicy = _a.errorPolicy;

    if (fetchPolicy === 'no-cache') {
      this.setQuery(queryId, function () {
        return {
          newData: {
            result: result.data,
            complete: true
          }
        };
      });
    } else {
      this.dataStore.markQueryResult(result, this.getQuery(queryId).document, variables, fetchMoreForQueryId, errorPolicy === 'ignore' || errorPolicy === 'all');
    }
  };

  QueryManager.prototype.queryListenerForObserver = function (queryId, options, observer) {
    var _this = this;

    function invoke(method, argument) {
      if (observer[method]) {
        try {
          observer[method](argument);
        } catch (e) {
           true || false;
        }
      } else if (method === 'error') {
         true || false;
      }
    }

    return function (queryStoreValue, newData) {
      _this.invalidate(queryId, false);

      if (!queryStoreValue) return;

      var _a = _this.getQuery(queryId),
          observableQuery = _a.observableQuery,
          document = _a.document;

      var fetchPolicy = observableQuery ? observableQuery.options.fetchPolicy : options.fetchPolicy;
      if (fetchPolicy === 'standby') return;
      var loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);
      var lastResult = observableQuery && observableQuery.getLastResult();
      var networkStatusChanged = !!(lastResult && lastResult.networkStatus !== queryStoreValue.networkStatus);
      var shouldNotifyIfLoading = options.returnPartialData || !newData && queryStoreValue.previousVariables || networkStatusChanged && options.notifyOnNetworkStatusChange || fetchPolicy === 'cache-only' || fetchPolicy === 'cache-and-network';

      if (loading && !shouldNotifyIfLoading) {
        return;
      }

      var hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);
      var errorPolicy = observableQuery && observableQuery.options.errorPolicy || options.errorPolicy || 'none';

      if (errorPolicy === 'none' && hasGraphQLErrors || queryStoreValue.networkError) {
        return invoke('error', new bundle_esm_ApolloError({
          graphQLErrors: queryStoreValue.graphQLErrors,
          networkError: queryStoreValue.networkError
        }));
      }

      try {
        var data = void 0;
        var isMissing = void 0;

        if (newData) {
          if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {
            _this.setQuery(queryId, function () {
              return {
                newData: null
              };
            });
          }

          data = newData.result;
          isMissing = !newData.complete;
        } else {
          var lastError = observableQuery && observableQuery.getLastError();
          var errorStatusChanged = errorPolicy !== 'none' && (lastError && lastError.graphQLErrors) !== queryStoreValue.graphQLErrors;

          if (lastResult && lastResult.data && !errorStatusChanged) {
            data = lastResult.data;
            isMissing = false;
          } else {
            var diffResult = _this.dataStore.getCache().diff({
              query: document,
              variables: queryStoreValue.previousVariables || queryStoreValue.variables,
              returnPartialData: true,
              optimistic: true
            });

            data = diffResult.result;
            isMissing = !diffResult.complete;
          }
        }

        var stale = isMissing && !(options.returnPartialData || fetchPolicy === 'cache-only');
        var resultFromStore = {
          data: stale ? lastResult && lastResult.data : data,
          loading: loading,
          networkStatus: queryStoreValue.networkStatus,
          stale: stale
        };

        if (errorPolicy === 'all' && hasGraphQLErrors) {
          resultFromStore.errors = queryStoreValue.graphQLErrors;
        }

        invoke('next', resultFromStore);
      } catch (networkError) {
        invoke('error', new bundle_esm_ApolloError({
          networkError: networkError
        }));
      }
    };
  };

  QueryManager.prototype.transform = function (document) {
    var transformCache = this.transformCache;

    if (!transformCache.has(document)) {
      var cache = this.dataStore.getCache();
      var transformed = cache.transformDocument(document);
      var forLink = Object(bundle_esm["D" /* removeConnectionDirectiveFromDocument */])(cache.transformForLink(transformed));
      var clientQuery = this.localState.clientQuery(transformed);
      var serverQuery = this.localState.serverQuery(forLink);
      var cacheEntry_1 = {
        document: transformed,
        hasClientExports: Object(bundle_esm["r" /* hasClientExports */])(transformed),
        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),
        clientQuery: clientQuery,
        serverQuery: serverQuery,
        defaultVars: Object(bundle_esm["h" /* getDefaultValues */])(Object(bundle_esm["m" /* getOperationDefinition */])(transformed))
      };

      var add = function add(doc) {
        if (doc && !transformCache.has(doc)) {
          transformCache.set(doc, cacheEntry_1);
        }
      };

      add(document);
      add(transformed);
      add(clientQuery);
      add(serverQuery);
    }

    return transformCache.get(document);
  };

  QueryManager.prototype.getVariables = function (document, variables) {
    return Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, this.transform(document).defaultVars), variables);
  };

  QueryManager.prototype.watchQuery = function (options, shouldSubscribe) {
    if (shouldSubscribe === void 0) {
      shouldSubscribe = true;
    }

     true ? Object(invariant_esm["b" /* invariant */])(options.fetchPolicy !== 'standby', 11) : undefined;
    options.variables = this.getVariables(options.query, options.variables);

    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {
      options.notifyOnNetworkStatusChange = false;
    }

    var transformedOptions = Object(tslib_es6["a" /* __assign */])({}, options);

    return new bundle_esm_ObservableQuery({
      queryManager: this,
      options: transformedOptions,
      shouldSubscribe: shouldSubscribe
    });
  };

  QueryManager.prototype.query = function (options) {
    var _this = this;

     true ? Object(invariant_esm["b" /* invariant */])(options.query, 12) : undefined;
     true ? Object(invariant_esm["b" /* invariant */])(options.query.kind === 'Document', 13) : undefined;
     true ? Object(invariant_esm["b" /* invariant */])(!options.returnPartialData, 14) : undefined;
     true ? Object(invariant_esm["b" /* invariant */])(!options.pollInterval, 15) : undefined;
    return new Promise(function (resolve, reject) {
      var watchedQuery = _this.watchQuery(options, false);

      _this.fetchQueryRejectFns.set("query:" + watchedQuery.queryId, reject);

      watchedQuery.result().then(resolve, reject).then(function () {
        return _this.fetchQueryRejectFns.delete("query:" + watchedQuery.queryId);
      });
    });
  };

  QueryManager.prototype.generateQueryId = function () {
    return String(this.idCounter++);
  };

  QueryManager.prototype.stopQueryInStore = function (queryId) {
    this.stopQueryInStoreNoBroadcast(queryId);
    this.broadcastQueries();
  };

  QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {
    this.stopPollingQuery(queryId);
    this.queryStore.stopQuery(queryId);
    this.invalidate(queryId);
  };

  QueryManager.prototype.addQueryListener = function (queryId, listener) {
    this.setQuery(queryId, function (_a) {
      var listeners = _a.listeners;
      listeners.add(listener);
      return {
        invalidated: false
      };
    });
  };

  QueryManager.prototype.updateQueryWatch = function (queryId, document, options) {
    var _this = this;

    var cancel = this.getQuery(queryId).cancel;
    if (cancel) cancel();

    var previousResult = function previousResult() {
      var previousResult = null;

      var observableQuery = _this.getQuery(queryId).observableQuery;

      if (observableQuery) {
        var lastResult = observableQuery.getLastResult();

        if (lastResult) {
          previousResult = lastResult.data;
        }
      }

      return previousResult;
    };

    return this.dataStore.getCache().watch({
      query: document,
      variables: options.variables,
      optimistic: true,
      previousResult: previousResult,
      callback: function callback(newData) {
        _this.setQuery(queryId, function () {
          return {
            invalidated: true,
            newData: newData
          };
        });
      }
    });
  };

  QueryManager.prototype.addObservableQuery = function (queryId, observableQuery) {
    this.setQuery(queryId, function () {
      return {
        observableQuery: observableQuery
      };
    });
  };

  QueryManager.prototype.removeObservableQuery = function (queryId) {
    var cancel = this.getQuery(queryId).cancel;
    this.setQuery(queryId, function () {
      return {
        observableQuery: null
      };
    });
    if (cancel) cancel();
  };

  QueryManager.prototype.clearStore = function () {
    this.fetchQueryRejectFns.forEach(function (reject) {
      reject( true ? new invariant_esm["a" /* InvariantError */](16) : undefined);
    });
    var resetIds = [];
    this.queries.forEach(function (_a, queryId) {
      var observableQuery = _a.observableQuery;
      if (observableQuery) resetIds.push(queryId);
    });
    this.queryStore.reset(resetIds);
    this.mutationStore.reset();
    return this.dataStore.reset();
  };

  QueryManager.prototype.resetStore = function () {
    var _this = this;

    return this.clearStore().then(function () {
      return _this.reFetchObservableQueries();
    });
  };

  QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {
    var _this = this;

    if (includeStandby === void 0) {
      includeStandby = false;
    }

    var observableQueryPromises = [];
    this.queries.forEach(function (_a, queryId) {
      var observableQuery = _a.observableQuery;

      if (observableQuery) {
        var fetchPolicy = observableQuery.options.fetchPolicy;
        observableQuery.resetLastResults();

        if (fetchPolicy !== 'cache-only' && (includeStandby || fetchPolicy !== 'standby')) {
          observableQueryPromises.push(observableQuery.refetch());
        }

        _this.setQuery(queryId, function () {
          return {
            newData: null
          };
        });

        _this.invalidate(queryId);
      }
    });
    this.broadcastQueries();
    return Promise.all(observableQueryPromises);
  };

  QueryManager.prototype.observeQuery = function (queryId, options, observer) {
    this.addQueryListener(queryId, this.queryListenerForObserver(queryId, options, observer));
    return this.fetchQuery(queryId, options);
  };

  QueryManager.prototype.startQuery = function (queryId, options, listener) {
     true || false;
    this.addQueryListener(queryId, listener);
    this.fetchQuery(queryId, options).catch(function () {
      return undefined;
    });
    return queryId;
  };

  QueryManager.prototype.startGraphQLSubscription = function (_a) {
    var _this = this;

    var query = _a.query,
        fetchPolicy = _a.fetchPolicy,
        variables = _a.variables;
    query = this.transform(query).document;
    variables = this.getVariables(query, variables);

    var makeObservable = function makeObservable(variables) {
      return _this.getObservableFromLink(query, {}, variables, false).map(function (result) {
        if (!fetchPolicy || fetchPolicy !== 'no-cache') {
          _this.dataStore.markSubscriptionResult(result, query, variables);

          _this.broadcastQueries();
        }

        if (Object(bundle_esm["q" /* graphQLResultHasError */])(result)) {
          throw new bundle_esm_ApolloError({
            graphQLErrors: result.errors
          });
        }

        return result;
      });
    };

    if (this.transform(query).hasClientExports) {
      var observablePromise_1 = this.localState.addExportedVariables(query, variables).then(makeObservable);
      return new bundle_esm_Observable(function (observer) {
        var sub = null;
        observablePromise_1.then(function (observable) {
          return sub = observable.subscribe(observer);
        }, observer.error);
        return function () {
          return sub && sub.unsubscribe();
        };
      });
    }

    return makeObservable(variables);
  };

  QueryManager.prototype.stopQuery = function (queryId) {
    this.stopQueryNoBroadcast(queryId);
    this.broadcastQueries();
  };

  QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {
    this.stopQueryInStoreNoBroadcast(queryId);
    this.removeQuery(queryId);
  };

  QueryManager.prototype.removeQuery = function (queryId) {
    this.fetchQueryRejectFns.delete("query:" + queryId);
    this.fetchQueryRejectFns.delete("fetchRequest:" + queryId);
    this.getQuery(queryId).subscriptions.forEach(function (x) {
      return x.unsubscribe();
    });
    this.queries.delete(queryId);
  };

  QueryManager.prototype.getCurrentQueryResult = function (observableQuery, optimistic) {
    if (optimistic === void 0) {
      optimistic = true;
    }

    var _a = observableQuery.options,
        variables = _a.variables,
        query = _a.query,
        fetchPolicy = _a.fetchPolicy,
        returnPartialData = _a.returnPartialData;
    var lastResult = observableQuery.getLastResult();
    var newData = this.getQuery(observableQuery.queryId).newData;

    if (newData && newData.complete) {
      return {
        data: newData.result,
        partial: false
      };
    }

    if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {
      return {
        data: undefined,
        partial: false
      };
    }

    var _b = this.dataStore.getCache().diff({
      query: query,
      variables: variables,
      previousResult: lastResult ? lastResult.data : undefined,
      returnPartialData: true,
      optimistic: optimistic
    }),
        result = _b.result,
        complete = _b.complete;

    return {
      data: complete || returnPartialData ? result : void 0,
      partial: !complete
    };
  };

  QueryManager.prototype.getQueryWithPreviousResult = function (queryIdOrObservable) {
    var observableQuery;

    if (typeof queryIdOrObservable === 'string') {
      var foundObserveableQuery = this.getQuery(queryIdOrObservable).observableQuery;
       true ? Object(invariant_esm["b" /* invariant */])(foundObserveableQuery, 17) : undefined;
      observableQuery = foundObserveableQuery;
    } else {
      observableQuery = queryIdOrObservable;
    }

    var _a = observableQuery.options,
        variables = _a.variables,
        query = _a.query;
    return {
      previousResult: this.getCurrentQueryResult(observableQuery, false).data,
      variables: variables,
      document: query
    };
  };

  QueryManager.prototype.broadcastQueries = function () {
    var _this = this;

    this.onBroadcast();
    this.queries.forEach(function (info, id) {
      if (info.invalidated) {
        info.listeners.forEach(function (listener) {
          if (listener) {
            listener(_this.queryStore.get(id), info.newData);
          }
        });
      }
    });
  };

  QueryManager.prototype.getLocalState = function () {
    return this.localState;
  };

  QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {
    var _this = this;

    if (deduplication === void 0) {
      deduplication = this.queryDeduplication;
    }

    var observable;
    var serverQuery = this.transform(query).serverQuery;

    if (serverQuery) {
      var _a = this,
          inFlightLinkObservables_1 = _a.inFlightLinkObservables,
          link = _a.link;

      var operation = {
        query: serverQuery,
        variables: variables,
        operationName: Object(bundle_esm["n" /* getOperationName */])(serverQuery) || void 0,
        context: this.prepareContext(Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, context), {
          forceFetch: !deduplication
        }))
      };
      context = operation.context;

      if (deduplication) {
        var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();
        inFlightLinkObservables_1.set(serverQuery, byVariables_1);
        var varJson_1 = JSON.stringify(variables);
        observable = byVariables_1.get(varJson_1);

        if (!observable) {
          byVariables_1.set(varJson_1, observable = multiplex(Object(apollo_link_lib_bundle_esm["execute"])(link, operation)));

          var cleanup = function cleanup() {
            byVariables_1.delete(varJson_1);
            if (!byVariables_1.size) inFlightLinkObservables_1.delete(serverQuery);
            cleanupSub_1.unsubscribe();
          };

          var cleanupSub_1 = observable.subscribe({
            next: cleanup,
            error: cleanup,
            complete: cleanup
          });
        }
      } else {
        observable = multiplex(Object(apollo_link_lib_bundle_esm["execute"])(link, operation));
      }
    } else {
      observable = bundle_esm_Observable.of({
        data: {}
      });
      context = this.prepareContext(context);
    }

    var clientQuery = this.transform(query).clientQuery;

    if (clientQuery) {
      observable = asyncMap(observable, function (result) {
        return _this.localState.runResolvers({
          document: clientQuery,
          remoteResult: result,
          context: context,
          variables: variables
        });
      });
    }

    return observable;
  };

  QueryManager.prototype.fetchRequest = function (_a) {
    var _this = this;

    var requestId = _a.requestId,
        queryId = _a.queryId,
        document = _a.document,
        options = _a.options,
        fetchMoreForQueryId = _a.fetchMoreForQueryId;
    var variables = options.variables,
        _b = options.errorPolicy,
        errorPolicy = _b === void 0 ? 'none' : _b,
        fetchPolicy = options.fetchPolicy;
    var resultFromStore;
    var errorsFromStore;
    return new Promise(function (resolve, reject) {
      var observable = _this.getObservableFromLink(document, options.context, variables);

      var fqrfId = "fetchRequest:" + queryId;

      _this.fetchQueryRejectFns.set(fqrfId, reject);

      var cleanup = function cleanup() {
        _this.fetchQueryRejectFns.delete(fqrfId);

        _this.setQuery(queryId, function (_a) {
          var subscriptions = _a.subscriptions;
          subscriptions.delete(subscription);
        });
      };

      var subscription = observable.map(function (result) {
        if (requestId >= _this.getQuery(queryId).lastRequestId) {
          _this.markQueryResult(queryId, result, options, fetchMoreForQueryId);

          _this.queryStore.markQueryResult(queryId, result, fetchMoreForQueryId);

          _this.invalidate(queryId);

          _this.invalidate(fetchMoreForQueryId);

          _this.broadcastQueries();
        }

        if (errorPolicy === 'none' && isNonEmptyArray(result.errors)) {
          return reject(new bundle_esm_ApolloError({
            graphQLErrors: result.errors
          }));
        }

        if (errorPolicy === 'all') {
          errorsFromStore = result.errors;
        }

        if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {
          resultFromStore = result.data;
        } else {
          var _a = _this.dataStore.getCache().diff({
            variables: variables,
            query: document,
            optimistic: false,
            returnPartialData: true
          }),
              result_1 = _a.result,
              complete = _a.complete;

          if (complete || options.returnPartialData) {
            resultFromStore = result_1;
          }
        }
      }).subscribe({
        error: function error(_error3) {
          cleanup();
          reject(_error3);
        },
        complete: function complete() {
          cleanup();
          resolve({
            data: resultFromStore,
            errors: errorsFromStore,
            loading: false,
            networkStatus: NetworkStatus.ready,
            stale: false
          });
        }
      });

      _this.setQuery(queryId, function (_a) {
        var subscriptions = _a.subscriptions;
        subscriptions.add(subscription);
      });
    });
  };

  QueryManager.prototype.getQuery = function (queryId) {
    return this.queries.get(queryId) || {
      listeners: new Set(),
      invalidated: false,
      document: null,
      newData: null,
      lastRequestId: 1,
      observableQuery: null,
      subscriptions: new Set()
    };
  };

  QueryManager.prototype.setQuery = function (queryId, updater) {
    var prev = this.getQuery(queryId);

    var newInfo = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, prev), updater(prev));

    this.queries.set(queryId, newInfo);
  };

  QueryManager.prototype.invalidate = function (queryId, invalidated) {
    if (invalidated === void 0) {
      invalidated = true;
    }

    if (queryId) {
      this.setQuery(queryId, function () {
        return {
          invalidated: invalidated
        };
      });
    }
  };

  QueryManager.prototype.prepareContext = function (context) {
    if (context === void 0) {
      context = {};
    }

    var newContext = this.localState.prepareContext(context);
    return Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, newContext), {
      clientAwareness: this.clientAwareness
    });
  };

  QueryManager.prototype.checkInFlight = function (queryId) {
    var query = this.queryStore.get(queryId);
    return query && query.networkStatus !== NetworkStatus.ready && query.networkStatus !== NetworkStatus.error;
  };

  QueryManager.prototype.startPollingQuery = function (options, queryId, listener) {
    var _this = this;

    var pollInterval = options.pollInterval;
     true ? Object(invariant_esm["b" /* invariant */])(pollInterval, 18) : undefined;

    if (!this.ssrMode) {
      var info = this.pollingInfoByQueryId.get(queryId);

      if (!info) {
        this.pollingInfoByQueryId.set(queryId, info = {});
      }

      info.interval = pollInterval;
      info.options = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, options), {
        fetchPolicy: 'network-only'
      });

      var maybeFetch_1 = function maybeFetch_1() {
        var info = _this.pollingInfoByQueryId.get(queryId);

        if (info) {
          if (_this.checkInFlight(queryId)) {
            poll_1();
          } else {
            _this.fetchQuery(queryId, info.options, FetchType.poll).then(poll_1, poll_1);
          }
        }
      };

      var poll_1 = function poll_1() {
        var info = _this.pollingInfoByQueryId.get(queryId);

        if (info) {
          clearTimeout(info.timeout);
          info.timeout = setTimeout(maybeFetch_1, info.interval);
        }
      };

      if (listener) {
        this.addQueryListener(queryId, listener);
      }

      poll_1();
    }

    return queryId;
  };

  QueryManager.prototype.stopPollingQuery = function (queryId) {
    this.pollingInfoByQueryId.delete(queryId);
  };

  return QueryManager;
}();

var bundle_esm_DataStore = function () {
  function DataStore(initialCache) {
    this.cache = initialCache;
  }

  DataStore.prototype.getCache = function () {
    return this.cache;
  };

  DataStore.prototype.markQueryResult = function (result, document, variables, fetchMoreForQueryId, ignoreErrors) {
    if (ignoreErrors === void 0) {
      ignoreErrors = false;
    }

    var writeWithErrors = !Object(bundle_esm["q" /* graphQLResultHasError */])(result);

    if (ignoreErrors && Object(bundle_esm["q" /* graphQLResultHasError */])(result) && result.data) {
      writeWithErrors = true;
    }

    if (!fetchMoreForQueryId && writeWithErrors) {
      this.cache.write({
        result: result.data,
        dataId: 'ROOT_QUERY',
        query: document,
        variables: variables
      });
    }
  };

  DataStore.prototype.markSubscriptionResult = function (result, document, variables) {
    if (!Object(bundle_esm["q" /* graphQLResultHasError */])(result)) {
      this.cache.write({
        result: result.data,
        dataId: 'ROOT_SUBSCRIPTION',
        query: document,
        variables: variables
      });
    }
  };

  DataStore.prototype.markMutationInit = function (mutation) {
    var _this = this;

    if (mutation.optimisticResponse) {
      var optimistic_1;

      if (typeof mutation.optimisticResponse === 'function') {
        optimistic_1 = mutation.optimisticResponse(mutation.variables);
      } else {
        optimistic_1 = mutation.optimisticResponse;
      }

      this.cache.recordOptimisticTransaction(function (c) {
        var orig = _this.cache;
        _this.cache = c;

        try {
          _this.markMutationResult({
            mutationId: mutation.mutationId,
            result: {
              data: optimistic_1
            },
            document: mutation.document,
            variables: mutation.variables,
            updateQueries: mutation.updateQueries,
            update: mutation.update
          });
        } finally {
          _this.cache = orig;
        }
      }, mutation.mutationId);
    }
  };

  DataStore.prototype.markMutationResult = function (mutation) {
    var _this = this;

    if (!Object(bundle_esm["q" /* graphQLResultHasError */])(mutation.result)) {
      var cacheWrites_1 = [{
        result: mutation.result.data,
        dataId: 'ROOT_MUTATION',
        query: mutation.document,
        variables: mutation.variables
      }];
      var updateQueries_1 = mutation.updateQueries;

      if (updateQueries_1) {
        Object.keys(updateQueries_1).forEach(function (id) {
          var _a = updateQueries_1[id],
              query = _a.query,
              updater = _a.updater;

          var _b = _this.cache.diff({
            query: query.document,
            variables: query.variables,
            returnPartialData: true,
            optimistic: false
          }),
              currentQueryResult = _b.result,
              complete = _b.complete;

          if (complete) {
            var nextQueryResult = Object(bundle_esm["I" /* tryFunctionOrLogError */])(function () {
              return updater(currentQueryResult, {
                mutationResult: mutation.result,
                queryName: Object(bundle_esm["n" /* getOperationName */])(query.document) || undefined,
                queryVariables: query.variables
              });
            });

            if (nextQueryResult) {
              cacheWrites_1.push({
                result: nextQueryResult,
                dataId: 'ROOT_QUERY',
                query: query.document,
                variables: query.variables
              });
            }
          }
        });
      }

      this.cache.performTransaction(function (c) {
        cacheWrites_1.forEach(function (write) {
          return c.write(write);
        });
        var update = mutation.update;

        if (update) {
          Object(bundle_esm["I" /* tryFunctionOrLogError */])(function () {
            return update(c, mutation.result);
          });
        }
      });
    }
  };

  DataStore.prototype.markMutationComplete = function (_a) {
    var mutationId = _a.mutationId,
        optimisticResponse = _a.optimisticResponse;

    if (optimisticResponse) {
      this.cache.removeOptimistic(mutationId);
    }
  };

  DataStore.prototype.markUpdateQueryResult = function (document, variables, newResult) {
    this.cache.write({
      result: newResult,
      dataId: 'ROOT_QUERY',
      variables: variables,
      query: document
    });
  };

  DataStore.prototype.reset = function () {
    return this.cache.reset();
  };

  return DataStore;
}();

var version = "2.6.8";
var hasSuggestedDevtools = false;

var bundle_esm_ApolloClient = function () {
  function ApolloClient(options) {
    var _this = this;

    this.defaultOptions = {};
    this.resetStoreCallbacks = [];
    this.clearStoreCallbacks = [];
    var cache = options.cache,
        _a = options.ssrMode,
        ssrMode = _a === void 0 ? false : _a,
        _b = options.ssrForceFetchDelay,
        ssrForceFetchDelay = _b === void 0 ? 0 : _b,
        connectToDevTools = options.connectToDevTools,
        _c = options.queryDeduplication,
        queryDeduplication = _c === void 0 ? true : _c,
        defaultOptions = options.defaultOptions,
        _d = options.assumeImmutableResults,
        assumeImmutableResults = _d === void 0 ? false : _d,
        resolvers = options.resolvers,
        typeDefs = options.typeDefs,
        fragmentMatcher = options.fragmentMatcher,
        clientAwarenessName = options.name,
        clientAwarenessVersion = options.version;
    var link = options.link;

    if (!link && resolvers) {
      link = apollo_link_lib_bundle_esm["ApolloLink"].empty();
    }

    if (!link || !cache) {
      throw  true ? new invariant_esm["a" /* InvariantError */](1) : undefined;
    }

    this.link = link;
    this.cache = cache;
    this.store = new bundle_esm_DataStore(cache);
    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
    this.queryDeduplication = queryDeduplication;
    this.defaultOptions = defaultOptions || {};
    this.typeDefs = typeDefs;

    if (ssrForceFetchDelay) {
      setTimeout(function () {
        return _this.disableNetworkFetches = false;
      }, ssrForceFetchDelay);
    }

    this.watchQuery = this.watchQuery.bind(this);
    this.query = this.query.bind(this);
    this.mutate = this.mutate.bind(this);
    this.resetStore = this.resetStore.bind(this);
    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
    var defaultConnectToDevTools =  false && false;

    if (typeof connectToDevTools === 'undefined' ? defaultConnectToDevTools : connectToDevTools && typeof window !== 'undefined') {
      window.__APOLLO_CLIENT__ = this;
    }

    if (!hasSuggestedDevtools && "production" !== 'production') {
      hasSuggestedDevtools = true;

      if (typeof window !== 'undefined' && window.document && window.top === window.self) {
        if (typeof window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
          if (window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf('Chrome') > -1) {
            console.debug('Download the Apollo DevTools ' + 'for a better development experience: ' + 'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm');
          }
        }
      }
    }

    this.version = version;
    this.localState = new bundle_esm_LocalState({
      cache: cache,
      client: this,
      resolvers: resolvers,
      fragmentMatcher: fragmentMatcher
    });
    this.queryManager = new bundle_esm_QueryManager({
      link: this.link,
      store: this.store,
      queryDeduplication: queryDeduplication,
      ssrMode: ssrMode,
      clientAwareness: {
        name: clientAwarenessName,
        version: clientAwarenessVersion
      },
      localState: this.localState,
      assumeImmutableResults: assumeImmutableResults,
      onBroadcast: function onBroadcast() {
        if (_this.devToolsHookCb) {
          _this.devToolsHookCb({
            action: {},
            state: {
              queries: _this.queryManager.queryStore.getStore(),
              mutations: _this.queryManager.mutationStore.getStore()
            },
            dataWithOptimisticResults: _this.cache.extract(true)
          });
        }
      }
    });
  }

  ApolloClient.prototype.stop = function () {
    this.queryManager.stop();
  };

  ApolloClient.prototype.watchQuery = function (options) {
    if (this.defaultOptions.watchQuery) {
      options = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, this.defaultOptions.watchQuery), options);
    }

    if (this.disableNetworkFetches && (options.fetchPolicy === 'network-only' || options.fetchPolicy === 'cache-and-network')) {
      options = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, options), {
        fetchPolicy: 'cache-first'
      });
    }

    return this.queryManager.watchQuery(options);
  };

  ApolloClient.prototype.query = function (options) {
    if (this.defaultOptions.query) {
      options = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, this.defaultOptions.query), options);
    }

     true ? Object(invariant_esm["b" /* invariant */])(options.fetchPolicy !== 'cache-and-network', 2) : undefined;

    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {
      options = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, options), {
        fetchPolicy: 'cache-first'
      });
    }

    return this.queryManager.query(options);
  };

  ApolloClient.prototype.mutate = function (options) {
    if (this.defaultOptions.mutate) {
      options = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, this.defaultOptions.mutate), options);
    }

    return this.queryManager.mutate(options);
  };

  ApolloClient.prototype.subscribe = function (options) {
    return this.queryManager.startGraphQLSubscription(options);
  };

  ApolloClient.prototype.readQuery = function (options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    return this.cache.readQuery(options, optimistic);
  };

  ApolloClient.prototype.readFragment = function (options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    return this.cache.readFragment(options, optimistic);
  };

  ApolloClient.prototype.writeQuery = function (options) {
    var result = this.cache.writeQuery(options);
    this.queryManager.broadcastQueries();
    return result;
  };

  ApolloClient.prototype.writeFragment = function (options) {
    var result = this.cache.writeFragment(options);
    this.queryManager.broadcastQueries();
    return result;
  };

  ApolloClient.prototype.writeData = function (options) {
    var result = this.cache.writeData(options);
    this.queryManager.broadcastQueries();
    return result;
  };

  ApolloClient.prototype.__actionHookForDevTools = function (cb) {
    this.devToolsHookCb = cb;
  };

  ApolloClient.prototype.__requestRaw = function (payload) {
    return Object(apollo_link_lib_bundle_esm["execute"])(this.link, payload);
  };

  ApolloClient.prototype.initQueryManager = function () {
     true || false;
    return this.queryManager;
  };

  ApolloClient.prototype.resetStore = function () {
    var _this = this;

    return Promise.resolve().then(function () {
      return _this.queryManager.clearStore();
    }).then(function () {
      return Promise.all(_this.resetStoreCallbacks.map(function (fn) {
        return fn();
      }));
    }).then(function () {
      return _this.reFetchObservableQueries();
    });
  };

  ApolloClient.prototype.clearStore = function () {
    var _this = this;

    return Promise.resolve().then(function () {
      return _this.queryManager.clearStore();
    }).then(function () {
      return Promise.all(_this.clearStoreCallbacks.map(function (fn) {
        return fn();
      }));
    });
  };

  ApolloClient.prototype.onResetStore = function (cb) {
    var _this = this;

    this.resetStoreCallbacks.push(cb);
    return function () {
      _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) {
        return c !== cb;
      });
    };
  };

  ApolloClient.prototype.onClearStore = function (cb) {
    var _this = this;

    this.clearStoreCallbacks.push(cb);
    return function () {
      _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) {
        return c !== cb;
      });
    };
  };

  ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {
    return this.queryManager.reFetchObservableQueries(includeStandby);
  };

  ApolloClient.prototype.extract = function (optimistic) {
    return this.cache.extract(optimistic);
  };

  ApolloClient.prototype.restore = function (serializedState) {
    return this.cache.restore(serializedState);
  };

  ApolloClient.prototype.addResolvers = function (resolvers) {
    this.localState.addResolvers(resolvers);
  };

  ApolloClient.prototype.setResolvers = function (resolvers) {
    this.localState.setResolvers(resolvers);
  };

  ApolloClient.prototype.getResolvers = function () {
    return this.localState.getResolvers();
  };

  ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {
    this.localState.setFragmentMatcher(fragmentMatcher);
  };

  return ApolloClient;
}();

/* harmony default export */ var apollo_client_bundle_esm = (bundle_esm_ApolloClient);

// CONCATENATED MODULE: ./node_modules/apollo-cache/lib/bundle.esm.js


function queryFromPojo(obj) {
  var op = {
    kind: 'OperationDefinition',
    operation: 'query',
    name: {
      kind: 'Name',
      value: 'GeneratedClientQuery'
    },
    selectionSet: selectionSetFromObj(obj)
  };
  var out = {
    kind: 'Document',
    definitions: [op]
  };
  return out;
}

function fragmentFromPojo(obj, typename) {
  var frag = {
    kind: 'FragmentDefinition',
    typeCondition: {
      kind: 'NamedType',
      name: {
        kind: 'Name',
        value: typename || '__FakeType'
      }
    },
    name: {
      kind: 'Name',
      value: 'GeneratedClientQuery'
    },
    selectionSet: selectionSetFromObj(obj)
  };
  var out = {
    kind: 'Document',
    definitions: [frag]
  };
  return out;
}

function selectionSetFromObj(obj) {
  if (typeof obj === 'number' || typeof obj === 'boolean' || typeof obj === 'string' || typeof obj === 'undefined' || obj === null) {
    return null;
  }

  if (Array.isArray(obj)) {
    return selectionSetFromObj(obj[0]);
  }

  var selections = [];
  Object.keys(obj).forEach(function (key) {
    var nestedSelSet = selectionSetFromObj(obj[key]);
    var field = {
      kind: 'Field',
      name: {
        kind: 'Name',
        value: key
      },
      selectionSet: nestedSelSet || undefined
    };
    selections.push(field);
  });
  var selectionSet = {
    kind: 'SelectionSet',
    selections: selections
  };
  return selectionSet;
}

var justTypenameQuery = {
  kind: 'Document',
  definitions: [{
    kind: 'OperationDefinition',
    operation: 'query',
    name: null,
    variableDefinitions: null,
    directives: [],
    selectionSet: {
      kind: 'SelectionSet',
      selections: [{
        kind: 'Field',
        alias: null,
        name: {
          kind: 'Name',
          value: '__typename'
        },
        arguments: [],
        directives: [],
        selectionSet: null
      }]
    }
  }]
};

var bundle_esm_ApolloCache = function () {
  function ApolloCache() {}

  ApolloCache.prototype.transformDocument = function (document) {
    return document;
  };

  ApolloCache.prototype.transformForLink = function (document) {
    return document;
  };

  ApolloCache.prototype.readQuery = function (options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    return this.read({
      query: options.query,
      variables: options.variables,
      optimistic: optimistic
    });
  };

  ApolloCache.prototype.readFragment = function (options, optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    return this.read({
      query: Object(bundle_esm["k" /* getFragmentQueryDocument */])(options.fragment, options.fragmentName),
      variables: options.variables,
      rootId: options.id,
      optimistic: optimistic
    });
  };

  ApolloCache.prototype.writeQuery = function (options) {
    this.write({
      dataId: 'ROOT_QUERY',
      result: options.data,
      query: options.query,
      variables: options.variables
    });
  };

  ApolloCache.prototype.writeFragment = function (options) {
    this.write({
      dataId: options.id,
      result: options.data,
      variables: options.variables,
      query: Object(bundle_esm["k" /* getFragmentQueryDocument */])(options.fragment, options.fragmentName)
    });
  };

  ApolloCache.prototype.writeData = function (_a) {
    var id = _a.id,
        data = _a.data;

    if (typeof id !== 'undefined') {
      var typenameResult = null;

      try {
        typenameResult = this.read({
          rootId: id,
          optimistic: false,
          query: justTypenameQuery
        });
      } catch (e) {}

      var __typename = typenameResult && typenameResult.__typename || '__ClientData';

      var dataToWrite = Object.assign({
        __typename: __typename
      }, data);
      this.writeFragment({
        id: id,
        fragment: fragmentFromPojo(dataToWrite, __typename),
        data: dataToWrite
      });
    } else {
      this.writeQuery({
        query: queryFromPojo(data),
        data: data
      });
    }
  };

  return ApolloCache;
}();

var Cache;

(function (Cache) {})(Cache || (Cache = {}));


// CONCATENATED MODULE: ./node_modules/@wry/context/lib/context.esm.js
// This currentContext variable will only be used if the makeSlotClass
// function is called, which happens only if this is the first copy of the
// @wry/context package to be imported.
var currentContext = null; // This unique internal object is used to denote the absence of a value
// for a given Slot, and is never exposed to outside code.

var MISSING_VALUE = {};
var idCounter = 1; // Although we can't do anything about the cost of duplicated code from
// accidentally bundling multiple copies of the @wry/context package, we can
// avoid creating the Slot class more than once using makeSlotClass.

var makeSlotClass = function makeSlotClass() {
  return (
    /** @class */
    function () {
      function Slot() {
        // If you have a Slot object, you can find out its slot.id, but you cannot
        // guess the slot.id of a Slot you don't have access to, thanks to the
        // randomized suffix.
        this.id = ["slot", idCounter++, Date.now(), Math.random().toString(36).slice(2)].join(":");
      }

      Slot.prototype.hasValue = function () {
        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {
          // We use the Slot object iself as a key to its value, which means the
          // value cannot be obtained without a reference to the Slot object.
          if (this.id in context_1.slots) {
            var value = context_1.slots[this.id];
            if (value === MISSING_VALUE) break;

            if (context_1 !== currentContext) {
              // Cache the value in currentContext.slots so the next lookup will
              // be faster. This caching is safe because the tree of contexts and
              // the values of the slots are logically immutable.
              currentContext.slots[this.id] = value;
            }

            return true;
          }
        }

        if (currentContext) {
          // If a value was not found for this Slot, it's never going to be found
          // no matter how many times we look it up, so we might as well cache
          // the absence of the value, too.
          currentContext.slots[this.id] = MISSING_VALUE;
        }

        return false;
      };

      Slot.prototype.getValue = function () {
        if (this.hasValue()) {
          return currentContext.slots[this.id];
        }
      };

      Slot.prototype.withValue = function (value, callback, // Given the prevalence of arrow functions, specifying arguments is likely
      // to be much more common than specifying `this`, hence this ordering:
      args, thisArg) {
        var _a;

        var slots = (_a = {
          __proto__: null
        }, _a[this.id] = value, _a);
        var parent = currentContext;
        currentContext = {
          parent: parent,
          slots: slots
        };

        try {
          // Function.prototype.apply allows the arguments array argument to be
          // omitted or undefined, so args! is fine here.
          return callback.apply(thisArg, args);
        } finally {
          currentContext = parent;
        }
      }; // Capture the current context and wrap a callback function so that it
      // reestablishes the captured context when called.


      Slot.bind = function (callback) {
        var context = currentContext;
        return function () {
          var saved = currentContext;

          try {
            currentContext = context;
            return callback.apply(this, arguments);
          } finally {
            currentContext = saved;
          }
        };
      }; // Immediately run a callback function without any captured context.


      Slot.noContext = function (callback, // Given the prevalence of arrow functions, specifying arguments is likely
      // to be much more common than specifying `this`, hence this ordering:
      args, thisArg) {
        if (currentContext) {
          var saved = currentContext;

          try {
            currentContext = null; // Function.prototype.apply allows the arguments array argument to be
            // omitted or undefined, so args! is fine here.

            return callback.apply(thisArg, args);
          } finally {
            currentContext = saved;
          }
        } else {
          return callback.apply(thisArg, args);
        }
      };

      return Slot;
    }()
  );
}; // We store a single global implementation of the Slot class as a permanent
// non-enumerable symbol property of the Array constructor. This obfuscation
// does nothing to prevent access to the Slot class, but at least it ensures
// the implementation (i.e. currentContext) cannot be tampered with, and all
// copies of the @wry/context package (hopefully just one) will share the
// same Slot implementation. Since the first copy of the @wry/context package
// to be imported wins, this technique imposes a very high cost for any
// future breaking changes to the Slot class.


var globalKey = "@wry/context:Slot";
var host = Array;

var Slot = host[globalKey] || function () {
  var Slot = makeSlotClass();

  try {
    Object.defineProperty(host, globalKey, {
      value: host[globalKey] = Slot,
      enumerable: false,
      writable: false,
      configurable: false
    });
  } finally {
    return Slot;
  }
}();

var bind = Slot.bind,
    noContext = Slot.noContext;

function setTimeoutWithContext(callback, delay) {
  return setTimeout(bind(callback), delay);
} // Turn any generator function into an async function (using yield instead
// of await), with context automatically preserved across yields.


function asyncFromGen(genFn) {
  return function () {
    var gen = genFn.apply(this, arguments);
    var boundNext = bind(gen.next);
    var boundThrow = bind(gen.throw);
    return new Promise(function (resolve, reject) {
      function invoke(method, argument) {
        try {
          var result = method.call(gen, argument);
        } catch (error) {
          return reject(error);
        }

        var next = result.done ? resolve : invokeNext;

        if (isPromiseLike(result.value)) {
          result.value.then(next, result.done ? reject : invokeThrow);
        } else {
          next(result.value);
        }
      }

      var invokeNext = function invokeNext(value) {
        return invoke(boundNext, value);
      };

      var invokeThrow = function invokeThrow(error) {
        return invoke(boundThrow, error);
      };

      invokeNext();
    });
  };
}

function isPromiseLike(value) {
  return value && typeof value.then === "function";
} // If you use the fibers npm package to implement coroutines in Node.js,
// you should call this function at least once to ensure context management
// remains coherent across any yields.


var wrappedFibers = [];

function wrapYieldingFiberMethods(Fiber) {
  // There can be only one implementation of Fiber per process, so this array
  // should never grow longer than one element.
  if (wrappedFibers.indexOf(Fiber) < 0) {
    var wrap = function wrap(obj, method) {
      var fn = obj[method];

      obj[method] = function () {
        return noContext(fn, arguments, this);
      };
    }; // These methods can yield, according to
    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100


    wrap(Fiber, "yield");
    wrap(Fiber.prototype, "run");
    wrap(Fiber.prototype, "throwInto");
    wrappedFibers.push(Fiber);
  }

  return Fiber;
}


// CONCATENATED MODULE: ./node_modules/optimism/lib/bundle.esm.js



function defaultDispose() {}

var bundle_esm_Cache =
/** @class */
function () {
  function Cache(max, dispose) {
    if (max === void 0) {
      max = Infinity;
    }

    if (dispose === void 0) {
      dispose = defaultDispose;
    }

    this.max = max;
    this.dispose = dispose;
    this.map = new Map();
    this.newest = null;
    this.oldest = null;
  }

  Cache.prototype.has = function (key) {
    return this.map.has(key);
  };

  Cache.prototype.get = function (key) {
    var entry = this.getEntry(key);
    return entry && entry.value;
  };

  Cache.prototype.getEntry = function (key) {
    var entry = this.map.get(key);

    if (entry && entry !== this.newest) {
      var older = entry.older,
          newer = entry.newer;

      if (newer) {
        newer.older = older;
      }

      if (older) {
        older.newer = newer;
      }

      entry.older = this.newest;
      entry.older.newer = entry;
      entry.newer = null;
      this.newest = entry;

      if (entry === this.oldest) {
        this.oldest = newer;
      }
    }

    return entry;
  };

  Cache.prototype.set = function (key, value) {
    var entry = this.getEntry(key);

    if (entry) {
      return entry.value = value;
    }

    entry = {
      key: key,
      value: value,
      newer: null,
      older: this.newest
    };

    if (this.newest) {
      this.newest.newer = entry;
    }

    this.newest = entry;
    this.oldest = this.oldest || entry;
    this.map.set(key, entry);
    return entry.value;
  };

  Cache.prototype.clean = function () {
    while (this.oldest && this.map.size > this.max) {
      this.delete(this.oldest.key);
    }
  };

  Cache.prototype.delete = function (key) {
    var entry = this.map.get(key);

    if (entry) {
      if (entry === this.newest) {
        this.newest = entry.older;
      }

      if (entry === this.oldest) {
        this.oldest = entry.newer;
      }

      if (entry.newer) {
        entry.newer.older = entry.older;
      }

      if (entry.older) {
        entry.older.newer = entry.newer;
      }

      this.map.delete(key);
      this.dispose(entry.value, key);
      return true;
    }

    return false;
  };

  return Cache;
}();

var parentEntrySlot = new Slot();
var reusableEmptyArray = [];
var emptySetPool = [];
var POOL_TARGET_SIZE = 100; // Since this package might be used browsers, we should avoid using the
// Node built-in assert module.

function assert(condition, optionalMessage) {
  if (!condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}

function valueIs(a, b) {
  var len = a.length;
  return (// Unknown values are not equal to each other.
    len > 0 && // Both values must be ordinary (or both exceptional) to be equal.
    len === b.length && // The underlying value or exception must be the same.
    a[len - 1] === b[len - 1]
  );
}

function valueGet(value) {
  switch (value.length) {
    case 0:
      throw new Error("unknown value");

    case 1:
      return value[0];

    case 2:
      throw value[1];
  }
}

function valueCopy(value) {
  return value.slice(0);
}

var Entry =
/** @class */
function () {
  function Entry(fn, args) {
    this.fn = fn;
    this.args = args;
    this.parents = new Set();
    this.childValues = new Map(); // When this Entry has children that are dirty, this property becomes
    // a Set containing other Entry objects, borrowed from emptySetPool.
    // When the set becomes empty, it gets recycled back to emptySetPool.

    this.dirtyChildren = null;
    this.dirty = true;
    this.recomputing = false;
    this.value = [];
    ++Entry.count;
  } // This is the most important method of the Entry API, because it
  // determines whether the cached this.value can be returned immediately,
  // or must be recomputed. The overall performance of the caching system
  // depends on the truth of the following observations: (1) this.dirty is
  // usually false, (2) this.dirtyChildren is usually null/empty, and thus
  // (3) valueGet(this.value) is usually returned without recomputation.


  Entry.prototype.recompute = function () {
    assert(!this.recomputing, "already recomputing");

    if (!rememberParent(this) && maybeReportOrphan(this)) {
      // The recipient of the entry.reportOrphan callback decided to dispose
      // of this orphan entry by calling entry.dispose(), so we don't need to
      // (and should not) proceed with the recomputation.
      return void 0;
    }

    return mightBeDirty(this) ? reallyRecompute(this) : valueGet(this.value);
  };

  Entry.prototype.setDirty = function () {
    if (this.dirty) return;
    this.dirty = true;
    this.value.length = 0;
    reportDirty(this); // We can go ahead and unsubscribe here, since any further dirty
    // notifications we receive will be redundant, and unsubscribing may
    // free up some resources, e.g. file watchers.

    maybeUnsubscribe(this);
  };

  Entry.prototype.dispose = function () {
    var _this = this;

    forgetChildren(this).forEach(maybeReportOrphan);
    maybeUnsubscribe(this); // Because this entry has been kicked out of the cache (in index.js),
    // we've lost the ability to find out if/when this entry becomes dirty,
    // whether that happens through a subscription, because of a direct call
    // to entry.setDirty(), or because one of its children becomes dirty.
    // Because of this loss of future information, we have to assume the
    // worst (that this entry might have become dirty very soon), so we must
    // immediately mark this entry's parents as dirty. Normally we could
    // just call entry.setDirty() rather than calling parent.setDirty() for
    // each parent, but that would leave this entry in parent.childValues
    // and parent.dirtyChildren, which would prevent the child from being
    // truly forgotten.

    this.parents.forEach(function (parent) {
      parent.setDirty();
      forgetChild(parent, _this);
    });
  };

  Entry.count = 0;
  return Entry;
}();

function rememberParent(child) {
  var parent = parentEntrySlot.getValue();

  if (parent) {
    child.parents.add(parent);

    if (!parent.childValues.has(child)) {
      parent.childValues.set(child, []);
    }

    if (mightBeDirty(child)) {
      reportDirtyChild(parent, child);
    } else {
      reportCleanChild(parent, child);
    }

    return parent;
  }
}

function reallyRecompute(entry) {
  // Since this recomputation is likely to re-remember some of this
  // entry's children, we forget our children here but do not call
  // maybeReportOrphan until after the recomputation finishes.
  var originalChildren = forgetChildren(entry); // Set entry as the parent entry while calling recomputeNewValue(entry).

  parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);

  if (maybeSubscribe(entry)) {
    // If we successfully recomputed entry.value and did not fail to
    // (re)subscribe, then this Entry is no longer explicitly dirty.
    setClean(entry);
  } // Now that we've had a chance to re-remember any children that were
  // involved in the recomputation, we can safely report any orphan
  // children that remain.


  originalChildren.forEach(maybeReportOrphan);
  return valueGet(entry.value);
}

function recomputeNewValue(entry) {
  entry.recomputing = true; // Set entry.value as unknown.

  entry.value.length = 0;

  try {
    // If entry.fn succeeds, entry.value will become a normal Value.
    entry.value[0] = entry.fn.apply(null, entry.args);
  } catch (e) {
    // If entry.fn throws, entry.value will become exceptional.
    entry.value[1] = e;
  } // Either way, this line is always reached.


  entry.recomputing = false;
}

function mightBeDirty(entry) {
  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}

function setClean(entry) {
  entry.dirty = false;

  if (mightBeDirty(entry)) {
    // This Entry may still have dirty children, in which case we can't
    // let our parents know we're clean just yet.
    return;
  }

  reportClean(entry);
}

function reportDirty(child) {
  child.parents.forEach(function (parent) {
    return reportDirtyChild(parent, child);
  });
}

function reportClean(child) {
  child.parents.forEach(function (parent) {
    return reportCleanChild(parent, child);
  });
} // Let a parent Entry know that one of its children may be dirty.


function reportDirtyChild(parent, child) {
  // Must have called rememberParent(child) before calling
  // reportDirtyChild(parent, child).
  assert(parent.childValues.has(child));
  assert(mightBeDirty(child));

  if (!parent.dirtyChildren) {
    parent.dirtyChildren = emptySetPool.pop() || new Set();
  } else if (parent.dirtyChildren.has(child)) {
    // If we already know this child is dirty, then we must have already
    // informed our own parents that we are dirty, so we can terminate
    // the recursion early.
    return;
  }

  parent.dirtyChildren.add(child);
  reportDirty(parent);
} // Let a parent Entry know that one of its children is no longer dirty.


function reportCleanChild(parent, child) {
  // Must have called rememberChild(child) before calling
  // reportCleanChild(parent, child).
  assert(parent.childValues.has(child));
  assert(!mightBeDirty(child));
  var childValue = parent.childValues.get(child);

  if (childValue.length === 0) {
    parent.childValues.set(child, valueCopy(child.value));
  } else if (!valueIs(childValue, child.value)) {
    parent.setDirty();
  }

  removeDirtyChild(parent, child);

  if (mightBeDirty(parent)) {
    return;
  }

  reportClean(parent);
}

function removeDirtyChild(parent, child) {
  var dc = parent.dirtyChildren;

  if (dc) {
    dc.delete(child);

    if (dc.size === 0) {
      if (emptySetPool.length < POOL_TARGET_SIZE) {
        emptySetPool.push(dc);
      }

      parent.dirtyChildren = null;
    }
  }
} // If the given entry has a reportOrphan method, and no remaining parents,
// call entry.reportOrphan and return true iff it returns true. The
// reportOrphan function should return true to indicate entry.dispose()
// has been called, and the entry has been removed from any other caches
// (see index.js for the only current example).


function maybeReportOrphan(entry) {
  return entry.parents.size === 0 && typeof entry.reportOrphan === "function" && entry.reportOrphan() === true;
} // Removes all children from this entry and returns an array of the
// removed children.


function forgetChildren(parent) {
  var children = reusableEmptyArray;

  if (parent.childValues.size > 0) {
    children = [];
    parent.childValues.forEach(function (_value, child) {
      forgetChild(parent, child);
      children.push(child);
    });
  } // After we forget all our children, this.dirtyChildren must be empty
  // and therefore must have been reset to null.


  assert(parent.dirtyChildren === null);
  return children;
}

function forgetChild(parent, child) {
  child.parents.delete(parent);
  parent.childValues.delete(child);
  removeDirtyChild(parent, child);
}

function maybeSubscribe(entry) {
  if (typeof entry.subscribe === "function") {
    try {
      maybeUnsubscribe(entry); // Prevent double subscriptions.

      entry.unsubscribe = entry.subscribe.apply(null, entry.args);
    } catch (e) {
      // If this Entry has a subscribe function and it threw an exception
      // (or an unsubscribe function it previously returned now throws),
      // return false to indicate that we were not able to subscribe (or
      // unsubscribe), and this Entry should remain dirty.
      entry.setDirty();
      return false;
    }
  } // Returning true indicates either that there was no entry.subscribe
  // function or that it succeeded.


  return true;
}

function maybeUnsubscribe(entry) {
  var unsubscribe = entry.unsubscribe;

  if (typeof unsubscribe === "function") {
    entry.unsubscribe = void 0;
    unsubscribe();
  }
} // A trie data structure that holds object keys weakly, yet can also hold
// non-object keys, unlike the native `WeakMap`.


var KeyTrie =
/** @class */
function () {
  function KeyTrie(weakness) {
    this.weakness = weakness;
  }

  KeyTrie.prototype.lookup = function () {
    var array = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      array[_i] = arguments[_i];
    }

    return this.lookupArray(array);
  };

  KeyTrie.prototype.lookupArray = function (array) {
    var node = this;
    array.forEach(function (key) {
      return node = node.getChildTrie(key);
    });
    return node.data || (node.data = Object.create(null));
  };

  KeyTrie.prototype.getChildTrie = function (key) {
    var map = this.weakness && isObjRef(key) ? this.weak || (this.weak = new WeakMap()) : this.strong || (this.strong = new Map());
    var child = map.get(key);
    if (!child) map.set(key, child = new KeyTrie(this.weakness));
    return child;
  };

  return KeyTrie;
}();

function isObjRef(value) {
  switch (typeof value) {
    case "object":
      if (value === null) break;
    // Fall through to return true...

    case "function":
      return true;
  }

  return false;
} // The defaultMakeCacheKey function is remarkably powerful, because it gives
// a unique object for any shallow-identical list of arguments. If you need
// to implement a custom makeCacheKey function, you may find it helpful to
// delegate the final work to defaultMakeCacheKey, which is why we export it
// here. However, you may want to avoid defaultMakeCacheKey if your runtime
// does not support WeakMap, or you have the ability to return a string key.
// In those cases, just write your own custom makeCacheKey functions.


var keyTrie = new KeyTrie(typeof WeakMap === "function");

function defaultMakeCacheKey() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  return keyTrie.lookupArray(args);
}

var caches = new Set();

function wrap(originalFunction, options) {
  if (options === void 0) {
    options = Object.create(null);
  }

  var cache = new bundle_esm_Cache(options.max || Math.pow(2, 16), function (entry) {
    return entry.dispose();
  });
  var disposable = !!options.disposable;
  var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;

  function optimistic() {
    if (disposable && !parentEntrySlot.hasValue()) {
      // If there's no current parent computation, and this wrapped
      // function is disposable (meaning we don't care about entry.value,
      // just dependency tracking), then we can short-cut everything else
      // in this function, because entry.recompute() is going to recycle
      // the entry object without recomputing anything, anyway.
      return void 0;
    }

    var key = makeCacheKey.apply(null, arguments);

    if (key === void 0) {
      return originalFunction.apply(null, arguments);
    }

    var args = Array.prototype.slice.call(arguments);
    var entry = cache.get(key);

    if (entry) {
      entry.args = args;
    } else {
      entry = new Entry(originalFunction, args);
      cache.set(key, entry);
      entry.subscribe = options.subscribe;

      if (disposable) {
        entry.reportOrphan = function () {
          return cache.delete(key);
        };
      }
    }

    var value = entry.recompute(); // Move this entry to the front of the least-recently used queue,
    // since we just finished computing its value.

    cache.set(key, entry);
    caches.add(cache); // Clean up any excess entries in the cache, but only if there is no
    // active parent entry, meaning we're not in the middle of a larger
    // computation that might be flummoxed by the cleaning.

    if (!parentEntrySlot.hasValue()) {
      caches.forEach(function (cache) {
        return cache.clean();
      });
      caches.clear();
    } // If options.disposable is truthy, the caller of wrap is telling us
    // they don't care about the result of entry.recompute(), so we should
    // avoid returning the value, so it won't be accidentally used.


    return disposable ? void 0 : value;
  }

  optimistic.dirty = function () {
    var key = makeCacheKey.apply(null, arguments);
    var child = key !== void 0 && cache.get(key);

    if (child) {
      child.setDirty();
    }
  };

  return optimistic;
}


// CONCATENATED MODULE: ./node_modules/apollo-cache-inmemory/lib/bundle.esm.js





var haveWarned = false;

function shouldWarn() {
  var answer = !haveWarned;

  if (!Object(bundle_esm["y" /* isTest */])()) {
    haveWarned = true;
  }

  return answer;
}

var HeuristicFragmentMatcher = function () {
  function HeuristicFragmentMatcher() {}

  HeuristicFragmentMatcher.prototype.ensureReady = function () {
    return Promise.resolve();
  };

  HeuristicFragmentMatcher.prototype.canBypassInit = function () {
    return true;
  };

  HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {
    var obj = context.store.get(idValue.id);
    var isRootQuery = idValue.id === 'ROOT_QUERY';

    if (!obj) {
      return isRootQuery;
    }

    var _a = obj.__typename,
        __typename = _a === void 0 ? isRootQuery && 'Query' : _a;

    if (!__typename) {
      if (shouldWarn()) {
         true || false;
         true || false;
         true || false;
      }

      return 'heuristic';
    }

    if (__typename === typeCondition) {
      return true;
    }

    if (shouldWarn()) {
       true || false;
    }

    return 'heuristic';
  };

  return HeuristicFragmentMatcher;
}();

var bundle_esm_IntrospectionFragmentMatcher = function () {
  function IntrospectionFragmentMatcher(options) {
    if (options && options.introspectionQueryResultData) {
      this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);
      this.isReady = true;
    } else {
      this.isReady = false;
    }

    this.match = this.match.bind(this);
  }

  IntrospectionFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {
     true ? Object(invariant_esm["b" /* invariant */])(this.isReady, 2) : undefined;
    var obj = context.store.get(idValue.id);
    var isRootQuery = idValue.id === 'ROOT_QUERY';

    if (!obj) {
      return isRootQuery;
    }

    var _a = obj.__typename,
        __typename = _a === void 0 ? isRootQuery && 'Query' : _a;

     true ? Object(invariant_esm["b" /* invariant */])(__typename, 3) : undefined;

    if (__typename === typeCondition) {
      return true;
    }

    var implementingTypes = this.possibleTypesMap[typeCondition];

    if (__typename && implementingTypes && implementingTypes.indexOf(__typename) > -1) {
      return true;
    }

    return false;
  };

  IntrospectionFragmentMatcher.prototype.parseIntrospectionResult = function (introspectionResultData) {
    var typeMap = {};

    introspectionResultData.__schema.types.forEach(function (type) {
      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {
        typeMap[type.name] = type.possibleTypes.map(function (implementingType) {
          return implementingType.name;
        });
      }
    });

    return typeMap;
  };

  return IntrospectionFragmentMatcher;
}();

var hasOwn = Object.prototype.hasOwnProperty;

var bundle_esm_DepTrackingCache = function () {
  function DepTrackingCache(data) {
    var _this = this;

    if (data === void 0) {
      data = Object.create(null);
    }

    this.data = data;
    this.depend = wrap(function (dataId) {
      return _this.data[dataId];
    }, {
      disposable: true,
      makeCacheKey: function makeCacheKey(dataId) {
        return dataId;
      }
    });
  }

  DepTrackingCache.prototype.toObject = function () {
    return this.data;
  };

  DepTrackingCache.prototype.get = function (dataId) {
    this.depend(dataId);
    return this.data[dataId];
  };

  DepTrackingCache.prototype.set = function (dataId, value) {
    var oldValue = this.data[dataId];

    if (value !== oldValue) {
      this.data[dataId] = value;
      this.depend.dirty(dataId);
    }
  };

  DepTrackingCache.prototype.delete = function (dataId) {
    if (hasOwn.call(this.data, dataId)) {
      delete this.data[dataId];
      this.depend.dirty(dataId);
    }
  };

  DepTrackingCache.prototype.clear = function () {
    this.replace(null);
  };

  DepTrackingCache.prototype.replace = function (newData) {
    var _this = this;

    if (newData) {
      Object.keys(newData).forEach(function (dataId) {
        _this.set(dataId, newData[dataId]);
      });
      Object.keys(this.data).forEach(function (dataId) {
        if (!hasOwn.call(newData, dataId)) {
          _this.delete(dataId);
        }
      });
    } else {
      Object.keys(this.data).forEach(function (dataId) {
        _this.delete(dataId);
      });
    }
  };

  return DepTrackingCache;
}();

function defaultNormalizedCacheFactory(seed) {
  return new bundle_esm_DepTrackingCache(seed);
}

var bundle_esm_StoreReader = function () {
  function StoreReader(_a) {
    var _this = this;

    var _b = _a === void 0 ? {} : _a,
        _c = _b.cacheKeyRoot,
        cacheKeyRoot = _c === void 0 ? new KeyTrie(bundle_esm["e" /* canUseWeakMap */]) : _c,
        _d = _b.freezeResults,
        freezeResults = _d === void 0 ? false : _d;

    var _e = this,
        executeStoreQuery = _e.executeStoreQuery,
        executeSelectionSet = _e.executeSelectionSet,
        executeSubSelectedArray = _e.executeSubSelectedArray;

    this.freezeResults = freezeResults;
    this.executeStoreQuery = wrap(function (options) {
      return executeStoreQuery.call(_this, options);
    }, {
      makeCacheKey: function makeCacheKey(_a) {
        var query = _a.query,
            rootValue = _a.rootValue,
            contextValue = _a.contextValue,
            variableValues = _a.variableValues,
            fragmentMatcher = _a.fragmentMatcher;

        if (contextValue.store instanceof bundle_esm_DepTrackingCache) {
          return cacheKeyRoot.lookup(contextValue.store, query, fragmentMatcher, JSON.stringify(variableValues), rootValue.id);
        }
      }
    });
    this.executeSelectionSet = wrap(function (options) {
      return executeSelectionSet.call(_this, options);
    }, {
      makeCacheKey: function makeCacheKey(_a) {
        var selectionSet = _a.selectionSet,
            rootValue = _a.rootValue,
            execContext = _a.execContext;

        if (execContext.contextValue.store instanceof bundle_esm_DepTrackingCache) {
          return cacheKeyRoot.lookup(execContext.contextValue.store, selectionSet, execContext.fragmentMatcher, JSON.stringify(execContext.variableValues), rootValue.id);
        }
      }
    });
    this.executeSubSelectedArray = wrap(function (options) {
      return executeSubSelectedArray.call(_this, options);
    }, {
      makeCacheKey: function makeCacheKey(_a) {
        var field = _a.field,
            array = _a.array,
            execContext = _a.execContext;

        if (execContext.contextValue.store instanceof bundle_esm_DepTrackingCache) {
          return cacheKeyRoot.lookup(execContext.contextValue.store, field, array, JSON.stringify(execContext.variableValues));
        }
      }
    });
  }

  StoreReader.prototype.readQueryFromStore = function (options) {
    return this.diffQueryAgainstStore(Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, options), {
      returnPartialData: false
    })).result;
  };

  StoreReader.prototype.diffQueryAgainstStore = function (_a) {
    var store = _a.store,
        query = _a.query,
        variables = _a.variables,
        previousResult = _a.previousResult,
        _b = _a.returnPartialData,
        returnPartialData = _b === void 0 ? true : _b,
        _c = _a.rootId,
        rootId = _c === void 0 ? 'ROOT_QUERY' : _c,
        fragmentMatcherFunction = _a.fragmentMatcherFunction,
        config = _a.config;
    var queryDefinition = Object(bundle_esm["o" /* getQueryDefinition */])(query);
    variables = Object(bundle_esm["c" /* assign */])({}, Object(bundle_esm["h" /* getDefaultValues */])(queryDefinition), variables);
    var context = {
      store: store,
      dataIdFromObject: config && config.dataIdFromObject,
      cacheRedirects: config && config.cacheRedirects || {}
    };
    var execResult = this.executeStoreQuery({
      query: query,
      rootValue: {
        type: 'id',
        id: rootId,
        generated: true,
        typename: 'Query'
      },
      contextValue: context,
      variableValues: variables,
      fragmentMatcher: fragmentMatcherFunction
    });
    var hasMissingFields = execResult.missing && execResult.missing.length > 0;

    if (hasMissingFields && !returnPartialData) {
      execResult.missing.forEach(function (info) {
        if (info.tolerable) return;
        throw  true ? new invariant_esm["a" /* InvariantError */](8) : undefined;
      });
    }

    if (previousResult) {
      if (Object(equality_esm["a" /* equal */])(previousResult, execResult.result)) {
        execResult.result = previousResult;
      }
    }

    return {
      result: execResult.result,
      complete: !hasMissingFields
    };
  };

  StoreReader.prototype.executeStoreQuery = function (_a) {
    var query = _a.query,
        rootValue = _a.rootValue,
        contextValue = _a.contextValue,
        variableValues = _a.variableValues,
        _b = _a.fragmentMatcher,
        fragmentMatcher = _b === void 0 ? defaultFragmentMatcher : _b;
    var mainDefinition = Object(bundle_esm["l" /* getMainDefinition */])(query);
    var fragments = Object(bundle_esm["j" /* getFragmentDefinitions */])(query);
    var fragmentMap = Object(bundle_esm["g" /* createFragmentMap */])(fragments);
    var execContext = {
      query: query,
      fragmentMap: fragmentMap,
      contextValue: contextValue,
      variableValues: variableValues,
      fragmentMatcher: fragmentMatcher
    };
    return this.executeSelectionSet({
      selectionSet: mainDefinition.selectionSet,
      rootValue: rootValue,
      execContext: execContext
    });
  };

  StoreReader.prototype.executeSelectionSet = function (_a) {
    var _this = this;

    var selectionSet = _a.selectionSet,
        rootValue = _a.rootValue,
        execContext = _a.execContext;
    var fragmentMap = execContext.fragmentMap,
        contextValue = execContext.contextValue,
        variables = execContext.variableValues;
    var finalResult = {
      result: null
    };
    var objectsToMerge = [];
    var object = contextValue.store.get(rootValue.id);
    var typename = object && object.__typename || rootValue.id === 'ROOT_QUERY' && 'Query' || void 0;

    function handleMissing(result) {
      var _a;

      if (result.missing) {
        finalResult.missing = finalResult.missing || [];

        (_a = finalResult.missing).push.apply(_a, result.missing);
      }

      return result.result;
    }

    selectionSet.selections.forEach(function (selection) {
      var _a;

      if (!Object(bundle_esm["F" /* shouldInclude */])(selection, variables)) {
        return;
      }

      if (Object(bundle_esm["t" /* isField */])(selection)) {
        var fieldResult = handleMissing(_this.executeField(object, typename, selection, execContext));

        if (typeof fieldResult !== 'undefined') {
          objectsToMerge.push((_a = {}, _a[Object(bundle_esm["E" /* resultKeyNameFromField */])(selection)] = fieldResult, _a));
        }
      } else {
        var fragment = void 0;

        if (Object(bundle_esm["v" /* isInlineFragment */])(selection)) {
          fragment = selection;
        } else {
          fragment = fragmentMap[selection.name.value];

          if (!fragment) {
            throw  true ? new invariant_esm["a" /* InvariantError */](9) : undefined;
          }
        }

        var typeCondition = fragment.typeCondition && fragment.typeCondition.name.value;
        var match = !typeCondition || execContext.fragmentMatcher(rootValue, typeCondition, contextValue);

        if (match) {
          var fragmentExecResult = _this.executeSelectionSet({
            selectionSet: fragment.selectionSet,
            rootValue: rootValue,
            execContext: execContext
          });

          if (match === 'heuristic' && fragmentExecResult.missing) {
            fragmentExecResult = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, fragmentExecResult), {
              missing: fragmentExecResult.missing.map(function (info) {
                return Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, info), {
                  tolerable: true
                });
              })
            });
          }

          objectsToMerge.push(handleMissing(fragmentExecResult));
        }
      }
    });
    finalResult.result = Object(bundle_esm["B" /* mergeDeepArray */])(objectsToMerge);

    if (this.freezeResults && "production" !== 'production') {
      Object.freeze(finalResult.result);
    }

    return finalResult;
  };

  StoreReader.prototype.executeField = function (object, typename, field, execContext) {
    var variables = execContext.variableValues,
        contextValue = execContext.contextValue;
    var fieldName = field.name.value;
    var args = Object(bundle_esm["b" /* argumentsObjectFromField */])(field, variables);
    var info = {
      resultKey: Object(bundle_esm["E" /* resultKeyNameFromField */])(field),
      directives: Object(bundle_esm["i" /* getDirectiveInfoFromField */])(field, variables)
    };
    var readStoreResult = readStoreResolver(object, typename, fieldName, args, contextValue, info);

    if (Array.isArray(readStoreResult.result)) {
      return this.combineExecResults(readStoreResult, this.executeSubSelectedArray({
        field: field,
        array: readStoreResult.result,
        execContext: execContext
      }));
    }

    if (!field.selectionSet) {
      assertSelectionSetForIdValue(field, readStoreResult.result);

      if (this.freezeResults && "production" !== 'production') {
        Object(bundle_esm["z" /* maybeDeepFreeze */])(readStoreResult);
      }

      return readStoreResult;
    }

    if (readStoreResult.result == null) {
      return readStoreResult;
    }

    return this.combineExecResults(readStoreResult, this.executeSelectionSet({
      selectionSet: field.selectionSet,
      rootValue: readStoreResult.result,
      execContext: execContext
    }));
  };

  StoreReader.prototype.combineExecResults = function () {
    var execResults = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      execResults[_i] = arguments[_i];
    }

    var missing;
    execResults.forEach(function (execResult) {
      if (execResult.missing) {
        missing = missing || [];
        missing.push.apply(missing, execResult.missing);
      }
    });
    return {
      result: execResults.pop().result,
      missing: missing
    };
  };

  StoreReader.prototype.executeSubSelectedArray = function (_a) {
    var _this = this;

    var field = _a.field,
        array = _a.array,
        execContext = _a.execContext;
    var missing;

    function handleMissing(childResult) {
      if (childResult.missing) {
        missing = missing || [];
        missing.push.apply(missing, childResult.missing);
      }

      return childResult.result;
    }

    array = array.map(function (item) {
      if (item === null) {
        return null;
      }

      if (Array.isArray(item)) {
        return handleMissing(_this.executeSubSelectedArray({
          field: field,
          array: item,
          execContext: execContext
        }));
      }

      if (field.selectionSet) {
        return handleMissing(_this.executeSelectionSet({
          selectionSet: field.selectionSet,
          rootValue: item,
          execContext: execContext
        }));
      }

      assertSelectionSetForIdValue(field, item);
      return item;
    });

    if (this.freezeResults && "production" !== 'production') {
      Object.freeze(array);
    }

    return {
      result: array,
      missing: missing
    };
  };

  return StoreReader;
}();

function assertSelectionSetForIdValue(field, value) {
  if (!field.selectionSet && Object(bundle_esm["u" /* isIdValue */])(value)) {
    throw  true ? new invariant_esm["a" /* InvariantError */](10) : undefined;
  }
}

function defaultFragmentMatcher() {
  return true;
}

function assertIdValue(idValue) {
   true ? Object(invariant_esm["b" /* invariant */])(Object(bundle_esm["u" /* isIdValue */])(idValue), 11) : undefined;
}

function readStoreResolver(object, typename, fieldName, args, context, _a) {
  var resultKey = _a.resultKey,
      directives = _a.directives;
  var storeKeyName = fieldName;

  if (args || directives) {
    storeKeyName = Object(bundle_esm["p" /* getStoreKeyName */])(storeKeyName, args, directives);
  }

  var fieldValue = void 0;

  if (object) {
    fieldValue = object[storeKeyName];

    if (typeof fieldValue === 'undefined' && context.cacheRedirects && typeof typename === 'string') {
      var type = context.cacheRedirects[typename];

      if (type) {
        var resolver = type[fieldName];

        if (resolver) {
          fieldValue = resolver(object, args, {
            getCacheKey: function getCacheKey(storeObj) {
              var id = context.dataIdFromObject(storeObj);
              return id && Object(bundle_esm["H" /* toIdValue */])({
                id: id,
                typename: storeObj.__typename
              });
            }
          });
        }
      }
    }
  }

  if (typeof fieldValue === 'undefined') {
    return {
      result: fieldValue,
      missing: [{
        object: object,
        fieldName: storeKeyName,
        tolerable: false
      }]
    };
  }

  if (Object(bundle_esm["w" /* isJsonValue */])(fieldValue)) {
    fieldValue = fieldValue.json;
  }

  return {
    result: fieldValue
  };
}

var ObjectCache = function () {
  function ObjectCache(data) {
    if (data === void 0) {
      data = Object.create(null);
    }

    this.data = data;
  }

  ObjectCache.prototype.toObject = function () {
    return this.data;
  };

  ObjectCache.prototype.get = function (dataId) {
    return this.data[dataId];
  };

  ObjectCache.prototype.set = function (dataId, value) {
    this.data[dataId] = value;
  };

  ObjectCache.prototype.delete = function (dataId) {
    this.data[dataId] = void 0;
  };

  ObjectCache.prototype.clear = function () {
    this.data = Object.create(null);
  };

  ObjectCache.prototype.replace = function (newData) {
    this.data = newData || Object.create(null);
  };

  return ObjectCache;
}();

function defaultNormalizedCacheFactory$1(seed) {
  return new ObjectCache(seed);
}

var bundle_esm_WriteError = function (_super) {
  Object(tslib_es6["d" /* __extends */])(WriteError, _super);

  function WriteError() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'WriteError';
    return _this;
  }

  return WriteError;
}(Error);

function enhanceErrorWithDocument(error, document) {
  var enhancedError = new bundle_esm_WriteError("Error writing result to store for query:\n " + JSON.stringify(document));
  enhancedError.message += '\n' + error.message;
  enhancedError.stack = error.stack;
  return enhancedError;
}

var bundle_esm_StoreWriter = function () {
  function StoreWriter() {}

  StoreWriter.prototype.writeQueryToStore = function (_a) {
    var query = _a.query,
        result = _a.result,
        _b = _a.store,
        store = _b === void 0 ? defaultNormalizedCacheFactory() : _b,
        variables = _a.variables,
        dataIdFromObject = _a.dataIdFromObject,
        fragmentMatcherFunction = _a.fragmentMatcherFunction;
    return this.writeResultToStore({
      dataId: 'ROOT_QUERY',
      result: result,
      document: query,
      store: store,
      variables: variables,
      dataIdFromObject: dataIdFromObject,
      fragmentMatcherFunction: fragmentMatcherFunction
    });
  };

  StoreWriter.prototype.writeResultToStore = function (_a) {
    var dataId = _a.dataId,
        result = _a.result,
        document = _a.document,
        _b = _a.store,
        store = _b === void 0 ? defaultNormalizedCacheFactory() : _b,
        variables = _a.variables,
        dataIdFromObject = _a.dataIdFromObject,
        fragmentMatcherFunction = _a.fragmentMatcherFunction;
    var operationDefinition = Object(bundle_esm["m" /* getOperationDefinition */])(document);

    try {
      return this.writeSelectionSetToStore({
        result: result,
        dataId: dataId,
        selectionSet: operationDefinition.selectionSet,
        context: {
          store: store,
          processedData: {},
          variables: Object(bundle_esm["c" /* assign */])({}, Object(bundle_esm["h" /* getDefaultValues */])(operationDefinition), variables),
          dataIdFromObject: dataIdFromObject,
          fragmentMap: Object(bundle_esm["g" /* createFragmentMap */])(Object(bundle_esm["j" /* getFragmentDefinitions */])(document)),
          fragmentMatcherFunction: fragmentMatcherFunction
        }
      });
    } catch (e) {
      throw enhanceErrorWithDocument(e, document);
    }
  };

  StoreWriter.prototype.writeSelectionSetToStore = function (_a) {
    var _this = this;

    var result = _a.result,
        dataId = _a.dataId,
        selectionSet = _a.selectionSet,
        context = _a.context;
    var variables = context.variables,
        store = context.store,
        fragmentMap = context.fragmentMap;
    selectionSet.selections.forEach(function (selection) {
      var _a;

      if (!Object(bundle_esm["F" /* shouldInclude */])(selection, variables)) {
        return;
      }

      if (Object(bundle_esm["t" /* isField */])(selection)) {
        var resultFieldKey = Object(bundle_esm["E" /* resultKeyNameFromField */])(selection);
        var value = result[resultFieldKey];

        if (typeof value !== 'undefined') {
          _this.writeFieldToStore({
            dataId: dataId,
            value: value,
            field: selection,
            context: context
          });
        } else {
          var isDefered = false;
          var isClient = false;

          if (selection.directives && selection.directives.length) {
            isDefered = selection.directives.some(function (directive) {
              return directive.name && directive.name.value === 'defer';
            });
            isClient = selection.directives.some(function (directive) {
              return directive.name && directive.name.value === 'client';
            });
          }

          if (!isDefered && !isClient && context.fragmentMatcherFunction) {
             true || false;
          }
        }
      } else {
        var fragment = void 0;

        if (Object(bundle_esm["v" /* isInlineFragment */])(selection)) {
          fragment = selection;
        } else {
          fragment = (fragmentMap || {})[selection.name.value];
           true ? Object(invariant_esm["b" /* invariant */])(fragment, 4) : undefined;
        }

        var matches = true;

        if (context.fragmentMatcherFunction && fragment.typeCondition) {
          var id = dataId || 'self';
          var idValue = Object(bundle_esm["H" /* toIdValue */])({
            id: id,
            typename: undefined
          });
          var fakeContext = {
            store: new ObjectCache((_a = {}, _a[id] = result, _a)),
            cacheRedirects: {}
          };
          var match = context.fragmentMatcherFunction(idValue, fragment.typeCondition.name.value, fakeContext);

          if (!Object(bundle_esm["x" /* isProduction */])() && match === 'heuristic') {
             true || false;
          }

          matches = !!match;
        }

        if (matches) {
          _this.writeSelectionSetToStore({
            result: result,
            selectionSet: fragment.selectionSet,
            dataId: dataId,
            context: context
          });
        }
      }
    });
    return store;
  };

  StoreWriter.prototype.writeFieldToStore = function (_a) {
    var _b;

    var field = _a.field,
        value = _a.value,
        dataId = _a.dataId,
        context = _a.context;
    var variables = context.variables,
        dataIdFromObject = context.dataIdFromObject,
        store = context.store;
    var storeValue;
    var storeObject;
    var storeFieldName = Object(bundle_esm["G" /* storeKeyNameFromField */])(field, variables);

    if (!field.selectionSet || value === null) {
      storeValue = value != null && typeof value === 'object' ? {
        type: 'json',
        json: value
      } : value;
    } else if (Array.isArray(value)) {
      var generatedId = dataId + "." + storeFieldName;
      storeValue = this.processArrayValue(value, generatedId, field.selectionSet, context);
    } else {
      var valueDataId = dataId + "." + storeFieldName;
      var generated = true;

      if (!isGeneratedId(valueDataId)) {
        valueDataId = '$' + valueDataId;
      }

      if (dataIdFromObject) {
        var semanticId = dataIdFromObject(value);
         true ? Object(invariant_esm["b" /* invariant */])(!semanticId || !isGeneratedId(semanticId), 5) : undefined;

        if (semanticId || typeof semanticId === 'number' && semanticId === 0) {
          valueDataId = semanticId;
          generated = false;
        }
      }

      if (!isDataProcessed(valueDataId, field, context.processedData)) {
        this.writeSelectionSetToStore({
          dataId: valueDataId,
          result: value,
          selectionSet: field.selectionSet,
          context: context
        });
      }

      var typename = value.__typename;
      storeValue = Object(bundle_esm["H" /* toIdValue */])({
        id: valueDataId,
        typename: typename
      }, generated);
      storeObject = store.get(dataId);
      var escapedId = storeObject && storeObject[storeFieldName];

      if (escapedId !== storeValue && Object(bundle_esm["u" /* isIdValue */])(escapedId)) {
        var hadTypename = escapedId.typename !== undefined;
        var hasTypename = typename !== undefined;
        var typenameChanged = hadTypename && hasTypename && escapedId.typename !== typename;
         true ? Object(invariant_esm["b" /* invariant */])(!generated || escapedId.generated || typenameChanged, 6) : undefined;
         true ? Object(invariant_esm["b" /* invariant */])(!hadTypename || hasTypename, 7) : undefined;

        if (escapedId.generated) {
          if (typenameChanged) {
            if (!generated) {
              store.delete(escapedId.id);
            }
          } else {
            mergeWithGenerated(escapedId.id, storeValue.id, store);
          }
        }
      }
    }

    storeObject = store.get(dataId);

    if (!storeObject || !Object(equality_esm["a" /* equal */])(storeValue, storeObject[storeFieldName])) {
      store.set(dataId, Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, storeObject), (_b = {}, _b[storeFieldName] = storeValue, _b)));
    }
  };

  StoreWriter.prototype.processArrayValue = function (value, generatedId, selectionSet, context) {
    var _this = this;

    return value.map(function (item, index) {
      if (item === null) {
        return null;
      }

      var itemDataId = generatedId + "." + index;

      if (Array.isArray(item)) {
        return _this.processArrayValue(item, itemDataId, selectionSet, context);
      }

      var generated = true;

      if (context.dataIdFromObject) {
        var semanticId = context.dataIdFromObject(item);

        if (semanticId) {
          itemDataId = semanticId;
          generated = false;
        }
      }

      if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {
        _this.writeSelectionSetToStore({
          dataId: itemDataId,
          result: item,
          selectionSet: selectionSet,
          context: context
        });
      }

      return Object(bundle_esm["H" /* toIdValue */])({
        id: itemDataId,
        typename: item.__typename
      }, generated);
    });
  };

  return StoreWriter;
}();

function isGeneratedId(id) {
  return id[0] === '$';
}

function mergeWithGenerated(generatedKey, realKey, cache) {
  if (generatedKey === realKey) {
    return false;
  }

  var generated = cache.get(generatedKey);
  var real = cache.get(realKey);
  var madeChanges = false;
  Object.keys(generated).forEach(function (key) {
    var value = generated[key];
    var realValue = real[key];

    if (Object(bundle_esm["u" /* isIdValue */])(value) && isGeneratedId(value.id) && Object(bundle_esm["u" /* isIdValue */])(realValue) && !Object(equality_esm["a" /* equal */])(value, realValue) && mergeWithGenerated(value.id, realValue.id, cache)) {
      madeChanges = true;
    }
  });
  cache.delete(generatedKey);

  var newRealValue = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, generated), real);

  if (Object(equality_esm["a" /* equal */])(newRealValue, real)) {
    return madeChanges;
  }

  cache.set(realKey, newRealValue);
  return true;
}

function isDataProcessed(dataId, field, processedData) {
  if (!processedData) {
    return false;
  }

  if (processedData[dataId]) {
    if (processedData[dataId].indexOf(field) >= 0) {
      return true;
    } else {
      processedData[dataId].push(field);
    }
  } else {
    processedData[dataId] = [field];
  }

  return false;
}

var defaultConfig = {
  fragmentMatcher: new HeuristicFragmentMatcher(),
  dataIdFromObject: defaultDataIdFromObject,
  addTypename: true,
  resultCaching: true,
  freezeResults: false
};

function defaultDataIdFromObject(result) {
  if (result.__typename) {
    if (result.id !== undefined) {
      return result.__typename + ":" + result.id;
    }

    if (result._id !== undefined) {
      return result.__typename + ":" + result._id;
    }
  }

  return null;
}

var hasOwn$1 = Object.prototype.hasOwnProperty;

var bundle_esm_OptimisticCacheLayer = function (_super) {
  Object(tslib_es6["d" /* __extends */])(OptimisticCacheLayer, _super);

  function OptimisticCacheLayer(optimisticId, parent, transaction) {
    var _this = _super.call(this, Object.create(null)) || this;

    _this.optimisticId = optimisticId;
    _this.parent = parent;
    _this.transaction = transaction;
    return _this;
  }

  OptimisticCacheLayer.prototype.toObject = function () {
    return Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, this.parent.toObject()), this.data);
  };

  OptimisticCacheLayer.prototype.get = function (dataId) {
    return hasOwn$1.call(this.data, dataId) ? this.data[dataId] : this.parent.get(dataId);
  };

  return OptimisticCacheLayer;
}(ObjectCache);

var bundle_esm_InMemoryCache = function (_super) {
  Object(tslib_es6["d" /* __extends */])(InMemoryCache, _super);

  function InMemoryCache(config) {
    if (config === void 0) {
      config = {};
    }

    var _this = _super.call(this) || this;

    _this.watches = new Set();
    _this.typenameDocumentCache = new Map();
    _this.cacheKeyRoot = new KeyTrie(bundle_esm["e" /* canUseWeakMap */]);
    _this.silenceBroadcast = false;
    _this.config = Object(tslib_es6["a" /* __assign */])(Object(tslib_es6["a" /* __assign */])({}, defaultConfig), config);

    if (_this.config.customResolvers) {
       true || false;
      _this.config.cacheRedirects = _this.config.customResolvers;
    }

    if (_this.config.cacheResolvers) {
       true || false;
      _this.config.cacheRedirects = _this.config.cacheResolvers;
    }

    _this.addTypename = !!_this.config.addTypename;
    _this.data = _this.config.resultCaching ? new bundle_esm_DepTrackingCache() : new ObjectCache();
    _this.optimisticData = _this.data;
    _this.storeWriter = new bundle_esm_StoreWriter();
    _this.storeReader = new bundle_esm_StoreReader({
      cacheKeyRoot: _this.cacheKeyRoot,
      freezeResults: config.freezeResults
    });
    var cache = _this;
    var maybeBroadcastWatch = cache.maybeBroadcastWatch;
    _this.maybeBroadcastWatch = wrap(function (c) {
      return maybeBroadcastWatch.call(_this, c);
    }, {
      makeCacheKey: function makeCacheKey(c) {
        if (c.optimistic) {
          return;
        }

        if (c.previousResult) {
          return;
        }

        if (cache.data instanceof bundle_esm_DepTrackingCache) {
          return cache.cacheKeyRoot.lookup(c.query, JSON.stringify(c.variables));
        }
      }
    });
    return _this;
  }

  InMemoryCache.prototype.restore = function (data) {
    if (data) this.data.replace(data);
    return this;
  };

  InMemoryCache.prototype.extract = function (optimistic) {
    if (optimistic === void 0) {
      optimistic = false;
    }

    return (optimistic ? this.optimisticData : this.data).toObject();
  };

  InMemoryCache.prototype.read = function (options) {
    if (typeof options.rootId === 'string' && typeof this.data.get(options.rootId) === 'undefined') {
      return null;
    }

    var fragmentMatcher = this.config.fragmentMatcher;
    var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
    return this.storeReader.readQueryFromStore({
      store: options.optimistic ? this.optimisticData : this.data,
      query: this.transformDocument(options.query),
      variables: options.variables,
      rootId: options.rootId,
      fragmentMatcherFunction: fragmentMatcherFunction,
      previousResult: options.previousResult,
      config: this.config
    }) || null;
  };

  InMemoryCache.prototype.write = function (write) {
    var fragmentMatcher = this.config.fragmentMatcher;
    var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
    this.storeWriter.writeResultToStore({
      dataId: write.dataId,
      result: write.result,
      variables: write.variables,
      document: this.transformDocument(write.query),
      store: this.data,
      dataIdFromObject: this.config.dataIdFromObject,
      fragmentMatcherFunction: fragmentMatcherFunction
    });
    this.broadcastWatches();
  };

  InMemoryCache.prototype.diff = function (query) {
    var fragmentMatcher = this.config.fragmentMatcher;
    var fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;
    return this.storeReader.diffQueryAgainstStore({
      store: query.optimistic ? this.optimisticData : this.data,
      query: this.transformDocument(query.query),
      variables: query.variables,
      returnPartialData: query.returnPartialData,
      previousResult: query.previousResult,
      fragmentMatcherFunction: fragmentMatcherFunction,
      config: this.config
    });
  };

  InMemoryCache.prototype.watch = function (watch) {
    var _this = this;

    this.watches.add(watch);
    return function () {
      _this.watches.delete(watch);
    };
  };

  InMemoryCache.prototype.evict = function (query) {
    throw  true ? new invariant_esm["a" /* InvariantError */](1) : undefined;
  };

  InMemoryCache.prototype.reset = function () {
    this.data.clear();
    this.broadcastWatches();
    return Promise.resolve();
  };

  InMemoryCache.prototype.removeOptimistic = function (idToRemove) {
    var toReapply = [];
    var removedCount = 0;
    var layer = this.optimisticData;

    while (layer instanceof bundle_esm_OptimisticCacheLayer) {
      if (layer.optimisticId === idToRemove) {
        ++removedCount;
      } else {
        toReapply.push(layer);
      }

      layer = layer.parent;
    }

    if (removedCount > 0) {
      this.optimisticData = layer;

      while (toReapply.length > 0) {
        var layer_1 = toReapply.pop();
        this.performTransaction(layer_1.transaction, layer_1.optimisticId);
      }

      this.broadcastWatches();
    }
  };

  InMemoryCache.prototype.performTransaction = function (transaction, optimisticId) {
    var _a = this,
        data = _a.data,
        silenceBroadcast = _a.silenceBroadcast;

    this.silenceBroadcast = true;

    if (typeof optimisticId === 'string') {
      this.data = this.optimisticData = new bundle_esm_OptimisticCacheLayer(optimisticId, this.optimisticData, transaction);
    }

    try {
      transaction(this);
    } finally {
      this.silenceBroadcast = silenceBroadcast;
      this.data = data;
    }

    this.broadcastWatches();
  };

  InMemoryCache.prototype.recordOptimisticTransaction = function (transaction, id) {
    return this.performTransaction(transaction, id);
  };

  InMemoryCache.prototype.transformDocument = function (document) {
    if (this.addTypename) {
      var result = this.typenameDocumentCache.get(document);

      if (!result) {
        result = Object(bundle_esm["a" /* addTypenameToDocument */])(document);
        this.typenameDocumentCache.set(document, result);
        this.typenameDocumentCache.set(result, result);
      }

      return result;
    }

    return document;
  };

  InMemoryCache.prototype.broadcastWatches = function () {
    var _this = this;

    if (!this.silenceBroadcast) {
      this.watches.forEach(function (c) {
        return _this.maybeBroadcastWatch(c);
      });
    }
  };

  InMemoryCache.prototype.maybeBroadcastWatch = function (c) {
    c.callback(this.diff({
      query: c.query,
      variables: c.variables,
      previousResult: c.previousResult && c.previousResult(),
      optimistic: c.optimistic
    }));
  };

  return InMemoryCache;
}(bundle_esm_ApolloCache);


// EXTERNAL MODULE: ./node_modules/graphql/execution/execute.mjs + 3 modules
var execution_execute = __webpack_require__(33);

// CONCATENATED MODULE: ./node_modules/apollo-link-schema/lib/bundle.esm.js




var bundle_esm_SchemaLink = function (_super) {
  Object(tslib_es6["d" /* __extends */])(SchemaLink, _super);

  function SchemaLink(_a) {
    var schema = _a.schema,
        rootValue = _a.rootValue,
        context = _a.context;

    var _this = _super.call(this) || this;

    _this.schema = schema;
    _this.rootValue = rootValue;
    _this.context = context;
    return _this;
  }

  SchemaLink.prototype.request = function (operation) {
    var _this = this;

    return new lib_bundle_esm["a" /* default */](function (observer) {
      Promise.resolve(Object(execution_execute["g" /* execute */])(_this.schema, operation.query, _this.rootValue, typeof _this.context === 'function' ? _this.context(operation) : _this.context, operation.variables, operation.operationName)).then(function (data) {
        if (!observer.closed) {
          observer.next(data);
          observer.complete();
        }
      }).catch(function (error) {
        if (!observer.closed) {
          observer.error(error);
        }
      });
    });
  };

  return SchemaLink;
}(apollo_link_lib_bundle_esm["ApolloLink"]);

/* harmony default export */ var apollo_link_schema_lib_bundle_esm = (bundle_esm_SchemaLink);

// CONCATENATED MODULE: ./src/utils.js
function parseResponse(response) {
  const object = typeof response === 'string' ? JSON.parse(response) : response;
  return object.hasOwnProperty('Ok') ? object.Ok : object;
}
function parseEntry(entry) {
  return JSON.parse(parseResponse(entry).App[1]);
}
// CONCATENATED MODULE: ./src/graphql/resolvers.js


const resolvers_resolvers = {
  Query: {
    async courses(_, {
      filter
    }, {
      callZome
    }) {
      const fnName = filter === 'enrolled-courses' ? 'get_my_enrolled_courses' : filter === 'my-courses' ? 'get_my_courses' : 'get_all_courses';
      const result = await callZome(INSTANCE_NAME, ZOME_NAME, fnName)({});
      return parseResponse(result);
    },

    async myAddress(_, __, {
      callZome
    }) {
      const result = await callZome(INSTANCE_NAME, ZOME_NAME, 'get_my_address')({});
      return parseResponse(result);
    }

  },
  Course: {
    async students(parent, _, {
      callZome
    }) {
      const result = await callZome(INSTANCE_NAME, ZOME_NAME, 'get_all_students')({
        course_address: parent.id
      });
      return parseResponse(result);
    }

  },
  Module: {
    async contents(parent, _, {
      callZome
    }) {
      const result = await callZome(INSTANCE_NAME, ZOME_NAME, 'get_contents')({
        module_address: parent.id
      });
      return parseResponse(result);
    }

  },
  Mutation: {
    async createCourse(_, {
      title
    }, {
      callZome
    }) {
      const result = await callZome(INSTANCE_NAME, ZOME_NAME, 'create_course')({
        timestamp: getTimestamp(),
        title
      });
      return parseResponse(result);
    },

    async updateCourse(_, {
      title,
      courseId,
      modulesAddresses
    }, {
      callZome
    }) {
      const result = await callZome(INSTANCE_NAME, ZOME_NAME, 'update_course')({
        title,
        course_address: courseId,
        modules_addresses: modulesAddresses
      });
      return parseResponse(result);
    },

    async deleteCourse(_, {
      courseId
    }, {
      callZome
    }) {
      const result = await callZome(INSTANCE_NAME, ZOME_NAME, 'delete_course')({
        course_address: courseId
      });
      return parseResponse(result);
    },

    async createModule(_, {
      courseId,
      title
    }, {
      callZome
    }) {
      const result = await callZome(INSTANCE_NAME, ZOME_NAME, 'create_module')({
        timestamp: getTimestamp(),
        course_address: courseId,
        title
      });
      return parseResponse(result);
    },

    async updateModule(_, {
      moduleId,
      title
    }, {
      callZome
    }) {
      const result = await callZome(INSTANCE_NAME, ZOME_NAME, 'update_module')({
        module_address: moduleId,
        title
      });
      return parseResponse(result);
    },

    async deleteModule(_, {
      moduleId
    }, {
      callZome
    }) {
      const result = await callZome(INSTANCE_NAME, ZOME_NAME, 'delete_module')({
        module_address: moduleId
      });
      return parseResponse(result);
    },

    async createContent(_, {
      content,
      moduleId
    }, {
      callZome
    }) {
      const result = await callZome(INSTANCE_NAME, ZOME_NAME, 'create_content')({
        timestamp: getTimestamp(),
        name: content.name,
        module_address: moduleId,
        url: content.url,
        description: content.description
      });
      return parseResponse(result);
    },

    async updateContent(_, {
      content,
      contentId
    }, {
      callZome
    }) {
      const result = await callZome(INSTANCE_NAME, ZOME_NAME, 'update_content')({
        name: content.name,
        content_address: contentId,
        url: content.url,
        description: content.description
      });
      return parseResponse(result);
    },

    async deleteContent(_, {
      contentId
    }, {
      callZome
    }) {
      const result = await callZome(INSTANCE_NAME, ZOME_NAME, 'delete_content')({
        content_address: contentId
      });
      return parseResponse(result);
    },

    async enrolInCourse(_, {
      courseId
    }, {
      callZome
    }) {
      const result = await callZome(INSTANCE_NAME, ZOME_NAME, 'enrol_in_course')({
        course_address: courseId
      });
      parseResponse(result);
      return courseId;
    }

  }
};

function getTimestamp() {
  return Math.floor(Date.now() / 1000);
}
// EXTERNAL MODULE: ./node_modules/graphql-tag/src/index.js
var src = __webpack_require__(34);
var src_default = /*#__PURE__*/__webpack_require__.n(src);

// CONCATENATED MODULE: ./src/graphql/schema.js

const schema_typeDefs = src_default.a`
  directive @loadEntry on FIELD_DEFINITION

  type Course {
    id: ID!
    title: String!
    modules: [Module!]! @loadEntry
    teacher_address: ID!
    students: [ID!]!
  }

  type Module {
    id: ID!
    course_address: Course! @loadEntry
    title: String!
    contents: [Content!]! @loadEntry
  }

  type Content {
    id: ID!
    name: String!
    description: String!
    url: String!
  }

  type Query {
    courses(filter: String!): [Course!]! @loadEntry
    course(courseId: ID!): Course! @loadEntry
    myAddress: ID!
  }

  input ContentInput {
    name: String!
    description: String!
    url: String!
  }

  type Mutation {
    createCourse(title: String!): Course! @loadEntry
    updateCourse(courseId: ID!, title: String!, modulesIds: [ID!]!): Course!
      @loadEntry
    deleteCourse(courseId: ID!): ID
    createModule(courseId: ID!, title: String!): Module! @loadEntry
    updateModule(moduleId: ID!, title: String!): Module! @loadEntry
    deleteModule(moduleId: ID!): ID
    createContent(moduleId: ID!, content: ContentInput!): Content! @loadEntry
    updateContent(contentId: ID!, content: ContentInput!): Content! @loadEntry
    deleteContent(contentId: ID!): ID
    enrolInCourse(courseId: ID!): Course! @loadEntry
  }
`;
/*
 */
// CONCATENATED MODULE: ./src/graphql/directive.js
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




class directive_LoadEntityDirective extends dist["SchemaDirectiveVisitor"] {
  visitFieldDefinition(field, detail) {
    let defaultResolver = field.resolve;

    field.resolve = async (parent, args, context, info) => {
      let entityId;

      if (defaultResolver) {
        entityId = await defaultResolver(parent, args, context, info);
      } else if (args.courseId) {
        entityId = args.courseId;
      } else {
        entityId = parent[field.name];
      }

      if (!entityId) return null;
      if (typeof entityId === 'string') return this.loadEntry(entityId, context.callZome);else return entityId.map(id => this.loadEntry(id, context.callZome));
    };
  }

  async loadEntry(entityId, callZome) {
    const entryResult = await callZome(INSTANCE_NAME, ZOME_NAME, 'get_entry')({
      address: entityId
    });
    const entry = parseEntry(entryResult);
    return _objectSpread({
      id: entityId
    }, entry);
  }

}
// EXTERNAL MODULE: ./node_modules/@holochain/hc-web-client/lib/index.js
var lib = __webpack_require__(164);

// CONCATENATED MODULE: ./src/connection.js
// hc-web-client.js is Holochains JavaScript library that helps
// you easily set up a WebSocket connection to your app.
// And it is a thin wrapper around rpc-websockets to enable calling zome functions
// in Holochain apps installed in a conductor.
// More info: https://github.com/holochain/hc-web-client


let connection_connection = undefined;
async function getConnection() {
  // return connection if already established
  if (connection_connection) return connection_connection; // establish a new websocket connection and expose callZome

  const {
    callZome
  } = await Object(lib["connect"])({
    url: HOST_URL
  }); // define connection and execute callZome function

  connection_connection = (instance, zome, fnName) => async params => {
    console.log(`Calling zome function: ${instance}/${zome}/${fnName} with params`, params); // https://developer.holochain.org/docs/guide/conductor_json_rpc_api/

    const result = await callZome(instance, zome, fnName)(params);
    console.log(`Zome function ${instance}/${zome}/${fnName} with params returned`, result);
    return result;
  };

  return connection_connection;
}
// CONCATENATED MODULE: ./src/graphql/index.js







let graphql_client = undefined;
async function getClient() {
  if (graphql_client) return graphql_client;
  const connection = await getConnection();
  const schema = Object(dist["makeExecutableSchema"])({
    typeDefs: schema_typeDefs,
    resolvers: resolvers_resolvers,
    schemaDirectives: {
      loadEntry: directive_LoadEntityDirective
    }
  });
  const link = new bundle_esm_SchemaLink({
    schema,
    context: {
      callZome: connection
    }
  });
  graphql_client = new bundle_esm_ApolloClient({
    cache: new bundle_esm_InMemoryCache(),
    connectToDevTools: true,
    link
  });
  return graphql_client;
}
// CONCATENATED MODULE: ./src/graphql/queries.js

const GET_COURSES = src_default.a`
  query GetCourses($filter: String!) {
    courses(filter: $filter) {
      id
      title
      teacher_address
      students
    }
  }
`;
const GET_COURSE_INFO = src_default.a`
  query GetCourseInfo($courseId: String!) {
    myAddress
    course(courseId: $courseId) {
      id
      title
      students
      teacher_address
      modules {
        id
        title
        contents {
          id
          name
          description
          url
        }
      }
    }
  }
`;
const CREATE_COURSE = src_default.a`
  mutation CreateCourse($title: String!) {
    createCourse(title: $title) {
      id
      title
      teacher_address
    }
  }
`;
const DELETE_COURSE = src_default.a`
  mutation DeleteCourse($courseId: ID!) {
    deleteCourse(courseId: $courseId)
  }
`;
const DELETE_MODULE = src_default.a`
  mutation DeleteModule($moduleId: ID!) {
    deleteModule(moduleId: $moduleId)
  }
`;
const DELETE_CONTENT = src_default.a`
  mutation DeleteContent($contentId: ID!) {
    deleteContent(contentId: $contentId)
  }
`;
const UPDATE_CONTENT = src_default.a`
  mutation UpdateContent($contentId: ID, $content: ContentInput!) {
    updateContent(contentId: $contentId, content: $content) {
      id
      name
      description
      url
    }
  }
`;
const CREATE_MODULE = src_default.a`
  mutation CreateModule($courseId: ID!, $title: String!) {
    createModule(courseId: $courseId, title: $title) {
      id
      title
    }
  }
`;
const UPDATE_MODULE = src_default.a`
  mutation UpdateModule($moduleId: ID!, $title: String!) {
    updateModule(moduleId: $moduleId, title: $title) {
      id
      title
    }
  }
`;
const CREATE_CONTENT = src_default.a`
  mutation CreateContent($moduleId: ID!, $content: ContentInput!) {
    createContent(moduleId: $moduleId, content: $content) {
      id
      name
      description
      url
    }
  }
`;
const ENROL_IN_COURSE = src_default.a`
  mutation EnrolInCourse($courseId: ID!) {
    enrolInCourse(courseId: $courseId) {
      id
      title
      students
    }
  }
`;
// CONCATENATED MODULE: ./node_modules/navigo/lib/navigo.es.js
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

function isPushStateAvailable() {
  return !!(typeof window !== 'undefined' && window.history && window.history.pushState);
}

function Navigo(r, useHash, hash) {
  this.root = null;
  this._routes = [];
  this._useHash = useHash;
  this._hash = typeof hash === 'undefined' ? '#' : hash;
  this._paused = false;
  this._destroyed = false;
  this._lastRouteResolved = null;
  this._notFoundHandler = null;
  this._defaultHandler = null;
  this._usePushState = !useHash && isPushStateAvailable();
  this._onLocationChange = this._onLocationChange.bind(this);
  this._genericHooks = null;
  this._historyAPIUpdateMethod = 'pushState';

  if (r) {
    this.root = useHash ? r.replace(/\/$/, '/' + this._hash) : r.replace(/\/$/, '');
  } else if (useHash) {
    this.root = this._cLoc().split(this._hash)[0].replace(/\/$/, '/' + this._hash);
  }

  this._listen();

  this.updatePageLinks();
}

function clean(s) {
  if (s instanceof RegExp) return s;
  return s.replace(/\/+$/, '').replace(/^\/+/, '^/');
}

function regExpResultToParams(match, names) {
  if (names.length === 0) return null;
  if (!match) return null;
  return match.slice(1, match.length).reduce(function (params, value, index) {
    if (params === null) params = {};
    params[names[index]] = decodeURIComponent(value);
    return params;
  }, null);
}

function replaceDynamicURLParts(route) {
  var paramNames = [],
      regexp;

  if (route instanceof RegExp) {
    regexp = route;
  } else {
    regexp = new RegExp(route.replace(Navigo.PARAMETER_REGEXP, function (full, dots, name) {
      paramNames.push(name);
      return Navigo.REPLACE_VARIABLE_REGEXP;
    }).replace(Navigo.WILDCARD_REGEXP, Navigo.REPLACE_WILDCARD) + Navigo.FOLLOWED_BY_SLASH_REGEXP, Navigo.MATCH_REGEXP_FLAGS);
  }

  return {
    regexp: regexp,
    paramNames: paramNames
  };
}

function getUrlDepth(url) {
  return url.replace(/\/$/, '').split('/').length;
}

function compareUrlDepth(urlA, urlB) {
  return getUrlDepth(urlB) - getUrlDepth(urlA);
}

function findMatchedRoutes(url) {
  var routes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return routes.map(function (route) {
    var _replaceDynamicURLPar = replaceDynamicURLParts(clean(route.route)),
        regexp = _replaceDynamicURLPar.regexp,
        paramNames = _replaceDynamicURLPar.paramNames;

    var match = url.replace(/^\/+/, '/').match(regexp);
    var params = regExpResultToParams(match, paramNames);
    return match ? {
      match: match,
      route: route,
      params: params
    } : false;
  }).filter(function (m) {
    return m;
  });
}

function navigo_es_match(url, routes) {
  return findMatchedRoutes(url, routes)[0] || false;
}

function root(url, routes) {
  var matched = routes.map(function (route) {
    return route.route === '' || route.route === '*' ? url : url.split(new RegExp(route.route + '($|\/)'))[0];
  });
  var fallbackURL = clean(url);

  if (matched.length > 1) {
    return matched.reduce(function (result, url) {
      if (result.length > url.length) result = url;
      return result;
    }, matched[0]);
  } else if (matched.length === 1) {
    return matched[0];
  }

  return fallbackURL;
}

function isHashChangeAPIAvailable() {
  return typeof window !== 'undefined' && 'onhashchange' in window;
}

function extractGETParameters(url) {
  return url.split(/\?(.*)?$/).slice(1).join('');
}

function getOnlyURL(url, useHash, hash) {
  var onlyURL = url,
      split;

  var cleanGETParam = function cleanGETParam(str) {
    return str.split(/\?(.*)?$/)[0];
  };

  if (typeof hash === 'undefined') {
    // To preserve BC
    hash = '#';
  }

  if (isPushStateAvailable() && !useHash) {
    onlyURL = cleanGETParam(url).split(hash)[0];
  } else {
    split = url.split(hash);
    onlyURL = split.length > 1 ? cleanGETParam(split[1]) : cleanGETParam(split[0]);
  }

  return onlyURL;
}

function manageHooks(handler, hooks, params) {
  if (hooks && (typeof hooks === 'undefined' ? 'undefined' : _typeof(hooks)) === 'object') {
    if (hooks.before) {
      hooks.before(function () {
        var shouldRoute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        if (!shouldRoute) return;
        handler();
        hooks.after && hooks.after(params);
      }, params);
      return;
    } else if (hooks.after) {
      handler();
      hooks.after && hooks.after(params);
      return;
    }
  }

  handler();
}

function isHashedRoot(url, useHash, hash) {
  if (isPushStateAvailable() && !useHash) {
    return false;
  }

  if (!url.match(hash)) {
    return false;
  }

  var split = url.split(hash);
  return split.length < 2 || split[1] === '';
}

Navigo.prototype = {
  helpers: {
    match: navigo_es_match,
    root: root,
    clean: clean,
    getOnlyURL: getOnlyURL
  },
  navigate: function navigate(path, absolute) {
    var to;
    path = path || '';

    if (this._usePushState) {
      to = (!absolute ? this._getRoot() + '/' : '') + path.replace(/^\/+/, '/');
      to = to.replace(/([^:])(\/{2,})/g, '$1/');

      history[this._historyAPIUpdateMethod]({}, '', to);

      this.resolve();
    } else if (typeof window !== 'undefined') {
      path = path.replace(new RegExp('^' + this._hash), '');
      window.location.href = window.location.href.replace(/#$/, '').replace(new RegExp(this._hash + '.*$'), '') + this._hash + path;
    }

    return this;
  },
  on: function on() {
    var _this = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (typeof args[0] === 'function') {
      this._defaultHandler = {
        handler: args[0],
        hooks: args[1]
      };
    } else if (args.length >= 2) {
      if (args[0] === '/') {
        var func = args[1];

        if (_typeof(args[1]) === 'object') {
          func = args[1].uses;
        }

        this._defaultHandler = {
          handler: func,
          hooks: args[2]
        };
      } else {
        this._add(args[0], args[1], args[2]);
      }
    } else if (_typeof(args[0]) === 'object') {
      var orderedRoutes = Object.keys(args[0]).sort(compareUrlDepth);
      orderedRoutes.forEach(function (route) {
        _this.on(route, args[0][route]);
      });
    }

    return this;
  },
  off: function off(handler) {
    if (this._defaultHandler !== null && handler === this._defaultHandler.handler) {
      this._defaultHandler = null;
    } else if (this._notFoundHandler !== null && handler === this._notFoundHandler.handler) {
      this._notFoundHandler = null;
    }

    this._routes = this._routes.reduce(function (result, r) {
      if (r.handler !== handler) result.push(r);
      return result;
    }, []);
    return this;
  },
  notFound: function notFound(handler, hooks) {
    this._notFoundHandler = {
      handler: handler,
      hooks: hooks
    };
    return this;
  },
  resolve: function resolve(current) {
    var _this2 = this;

    var handler, m;

    var url = (current || this._cLoc()).replace(this._getRoot(), '');

    if (this._useHash) {
      url = url.replace(new RegExp('^\/' + this._hash), '/');
    }

    var GETParameters = extractGETParameters(current || this._cLoc());
    var onlyURL = getOnlyURL(url, this._useHash, this._hash);
    if (this._paused) return false;

    if (this._lastRouteResolved && onlyURL === this._lastRouteResolved.url && GETParameters === this._lastRouteResolved.query) {
      if (this._lastRouteResolved.hooks && this._lastRouteResolved.hooks.already) {
        this._lastRouteResolved.hooks.already(this._lastRouteResolved.params);
      }

      return false;
    }

    m = navigo_es_match(onlyURL, this._routes);

    if (m) {
      this._callLeave();

      this._lastRouteResolved = {
        url: onlyURL,
        query: GETParameters,
        hooks: m.route.hooks,
        params: m.params,
        name: m.route.name
      };
      handler = m.route.handler;
      manageHooks(function () {
        manageHooks(function () {
          m.route.route instanceof RegExp ? handler.apply(undefined, m.match.slice(1, m.match.length)) : handler(m.params, GETParameters);
        }, m.route.hooks, m.params, _this2._genericHooks);
      }, this._genericHooks, m.params);
      return m;
    } else if (this._defaultHandler && (onlyURL === '' || onlyURL === '/' || onlyURL === this._hash || isHashedRoot(onlyURL, this._useHash, this._hash))) {
      manageHooks(function () {
        manageHooks(function () {
          _this2._callLeave();

          _this2._lastRouteResolved = {
            url: onlyURL,
            query: GETParameters,
            hooks: _this2._defaultHandler.hooks
          };

          _this2._defaultHandler.handler(GETParameters);
        }, _this2._defaultHandler.hooks);
      }, this._genericHooks);
      return true;
    } else if (this._notFoundHandler) {
      manageHooks(function () {
        manageHooks(function () {
          _this2._callLeave();

          _this2._lastRouteResolved = {
            url: onlyURL,
            query: GETParameters,
            hooks: _this2._notFoundHandler.hooks
          };

          _this2._notFoundHandler.handler(GETParameters);
        }, _this2._notFoundHandler.hooks);
      }, this._genericHooks);
    }

    return false;
  },
  destroy: function destroy() {
    this._routes = [];
    this._destroyed = true;
    this._lastRouteResolved = null;
    this._genericHooks = null;
    clearTimeout(this._listeningInterval);

    if (typeof window !== 'undefined') {
      window.removeEventListener('popstate', this._onLocationChange);
      window.removeEventListener('hashchange', this._onLocationChange);
    }
  },
  updatePageLinks: function updatePageLinks() {
    var self = this;
    if (typeof document === 'undefined') return;

    this._findLinks().forEach(function (link) {
      if (!link.hasListenerAttached) {
        link.addEventListener('click', function (e) {
          if ((e.ctrlKey || e.metaKey) && e.target.tagName.toLowerCase() == 'a') {
            return false;
          }

          var location = self.getLinkPath(link);

          if (!self._destroyed) {
            e.preventDefault();
            self.navigate(location.replace(/\/+$/, '').replace(/^\/+/, '/'));
          }
        });
        link.hasListenerAttached = true;
      }
    });
  },
  generate: function generate(name) {
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var result = this._routes.reduce(function (result, route) {
      var key;

      if (route.name === name) {
        result = route.route;

        for (key in data) {
          result = result.toString().replace(':' + key, data[key]);
        }
      }

      return result;
    }, '');

    return this._useHash ? this._hash + result : result;
  },
  link: function link(path) {
    return this._getRoot() + path;
  },
  pause: function pause() {
    var status = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    this._paused = status;

    if (status) {
      this._historyAPIUpdateMethod = 'replaceState';
    } else {
      this._historyAPIUpdateMethod = 'pushState';
    }
  },
  resume: function resume() {
    this.pause(false);
  },
  historyAPIUpdateMethod: function historyAPIUpdateMethod(value) {
    if (typeof value === 'undefined') return this._historyAPIUpdateMethod;
    this._historyAPIUpdateMethod = value;
    return value;
  },
  disableIfAPINotAvailable: function disableIfAPINotAvailable() {
    if (!isPushStateAvailable()) {
      this.destroy();
    }
  },
  lastRouteResolved: function lastRouteResolved() {
    return this._lastRouteResolved;
  },
  getLinkPath: function getLinkPath(link) {
    return link.getAttribute('href');
  },
  hooks: function hooks(_hooks) {
    this._genericHooks = _hooks;
  },
  _add: function _add(route) {
    var handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var hooks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    if (typeof route === 'string') {
      route = encodeURI(route);
    }

    this._routes.push((typeof handler === 'undefined' ? 'undefined' : _typeof(handler)) === 'object' ? {
      route: route,
      handler: handler.uses,
      name: handler.as,
      hooks: hooks || handler.hooks
    } : {
      route: route,
      handler: handler,
      hooks: hooks
    });

    return this._add;
  },
  _getRoot: function _getRoot() {
    if (this.root !== null) return this.root;
    this.root = root(this._cLoc().split('?')[0], this._routes);
    return this.root;
  },
  _listen: function _listen() {
    var _this3 = this;

    if (this._usePushState) {
      window.addEventListener('popstate', this._onLocationChange);
    } else if (isHashChangeAPIAvailable()) {
      window.addEventListener('hashchange', this._onLocationChange);
    } else {
      var cached = this._cLoc(),
          current = void 0,
          _check = void 0;

      _check = function check() {
        current = _this3._cLoc();

        if (cached !== current) {
          cached = current;

          _this3.resolve();
        }

        _this3._listeningInterval = setTimeout(_check, 200);
      };

      _check();
    }
  },
  _cLoc: function _cLoc() {
    if (typeof window !== 'undefined') {
      if (typeof window.__NAVIGO_WINDOW_LOCATION_MOCK__ !== 'undefined') {
        return window.__NAVIGO_WINDOW_LOCATION_MOCK__;
      }

      return clean(window.location.href);
    }

    return '';
  },
  _findLinks: function _findLinks() {
    return [].slice.call(document.querySelectorAll('[data-navigo]'));
  },
  _onLocationChange: function _onLocationChange() {
    this.resolve();
  },
  _callLeave: function _callLeave() {
    var lastRouteResolved = this._lastRouteResolved;

    if (lastRouteResolved && lastRouteResolved.hooks && lastRouteResolved.hooks.leave) {
      lastRouteResolved.hooks.leave(lastRouteResolved.params);
    }
  }
};
Navigo.PARAMETER_REGEXP = /([:*])(\w+)/g;
Navigo.WILDCARD_REGEXP = /\*/g;
Navigo.REPLACE_VARIABLE_REGEXP = '([^\/]+)';
Navigo.REPLACE_WILDCARD = '(?:.*)';
Navigo.FOLLOWED_BY_SLASH_REGEXP = '(?:\/$|$)';
Navigo.MATCH_REGEXP_FLAGS = '';
/* harmony default export */ var navigo_es = (Navigo);
// CONCATENATED MODULE: ./src/router.js

const router = new navigo_es(`http://localhost:${window.location.port}`);
// CONCATENATED MODULE: ./src/components/leap-dashboard.js











const tabs = ['enrolled-courses', 'my-courses', 'all-courses'];
class leap_dashboard_LeapDashboard extends lit_element_LitElement {
  static get styles() {
    return [sharedStyles, css`
        mwc-card {
          margin: 24px;
        }

        .card-content {
          padding: 16px;
          min-height: 200px;
          display: flex;
          flex-direction: column;
        }

        .fab {
          position: absolute;
          right: 36px;
          bottom: 36px;
        }

        .title {
          font-size: 24px;
        }

        leap-courses-list {
          margin-top: 8px;
          flex: 1;
          display: flex;
        }
      `];
  }

  firstUpdated() {
    this.activeTab = 0;
  }

  static get properties() {
    return {
      activeTab: {
        type: Number
      }
    };
  }

  renderCreateCourseDialog() {
    return lit_html_html`
      <mwc-dialog id="create-course-dialog" heading="Create course">
        <mwc-textfield
          style="margin-top: 16px;"
          outlined
          label="Title"
          dialogInitialFocus
          @input=${e => this.courseTitle = e.target.value}
        >
        </mwc-textfield>

        <mwc-button
          slot="primaryAction"
          dialogAction="create"
          @click=${() => this.createCourse()}
        >
          Create
        </mwc-button>
        <mwc-button slot="secondaryAction" dialogAction="cancel">
          Cancel
        </mwc-button>
      </mwc-dialog>
    `;
  }

  async createCourse() {
    const client = await getClient();
    const result = await client.mutate({
      mutation: CREATE_COURSE,
      variables: {
        title: this.courseTitle
      }
    });
    router.navigate(`course/${result.data.createCourse.id}`);
  }

  render() {
    return lit_html_html`
      ${this.renderCreateCourseDialog()}
      <div class="column fill" style="position: relative;">
        <mwc-top-app-bar>
          <div slot="title">LeaP ${USERNAME ? '/ ' + USERNAME : ''}</div>
        </mwc-top-app-bar>

        <div
          class="row fill"
          style="justify-content: center; align-items: start;"
        >
          <mwc-card>
            <div class="card-content">
              <span class="title">All courses</span>
              <leap-courses-list
                class="fill"
                filter="all-courses"
              ></leap-courses-list>
            </div>
          </mwc-card>

          <mwc-card>
            <div class="card-content">
              <span class="title">My courses</span>
              <leap-courses-list
                class="fill"
                filter="my-courses"
              ></leap-courses-list>
            </div>
          </mwc-card>

          <mwc-card>
            <div class="card-content">
              <span class="title">Enrolled courses</span>
              <leap-courses-list
                class="fill"
                filter="enrolled-courses"
              ></leap-courses-list>
            </div>
          </mwc-card>
        </div>

        <mwc-fab
          label="Create course"
          icon="add"
          extended
          class="fab"
          @click=${() => this.shadowRoot.getElementById('create-course-dialog').open = true}
        ></mwc-fab>
      </div>
    `;
  }

}
// CONCATENATED MODULE: ./src/components/leap-app.js


class leap_app_LeapApp extends lit_element_LitElement {
  static get properties() {
    return {
      appContent: {
        type: Object
      }
    };
  }

  constructor() {
    super();
    router.on(() => router.navigate('/home')).on('/home', () => this.appContent = lit_html_html`
            <leap-dashboard></leap-dashboard>
          `).on('/course/:id', params => this.appContent = lit_html_html`
            <leap-course-detail .courseId=${params.id}></leap-course-detail>
          `).resolve();
  }

  render() {
    return this.appContent;
  }

}
// CONCATENATED MODULE: ./node_modules/@authentic/mwc-base/observer.js
const mwc_base_observer_observer = observer => (proto, propName) => {
  // if we haven't wrapped `updated` in this class, do so
  if (!proto.constructor._observers) {
    proto.constructor._observers = new Map();
    const userUpdated = proto.updated;

    proto.updated = function (changedProperties) {
      userUpdated.call(this, changedProperties);
      changedProperties.forEach((v, k) => {
        const observer = this.constructor._observers.get(k);

        if (observer !== undefined) {
          observer.call(this, this[k], v);
        }
      });
    }; // clone any existing observers (superclasses)

  } else if (!proto.constructor.hasOwnProperty('_observers')) {
    const observers = proto.constructor._observers;
    proto.constructor._observers = new Map();
    observers.forEach((v, k) => proto.constructor._observers.set(k, v));
  } // set this method


  proto.constructor._observers.set(propName, observer);
};
// CONCATENATED MODULE: ./node_modules/@material/dom/ponyfill.js
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
 * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
 */
function _material_dom_ponyfill_closest(element, selector) {
  if (element.closest) {
    return element.closest(selector);
  }

  var el = element;

  while (el) {
    if (node_modules_material_dom_ponyfill_matches(el, selector)) {
      return el;
    }

    el = el.parentElement;
  }

  return null;
}
function node_modules_material_dom_ponyfill_matches(element, selector) {
  var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
  return nativeMatches.call(element, selector);
}
// CONCATENATED MODULE: ./node_modules/@authentic/mwc-base/utils.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * Return an element assigned to a given slot that matches the given selector
 */

function utils_findAssignedElement(slot, selector) {
  for (const node of slot.assignedNodes({
    flatten: true
  })) {
    if (node.nodeType === Node.ELEMENT_NODE) {
      const el = node;

      if (node_modules_material_dom_ponyfill_matches(el, selector)) {
        return el;
      }
    }
  }

  return null;
}
/**
 * Return all elements assigned to a given slot that matches the given selector
 */

function findAssignedElements(slot, selector) {
  const els = [];

  for (const node of slot.assignedNodes({
    flatten: true
  })) {
    if (node.nodeType === Node.ELEMENT_NODE) {
      const el = node;

      if (node_modules_material_dom_ponyfill_matches(el, selector)) {
        els.push(el);
      }
    }
  }

  return els;
}
/**
 * Emits a Custom Event
 */

function emit(target, evtType, evtData = {}, shouldBubble = false) {
  let evt;

  if (typeof CustomEvent === 'function') {
    evt = new CustomEvent(evtType, {
      detail: evtData,
      bubbles: shouldBubble,
      composed: shouldBubble
    });
  } else {
    evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(evtType, shouldBubble, false, evtData);
  }

  target.dispatchEvent(evt);
}
function utils_addHasRemoveClass(element) {
  return {
    addClass: className => {
      element.classList.add(className);
    },
    removeClass: className => {
      element.classList.remove(className);
    },
    hasClass: className => element.classList.contains(className)
  };
}
/**
 * Returns the events path which is an array of the objects on which listeners will be invoked
 */

function eventPath(e) {
  if ('composedPath' in e) return e.composedPath();
  if ('path' in e) return e['path']; //polyfill

  const path = [];
  let currentElem = e['target'];

  while (currentElem) {
    path.push(currentElem);
    currentElem = currentElem['parentElement'];
  }

  if (path.indexOf(window) === -1 && path.indexOf(document) === -1) path.push(document);
  if (path.indexOf(window) === -1) path.push(window);
  return path;
}
// CONCATENATED MODULE: ./node_modules/@authentic/mwc-base/base-element.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/





class mwc_base_base_element_BaseElement extends lit_element_LitElement {
  /**
   * Create and attach the MDC Foundation to the instance
   */
  createFoundation() {
    if (this.mdcFoundation !== undefined) {
      this.mdcFoundation.destroy();
    }

    this.mdcFoundation = new this.mdcFoundationClass(this.createAdapter());
    this.mdcFoundation.init();
  }
  /**
   * Invoked when the element is first updated. Implement to perform one time
   * work on the element after update.
   *
   * Setting properties inside this method will trigger the element to update
   * again after this update cycle completes.
   *
   * @param _changedProperties Map of changed properties with old values
   */


  firstUpdated() {
    this.createFoundation();
  }

}
// CONCATENATED MODULE: ./node_modules/@material/base/foundation.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var node_modules_material_base_foundation_MDCFoundation_0 =
/** @class */
function () {
  function MDCFoundation(adapter) {
    if (adapter === void 0) {
      adapter = {};
    }

    this.adapter_ = adapter;
  }

  Object.defineProperty(MDCFoundation, "cssClasses", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "strings", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "numbers", {
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCFoundation, "defaultAdapter", {
    get: function get() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    },
    enumerable: true,
    configurable: true
  });

  MDCFoundation.prototype.init = function () {// Subclasses should override this method to perform initialization routines (registering events, etc.)
  };

  MDCFoundation.prototype.destroy = function () {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  };

  return MDCFoundation;
}();

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var node_modules_material_base_foundation_0 = (node_modules_material_base_foundation_MDCFoundation_0);
// CONCATENATED MODULE: ./node_modules/@material/ripple/constants.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var _material_ripple_constants_cssClasses = {
  // Ripple is a special case where the "root" component is really a "mixin" of sorts,
  // given that it's an 'upgrade' to an existing component. That being said it is the root
  // CSS class that all other CSS classes derive from.
  BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
  FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
  FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation',
  ROOT: 'mdc-ripple-upgraded',
  UNBOUNDED: 'mdc-ripple-upgraded--unbounded'
};
var _material_ripple_constants_strings = {
  VAR_FG_SCALE: '--mdc-ripple-fg-scale',
  VAR_FG_SIZE: '--mdc-ripple-fg-size',
  VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end',
  VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
  VAR_LEFT: '--mdc-ripple-left',
  VAR_TOP: '--mdc-ripple-top'
};
var _material_ripple_constants_numbers = {
  DEACTIVATION_TIMEOUT_MS: 225,
  FG_DEACTIVATION_MS: 150,
  INITIAL_ORIGIN_SCALE: 0.6,
  PADDING: 10,
  TAP_DELAY_MS: 300
};
// CONCATENATED MODULE: ./node_modules/@material/ripple/util.js
/**
 * Stores result from supportsCssVariables to avoid redundant processing to
 * detect CSS custom variable support.
 */
var util_supportsCssVariables_;
/**
 * Stores result from applyPassive to avoid redundant processing to detect
 * passive event listener support.
 */

var supportsPassive_;

function detectEdgePseudoVarBug(windowObj) {
  // Detect versions of Edge with buggy var() support
  // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
  var document = windowObj.document;
  var node = document.createElement('div');
  node.className = 'mdc-ripple-surface--test-edge-var-bug';
  document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
  // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
  // but Firefox is known to support CSS custom properties correctly.
  // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

  var computedStyle = windowObj.getComputedStyle(node);
  var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';

  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }

  return hasPseudoVarBug;
}

function util_supportsCssVariables(windowObj, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }

  var CSS = windowObj.CSS;
  var supportsCssVars = util_supportsCssVariables_;

  if (typeof util_supportsCssVariables_ === 'boolean' && !forceRefresh) {
    return util_supportsCssVariables_;
  }

  var supportsFunctionPresent = CSS && typeof CSS.supports === 'function';

  if (!supportsFunctionPresent) {
    return false;
  }

  var explicitlySupportsCssVars = CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
  // See: README section on Safari

  var weAreFeatureDetectingSafari10plus = CSS.supports('(--css-vars: yes)') && CSS.supports('color', '#00000000');

  if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
    supportsCssVars = !detectEdgePseudoVarBug(windowObj);
  } else {
    supportsCssVars = false;
  }

  if (!forceRefresh) {
    util_supportsCssVariables_ = supportsCssVars;
  }

  return supportsCssVars;
}
/**
 * Determine whether the current browser supports passive event listeners, and
 * if so, use them.
 */

function util_applyPassive(globalObj, forceRefresh) {
  if (globalObj === void 0) {
    globalObj = window;
  }

  if (forceRefresh === void 0) {
    forceRefresh = false;
  }

  if (supportsPassive_ === undefined || forceRefresh) {
    var isSupported_1 = false;

    try {
      globalObj.document.addEventListener('test', function () {
        return undefined;
      }, {
        get passive() {
          isSupported_1 = true;
          return isSupported_1;
        }

      });
    } catch (e) {} // tslint:disable-line:no-empty cannot throw error due to tests. tslint also disables console.log.


    supportsPassive_ = isSupported_1;
  }

  return supportsPassive_ ? {
    passive: true
  } : false;
}
function util_getNormalizedEventCoords(evt, pageOffset, clientRect) {
  if (!evt) {
    return {
      x: 0,
      y: 0
    };
  }

  var x = pageOffset.x,
      y = pageOffset.y;
  var documentX = x + clientRect.left;
  var documentY = y + clientRect.top;
  var normalizedX;
  var normalizedY; // Determine touch point relative to the ripple container.

  if (evt.type === 'touchstart') {
    var touchEvent = evt;
    normalizedX = touchEvent.changedTouches[0].pageX - documentX;
    normalizedY = touchEvent.changedTouches[0].pageY - documentY;
  } else {
    var mouseEvent = evt;
    normalizedX = mouseEvent.pageX - documentX;
    normalizedY = mouseEvent.pageY - documentY;
  }

  return {
    x: normalizedX,
    y: normalizedY
  };
}
// CONCATENATED MODULE: ./node_modules/@material/ripple/foundation.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */



 // Activation events registered on the root element of each instance for activation

var foundation_ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

var foundation_POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // simultaneous nested activations

var foundation_activatedTargets = [];

var ripple_foundation_MDCRippleFoundation =
/** @class */
function (_super) {
  tslib_es6["d" /* __extends */](MDCRippleFoundation, _super);

  function MDCRippleFoundation(adapter) {
    var _this = _super.call(this, tslib_es6["a" /* __assign */]({}, MDCRippleFoundation.defaultAdapter, adapter)) || this;

    _this.activationAnimationHasEnded_ = false;
    _this.activationTimer_ = 0;
    _this.fgDeactivationRemovalTimer_ = 0;
    _this.fgScale_ = '0';
    _this.frame_ = {
      width: 0,
      height: 0
    };
    _this.initialSize_ = 0;
    _this.layoutFrame_ = 0;
    _this.maxRadius_ = 0;
    _this.unboundedCoords_ = {
      left: 0,
      top: 0
    };
    _this.activationState_ = _this.defaultActivationState_();

    _this.activationTimerCallback_ = function () {
      _this.activationAnimationHasEnded_ = true;

      _this.runDeactivationUXLogicIfReady_();
    };

    _this.activateHandler_ = function (e) {
      return _this.activate_(e);
    };

    _this.deactivateHandler_ = function () {
      return _this.deactivate_();
    };

    _this.focusHandler_ = function () {
      return _this.handleFocus();
    };

    _this.blurHandler_ = function () {
      return _this.handleBlur();
    };

    _this.resizeHandler_ = function () {
      return _this.layout();
    };

    return _this;
  }

  Object.defineProperty(MDCRippleFoundation, "cssClasses", {
    get: function get() {
      return _material_ripple_constants_cssClasses;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation, "strings", {
    get: function get() {
      return _material_ripple_constants_strings;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation, "numbers", {
    get: function get() {
      return _material_ripple_constants_numbers;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation, "defaultAdapter", {
    get: function get() {
      return {
        addClass: function addClass() {
          return undefined;
        },
        browserSupportsCssVars: function browserSupportsCssVars() {
          return true;
        },
        computeBoundingRect: function computeBoundingRect() {
          return {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            width: 0,
            height: 0
          };
        },
        containsEventTarget: function containsEventTarget() {
          return true;
        },
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() {
          return undefined;
        },
        deregisterInteractionHandler: function deregisterInteractionHandler() {
          return undefined;
        },
        deregisterResizeHandler: function deregisterResizeHandler() {
          return undefined;
        },
        getWindowPageOffset: function getWindowPageOffset() {
          return {
            x: 0,
            y: 0
          };
        },
        isSurfaceActive: function isSurfaceActive() {
          return true;
        },
        isSurfaceDisabled: function isSurfaceDisabled() {
          return true;
        },
        isUnbounded: function isUnbounded() {
          return true;
        },
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler() {
          return undefined;
        },
        registerInteractionHandler: function registerInteractionHandler() {
          return undefined;
        },
        registerResizeHandler: function registerResizeHandler() {
          return undefined;
        },
        removeClass: function removeClass() {
          return undefined;
        },
        updateCssVariable: function updateCssVariable() {
          return undefined;
        }
      };
    },
    enumerable: true,
    configurable: true
  });

  MDCRippleFoundation.prototype.init = function () {
    var _this = this;

    var supportsPressRipple = this.supportsPressRipple_();
    this.registerRootHandlers_(supportsPressRipple);

    if (supportsPressRipple) {
      var _a = MDCRippleFoundation.cssClasses,
          ROOT_1 = _a.ROOT,
          UNBOUNDED_1 = _a.UNBOUNDED;
      requestAnimationFrame(function () {
        _this.adapter_.addClass(ROOT_1);

        if (_this.adapter_.isUnbounded()) {
          _this.adapter_.addClass(UNBOUNDED_1); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


          _this.layoutInternal_();
        }
      });
    }
  };

  MDCRippleFoundation.prototype.destroy = function () {
    var _this = this;

    if (this.supportsPressRipple_()) {
      if (this.activationTimer_) {
        clearTimeout(this.activationTimer_);
        this.activationTimer_ = 0;
        this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
      }

      if (this.fgDeactivationRemovalTimer_) {
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.fgDeactivationRemovalTimer_ = 0;
        this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
      }

      var _a = MDCRippleFoundation.cssClasses,
          ROOT_2 = _a.ROOT,
          UNBOUNDED_2 = _a.UNBOUNDED;
      requestAnimationFrame(function () {
        _this.adapter_.removeClass(ROOT_2);

        _this.adapter_.removeClass(UNBOUNDED_2);

        _this.removeCssVars_();
      });
    }

    this.deregisterRootHandlers_();
    this.deregisterDeactivationHandlers_();
  };
  /**
   * @param evt Optional event containing position information.
   */


  MDCRippleFoundation.prototype.activate = function (evt) {
    this.activate_(evt);
  };

  MDCRippleFoundation.prototype.deactivate = function () {
    this.deactivate_();
  };

  MDCRippleFoundation.prototype.layout = function () {
    var _this = this;

    if (this.layoutFrame_) {
      cancelAnimationFrame(this.layoutFrame_);
    }

    this.layoutFrame_ = requestAnimationFrame(function () {
      _this.layoutInternal_();

      _this.layoutFrame_ = 0;
    });
  };

  MDCRippleFoundation.prototype.setUnbounded = function (unbounded) {
    var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

    if (unbounded) {
      this.adapter_.addClass(UNBOUNDED);
    } else {
      this.adapter_.removeClass(UNBOUNDED);
    }
  };

  MDCRippleFoundation.prototype.handleFocus = function () {
    var _this = this;

    requestAnimationFrame(function () {
      return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
    });
  };

  MDCRippleFoundation.prototype.handleBlur = function () {
    var _this = this;

    requestAnimationFrame(function () {
      return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
    });
  };
  /**
   * We compute this property so that we are not querying information about the client
   * until the point in time where the foundation requests it. This prevents scenarios where
   * client-side feature-detection may happen too early, such as when components are rendered on the server
   * and then initialized at mount time on the client.
   */


  MDCRippleFoundation.prototype.supportsPressRipple_ = function () {
    return this.adapter_.browserSupportsCssVars();
  };

  MDCRippleFoundation.prototype.defaultActivationState_ = function () {
    return {
      activationEvent: undefined,
      hasDeactivationUXRun: false,
      isActivated: false,
      isProgrammatic: false,
      wasActivatedByPointer: false,
      wasElementMadeActive: false
    };
  };
  /**
   * supportsPressRipple Passed from init to save a redundant function call
   */


  MDCRippleFoundation.prototype.registerRootHandlers_ = function (supportsPressRipple) {
    var _this = this;

    if (supportsPressRipple) {
      foundation_ACTIVATION_EVENT_TYPES.forEach(function (evtType) {
        _this.adapter_.registerInteractionHandler(evtType, _this.activateHandler_);
      });

      if (this.adapter_.isUnbounded()) {
        this.adapter_.registerResizeHandler(this.resizeHandler_);
      }
    }

    this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
    this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
  };

  MDCRippleFoundation.prototype.registerDeactivationHandlers_ = function (evt) {
    var _this = this;

    if (evt.type === 'keydown') {
      this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
    } else {
      foundation_POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (evtType) {
        _this.adapter_.registerDocumentInteractionHandler(evtType, _this.deactivateHandler_);
      });
    }
  };

  MDCRippleFoundation.prototype.deregisterRootHandlers_ = function () {
    var _this = this;

    foundation_ACTIVATION_EVENT_TYPES.forEach(function (evtType) {
      _this.adapter_.deregisterInteractionHandler(evtType, _this.activateHandler_);
    });
    this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
    this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

    if (this.adapter_.isUnbounded()) {
      this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    }
  };

  MDCRippleFoundation.prototype.deregisterDeactivationHandlers_ = function () {
    var _this = this;

    this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
    foundation_POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (evtType) {
      _this.adapter_.deregisterDocumentInteractionHandler(evtType, _this.deactivateHandler_);
    });
  };

  MDCRippleFoundation.prototype.removeCssVars_ = function () {
    var _this = this;

    var rippleStrings = MDCRippleFoundation.strings;
    var keys = Object.keys(rippleStrings);
    keys.forEach(function (key) {
      if (key.indexOf('VAR_') === 0) {
        _this.adapter_.updateCssVariable(rippleStrings[key], null);
      }
    });
  };

  MDCRippleFoundation.prototype.activate_ = function (evt) {
    var _this = this;

    if (this.adapter_.isSurfaceDisabled()) {
      return;
    }

    var activationState = this.activationState_;

    if (activationState.isActivated) {
      return;
    } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


    var previousActivationEvent = this.previousActivationEvent_;
    var isSameInteraction = previousActivationEvent && evt !== undefined && previousActivationEvent.type !== evt.type;

    if (isSameInteraction) {
      return;
    }

    activationState.isActivated = true;
    activationState.isProgrammatic = evt === undefined;
    activationState.activationEvent = evt;
    activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== undefined && (evt.type === 'mousedown' || evt.type === 'touchstart' || evt.type === 'pointerdown');
    var hasActivatedChild = evt !== undefined && foundation_activatedTargets.length > 0 && foundation_activatedTargets.some(function (target) {
      return _this.adapter_.containsEventTarget(target);
    });

    if (hasActivatedChild) {
      // Immediately reset activation state, while preserving logic that prevents touch follow-on events
      this.resetActivationState_();
      return;
    }

    if (evt !== undefined) {
      foundation_activatedTargets.push(evt.target);
      this.registerDeactivationHandlers_(evt);
    }

    activationState.wasElementMadeActive = this.checkElementMadeActive_(evt);

    if (activationState.wasElementMadeActive) {
      this.animateActivation_();
    }

    requestAnimationFrame(function () {
      // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
      foundation_activatedTargets = [];

      if (!activationState.wasElementMadeActive && evt !== undefined && (evt.key === ' ' || evt.keyCode === 32)) {
        // If space was pressed, try again within an rAF call to detect :active, because different UAs report
        // active states inconsistently when they're called within event handling code:
        // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
        // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
        // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
        // variable is set within a rAF callback for a submit button interaction (#2241).
        activationState.wasElementMadeActive = _this.checkElementMadeActive_(evt);

        if (activationState.wasElementMadeActive) {
          _this.animateActivation_();
        }
      }

      if (!activationState.wasElementMadeActive) {
        // Reset activation state immediately if element was not made active.
        _this.activationState_ = _this.defaultActivationState_();
      }
    });
  };

  MDCRippleFoundation.prototype.checkElementMadeActive_ = function (evt) {
    return evt !== undefined && evt.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
  };

  MDCRippleFoundation.prototype.animateActivation_ = function () {
    var _this = this;

    var _a = MDCRippleFoundation.strings,
        VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START,
        VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;
    var _b = MDCRippleFoundation.cssClasses,
        FG_DEACTIVATION = _b.FG_DEACTIVATION,
        FG_ACTIVATION = _b.FG_ACTIVATION;
    var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
    this.layoutInternal_();
    var translateStart = '';
    var translateEnd = '';

    if (!this.adapter_.isUnbounded()) {
      var _c = this.getFgTranslationCoordinates_(),
          startPoint = _c.startPoint,
          endPoint = _c.endPoint;

      translateStart = startPoint.x + "px, " + startPoint.y + "px";
      translateEnd = endPoint.x + "px, " + endPoint.y + "px";
    }

    this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
    this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

    clearTimeout(this.activationTimer_);
    clearTimeout(this.fgDeactivationRemovalTimer_);
    this.rmBoundedActivationClasses_();
    this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

    this.adapter_.computeBoundingRect();
    this.adapter_.addClass(FG_ACTIVATION);
    this.activationTimer_ = setTimeout(function () {
      return _this.activationTimerCallback_();
    }, DEACTIVATION_TIMEOUT_MS);
  };

  MDCRippleFoundation.prototype.getFgTranslationCoordinates_ = function () {
    var _a = this.activationState_,
        activationEvent = _a.activationEvent,
        wasActivatedByPointer = _a.wasActivatedByPointer;
    var startPoint;

    if (wasActivatedByPointer) {
      startPoint = util_getNormalizedEventCoords(activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
    } else {
      startPoint = {
        x: this.frame_.width / 2,
        y: this.frame_.height / 2
      };
    } // Center the element around the start point.


    startPoint = {
      x: startPoint.x - this.initialSize_ / 2,
      y: startPoint.y - this.initialSize_ / 2
    };
    var endPoint = {
      x: this.frame_.width / 2 - this.initialSize_ / 2,
      y: this.frame_.height / 2 - this.initialSize_ / 2
    };
    return {
      startPoint: startPoint,
      endPoint: endPoint
    };
  };

  MDCRippleFoundation.prototype.runDeactivationUXLogicIfReady_ = function () {
    var _this = this; // This method is called both when a pointing device is released, and when the activation animation ends.
    // The deactivation animation should only run after both of those occur.


    var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
    var _a = this.activationState_,
        hasDeactivationUXRun = _a.hasDeactivationUXRun,
        isActivated = _a.isActivated;
    var activationHasEnded = hasDeactivationUXRun || !isActivated;

    if (activationHasEnded && this.activationAnimationHasEnded_) {
      this.rmBoundedActivationClasses_();
      this.adapter_.addClass(FG_DEACTIVATION);
      this.fgDeactivationRemovalTimer_ = setTimeout(function () {
        _this.adapter_.removeClass(FG_DEACTIVATION);
      }, _material_ripple_constants_numbers.FG_DEACTIVATION_MS);
    }
  };

  MDCRippleFoundation.prototype.rmBoundedActivationClasses_ = function () {
    var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
    this.adapter_.removeClass(FG_ACTIVATION);
    this.activationAnimationHasEnded_ = false;
    this.adapter_.computeBoundingRect();
  };

  MDCRippleFoundation.prototype.resetActivationState_ = function () {
    var _this = this;

    this.previousActivationEvent_ = this.activationState_.activationEvent;
    this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
    // Store the previous event until it's safe to assume that subsequent events are for new interactions.

    setTimeout(function () {
      return _this.previousActivationEvent_ = undefined;
    }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
  };

  MDCRippleFoundation.prototype.deactivate_ = function () {
    var _this = this;

    var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

    if (!activationState.isActivated) {
      return;
    }

    var state = tslib_es6["a" /* __assign */]({}, activationState);

    if (activationState.isProgrammatic) {
      requestAnimationFrame(function () {
        return _this.animateDeactivation_(state);
      });
      this.resetActivationState_();
    } else {
      this.deregisterDeactivationHandlers_();
      requestAnimationFrame(function () {
        _this.activationState_.hasDeactivationUXRun = true;

        _this.animateDeactivation_(state);

        _this.resetActivationState_();
      });
    }
  };

  MDCRippleFoundation.prototype.animateDeactivation_ = function (_a) {
    var wasActivatedByPointer = _a.wasActivatedByPointer,
        wasElementMadeActive = _a.wasElementMadeActive;

    if (wasActivatedByPointer || wasElementMadeActive) {
      this.runDeactivationUXLogicIfReady_();
    }
  };

  MDCRippleFoundation.prototype.layoutInternal_ = function () {
    var _this = this;

    this.frame_ = this.adapter_.computeBoundingRect();
    var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
    // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
    // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
    // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
    // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
    // `overflow: hidden`.

    var getBoundedRadius = function getBoundedRadius() {
      var hypotenuse = Math.sqrt(Math.pow(_this.frame_.width, 2) + Math.pow(_this.frame_.height, 2));
      return hypotenuse + MDCRippleFoundation.numbers.PADDING;
    };

    this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

    this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
    this.fgScale_ = "" + this.maxRadius_ / this.initialSize_;
    this.updateLayoutCssVars_();
  };

  MDCRippleFoundation.prototype.updateLayoutCssVars_ = function () {
    var _a = MDCRippleFoundation.strings,
        VAR_FG_SIZE = _a.VAR_FG_SIZE,
        VAR_LEFT = _a.VAR_LEFT,
        VAR_TOP = _a.VAR_TOP,
        VAR_FG_SCALE = _a.VAR_FG_SCALE;
    this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + "px");
    this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

    if (this.adapter_.isUnbounded()) {
      this.unboundedCoords_ = {
        left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
        top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
      };
      this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + "px");
      this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + "px");
    }
  };

  return MDCRippleFoundation;
}(node_modules_material_base_foundation_MDCFoundation_0);

 // tslint:disable-next-line:no-default-export Needed for backward compatibility with MDC Web v0.44.0 and earlier.

/* harmony default export */ var _material_ripple_foundation = (ripple_foundation_MDCRippleFoundation);
// CONCATENATED MODULE: ./node_modules/@authentic/mwc-ripple/mwc-ripple-global-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_ripple_mwc_ripple_global_css_style = css`/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
@keyframes mdc-ripple-fg-radius-in {
  from {
    animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1);
  }
  to {
    transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));
  }
}
@keyframes mdc-ripple-fg-opacity-in {
  from {
    animation-timing-function: linear;
    opacity: 0;
  }
  to {
    opacity: var(--mdc-ripple-fg-opacity, 0);
  }
}
@keyframes mdc-ripple-fg-opacity-out {
  from {
    animation-timing-function: linear;
    opacity: var(--mdc-ripple-fg-opacity, 0);
  }
  to {
    opacity: 0;
  }
}`;
// CONCATENATED MODULE: ./node_modules/@authentic/mwc-ripple/ripple-directive.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/





const ripple_directive_supportsCssVariables = util_supportsCssVariables(window); // NOTE: This is a workaround for https://bugs.webkit.org/show_bug.cgi?id=173027.
// Since keyframes on pseudo-elements (:after) are not supported in Shadow DOM,
// we put the keyframe style into the <head> element.

const ripple_directive_isSafari = navigator.userAgent.match(/Safari/);
let ripple_directive_didApplyRippleStyle = false;

const ripple_directive_applyRippleStyle = () => {
  ripple_directive_didApplyRippleStyle = true;
  const part = new parts_NodePart({
    templateFactory: templateFactory
  });
  part.appendInto(document.head);
  part.setValue(mwc_ripple_mwc_ripple_global_css_style);
  part.commit();
};
/**
 * Applied a ripple to the node specified by {surfaceNode}.
 * @param options {RippleNodeOptions}
 */


const ripple_directive_rippleNode = options => {
  if (ripple_directive_isSafari && !ripple_directive_didApplyRippleStyle) {
    ripple_directive_applyRippleStyle();
  } // TODO(sorvell): This directive requires bringing css yourself. We probably need to do this
  // because of ShadyCSS, but on Safari, the keyframes styling must be global. Perhaps this
  // directive could fix that.


  const surfaceNode = options.surfaceNode;
  const interactionNode = options.interactionNode || surfaceNode; // only style interaction node if not in the same root

  if (interactionNode.getRootNode() !== surfaceNode.getRootNode()) {
    if (interactionNode.style.position === '') {
      interactionNode.style.position = 'relative';
    }
  }

  const adapter = Object.assign({
    browserSupportsCssVars: () => ripple_directive_supportsCssVariables,
    isUnbounded: () => options.unbounded === undefined ? true : options.unbounded,
    isSurfaceActive: () => node_modules_material_dom_ponyfill_matches(interactionNode, ':active'),
    isSurfaceDisabled: () => Boolean(options.disabled),
    addClass: className => surfaceNode.classList.add(className),
    removeClass: className => surfaceNode.classList.remove(className),
    containsEventTarget: target => interactionNode.contains(target),
    registerInteractionHandler: (type, handler) => interactionNode.addEventListener(type, handler, util_applyPassive()),
    deregisterInteractionHandler: (type, handler) => interactionNode.removeEventListener(type, handler, util_applyPassive()),
    registerDocumentInteractionHandler: (evtType, handler) => document.documentElement.addEventListener(evtType, handler, util_applyPassive()),
    deregisterDocumentInteractionHandler: (evtType, handler) => document.documentElement.removeEventListener(evtType, handler, util_applyPassive()),
    registerResizeHandler: handler => window.addEventListener('resize', handler),
    deregisterResizeHandler: handler => window.removeEventListener('resize', handler),
    updateCssVariable: (varName, value) => surfaceNode.style.setProperty(varName, value),
    computeBoundingRect: () => surfaceNode.getBoundingClientRect(),
    getWindowPageOffset: () => ({
      x: window.pageXOffset,
      y: window.pageYOffset
    })
  }, options.adapter);
  const rippleFoundation = new _material_ripple_foundation(adapter);
  rippleFoundation.init();
  return rippleFoundation;
};
const ripple_directive_rippleInteractionNodes = new WeakMap();
/**
 * A directive that applies a Material ripple to a part node. The directive
 * should be applied to a PropertyPart.
 * @param options {RippleOptions}
 */

const ripple_directive_ripple = directive_directive((options = {}) => part => {
  const surfaceNode = part.committer.element;
  const interactionNode = options.interactionNode || surfaceNode;
  let rippleFoundation = part.value; // if the interaction node changes, destroy and invalidate the foundation.

  const existingInteractionNode = ripple_directive_rippleInteractionNodes.get(rippleFoundation);

  if (existingInteractionNode !== undefined && existingInteractionNode !== interactionNode) {
    rippleFoundation.destroy();
    rippleFoundation = noChange;
  } // make the ripple, if needed


  if (rippleFoundation === noChange) {
    rippleFoundation = ripple_directive_rippleNode(Object.assign({}, options, {
      surfaceNode
    }));
    ripple_directive_rippleInteractionNodes.set(rippleFoundation, interactionNode);
    part.setValue(rippleFoundation); // otherwise update settings as needed.
  } else {
    if (options.unbounded !== undefined) {
      rippleFoundation.setUnbounded(options.unbounded);
    }

    if (options.disabled !== undefined) {
      rippleFoundation.setUnbounded(options.disabled);
    }
  }

  if (options.active === true) {
    rippleFoundation.activate();
  } else if (options.active === false) {
    rippleFoundation.deactivate();
  }
});
// CONCATENATED MODULE: ./node_modules/@authentic/mwc-card/mwc-card-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_card_css_style = css`/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
.mdc-card {
  border-radius: 4px;
  background-color: #fff;
  /* @alternate */
  background-color: var(--mdc-theme-surface, #fff);
  box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12);
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
}

.mdc-card--outlined {
  box-shadow: 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12);
  border-width: 1px;
  border-style: solid;
  border-color: #e0e0e0;
}

.mdc-card__media {
  position: relative;
  box-sizing: border-box;
  background-repeat: no-repeat;
  background-position: center;
  background-size: cover;
}
.mdc-card__media::before {
  display: block;
  content: "";
}

.mdc-card__media:first-child {
  border-top-left-radius: inherit;
  border-top-right-radius: inherit;
}

.mdc-card__media:last-child {
  border-bottom-left-radius: inherit;
  border-bottom-right-radius: inherit;
}

.mdc-card__media--square::before {
  margin-top: 100%;
}

.mdc-card__media--16-9::before {
  margin-top: 56.25%;
}

.mdc-card__media-content {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  box-sizing: border-box;
}

.mdc-card__primary-action {
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  position: relative;
  outline: none;
  color: inherit;
  text-decoration: none;
  cursor: pointer;
  overflow: hidden;
}

.mdc-card__primary-action:first-child {
  border-top-left-radius: inherit;
  border-top-right-radius: inherit;
}

.mdc-card__primary-action:last-child {
  border-bottom-left-radius: inherit;
  border-bottom-right-radius: inherit;
}

.mdc-card__actions {
  display: flex;
  flex-direction: row;
  align-items: center;
  box-sizing: border-box;
  min-height: 52px;
  padding: 8px;
}

.mdc-card__actions--full-bleed {
  padding: 0;
}

.mdc-card__action-buttons,
.mdc-card__action-icons {
  display: flex;
  flex-direction: row;
  align-items: center;
  box-sizing: border-box;
}

.mdc-card__action-icons {
  color: rgba(0, 0, 0, 0.6);
  flex-grow: 1;
  justify-content: flex-end;
}

.mdc-card__action-buttons + .mdc-card__action-icons {
  /* @noflip */
  margin-left: 16px;
  /* @noflip */
  margin-right: 0;
}
[dir=rtl] .mdc-card__action-buttons + .mdc-card__action-icons, .mdc-card__action-buttons + .mdc-card__action-icons[dir=rtl] {
  /* @noflip */
  margin-left: 0;
  /* @noflip */
  margin-right: 16px;
}

.mdc-card__action {
  display: inline-flex;
  flex-direction: row;
  align-items: center;
  box-sizing: border-box;
  justify-content: center;
  cursor: pointer;
  user-select: none;
}
.mdc-card__action:focus {
  outline: none;
}

.mdc-card__action--button {
  /* @noflip */
  margin-left: 0;
  /* @noflip */
  margin-right: 8px;
  padding: 0 8px;
}
[dir=rtl] .mdc-card__action--button, .mdc-card__action--button[dir=rtl] {
  /* @noflip */
  margin-left: 8px;
  /* @noflip */
  margin-right: 0;
}
.mdc-card__action--button:last-child {
  /* @noflip */
  margin-left: 0;
  /* @noflip */
  margin-right: 0;
}
[dir=rtl] .mdc-card__action--button:last-child, .mdc-card__action--button:last-child[dir=rtl] {
  /* @noflip */
  margin-left: 0;
  /* @noflip */
  margin-right: 0;
}

.mdc-card__actions--full-bleed .mdc-card__action--button {
  justify-content: space-between;
  width: 100%;
  height: auto;
  max-height: none;
  margin: 0;
  padding: 8px 16px;
  /* @noflip */
  text-align: left;
}
[dir=rtl] .mdc-card__actions--full-bleed .mdc-card__action--button, .mdc-card__actions--full-bleed .mdc-card__action--button[dir=rtl] {
  /* @noflip */
  text-align: right;
}

.mdc-card__action--icon {
  margin: -6px 0;
  padding: 12px;
}

.mdc-card__action--icon:not(:disabled) {
  color: rgba(0, 0, 0, 0.6);
}

@keyframes mdc-ripple-fg-radius-in {
  from {
    animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    transform: translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1);
  }
  to {
    transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));
  }
}
@keyframes mdc-ripple-fg-opacity-in {
  from {
    animation-timing-function: linear;
    opacity: 0;
  }
  to {
    opacity: var(--mdc-ripple-fg-opacity, 0);
  }
}
@keyframes mdc-ripple-fg-opacity-out {
  from {
    animation-timing-function: linear;
    opacity: var(--mdc-ripple-fg-opacity, 0);
  }
  to {
    opacity: 0;
  }
}
.mdc-ripple-surface--test-edge-var-bug {
  --mdc-ripple-surface-test-edge-var: 1px solid #000;
  visibility: hidden;
}
.mdc-ripple-surface--test-edge-var-bug::before {
  border: var(--mdc-ripple-surface-test-edge-var);
}

.mdc-card__primary-action {
  --mdc-ripple-fg-size: 0;
  --mdc-ripple-left: 0;
  --mdc-ripple-top: 0;
  --mdc-ripple-fg-scale: 1;
  --mdc-ripple-fg-translate-end: 0;
  --mdc-ripple-fg-translate-start: 0;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}
.mdc-card__primary-action::before, .mdc-card__primary-action::after {
  position: absolute;
  border-radius: 50%;
  opacity: 0;
  pointer-events: none;
  content: "";
}
.mdc-card__primary-action::before {
  transition: opacity 15ms linear, background-color 15ms linear;
  z-index: 1;
}
.mdc-card__primary-action.mdc-ripple-upgraded::before {
  transform: scale(var(--mdc-ripple-fg-scale, 1));
}
.mdc-card__primary-action.mdc-ripple-upgraded::after {
  top: 0;
  /* @noflip */
  left: 0;
  transform: scale(0);
  transform-origin: center center;
}
.mdc-card__primary-action.mdc-ripple-upgraded--unbounded::after {
  top: var(--mdc-ripple-top, 0);
  /* @noflip */
  left: var(--mdc-ripple-left, 0);
}
.mdc-card__primary-action.mdc-ripple-upgraded--foreground-activation::after {
  animation: mdc-ripple-fg-radius-in 225ms forwards, mdc-ripple-fg-opacity-in 75ms forwards;
}
.mdc-card__primary-action.mdc-ripple-upgraded--foreground-deactivation::after {
  animation: mdc-ripple-fg-opacity-out 150ms;
  transform: translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1));
}
.mdc-card__primary-action::before, .mdc-card__primary-action::after {
  top: calc(50% - 100%);
  /* @noflip */
  left: calc(50% - 100%);
  width: 200%;
  height: 200%;
}
.mdc-card__primary-action.mdc-ripple-upgraded::after {
  width: var(--mdc-ripple-fg-size, 100%);
  height: var(--mdc-ripple-fg-size, 100%);
}
.mdc-card__primary-action::before, .mdc-card__primary-action::after {
  background-color: #000;
}
.mdc-card__primary-action:hover::before {
  opacity: 0.04;
}
.mdc-card__primary-action:not(.mdc-ripple-upgraded):focus::before, .mdc-card__primary-action.mdc-ripple-upgraded--background-focused::before {
  transition-duration: 75ms;
  opacity: 0.12;
}
.mdc-card__primary-action:not(.mdc-ripple-upgraded)::after {
  transition: opacity 150ms linear;
}
.mdc-card__primary-action:not(.mdc-ripple-upgraded):active::after {
  transition-duration: 75ms;
  opacity: 0.12;
}
.mdc-card__primary-action.mdc-ripple-upgraded {
  --mdc-ripple-fg-opacity: 0.12;
}

:host {
  display: inline-block;
  width: 344px;
}

.mdc-card {
  height: 100%;
}

.mdc-card__primary-action {
  flex-grow: 1;
}
.mdc-card__primary-action--empty {
  display: none;
}

.mdc-card__actions--empty {
  display: none;
}
.mdc-card__actions ::slotted(*) {
  display: inline-flex;
  flex-direction: row;
  align-items: center;
  box-sizing: border-box;
  justify-content: center;
  cursor: pointer;
  user-select: none;
}
.mdc-card__actions ::slotted(*):focus {
  outline: none;
}
.mdc-card__actions ::slotted(mwc-button) {
  /* @noflip */
  margin-left: 0;
  /* @noflip */
  margin-right: 8px;
}
[dir=rtl] .mdc-card__actions ::slotted(mwc-button), .mdc-card__actions ::slotted(mwc-button)[dir=rtl] {
  /* @noflip */
  margin-left: 8px;
  /* @noflip */
  margin-right: 0;
}
.mdc-card__actions ::slotted(mwc-button):last-child {
  /* @noflip */
  margin-left: 0;
  /* @noflip */
  margin-right: 0;
}
[dir=rtl] .mdc-card__actions ::slotted(mwc-button):last-child, .mdc-card__actions ::slotted(mwc-button):last-child[dir=rtl] {
  /* @noflip */
  margin-left: 0;
  /* @noflip */
  margin-right: 0;
}
.mdc-card__actions ::slotted(mwc-icon-button) {
  margin: -6px 0;
}
.mdc-card__actions ::slotted(mwc-icon-button:not(:disabled)) {
  color: rgba(0, 0, 0, 0.6);
}`;
// EXTERNAL MODULE: ./node_modules/@authentic/mwc-icon/mwc-icon-font.js
var mwc_icon_font = __webpack_require__(231);

// CONCATENATED MODULE: ./node_modules/@authentic/mwc-card/mwc-card.js
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/






let mwc_card_Card = class Card extends lit_element_LitElement {
  constructor() {
    super(...arguments);
    /**
     * Optional. Default value is false. Removes the shadow and displays a hairline outline instead.
     */

    this.outlined = false;
    /**
     * Optional. Define the aspect ratio for the main image, it can be 'square' or '16-9'
     */

    this.aspectRatio = '';
  }

  get headerEls() {
    return this.slotHeaderEl && findAssignedElements(this.slotHeaderEl, '*');
  }

  get mediaEls() {
    return this.slotMediaEl && findAssignedElements(this.slotMediaEl, '*');
  }

  get contentEls() {
    return this.slotContentEl && findAssignedElements(this.slotContentEl, '*');
  }

  get actionButtons() {
    return this.slotActionButtonsEl && findAssignedElements(this.slotActionButtonsEl, 'mwc-button');
  }

  get actionIcons() {
    return this.slotActionIconsEl && findAssignedElements(this.slotActionIconsEl, 'mwc-icon-button');
  }
  /**
   * Used to render the lit-html TemplateResult to the element's DOM
   */


  render() {
    const styles = {
      'mdc-card': true,
      'mdc-card--outlined': this.outlined
    };
    const mediaStyles = {
      'mdc-card__media': true,
      [`mdc-card__media--${this.aspectRatio}`]: this.aspectRatio !== ''
    };
    return lit_html_html`
      <div class="${classMap(styles)}">
        <div class="mdc-card__primary-action" tabindex="0" .ripple="${ripple_directive_ripple({
      unbounded: false
    })}">
          <slot name="header"></slot>
          
          <div class="${classMap(mediaStyles)}">
            <div class="mdc-card__media-content">
              <slot name="media"></slot>
            </div>
          </div>

          <slot name="content"></slot>
        </div>

        <slot></slot>

        <div class="mdc-card__actions">
          <div class="mdc-card__action-buttons">
            <slot name="action-buttons"></slot>
          </div>

          <div class="mdc-card__action-icons">
            <slot name="action-icons"></slot>
          </div>
        </div>
      </div>
    `;
  }
  /**
   * This method is invoked whenever the card is updated
   * @param _changedProperties Map of changed properties with old values
   */


  updated(_changedProperties) {
    super.updated(_changedProperties);

    const _hasHeaderEls = this.headerEls.length > 0;

    const _hasMediaEls = this.mediaEls.length > 0;

    const _hasContentEls = this.contentEls.length > 0;

    const _hasPrimaryAction = _hasHeaderEls || _hasMediaEls || _hasContentEls;

    const _hasActionButtons = this.actionButtons.length > 0;

    const _hasActionIcons = this.actionIcons.length > 0;

    const _hasActions = _hasActionButtons || _hasActionIcons;

    this.primaryActionEl.classList.toggle('mdc-card__primary-action--empty', !_hasPrimaryAction);
    this.actionButtonsEl.classList.toggle('mdc-card__action-buttons--empty', !_hasActionButtons);
    this.actionIconsEl.classList.toggle('mdc-card__action-icons--empty', !_hasActionIcons);
    this.actionsEl.classList.toggle('mdc-card__actions--empty', !_hasActions);
  }

};
mwc_card_Card.styles = mwc_card_css_style;

__decorate([decorators_query('.mdc-card__primary-action')], mwc_card_Card.prototype, "primaryActionEl", void 0);

__decorate([decorators_query('.mdc-card__actions')], mwc_card_Card.prototype, "actionsEl", void 0);

__decorate([decorators_query('.mdc-card__action-buttons')], mwc_card_Card.prototype, "actionButtonsEl", void 0);

__decorate([decorators_query('.mdc-card__action-icons')], mwc_card_Card.prototype, "actionIconsEl", void 0);

__decorate([decorators_query('slot[name="header"]')], mwc_card_Card.prototype, "slotHeaderEl", void 0);

__decorate([decorators_query('slot[name="media"]')], mwc_card_Card.prototype, "slotMediaEl", void 0);

__decorate([decorators_query('slot[name="content"]')], mwc_card_Card.prototype, "slotContentEl", void 0);

__decorate([decorators_query('slot[name="action-buttons"]')], mwc_card_Card.prototype, "slotActionButtonsEl", void 0);

__decorate([decorators_query('slot[name="action-icons"]')], mwc_card_Card.prototype, "slotActionIconsEl", void 0);

__decorate([property({
  type: Boolean
})], mwc_card_Card.prototype, "outlined", void 0);

__decorate([property({
  type: String
})], mwc_card_Card.prototype, "aspectRatio", void 0);

mwc_card_Card = __decorate([customElement("mwc-card")], mwc_card_Card);

// CONCATENATED MODULE: ./node_modules/@material/list/constants.js
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var list_constants_cssClasses = {
  LIST_ITEM_ACTIVATED_CLASS: 'mdc-list-item--activated',
  LIST_ITEM_CLASS: 'mdc-list-item',
  LIST_ITEM_DISABLED_CLASS: 'mdc-list-item--disabled',
  LIST_ITEM_SELECTED_CLASS: 'mdc-list-item--selected',
  ROOT: 'mdc-list'
};
var list_constants_strings = {
  ACTION_EVENT: 'MDCList:action',
  ARIA_CHECKED: 'aria-checked',
  ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
  ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
  ARIA_CURRENT: 'aria-current',
  ARIA_DISABLED: 'aria-disabled',
  ARIA_ORIENTATION: 'aria-orientation',
  ARIA_ORIENTATION_HORIZONTAL: 'horizontal',
  ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
  ARIA_SELECTED: 'aria-selected',
  CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"], input[type="radio"]',
  CHECKBOX_SELECTOR: 'input[type="checkbox"]',
  CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + list_constants_cssClasses.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + list_constants_cssClasses.LIST_ITEM_CLASS + " a\n  ",
  FOCUSABLE_CHILD_ELEMENTS: "\n    ." + list_constants_cssClasses.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + list_constants_cssClasses.LIST_ITEM_CLASS + " a,\n    ." + list_constants_cssClasses.LIST_ITEM_CLASS + " input[type=\"radio\"]:not(:disabled),\n    ." + list_constants_cssClasses.LIST_ITEM_CLASS + " input[type=\"checkbox\"]:not(:disabled)\n  ",
  RADIO_SELECTOR: 'input[type="radio"]'
};
var list_constants_numbers = {
  UNSET_INDEX: -1
};

// CONCATENATED MODULE: ./node_modules/@material/mwc-list/mwc-list-foundation.js
/**
 @license
 Copyright 2020 Google Inc. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */



const findIndexDiff = (oldSet, newSet) => {
  const oldArr = Array.from(oldSet);
  const newArr = Array.from(newSet);
  const diff = {
    added: [],
    removed: []
  };
  const oldSorted = oldArr.sort();
  const newSorted = newArr.sort();
  let i = 0;
  let j = 0;

  while (i < oldSorted.length || j < newSorted.length) {
    const oldVal = oldSorted[i];
    const newVal = newSorted[j];

    if (oldVal === newVal) {
      i++;
      j++;
      continue;
    }

    if (oldVal !== undefined && (newVal === undefined || oldVal < newVal)) {
      diff.removed.push(oldVal);
      i++;
      continue;
    }

    if (newVal !== undefined && (oldVal === undefined || newVal < oldVal)) {
      diff.added.push(newVal);
      j++;
      continue;
    }
  }

  return diff;
};

const ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];
function isIndexSet(selectedIndex) {
  return selectedIndex instanceof Set;
}
function isEventMulti(evt) {
  return isIndexSet(evt.detail.index);
}
const createSetFromIndex = index => {
  const entry = index === list_constants_numbers.UNSET_INDEX ? new Set() : index;
  return isIndexSet(entry) ? new Set(entry) : new Set([entry]);
};
class mwc_list_foundation_MDCListFoundation extends node_modules_material_base_foundation_MDCFoundation_0 {
  constructor(adapter) {
    super(Object.assign(Object.assign({}, mwc_list_foundation_MDCListFoundation.defaultAdapter), adapter));
    this.isMulti_ = false;
    this.wrapFocus_ = false;
    this.isVertical_ = true;
    this.selectedIndex_ = list_constants_numbers.UNSET_INDEX;
    this.focusedItemIndex_ = list_constants_numbers.UNSET_INDEX;
    this.useActivatedClass_ = false;
    this.ariaCurrentAttrValue_ = null;
  }

  static get strings() {
    return list_constants_strings;
  }

  static get numbers() {
    return list_constants_numbers;
  }

  static get defaultAdapter() {
    return {
      focusItemAtIndex: () => undefined,
      getFocusedElementIndex: () => 0,
      getListItemCount: () => 0,
      isFocusInsideList: () => false,
      isRootFocused: () => false,
      notifyAction: () => undefined,
      notifySelected: () => undefined,
      getSelectedStateForElementIndex: () => false,
      setDisabledStateForElementIndex: () => undefined,
      getDisabledStateForElementIndex: () => false,
      setSelectedStateForElementIndex: () => undefined,
      setActivatedStateForElementIndex: () => undefined,
      setTabIndexForElementIndex: () => undefined,
      setAttributeForElementIndex: () => undefined,
      getAttributeForElementIndex: () => null
    };
  }
  /**
   * Sets the private wrapFocus_ variable.
   */


  setWrapFocus(value) {
    this.wrapFocus_ = value;
  }
  /**
   * Sets the private wrapFocus_ variable.
   */


  setMulti(value) {
    this.isMulti_ = value;
  }
  /**
   * Sets the isVertical_ private variable.
   */


  setVerticalOrientation(value) {
    this.isVertical_ = value;
  }
  /**
   * Sets the useActivatedClass_ private variable.
   */


  setUseActivatedClass(useActivated) {
    this.useActivatedClass_ = useActivated;
  }

  getSelectedIndex() {
    return this.selectedIndex_;
  }

  setSelectedIndex(index) {
    if (!this.isIndexValid_(index)) {
      return;
    }

    if (this.isMulti_) {
      this.setMultiSelectionAtIndex_(createSetFromIndex(index));
    } else {
      this.setSingleSelectionAtIndex_(index);
    }
  }
  /**
   * Focus in handler for the list items.
   */


  handleFocusIn(_, listItemIndex) {
    if (listItemIndex >= 0) {
      this.adapter_.setTabIndexForElementIndex(listItemIndex, 0);
    }
  }
  /**
   * Focus out handler for the list items.
   */


  handleFocusOut(_, listItemIndex) {
    if (listItemIndex >= 0) {
      this.adapter_.setTabIndexForElementIndex(listItemIndex, -1);
    }
    /**
     * Between Focusout & Focusin some browsers do not have focus on any
     * element. Setting a delay to wait till the focus is moved to next element.
     */


    setTimeout(() => {
      if (!this.adapter_.isFocusInsideList()) {
        this.setTabindexToFirstSelectedItem_();
      }
    }, 0);
  }
  /**
   * Key handler for the list.
   */


  handleKeydown(evt, isRootListItem, listItemIndex) {
    const isArrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
    const isArrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
    const isArrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
    const isArrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
    const isHome = evt.key === 'Home' || evt.keyCode === 36;
    const isEnd = evt.key === 'End' || evt.keyCode === 35;
    const isEnter = evt.key === 'Enter' || evt.keyCode === 13;
    const isSpace = evt.key === 'Space' || evt.keyCode === 32;

    if (this.adapter_.isRootFocused()) {
      if (isArrowUp || isEnd) {
        evt.preventDefault();
        this.focusLastElement();
      } else if (isArrowDown || isHome) {
        evt.preventDefault();
        this.focusFirstElement();
      }

      return;
    }

    let currentIndex = this.adapter_.getFocusedElementIndex();

    if (currentIndex === -1) {
      currentIndex = listItemIndex;

      if (currentIndex < 0) {
        // If this event doesn't have a mdc-list-item ancestor from the
        // current list (not from a sublist), return early.
        return;
      }
    }

    let nextIndex;

    if (this.isVertical_ && isArrowDown || !this.isVertical_ && isArrowRight) {
      this.preventDefaultEvent_(evt);
      nextIndex = this.focusNextElement(currentIndex);
    } else if (this.isVertical_ && isArrowUp || !this.isVertical_ && isArrowLeft) {
      this.preventDefaultEvent_(evt);
      nextIndex = this.focusPrevElement(currentIndex);
    } else if (isHome) {
      this.preventDefaultEvent_(evt);
      nextIndex = this.focusFirstElement();
    } else if (isEnd) {
      this.preventDefaultEvent_(evt);
      nextIndex = this.focusLastElement();
    } else if (isEnter || isSpace) {
      if (isRootListItem) {
        // Return early if enter key is pressed on anchor element which triggers
        // synthetic MouseEvent event.
        const target = evt.target;

        if (target && target.tagName === 'A' && isEnter) {
          return;
        }

        this.preventDefaultEvent_(evt);
        this.setSelectedIndexOnAction_(currentIndex);
      }
    }

    this.focusedItemIndex_ = currentIndex;

    if (nextIndex !== undefined) {
      this.setTabindexAtIndex_(nextIndex);
      this.focusedItemIndex_ = nextIndex;
    }
  }
  /**
   * Click handler for the list.
   */


  handleSingleSelection(index, force) {
    if (index === list_constants_numbers.UNSET_INDEX) {
      return;
    }

    this.setSelectedIndexOnAction_(index, force);
    this.setTabindexAtIndex_(index);
    this.focusedItemIndex_ = index;
  }
  /**
   * Focuses the next element on the list.
   */


  focusNextElement(index) {
    const count = this.adapter_.getListItemCount();
    let nextIndex = index + 1;

    if (nextIndex >= count) {
      if (this.wrapFocus_) {
        nextIndex = 0;
      } else {
        // Return early because last item is already focused.
        return index;
      }
    }

    this.adapter_.focusItemAtIndex(nextIndex);
    return nextIndex;
  }
  /**
   * Focuses the previous element on the list.
   */


  focusPrevElement(index) {
    let prevIndex = index - 1;

    if (prevIndex < 0) {
      if (this.wrapFocus_) {
        prevIndex = this.adapter_.getListItemCount() - 1;
      } else {
        // Return early because first item is already focused.
        return index;
      }
    }

    this.adapter_.focusItemAtIndex(prevIndex);
    return prevIndex;
  }

  focusFirstElement() {
    this.adapter_.focusItemAtIndex(0);
    return 0;
  }

  focusLastElement() {
    const lastIndex = this.adapter_.getListItemCount() - 1;
    this.adapter_.focusItemAtIndex(lastIndex);
    return lastIndex;
  }
  /**
   * @param itemIndex Index of the list item
   * @param isEnabled Sets the list item to enabled or disabled.
   */


  setEnabled(itemIndex, isEnabled) {
    if (!this.isIndexValid_(itemIndex)) {
      return;
    }

    this.adapter_.setDisabledStateForElementIndex(itemIndex, !isEnabled);
  }
  /**
   * Ensures that preventDefault is only called if the containing element
   * doesn't consume the event, and it will cause an unintended scroll.
   */


  preventDefaultEvent_(evt) {
    const target = evt.target;
    const tagName = `${target.tagName}`.toLowerCase();

    if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
      evt.preventDefault();
    }
  }

  setSingleSelectionAtIndex_(index) {
    if (this.selectedIndex_ === index) {
      return;
    } // unset previous


    if (this.selectedIndex_ !== list_constants_numbers.UNSET_INDEX) {
      this.adapter_.setSelectedStateForElementIndex(this.selectedIndex_, false);

      if (this.useActivatedClass_) {
        this.adapter_.setActivatedStateForElementIndex(this.selectedIndex_, false);
      }
    } // set new


    this.adapter_.setSelectedStateForElementIndex(index, true);

    if (this.useActivatedClass_) {
      this.adapter_.setActivatedStateForElementIndex(index, true);
    }

    this.setAriaForSingleSelectionAtIndex_(index);
    this.selectedIndex_ = index;
    this.adapter_.notifySelected(index);
  }

  setMultiSelectionAtIndex_(newIndex) {
    const oldIndex = createSetFromIndex(this.selectedIndex_);
    const diff = findIndexDiff(oldIndex, newIndex);

    if (!diff.removed.length && !diff.added.length) {
      return;
    }

    for (const removed of diff.removed) {
      this.adapter_.setSelectedStateForElementIndex(removed, false);

      if (this.useActivatedClass_) {
        this.adapter_.setActivatedStateForElementIndex(removed, false);
      }
    }

    for (const added of diff.added) {
      this.adapter_.setSelectedStateForElementIndex(added, true);

      if (this.useActivatedClass_) {
        this.adapter_.setActivatedStateForElementIndex(added, true);
      }
    }

    this.selectedIndex_ = newIndex;
    this.adapter_.notifySelected(newIndex, diff);
  }
  /**
   * Sets aria attribute for single selection at given index.
   */


  setAriaForSingleSelectionAtIndex_(index) {
    // Detect the presence of aria-current and get the value only during list
    // initialization when it is in unset state.
    if (this.selectedIndex_ === list_constants_numbers.UNSET_INDEX) {
      this.ariaCurrentAttrValue_ = this.adapter_.getAttributeForElementIndex(index, list_constants_strings.ARIA_CURRENT);
    }

    const isAriaCurrent = this.ariaCurrentAttrValue_ !== null;
    const ariaAttribute = isAriaCurrent ? list_constants_strings.ARIA_CURRENT : list_constants_strings.ARIA_SELECTED;

    if (this.selectedIndex_ !== list_constants_numbers.UNSET_INDEX) {
      this.adapter_.setAttributeForElementIndex(this.selectedIndex_, ariaAttribute, 'false');
    }

    const ariaAttributeValue = isAriaCurrent ? this.ariaCurrentAttrValue_ : 'true';
    this.adapter_.setAttributeForElementIndex(index, ariaAttribute, ariaAttributeValue);
  }

  setTabindexAtIndex_(index) {
    if (this.focusedItemIndex_ === list_constants_numbers.UNSET_INDEX && index !== 0) {
      // If no list item was selected set first list item's tabindex to -1.
      // Generally, tabindex is set to 0 on first list item of list that has no
      // preselected items.
      this.adapter_.setTabIndexForElementIndex(0, -1);
    } else if (this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {
      this.adapter_.setTabIndexForElementIndex(this.focusedItemIndex_, -1);
    }

    this.adapter_.setTabIndexForElementIndex(index, 0);
  }

  setTabindexToFirstSelectedItem_() {
    let targetIndex = 0;

    if (typeof this.selectedIndex_ === 'number' && this.selectedIndex_ !== list_constants_numbers.UNSET_INDEX) {
      targetIndex = this.selectedIndex_;
    } else if (isIndexSet(this.selectedIndex_) && this.selectedIndex_.size > 0) {
      targetIndex = Math.min(...this.selectedIndex_);
    }

    this.setTabindexAtIndex_(targetIndex);
  }

  isIndexValid_(index) {
    if (index instanceof Set) {
      if (!this.isMulti_) {
        throw new Error('MDCListFoundation: Array of index is only supported for checkbox based list');
      }

      if (index.size === 0) {
        return true;
      } else {
        let isOneInRange = false;

        for (const entry of index) {
          isOneInRange = this.isIndexInRange_(entry);

          if (isOneInRange) {
            break;
          }
        }

        return isOneInRange;
      }
    } else if (typeof index === 'number') {
      if (this.isMulti_) {
        throw new Error('MDCListFoundation: Expected array of index for checkbox based list but got number: ' + index);
      }

      return this.isIndexInRange_(index);
    } else {
      return false;
    }
  }

  isIndexInRange_(index) {
    const listSize = this.adapter_.getListItemCount();
    return index >= 0 && index < listSize;
  }
  /**
   * Sets selected index on user action, toggles checkbox / radio based on
   * toggleCheckbox value. User interaction should not toggle list item(s) when
   * disabled.
   */


  setSelectedIndexOnAction_(index, force) {
    if (this.adapter_.getDisabledStateForElementIndex(index)) {
      return;
    }

    let checkedIndex = index;

    if (this.isMulti_) {
      checkedIndex = new Set([index]);
    }

    if (!this.isIndexValid_(checkedIndex)) {
      return;
    }

    if (this.isMulti_) {
      this.toggleMultiAtIndex(index, force);
    } else {
      this.setSingleSelectionAtIndex_(index);
    }

    this.adapter_.notifyAction(index);
  }

  toggleMultiAtIndex(index, force) {
    let newSelectionValue = false;

    if (force === undefined) {
      newSelectionValue = !this.adapter_.getSelectedStateForElementIndex(index);
    } else {
      newSelectionValue = force;
    }

    const newSet = createSetFromIndex(this.selectedIndex_);

    if (newSelectionValue) {
      newSet.add(index);
    } else {
      newSet.delete(index);
    }

    this.setMultiSelectionAtIndex_(newSet);
  }

} // tslint:disable-next-line:no-default-export Needed for backward compatibility
// with MDC Web v0.44.0 and earlier.

/* harmony default export */ var mwc_list_foundation = (mwc_list_foundation_MDCListFoundation);
// CONCATENATED MODULE: ./node_modules/@material/mwc-list/mwc-list-base.js
/**
@license
Copyright 2020 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/








const isListItem = element => {
  return element.hasAttribute('mwc-list-item');
};
/**
 * @fires selected {SelectedDetail}
 * @fires action {ActionDetail}
 */


class mwc_list_base_ListBase extends base_element_BaseElement {
  constructor() {
    super(...arguments);
    this.mdcAdapter = null;
    this.mdcFoundationClass = mwc_list_foundation;
    this.activatable = false;
    this.multi = false;
    this.wrapFocus = false;
    this.itemRoles = null;
    this.innerRole = null;
    this.rootTabbable = false;
    this.previousTabindex = null;
    this.noninteractive = false;
    this.items_ = [];
  }

  get assignedElements() {
    const slot = this.slotElement;

    if (slot) {
      return slot.assignedNodes({
        flatten: true
      }).filter(isNodeElement);
    }

    return [];
  }

  get items() {
    return this.items_;
  }

  updateItems() {
    const nodes = this.assignedElements;
    const listItems = [];

    for (const node of nodes) {
      if (isListItem(node)) {
        listItems.push(node);
      }

      if (node.hasAttribute('divider') && !node.hasAttribute('role')) {
        node.setAttribute('role', 'separator');
      }
    }

    this.items_ = listItems;
    const selectedIndices = new Set();
    this.items_.forEach((item, index) => {
      if (this.itemRoles) {
        item.setAttribute('role', this.itemRoles);
      } else {
        item.removeAttribute('role');
      }

      if (item.selected) {
        selectedIndices.add(index);
      }
    });

    if (this.multi) {
      this.select(selectedIndices);
    } else {
      const index = selectedIndices.size ? selectedIndices.entries().next().value[1] : -1;
      this.select(index);
    }
  }

  get selected() {
    const index = this.index;

    if (!isIndexSet(index)) {
      if (index === -1) {
        return null;
      }

      return this.items[index];
    }

    const selected = [];

    for (const entry of index) {
      selected.push(this.items[entry]);
    }

    return selected;
  }

  get index() {
    if (this.mdcFoundation) {
      return this.mdcFoundation.getSelectedIndex();
    }

    return -1;
  }

  render() {
    const role = this.innerRole === null ? undefined : this.innerRole;
    const tabindex = this.rootTabbable ? '0' : '-1';
    return lit_html_html`
      <!-- @ts-ignore -->
      <ul
          tabindex=${tabindex}
          role="${ifDefined(role)}"
          class="mdc-list"
          @keydown=${this.onKeydown}
          @focusin=${this.onFocusIn}
          @focusout=${this.onFocusOut}
          @request-selected=${this.onRequestSelected}>
        <slot
            @slotchange=${this.onSlotChange}
            @list-item-rendered=${this.onListItemConnected}>
        </slot>
      </ul>
    `;
  }

  onFocusIn(evt) {
    if (this.mdcFoundation && this.mdcRoot) {
      const index = this.getIndexOfTarget(evt);
      this.mdcFoundation.handleFocusIn(evt, index);
    }
  }

  onFocusOut(evt) {
    if (this.mdcFoundation && this.mdcRoot) {
      const index = this.getIndexOfTarget(evt);
      this.mdcFoundation.handleFocusOut(evt, index);
    }
  }

  onKeydown(evt) {
    if (this.mdcFoundation && this.mdcRoot) {
      const index = this.getIndexOfTarget(evt);
      const target = evt.target;
      const isRootListItem = isListItem(target);
      this.mdcFoundation.handleKeydown(evt, isRootListItem, index);
    }
  }

  onRequestSelected(evt) {
    if (this.mdcFoundation) {
      const index = this.getIndexOfTarget(evt);

      if (index === -1) {
        return;
      }

      const element = this.items[index];

      if (element.disabled) {
        return;
      }

      const selected = evt.detail.selected;
      this.mdcFoundation.handleSingleSelection(index, selected);
      evt.stopPropagation();
    }
  }

  getIndexOfTarget(evt) {
    const elements = this.items;
    const path = evt.composedPath();

    for (const pathItem of path) {
      let index = -1;

      if (isNodeElement(pathItem) && isListItem(pathItem)) {
        index = elements.indexOf(pathItem);
      }

      if (index !== -1) {
        return index;
      }
    }

    return -1;
  }

  createAdapter() {
    this.mdcAdapter = {
      getListItemCount: () => {
        if (this.mdcRoot) {
          return this.items.length;
        }

        return 0;
      },
      getFocusedElementIndex: () => {
        if (!this.mdcRoot) {
          return -1;
        }

        if (!this.items.length) {
          return -1;
        }

        const activeElementPath = deepActiveElementPath();

        if (!activeElementPath.length) {
          return -1;
        }

        for (let i = activeElementPath.length - 1; i >= 0; i--) {
          const activeItem = activeElementPath[i];

          if (isListItem(activeItem)) {
            return this.items.indexOf(activeItem);
          }
        }

        return -1;
      },
      getAttributeForElementIndex: (index, attr) => {
        const listElement = this.mdcRoot;

        if (!listElement) {
          return '';
        }

        const element = this.items[index];
        return element ? element.getAttribute(attr) : '';
      },
      setAttributeForElementIndex: (index, attr, val) => {
        if (!this.mdcRoot) {
          return;
        }

        const element = this.items[index];

        if (element) {
          element.setAttribute(attr, val);
        }
      },
      focusItemAtIndex: index => {
        const element = this.items[index];

        if (element) {
          element.focus();
        }
      },
      setTabIndexForElementIndex: (index, value) => {
        const item = this.items[index];

        if (item) {
          item.tabindex = value;
        }
      },
      notifyAction: index => {
        const init = {
          bubbles: true,
          composed: true
        };
        init.detail = {
          index
        };
        const ev = new CustomEvent('action', init);
        this.dispatchEvent(ev);
      },
      notifySelected: (index, diff) => {
        const init = {
          bubbles: true,
          composed: true
        };
        init.detail = {
          index,
          diff
        };
        const ev = new CustomEvent('selected', init);
        this.dispatchEvent(ev);
      },
      isFocusInsideList: () => {
        return doesElementContainFocus(this);
      },
      isRootFocused: () => {
        const mdcRoot = this.mdcRoot;
        const root = mdcRoot.getRootNode();
        return root.activeElement === mdcRoot;
      },
      setDisabledStateForElementIndex: (index, value) => {
        const item = this.items[index];

        if (!item) {
          return;
        }

        item.disabled = value;
      },
      getDisabledStateForElementIndex: index => {
        const item = this.items[index];

        if (!item) {
          return false;
        }

        return item.disabled;
      },
      setSelectedStateForElementIndex: (index, value) => {
        const item = this.items[index];

        if (!item) {
          return;
        }

        item.selected = value;
      },
      getSelectedStateForElementIndex: index => {
        const item = this.items[index];

        if (!item) {
          return false;
        }

        return item.selected;
      },
      setActivatedStateForElementIndex: (index, value) => {
        const item = this.items[index];

        if (!item) {
          return;
        }

        item.activated = value;
      }
    };
    return this.mdcAdapter;
  }

  selectUi(index, activate = false) {
    const item = this.items[index];

    if (item) {
      item.selected = true;
      item.activated = activate;
    }
  }

  deselectUi(index) {
    const item = this.items[index];

    if (item) {
      item.selected = false;
      item.activated = false;
    }
  }

  select(index) {
    if (!this.mdcFoundation) {
      return;
    }

    this.mdcFoundation.setSelectedIndex(index);
  }

  toggle(index, force) {
    this.mdcFoundation.toggleMultiAtIndex(index, force);
  }

  onSlotChange() {
    this.layout();
  }

  onListItemConnected(e) {
    const target = e.target;
    this.layout(this.items.indexOf(target) === -1);
  }

  layout(updateItems = true) {
    if (updateItems) {
      this.updateItems();
    }

    if (!this.noninteractive) {
      let first = null;

      for (const item of this.items) {
        if (!first && !item.noninteractive) {
          first = item;
        }

        item.tabindex = -1;
      }

      if (first) {
        first.tabindex = 0;
      }
    }
  }

  focus() {
    const root = this.mdcRoot;

    if (root) {
      root.focus();
    }
  }

  blur() {
    const root = this.mdcRoot;

    if (root) {
      root.blur();
    }
  }

}

Object(tslib_es6["c" /* __decorate */])([decorators_query('.mdc-list')], mwc_list_base_ListBase.prototype, "mdcRoot", void 0);

Object(tslib_es6["c" /* __decorate */])([decorators_query('slot')], mwc_list_base_ListBase.prototype, "slotElement", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
}), observer_observer(function (value) {
  if (this.mdcFoundation) {
    this.mdcFoundation.setUseActivatedClass(value);
  }
})], mwc_list_base_ListBase.prototype, "activatable", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
}), observer_observer(function (newValue, oldValue) {
  if (this.mdcFoundation) {
    this.mdcFoundation.setMulti(newValue);
  }

  if (oldValue !== undefined) {
    this.layout();
  }
})], mwc_list_base_ListBase.prototype, "multi", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
}), observer_observer(function (value) {
  if (this.mdcFoundation) {
    this.mdcFoundation.setWrapFocus(value);
  }
})], mwc_list_base_ListBase.prototype, "wrapFocus", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
}), observer_observer(function (_newValue, oldValue) {
  if (oldValue !== undefined) {
    this.updateItems();
  }
})], mwc_list_base_ListBase.prototype, "itemRoles", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
})], mwc_list_base_ListBase.prototype, "innerRole", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_list_base_ListBase.prototype, "rootTabbable", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
}), observer_observer(function (value) {
  const slot = this.slotElement;

  if (value && slot) {
    const tabbable = findAssignedElement(slot, '[tabindex="0"]');
    this.previousTabindex = tabbable;

    if (tabbable) {
      tabbable.setAttribute('tabindex', '-1');
    }
  } else if (!value && this.previousTabindex) {
    this.previousTabindex.setAttribute('tabindex', '0');
    this.previousTabindex = null;
  }
})], mwc_list_base_ListBase.prototype, "noninteractive", void 0);
// CONCATENATED MODULE: ./node_modules/@material/mwc-list/mwc-list-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_list_css_style = css`@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}:host{display:block}.mdc-list{font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:1rem;line-height:1.75rem;font-weight:400;letter-spacing:.009375em;text-decoration:inherit;text-transform:inherit;line-height:1.5rem;margin:0;padding:8px 0;list-style-type:none;color:rgba(0,0,0,.87);color:var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87));padding:var(--mdc-list-vertical-padding, 8px) 0}.mdc-list:focus{outline:none}.mdc-list-item{height:48px}.mdc-list--dense{padding-top:4px;padding-bottom:4px;font-size:.812rem}.mdc-list ::slotted([divider]){height:0;margin:0;border:none;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:rgba(0,0,0,.12)}.mdc-list ::slotted([divider][padded]){margin:0 var(--mdc-list-side-padding, 16px)}.mdc-list ::slotted([divider][inset]){margin-left:var(--mdc-list-inset-margin, 72px);margin-right:0;width:calc(100% - var(--mdc-list-inset-margin, 72px))}.mdc-list-group[dir=rtl] .mdc-list ::slotted([divider][inset]),[dir=rtl] .mdc-list-group .mdc-list ::slotted([divider][inset]){margin-left:0;margin-right:var(--mdc-list-inset-margin, 72px)}.mdc-list ::slotted([divider][inset][padded]){width:calc(100% - var(--mdc-list-inset-margin, 72px) - var(--mdc-list-side-padding, 16px))}.mdc-list--dense ::slotted([mwc-list-item]){height:40px}.mdc-list--dense ::slotted([mwc-list]){--mdc-list-item-graphic-size: 20px}.mdc-list--two-line.mdc-list--dense ::slotted([mwc-list-item]),.mdc-list--avatar-list.mdc-list--dense ::slotted([mwc-list-item]){height:60px}.mdc-list--avatar-list.mdc-list--dense ::slotted([mwc-list]){--mdc-list-item-graphic-size: 36px}:host([noninteractive]){pointer-events:none;cursor:default}.mdc-list--dense ::slotted(.mdc-list-item__primary-text){display:block;margin-top:0;line-height:normal;margin-bottom:-20px}.mdc-list--dense ::slotted(.mdc-list-item__primary-text)::before{display:inline-block;width:0;height:24px;content:"";vertical-align:0}.mdc-list--dense ::slotted(.mdc-list-item__primary-text)::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}`;
// CONCATENATED MODULE: ./node_modules/@material/mwc-list/mwc-list.js
/**
@license
Copyright 2020 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/





let mwc_list_List = class List extends mwc_list_base_ListBase {};
mwc_list_List.styles = mwc_list_css_style;
mwc_list_List = Object(tslib_es6["c" /* __decorate */])([customElement('mwc-list')], mwc_list_List);

// CONCATENATED MODULE: ./node_modules/@material/mwc-list/mwc-list-item-base.js
/**
 @license
 Copyright 2020 Google Inc. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */




/**
 * @fires request-selected {RequestSelectedDetail}
 */

class mwc_list_item_base_ListItemBase extends lit_element_LitElement {
  constructor() {
    super(...arguments);
    this.value = '';
    this.group = null;
    this.tabindex = -1;
    this.disabled = false;
    this.twoline = false;
    this.activated = false;
    this.graphic = null;
    this.hasMeta = false;
    this.noninteractive = false;
    this.selected = false;
    this.boundOnClick = this.onClick.bind(this);
  }

  get text() {
    const textContent = this.textContent;
    return textContent ? textContent.trim() : '';
  }

  render() {
    const text = this.renderText();
    const graphic = this.graphic ? this.renderGraphic() : lit_html_html``;
    const meta = this.hasMeta ? this.renderMeta() : lit_html_html``;
    return lit_html_html`
      ${graphic}
      ${text}
      ${meta}`;
  }

  renderGraphic() {
    return lit_html_html`
      <span class="mdc-list-item__graphic material-icons">
        <slot name="graphic"></slot>
      </span>`;
  }

  renderMeta() {
    return lit_html_html`
      <span class="mdc-list-item__meta material-icons">
        <slot name="meta"></slot>
      </span>`;
  }

  renderText() {
    const inner = this.twoline ? this.renderTwoline() : this.renderSingleLine();
    return lit_html_html`
      <span class="mdc-list-item__text">
        ${inner}
      </span>`;
  }

  renderSingleLine() {
    return lit_html_html`<slot></slot>`;
  }

  renderTwoline() {
    return lit_html_html`
      <span class="mdc-list-item__primary-text">
        <slot></slot>
      </span>
      <span class="mdc-list-item__secondary-text">
        <slot name="secondary"></slot>
      </span>
    `;
  }

  onClick() {
    this.fireRequestDetail(false, !this.selected);
  }

  fireRequestDetail(isClick, selected) {
    const customEv = new CustomEvent('request-selected', {
      bubbles: true,
      composed: true,
      detail: {
        isClick,
        selected
      }
    });
    this.dispatchEvent(customEv);
  }

  connectedCallback() {
    super.connectedCallback();

    if (!this.noninteractive) {
      this.toggleAttribute('mwc-list-item', true);
    }

    this.addEventListener('click', this.boundOnClick);
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener('click', this.boundOnClick);
  }

  firstUpdated() {
    this.dispatchEvent(new Event('list-item-rendered', {
      bubbles: true,
      composed: true
    }));
    rippleNode({
      surfaceNode: this,
      unbounded: false
    });
  }

}

Object(tslib_es6["c" /* __decorate */])([decorators_query('slot')], mwc_list_item_base_ListItemBase.prototype, "slotElement", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
})], mwc_list_item_base_ListItemBase.prototype, "value", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String,
  reflect: true
})], mwc_list_item_base_ListItemBase.prototype, "group", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Number,
  reflect: true
})], mwc_list_item_base_ListItemBase.prototype, "tabindex", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
}), observer_observer(function (value) {
  if (value) {
    this.setAttribute('aria-disabled', 'true');
  } else {
    this.setAttribute('aria-disabled', 'false');
  }
})], mwc_list_item_base_ListItemBase.prototype, "disabled", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
})], mwc_list_item_base_ListItemBase.prototype, "twoline", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
})], mwc_list_item_base_ListItemBase.prototype, "activated", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String,
  reflect: true
})], mwc_list_item_base_ListItemBase.prototype, "graphic", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean
})], mwc_list_item_base_ListItemBase.prototype, "hasMeta", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
}), observer_observer(function (value) {
  if (value) {
    this.removeAttribute('aria-checked');
    this.removeAttribute('mwc-list-item');
    this.selected = false;
    this.activated = false;
    this.tabIndex = -1;
  } else {
    this.toggleAttribute('mwc-list-item', true);
  }
})], mwc_list_item_base_ListItemBase.prototype, "noninteractive", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
}), observer_observer(function (value) {
  if (value) {
    this.setAttribute('aria-selected', 'true');
  } else {
    this.setAttribute('aria-selected', 'false');
  }
})], mwc_list_item_base_ListItemBase.prototype, "selected", void 0);
// CONCATENATED MODULE: ./node_modules/@material/mwc-list/mwc-list-item-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_list_item_css_style = css`:host{cursor:pointer;user-select:none;height:48px;display:flex;position:relative;align-items:center;justify-content:flex-start;padding:0 16px;overflow:hidden;padding-left:var(--mdc-list-side-padding, 16px);padding-right:var(--mdc-list-side-padding, 16px);outline:none;height:48px;color:rgba(0,0,0,.87);color:var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87))}:host:focus{outline:none}:host([activated]){color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}:host([activated]) .mdc-list-item__graphic{color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}.mdc-list-item__graphic{flex-shrink:0;align-items:center;justify-content:center;fill:currentColor;display:inline-flex}.mdc-list-item__graphic ::slotted(*){flex-shrink:0;align-items:center;justify-content:center;fill:currentColor;width:100%;height:100%;text-align:center}.mdc-list-item__meta{width:var(--mdc-list-item-meta-size, 24px);height:var(--mdc-list-item-meta-size, 24px);margin-left:auto;margin-right:0;color:rgba(0,0,0,.38);color:var(--mdc-theme-text-hint-on-background, rgba(0, 0, 0, 0.38))}.mdc-list-item__meta ::slotted(*){line-height:var(--mdc-list-item-meta-size, 24px)}.mdc-list-item__meta ::slotted(.material-icons),.mdc-list-item__meta ::slotted(mwc-icon){line-height:var(--mdc-list-item-meta-size, 24px) !important}.mdc-list-item__meta ::slotted(:not(.material-icons):not(mwc-icon)){font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:.75rem;line-height:1.25rem;font-weight:400;letter-spacing:.0333333333em;text-decoration:inherit;text-transform:inherit}:host[dir=rtl] .mdc-list-item__meta,[dir=rtl] :host .mdc-list-item__meta{margin-left:0;margin-right:auto}.mdc-list-item__meta ::slotted(*){width:100%;height:100%}.mdc-list-item__text{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.mdc-list-item__text ::slotted([for]),.mdc-list-item__text[for]{pointer-events:none}.mdc-list-item__primary-text{text-overflow:ellipsis;white-space:nowrap;overflow:hidden;display:block;margin-top:0;line-height:normal;margin-bottom:-20px;display:block}.mdc-list-item__primary-text::before{display:inline-block;width:0;height:32px;content:"";vertical-align:0}.mdc-list-item__primary-text::after{display:inline-block;width:0;height:20px;content:"";vertical-align:-20px}.mdc-list-item__secondary-text{font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:.875rem;line-height:1.25rem;font-weight:400;letter-spacing:.0178571429em;text-decoration:inherit;text-transform:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;display:block;margin-top:0;line-height:normal;display:block}.mdc-list-item__secondary-text::before{display:inline-block;width:0;height:20px;content:"";vertical-align:0}.mdc-list--dense .mdc-list-item__secondary-text{display:block;margin-top:0;line-height:normal;font-size:inherit}.mdc-list--dense .mdc-list-item__secondary-text::before{display:inline-block;width:0;height:20px;content:"";vertical-align:0}* ::slotted(a),a{color:inherit;text-decoration:none}:host([twoline]){height:72px}:host([twoline]) .mdc-list-item__text{align-self:flex-start}:host(:not([disabled])){--mdc-ripple-fg-size: 0;--mdc-ripple-left: 0;--mdc-ripple-top: 0;--mdc-ripple-fg-scale: 1;--mdc-ripple-fg-translate-end: 0;--mdc-ripple-fg-translate-start: 0;-webkit-tap-highlight-color:rgba(0,0,0,0)}:host(:not([disabled]))::before,:host(:not([disabled]))::after{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:"";top:calc(50% - 100%);left:calc(50% - 100%);width:200%;height:200%}:host(:not([disabled]))::before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1}:host(:not([disabled]))::before,:host(:not([disabled]))::after{background-color:#000}:host(.mdc-ripple-upgraded:not([disabled]))::before{transform:scale(var(--mdc-ripple-fg-scale, 1))}:host(.mdc-ripple-upgraded:not([disabled]))::after{top:0;left:0;transform:scale(0);transform-origin:center center;width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}:host(.mdc-ripple-upgraded--unbounded:not([disabled]))::after{top:var(--mdc-ripple-top, 0);left:var(--mdc-ripple-left, 0)}:host(.mdc-ripple-upgraded--foreground-activation:not([disabled]))::after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}:host(.mdc-ripple-upgraded--foreground-deactivation:not([disabled]))::after{animation:mdc-ripple-fg-opacity-out 150ms;transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}:host([disabled],[noninteractive]){cursor:default;pointer-events:none}:host([disabled]) .mdc-list-item__text ::slotted(*){opacity:.38}:host([disabled]) .mdc-list-item__text ::slotted(*),:host([disabled]) .mdc-list-item__primary-text ::slotted(*),:host([disabled]) .mdc-list-item__secondary-text ::slotted(*){color:#000;color:var(--mdc-theme-on-surface, #000)}:host(:not([disabled]):hover)::before{opacity:.04}:host(:not([disabled]).mdc-ripple-upgraded--background-focused)::before,:host(:not([disabled]):not(.mdc-ripple-upgraded):focus)::before{transition-duration:75ms;opacity:.12}:host(:not([disabled]):not(.mdc-ripple-upgraded))::after{transition:opacity 150ms linear}:host(:not([disabled]):not(.mdc-ripple-upgraded):active)::after{transition-duration:75ms;opacity:.12}:host(:not([disabled]).mdc-ripple-upgraded){--mdc-ripple-fg-opacity: 0.12}:host([activated]:not([disabled]).mdc-ripple-upgraded--background-focused)::before,:host([activated]:not([disabled]):not(.mdc-ripple-upgraded):focus)::before{transition-duration:75ms;opacity:.2}:host([activated]:not([disabled]):not(.mdc-ripple-upgraded):active)::after{opacity:.2}:host([activated]:not([disabled]).mdc-ripple-upgraded){--mdc-ripple-fg-opacity: 0.2}:host([activated]:not([disabled]))::before{opacity:.12}:host([activated]:not([disabled]))::before,:host([activated]:not([disabled]))::after{background-color:#6200ee;background-color:var(--mdc-theme-primary, #6200ee)}:host([activated]:not([disabled]):hover)::before{opacity:.16}:host([activated]:not([disabled]).mdc-ripple-upgraded--background-focused)::before,:host([activated]:not([disabled]):not(.mdc-ripple-upgraded):focus)::before{transition-duration:75ms;opacity:.24}:host([activated]:not([disabled]):not(.mdc-ripple-upgraded):active)::after{opacity:.24}:host([activated]:not([disabled]).mdc-ripple-upgraded){--mdc-ripple-fg-opacity: 0.24}.mdc-list-item__secondary-text ::slotted(*){color:rgba(0,0,0,.54);color:var(--mdc-theme-text-secondary-on-background, rgba(0, 0, 0, 0.54))}.mdc-list-item__graphic ::slotted(*){background-color:transparent;color:rgba(0,0,0,.38);color:var(--mdc-theme-text-icon-on-background, rgba(0, 0, 0, 0.38))}.mdc-list-group__subheader ::slotted(*){color:rgba(0,0,0,.87);color:var(--mdc-theme-text-primary-on-background, rgba(0, 0, 0, 0.87))}:host([graphic=avatar]) .mdc-list-item__graphic{width:var(--mdc-list-item-graphic-size, 40px);height:var(--mdc-list-item-graphic-size, 40px)}:host([graphic=avatar]) .mdc-list-item__graphic ::slotted(*){line-height:var(--mdc-list-item-graphic-size, 40px)}:host([graphic=avatar]) .mdc-list-item__graphic ::slotted(.material-icons),:host([graphic=avatar]) .mdc-list-item__graphic ::slotted(mwc-icon){line-height:var(--mdc-list-item-graphic-size, 40px) !important}:host([graphic=avatar]) .mdc-list-item__graphic ::slotted(*){border-radius:50%}:host([graphic=avatar],[graphic=medium],[graphic=large],[graphic=control]) .mdc-list-item__graphic{margin-left:0;margin-right:var(--mdc-list-item-graphic-margin, 16px)}:host[dir=rtl] :host([graphic=avatar],[graphic=medium],[graphic=large],[graphic=control]) .mdc-list-item__graphic,[dir=rtl] :host :host([graphic=avatar],[graphic=medium],[graphic=large],[graphic=control]) .mdc-list-item__graphic{margin-left:var(--mdc-list-item-graphic-margin, 16px);margin-right:0}:host([graphic=icon]) .mdc-list-item__graphic{width:var(--mdc-list-item-graphic-size, 24px);height:var(--mdc-list-item-graphic-size, 24px);margin-left:0;margin-right:var(--mdc-list-item-graphic-margin, 32px)}:host([graphic=icon]) .mdc-list-item__graphic ::slotted(*){line-height:var(--mdc-list-item-graphic-size, 24px)}:host([graphic=icon]) .mdc-list-item__graphic ::slotted(.material-icons),:host([graphic=icon]) .mdc-list-item__graphic ::slotted(mwc-icon){line-height:var(--mdc-list-item-graphic-size, 24px) !important}:host[dir=rtl] :host([graphic=icon]) .mdc-list-item__graphic,[dir=rtl] :host :host([graphic=icon]) .mdc-list-item__graphic{margin-left:var(--mdc-list-item-graphic-margin, 32px);margin-right:0}:host([graphic=avatar]:not([twoLine])),:host([graphic=icon]:not([twoLine])){height:56px}:host([graphic=medium]:not([twoLine])),:host([graphic=large]:not([twoLine])){height:72px}:host([graphic=medium]) .mdc-list-item__graphic,:host([graphic=large]) .mdc-list-item__graphic{width:var(--mdc-list-item-graphic-size, 56px);height:var(--mdc-list-item-graphic-size, 56px)}:host([graphic=medium]) .mdc-list-item__graphic ::slotted(*),:host([graphic=large]) .mdc-list-item__graphic ::slotted(*){line-height:var(--mdc-list-item-graphic-size, 56px)}:host([graphic=medium]) .mdc-list-item__graphic ::slotted(.material-icons),:host([graphic=medium]) .mdc-list-item__graphic ::slotted(mwc-icon),:host([graphic=large]) .mdc-list-item__graphic ::slotted(.material-icons),:host([graphic=large]) .mdc-list-item__graphic ::slotted(mwc-icon){line-height:var(--mdc-list-item-graphic-size, 56px) !important}:host([graphic=large]){padding-left:0px}`;
// CONCATENATED MODULE: ./node_modules/@material/mwc-list/mwc-list-item.js
/**
@license
Copyright 2020 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




let mwc_list_item_ListItem = class ListItem extends mwc_list_item_base_ListItemBase {};
mwc_list_item_ListItem.styles = mwc_list_item_css_style;
mwc_list_item_ListItem = Object(tslib_es6["c" /* __decorate */])([customElement('mwc-list-item')], mwc_list_item_ListItem);

// CONCATENATED MODULE: ./node_modules/@authentic/mwc-circular-progress/constants.js
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
const mwc_circular_progress_constants_cssClasses = {
  CLOSED_CLASS: 'mwc-circular-progress--closed',
  DETERMINATE_CLASS: 'mwc-circular-progress--determinate',
  DISABLE_SHRINK_CLASS: 'mwc-circular-progress--disable-shrink',
  INDETERMINATE_CLASS: 'mwc-circular-progress--indeterminate',
  FIXED_CLASS: 'mwc-circular-progress--fixed'
};
// CONCATENATED MODULE: ./node_modules/@authentic/mwc-circular-progress/foundation.js
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

class foundation_MDCCircularProgressFoundation {
  constructor(adapter) {
    this.determinate_ = true;
    this.progress_ = 0;
    this.adapter_ = Object.assign({}, foundation_MDCCircularProgressFoundation.defaultAdapter, adapter);
  }

  static get cssClasses() {
    return mwc_circular_progress_constants_cssClasses;
  }

  static get defaultAdapter() {
    return {
      addClass: () =>
      /* className: string */
      {},
      hasClass: () =>
      /* className: string */
      false,
      removeClass: () =>
      /* className: string */
      {},
      setStyle: () =>
      /* el: Element, styleProperty: string, value: string */
      {},
      getElement: () =>
      /* el: Element */
      {},
      getColor: () =>
      /* color: string */
      {}
    };
  }

  init() {
    this.determinate_ = !this.adapter_.hasClass(mwc_circular_progress_constants_cssClasses.INDETERMINATE_CLASS);
    this.color_ = this.adapter_.getColor();
    this.progress_ = 0;
    this.setColor();
  }

  destroy() {}

  setDeterminate(isDeterminate) {
    this.determinate_ = isDeterminate;

    if (this.determinate_) {
      this.adapter_.removeClass(mwc_circular_progress_constants_cssClasses.INDETERMINATE_CLASS);
    } else {
      this.adapter_.addClass(mwc_circular_progress_constants_cssClasses.INDETERMINATE_CLASS);
    }
  }

  setColor(value = this.color_) {
    this.color_ = value;
    this.adapter_.setStyle(this.adapter_.getElement(), 'color', this.color_);
  }

  setProgress(value) {
    this.progress_ = value;
  }

  open() {
    this.adapter_.removeClass(mwc_circular_progress_constants_cssClasses.CLOSED_CLASS);
  }

  close() {
    this.adapter_.addClass(mwc_circular_progress_constants_cssClasses.CLOSED_CLASS);
  }

}
// CONCATENATED MODULE: ./node_modules/@authentic/mwc-circular-progress/mwc-circular-progress-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_circular_progress_css_style = css`/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
@keyframes mwc-circular-progress-rotate {
  100% {
    transform: rotate(360deg) translateZ(0);
  }
}
@keyframes mwc-circular-progress-dash {
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0px;
  }
  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }
  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
}
:host {
  display: block;
}

.mwc-circular-progress {
  line-height: 1;
}
.mwc-circular-progress__bg {
  stroke-dasharray: 0 !important;
  stroke-dashoffset: 0 !important;
  animation: none !important;
}
.mwc-circular-progress--closed {
  display: none;
}
.mwc-circular-progress--primary {
  color: #6200ee;
}
.mwc-circular-progress--secondary {
  color: #018786;
}
.mwc-circular-progress circle {
  stroke: currentColor;
}

.mwc-circular-progress.mwc-circular-progress--fixed {
  transition: transform 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
}
.mwc-circular-progress.mwc-circular-progress--fixed circle {
  transition: stroke-dashoffset 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
}

.mwc-circular-progress.mwc-circular-progress--indeterminate {
  animation: 1.4s linear 0s infinite normal none mwc-circular-progress-rotate;
  animation-play-state: unset;
}
.mwc-circular-progress.mwc-circular-progress--indeterminate circle {
  animation: 1.4s ease-in-out 0s infinite normal none mwc-circular-progress-dash;
  animation-play-state: unset;
  stroke-dasharray: 80px, 200px;
  stroke-dashoffset: 0px;
}

.mwc-circular-progress.mwc-circular-progress--disable-shrink circle {
  animation: none;
}`;
// CONCATENATED MODULE: ./node_modules/@authentic/mwc-circular-progress/mwc-circular-progress.js
var mwc_circular_progress_decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/








const getRelativeValue = (value, min, max) => {
  const clampedValue = Math.min(Math.max(min, value), max);
  return (clampedValue - min) / (max - min);
};
const easeOut = t => {
  t = getRelativeValue(t, 0, 1); // https://gist.github.com/gre/1650294

  t = (t -= 1) * t * t + 1;
  return t;
};
const easeIn = t => {
  return t * t;
};
let mwc_circular_progress_CircularProgress = class CircularProgress extends lit_element_LitElement {
  constructor() {
    super(...arguments);
    this.SIZE = 44;
    /**
     * Optional. Default value sets to false. This property is use to applies the "Theme Secondary" color to the indicator
     */

    this.secondary = false;
    /**
     * A number representing the size of the circle
     */

    this.size = 44;
    /**
     * A number representing thickness of the circle
     */

    this.thickness = 4;
    /**
     * Optional. Default value sets to false. Allows the indicator to be set to a defined state of progress, from 0 to 100%
     */

    this.fixed = false;
    /**
     * Optional. Default value sets to false. It disables the shrink animation of the indicator. This only works if the variant is indeterminate.
     */

    this.disableShrink = false;
    /**
     * Optional. Default value sets to false. Use along with progress property to define how long a process will take
     */

    this.determinate = false;
    /**
     * Optional. Default value is 0. Sets the progress indicator with values between 0 and 100
     */

    this.progress = 0;
    /**
     * Optional. Default value sets to false. Use to hides the circular progress indicator.
     */

    this.closed = false;
  }
  /**
   * Used to render the lit-html TemplateResult to the element's DOM
   */


  render() {
    const {
      fixed,
      determinate,
      closed,
      SIZE,
      thickness,
      disableShrink
    } = this;
    const classes = {
      'mwc-circular-progress': true,
      [mwc_circular_progress_constants_cssClasses.FIXED_CLASS]: fixed,
      [mwc_circular_progress_constants_cssClasses.DETERMINATE_CLASS]: determinate && !fixed,
      [mwc_circular_progress_constants_cssClasses.INDETERMINATE_CLASS]: !determinate && !fixed,
      [mwc_circular_progress_constants_cssClasses.DISABLE_SHRINK_CLASS]: disableShrink,
      [mwc_circular_progress_constants_cssClasses.CLOSED_CLASS]: closed,
      'mwc-circular-progress--primary': !this.secondary && !this.color,
      'mwc-circular-progress--secondary': this.secondary && !this.color
    };
    return lit_html_html`
      <div role="progressbar" class="${classMap(classes)}">
        ${svg`
          <svg viewBox="${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}">
            <circle class="mwc-circular-progress__bg" color="#efefed" cx="${SIZE}" cy="${SIZE}" r="${(SIZE - thickness) / 2}" fill="none" stroke-width="${thickness}" />
            <circle id="progress" cx="${SIZE}" cy="${SIZE}" r="${(SIZE - thickness) / 2}" fill="none" stroke-width="${thickness}" />
          </svg>
        `}
      </div>`;
  }
  /**
   * Create the adapter for the `mdcFoundation`.
   *
   * To extend, spread the super class version into you class:
   * `{...super.createAdapter(), foo() => {}}`
   */


  createAdapter() {
    return {
      addClass: className => {
        this.mdcRoot.classList.add(className);
      },
      removeClass: className => {
        this.mdcRoot.classList.remove(className);
      },
      hasClass: className => {
        return this.mdcRoot.classList.contains(className);
      },
      setStyle: (el, property, value) => {
        if (el) {
          el.style[property] = value;
        }
      },
      getElement: () => {
        return this.mdcRoot;
      },
      getColor: () => {
        return this.color;
      }
    };
  }
  /**
   * Create and attach the MDC Foundation to the instance
   */


  createFoundation() {
    if (this.mdcFoundation) {
      this.mdcFoundation.destroy();
    }

    this.mdcFoundation = new foundation_MDCCircularProgressFoundation(this.createAdapter());
    this.mdcFoundation.init();
  }
  /**
   * Invoked when the element is first updated.
   * Implement to perform one time work on the element after update.
   */


  firstUpdated() {
    this.createFoundation();
  }
  /**
   * This method is invoked whenever the circular-progress is updated
   * @param _changedProperties Map of changed properties with old values
   */


  updated(_changedProperties) {
    super.updated(_changedProperties);
    const {
      fixed,
      determinate,
      SIZE,
      size,
      thickness,
      progress
    } = this;

    if (determinate || fixed) {
      const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
      const strokeDasharray = circumference.toFixed(3);
      const strokeDashoffset = fixed ? `${((100 - progress) / 100 * circumference).toFixed(3)}px` : `${(easeIn((100 - progress) / 100) * circumference).toFixed(3)}px`;
      const transform = fixed ? 'rotate(-90deg)' : `rotate(${(easeOut(progress / 70) * 270).toFixed(3)}deg)`;
      this.mdcRoot.style.transform = transform;
      this.circleEl.style.strokeDasharray = strokeDasharray;
      this.circleEl.style.strokeDashoffset = strokeDashoffset;
    }

    this.mdcRoot.style.width = `${size}px`;
    this.mdcRoot.style.height = `${size}px`;
  }
  /**
   * Puts the component in the open state.
   */


  open() {
    this.closed = false;
  }
  /**
   * Puts the component in the closed state.
   */


  close() {
    this.closed = true;
  }

};
mwc_circular_progress_CircularProgress.styles = mwc_circular_progress_css_style;

mwc_circular_progress_decorate([decorators_query('.mwc-circular-progress')], mwc_circular_progress_CircularProgress.prototype, "mdcRoot", void 0);

mwc_circular_progress_decorate([decorators_query('circle#progress')], mwc_circular_progress_CircularProgress.prototype, "circleEl", void 0);

mwc_circular_progress_decorate([decorators_query('.mdc-circular-progress__bar')], mwc_circular_progress_CircularProgress.prototype, "bar", void 0);

mwc_circular_progress_decorate([property({
  type: String
}), mwc_base_observer_observer(function (value) {
  this.mdcFoundation.setColor(value);
})], mwc_circular_progress_CircularProgress.prototype, "color", void 0);

mwc_circular_progress_decorate([property({
  type: Boolean
})], mwc_circular_progress_CircularProgress.prototype, "secondary", void 0);

mwc_circular_progress_decorate([property({
  type: Number
})], mwc_circular_progress_CircularProgress.prototype, "size", void 0);

mwc_circular_progress_decorate([property({
  type: Number
})], mwc_circular_progress_CircularProgress.prototype, "thickness", void 0);

mwc_circular_progress_decorate([property({
  type: Boolean
})], mwc_circular_progress_CircularProgress.prototype, "fixed", void 0);

mwc_circular_progress_decorate([property({
  type: Boolean
})], mwc_circular_progress_CircularProgress.prototype, "disableShrink", void 0);

mwc_circular_progress_decorate([property({
  type: Boolean,
  reflect: true
}), mwc_base_observer_observer(function (value) {
  this.mdcFoundation.setDeterminate(value || this.fixed);
})], mwc_circular_progress_CircularProgress.prototype, "determinate", void 0);

mwc_circular_progress_decorate([property({
  type: Number
}), mwc_base_observer_observer(function (value) {
  this.mdcFoundation.setProgress(value);

  if (this.determinate) {
    this.setAttribute('aria-valuenow', Math.round(value).toString());
  }
})], mwc_circular_progress_CircularProgress.prototype, "progress", void 0);

mwc_circular_progress_decorate([property({
  type: Boolean,
  reflect: true
}), mwc_base_observer_observer(function (value) {
  if (value) {
    this.mdcFoundation.close();
  } else {
    this.mdcFoundation.open();
  }
})], mwc_circular_progress_CircularProgress.prototype, "closed", void 0);

mwc_circular_progress_CircularProgress = mwc_circular_progress_decorate([customElement('mwc-circular-progress')], mwc_circular_progress_CircularProgress);

// CONCATENATED MODULE: ./src/components/leap-courses-list.js









class leap_courses_list_LeapCoursesList extends lit_element_LitElement {
  static get properties() {
    return {
      filter: {
        type: String
      },
      courses: {
        type: Array
      }
    };
  }

  static get styles() {
    return sharedStyles;
  }

  async firstUpdated() {
    this.loadCourses();
  }

  async loadCourses() {
    this.courses = undefined;
    const client = await getClient();
    const result = await client.query({
      query: GET_COURSES,
      variables: {
        filter: this.filter || 'all'
      }
    });
    this.courses = result.data.courses;

    if (this.courses.length > 0) {
      this.selectedCourseId = this.courses[0].id;
    }
  }

  updated(changedValues) {
    super.updated(changedValues);

    if (changedValues.get('filter')) {
      this.loadCourses();
    }
  }

  render() {
    if (!this.courses) return lit_html_html`
        <div class="fill center-content" style="align-self: center;">
          <mwc-circular-progress></mwc-circular-progress>
        </div>
      `;
    if (this.courses.length === 0) return lit_html_html`
        <div class="fill center-content" style="align-self: center;">
          <leap-empty-placeholder
            message="There are no courses in this category"
          ></leap-empty-placeholder>
        </div>
      `;
    return lit_html_html`
      <mwc-list style="flex: 1;">
        ${this.courses.map(course => lit_html_html`
            <mwc-list-item
              @click=${() => router.navigate(`course/${course.id}`)}
            >
              <span>${course.title}</span>
            </mwc-list-item>
          `)}
      </mwc-list>
    `;
  }

}
// CONCATENATED MODULE: ./node_modules/@material/mwc-icon-button/mwc-icon-button-base.js

/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/



class mwc_icon_button_base_IconButtonBase extends lit_element_LitElement {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.icon = '';
    this.label = '';
  }

  render() {
    return lit_html_html`<button
    .ripple="${ripple()}"
    class="mdc-icon-button"
    aria-label="${this.label || this.icon}"
    ?disabled="${this.disabled}">
    <i class="material-icons">${this.icon}</i>
    <slot></slot>
  </button>`;
  }

}

Object(tslib_es6["c" /* __decorate */])([property({
  type: Boolean,
  reflect: true
})], mwc_icon_button_base_IconButtonBase.prototype, "disabled", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
})], mwc_icon_button_base_IconButtonBase.prototype, "icon", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: String
})], mwc_icon_button_base_IconButtonBase.prototype, "label", void 0);
// CONCATENATED MODULE: ./node_modules/@material/mwc-icon-button/mwc-icon-button-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_icon_button_css_style = css`.mdc-icon-button{display:inline-block;position:relative;box-sizing:border-box;border:none;outline:none;background-color:transparent;fill:currentColor;color:inherit;font-size:24px;text-decoration:none;cursor:pointer;user-select:none;width:48px;height:48px;padding:12px}.mdc-icon-button svg,.mdc-icon-button img{width:24px;height:24px}.mdc-icon-button:disabled{color:rgba(0,0,0,.38);color:var(--mdc-theme-text-disabled-on-light, rgba(0, 0, 0, 0.38))}.mdc-icon-button:disabled{cursor:default;pointer-events:none}.mdc-icon-button__icon{display:inline-block}.mdc-icon-button__icon.mdc-icon-button__icon--on{display:none}.mdc-icon-button--on .mdc-icon-button__icon{display:none}.mdc-icon-button--on .mdc-icon-button__icon.mdc-icon-button__icon--on{display:inline-block}@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}.mdc-icon-button{--mdc-ripple-fg-size: 0;--mdc-ripple-left: 0;--mdc-ripple-top: 0;--mdc-ripple-fg-scale: 1;--mdc-ripple-fg-translate-end: 0;--mdc-ripple-fg-translate-start: 0;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mdc-icon-button::before,.mdc-icon-button::after{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:""}.mdc-icon-button::before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1}.mdc-icon-button.mdc-ripple-upgraded::before{transform:scale(var(--mdc-ripple-fg-scale, 1))}.mdc-icon-button.mdc-ripple-upgraded::after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-icon-button.mdc-ripple-upgraded--unbounded::after{top:var(--mdc-ripple-top, 0);left:var(--mdc-ripple-left, 0)}.mdc-icon-button.mdc-ripple-upgraded--foreground-activation::after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-icon-button.mdc-ripple-upgraded--foreground-deactivation::after{animation:mdc-ripple-fg-opacity-out 150ms;transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}.mdc-icon-button::before,.mdc-icon-button::after{top:calc(50% - 50%);left:calc(50% - 50%);width:100%;height:100%}.mdc-icon-button.mdc-ripple-upgraded::before,.mdc-icon-button.mdc-ripple-upgraded::after{top:var(--mdc-ripple-top, calc(50% - 50%));left:var(--mdc-ripple-left, calc(50% - 50%));width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-icon-button.mdc-ripple-upgraded::after{width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-icon-button::before,.mdc-icon-button::after{background-color:#000}.mdc-icon-button:hover::before{opacity:.04}.mdc-icon-button.mdc-ripple-upgraded--background-focused::before,.mdc-icon-button:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:.12}.mdc-icon-button:not(.mdc-ripple-upgraded)::after{transition:opacity 150ms linear}.mdc-icon-button:not(.mdc-ripple-upgraded):active::after{transition-duration:75ms;opacity:.12}.mdc-icon-button.mdc-ripple-upgraded{--mdc-ripple-fg-opacity: 0.12}.material-icons{font-family:var(--mdc-icon-font, "Material Icons");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:"liga"}:host{display:inline-block;outline:none}:host,.mdc-icon-button{vertical-align:top}.mdc-icon-button{width:var(--mdc-icon-button-size, 48px);height:var(--mdc-icon-button-size, 48px);padding:calc((var(--mdc-icon-button-size, 48px) - var(--mdc-icon-size, 24px)) / 2)}.mdc-icon-button>i{position:absolute;top:0;padding-top:inherit}.mdc-icon-button i,.mdc-icon-button svg,.mdc-icon-button img,.mdc-icon-button ::slotted(*){display:block;width:var(--mdc-icon-size, 24px);height:var(--mdc-icon-size, 24px)}.mdc-ripple-upgraded:focus::before,.mdc-ripple-upgraded:focus::after{background-color:currentColor;background-color:var(--mdc-theme-on-primary, currentColor);opacity:.12;opacity:var(--mdc-icon-button-ripple-opacity, 0.12)}`;
// CONCATENATED MODULE: ./node_modules/@material/mwc-icon-button/mwc-icon-button.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




let mwc_icon_button_IconButton = class IconButton extends mwc_icon_button_base_IconButtonBase {};
mwc_icon_button_IconButton.styles = mwc_icon_button_css_style;
mwc_icon_button_IconButton = Object(tslib_es6["c" /* __decorate */])([customElement('mwc-icon-button')], mwc_icon_button_IconButton);

// CONCATENATED MODULE: ./src/components/leap-course-detail.js








class leap_course_detail_LeapCourseDetail extends lit_element_LitElement {
  static get properties() {
    return {
      courseId: {
        type: String
      },
      course: {
        type: Object
      }
    };
  }

  static get styles() {
    return [sharedStyles, css`
        .fab {
          position: absolute;
          bottom: 16px;
          right: 16px;
        }
      `];
  }

  async loadCourse() {
    this.course = undefined;
    const client = await getClient();
    const result = await client.query({
      query: GET_COURSE_INFO,
      variables: {
        courseId: this.courseId
      }
    });
    this.course = result.data.course;
    this.myAddress = result.data.myAddress;
  }

  firstUpdated() {
    this.loadCourse();
  }

  updated(changedValues) {
    super.updated(changedValues);

    if (changedValues.get('courseId')) {
      this.loadCourse();
    }
  }

  async createModule() {
    const client = await getClient();
    const result = await client.mutate({
      mutation: CREATE_MODULE,
      variables: {
        courseId: this.courseId,
        title: this.moduleTitle
      },
      refetchQueries: [{
        query: GET_COURSE_INFO,
        variables: {
          courseId: this.courseId
        }
      }]
    });
    window.location.reload();
  }

  renderCreateModuleDialog() {
    return lit_html_html`
      <mwc-dialog id="create-module-dialog" heading="Create module">
        <mwc-textfield
          style="margin-top: 16px;"
          outlined
          label="Title"
          dialogInitialFocus
          @input=${e => this.moduleTitle = e.target.value}
        >
        </mwc-textfield>

        <mwc-button
          slot="primaryAction"
          dialogAction="create"
          @click=${() => this.createModule()}
        >
          Create
        </mwc-button>
        <mwc-button slot="secondaryAction" dialogAction="cancel">
          Cancel
        </mwc-button>
      </mwc-dialog>
    `;
  }

  renderModules() {
    if (this.course.modules.length === 0) return lit_html_html`
        <leap-empty-placeholder
          message="There are no modules in this course"
        ></leap-empty-placeholder>
      `;
    return lit_html_html`
      <div class="column">
        ${this.course.modules.map(module => lit_html_html`
              <leap-module
                .module=${module}
                .editable=${this.userIsTeacher()}
                style="padding-bottom: 24px;"
              ></leap-module>
            `)}
      </div>
    `;
  }

  userIsTeacher() {
    return this.myAddress === this.course.teacher_address;
  }

  async enrolInCourse() {
    const client = await getClient();
    await client.mutate({
      mutation: ENROL_IN_COURSE,
      variables: {
        courseId: this.courseId
      }
    });
    router.navigate('/home');
  }

  async deleteCourse() {
    const client = await getClient();
    await client.mutate({
      mutation: DELETE_COURSE,
      variables: {
        courseId: this.courseId
      }
    });
    router.navigate('/home');
  }

  renderCourseInfo() {
    return lit_html_html`
      <mwc-card class="fill">
        <div class="row center-content" style="padding: 24px;">
          <div class="column fill">
            <span class="title" style="padding-bottom: 16px;"
              >${this.course.title}</span
            >
            <span>Taught by ${this.course.teacher_address}</span>
          </div>

          ${this.userIsTeacher() ? lit_html_html`
                <div class="column">
                  <mwc-button
                    icon="add"
                    label="Add module"
                    raised
                    style="padding-bottom: 8px;"
                    @click=${() => this.shadowRoot.getElementById('create-module-dialog').open = true}
                  ></mwc-button>

                  <mwc-button
                    icon="delete"
                    label="Delete course"
                    outlined
                    class="danger"
                    @click=${() => this.deleteCourse()}
                  ></mwc-button>
                </div>
              ` : lit_html_html`
                <mwc-button
                  icon="school"
                  label="Enrol in this course"
                  outlined
                  @click=${() => this.enrolInCourse()}
                ></mwc-button>
              `}
        </div>
      </mwc-card>
    `;
  }

  renderStudentsList() {
    if (this.course.students.length === 0) return lit_html_html`
        <leap-empty-placeholder
          message="There are no students enrolled in this course"
        ></leap-empty-placeholder>
      `;
    return lit_html_html`
      <mwc-list>
        ${this.course.students.map(student => lit_html_html`
            <span>
              ${student}
            </span>
          `)}
      </mwc-list>
    `;
  }

  render() {
    if (!this.course) return lit_html_html`
        <div class="column fill center-content" style="position: relative;">
          <mwc-circular-progress></mwc-circular-progress>
        </div>
      `;
    return lit_html_html`
      ${this.renderCreateModuleDialog()}

      <div class="column">
        <mwc-top-app-bar>
          <mwc-icon-button
            icon="arrow_back"
            slot="navigationIcon"
            @click=${() => router.navigate('/home')}
          ></mwc-icon-button>
          <div slot="title">${this.course.title}</div>
        </mwc-top-app-bar>

        <div
          class="column"
          style="position: relative; padding: 16px; width: 1000px; align-self: center;"
        >
          ${this.renderCourseInfo()}

          <div class="row">
            <div class="column" style="flex: 3; padding-right: 24px;">
              <h3>Modules</h3>
              ${this.renderModules()}
            </div>

            <div class="column" style="flex: 1;">
              <h3>Students</h3>
              ${this.renderStudentsList()}
            </div>
          </div>
        </div>
      </div>
    `;
  }

}
// CONCATENATED MODULE: ./node_modules/@material/mwc-textarea/mwc-textarea-base.js
/**
@license
Copyright 2019 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/





class mwc_textarea_base_TextAreaBase extends mwc_textfield_base_TextFieldBase {
  constructor() {
    super(...arguments);
    this.rows = 2;
    this.cols = 20;
  }

  get shouldRenderHelperText() {
    return !!this.helper || !!this.validationMessage;
  }

  render() {
    const classes = {
      'mdc-text-field--disabled': this.disabled,
      'mdc-text-field--no-label': !this.label,
      'mdc-text-field--outlined': this.outlined,
      'mdc-text-field--fullwidth': this.fullWidth,
      'mdc-text-field--end-aligned': this.endAligned
    };
    return lit_html_html`
      <label class="mdc-text-field mdc-text-field--textarea ${classMap(classes)}">
        ${this.renderCharCounter()}
        ${this.renderInput()}
        ${this.outlined ? this.renderOutlined() : this.renderLabelText()}
      </label>
      ${this.renderHelperText()}
    `;
  }

  renderInput() {
    const maxOrUndef = this.maxLength === -1 ? undefined : this.maxLength;
    return lit_html_html`
      <textarea
          aria-labelledby="label"
          class="mdc-text-field__input"
          .value="${this.value}"
          rows="${this.rows}"
          cols="${this.cols}"
          ?disabled="${this.disabled}"
          placeholder="${this.placeholder}"
          ?required="${this.required}"
          maxlength="${ifDefined(maxOrUndef)}"
          @input="${this.handleInputChange}"
          @blur="${this.onInputBlur}">
      </textarea>`;
  }

}

Object(tslib_es6["c" /* __decorate */])([decorators_query('textarea')], mwc_textarea_base_TextAreaBase.prototype, "formElement", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Number
})], mwc_textarea_base_TextAreaBase.prototype, "rows", void 0);

Object(tslib_es6["c" /* __decorate */])([property({
  type: Number
})], mwc_textarea_base_TextAreaBase.prototype, "cols", void 0);
// CONCATENATED MODULE: ./node_modules/@material/mwc-textarea/mwc-textarea-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_textarea_css_style = css`.mdc-floating-label{font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:1rem;font-weight:400;letter-spacing:.009375em;text-decoration:inherit;text-transform:inherit;position:absolute;left:0;transform-origin:left top;line-height:1.15rem;text-align:left;text-overflow:ellipsis;white-space:nowrap;cursor:text;overflow:hidden;will-change:transform;transition:transform 150ms cubic-bezier(0.4, 0, 0.2, 1),color 150ms cubic-bezier(0.4, 0, 0.2, 1)}[dir=rtl] .mdc-floating-label,.mdc-floating-label[dir=rtl]{right:0;left:auto;transform-origin:right top;text-align:right}.mdc-floating-label--float-above{cursor:auto}.mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-standard 250ms 1}@keyframes mdc-floating-label-shake-float-above-standard{0%{transform:translateX(calc(0 - 0%)) translateY(-106%) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-106%) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-106%) scale(0.75)}100%{transform:translateX(calc(0 - 0%)) translateY(-106%) scale(0.75)}}.mdc-line-ripple{position:absolute;bottom:0;left:0;width:100%;height:2px;transform:scaleX(0);opacity:0;z-index:2;transition:transform 180ms cubic-bezier(0.4, 0, 0.2, 1),opacity 180ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-line-ripple--active{transform:scaleX(1);opacity:1}.mdc-line-ripple--deactivating{opacity:0}.mdc-notched-outline{display:flex;position:absolute;right:0;left:0;box-sizing:border-box;width:100%;max-width:100%;height:100%;text-align:left;pointer-events:none}[dir=rtl] .mdc-notched-outline,.mdc-notched-outline[dir=rtl]{text-align:right}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{box-sizing:border-box;height:100%;border-top:1px solid;border-bottom:1px solid;pointer-events:none}.mdc-notched-outline__leading{border-left:1px solid;border-right:none;width:12px}[dir=rtl] .mdc-notched-outline__leading,.mdc-notched-outline__leading[dir=rtl]{border-left:none;border-right:1px solid}.mdc-notched-outline__trailing{border-left:none;border-right:1px solid;flex-grow:1}[dir=rtl] .mdc-notched-outline__trailing,.mdc-notched-outline__trailing[dir=rtl]{border-left:1px solid;border-right:none}.mdc-notched-outline__notch{flex:0 0 auto;width:auto;max-width:calc(100% - 12px * 2)}.mdc-notched-outline .mdc-floating-label{display:inline-block;position:relative;max-width:100%}.mdc-notched-outline .mdc-floating-label--float-above{text-overflow:clip}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:calc(100% / .75)}.mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:0;padding-right:8px;border-top:none}[dir=rtl] .mdc-notched-outline--notched .mdc-notched-outline__notch,.mdc-notched-outline--notched .mdc-notched-outline__notch[dir=rtl]{padding-left:8px;padding-right:0}.mdc-notched-outline--no-label .mdc-notched-outline__notch{padding:0}.mdc-text-field-helper-text{font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:.75rem;line-height:1.25rem;font-weight:400;letter-spacing:.0333333333em;text-decoration:inherit;text-transform:inherit;display:block;margin-top:0;line-height:normal;margin:0;opacity:0;will-change:opacity;transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-text-field-helper-text::before{display:inline-block;width:0;height:16px;content:"";vertical-align:0}.mdc-text-field-helper-text--persistent{transition:none;opacity:1;will-change:initial}.mdc-text-field-character-counter{font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:.75rem;line-height:1.25rem;font-weight:400;letter-spacing:.0333333333em;text-decoration:inherit;text-transform:inherit;display:block;margin-top:0;line-height:normal;margin-left:auto;margin-right:0;padding-left:16px;padding-right:0;white-space:nowrap}.mdc-text-field-character-counter::before{display:inline-block;width:0;height:16px;content:"";vertical-align:0}[dir=rtl] .mdc-text-field-character-counter,.mdc-text-field-character-counter[dir=rtl]{margin-left:0;margin-right:auto}[dir=rtl] .mdc-text-field-character-counter,.mdc-text-field-character-counter[dir=rtl]{padding-left:0;padding-right:16px}.mdc-text-field__icon{position:absolute;top:50%;transform:translateY(-50%);cursor:pointer}.mdc-text-field__icon:not([tabindex]),.mdc-text-field__icon[tabindex="-1"]{cursor:default;pointer-events:none}@keyframes mdc-ripple-fg-radius-in{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:translate(var(--mdc-ripple-fg-translate-start, 0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}}@keyframes mdc-ripple-fg-opacity-in{from{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity, 0)}}@keyframes mdc-ripple-fg-opacity-out{from{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity, 0)}to{opacity:0}}.mdc-text-field{--mdc-ripple-fg-size: 0;--mdc-ripple-left: 0;--mdc-ripple-top: 0;--mdc-ripple-fg-scale: 1;--mdc-ripple-fg-translate-end: 0;--mdc-ripple-fg-translate-start: 0;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mdc-text-field::before,.mdc-text-field::after{position:absolute;border-radius:50%;opacity:0;pointer-events:none;content:""}.mdc-text-field::before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1}.mdc-text-field.mdc-ripple-upgraded::before{transform:scale(var(--mdc-ripple-fg-scale, 1))}.mdc-text-field.mdc-ripple-upgraded::after{top:0;left:0;transform:scale(0);transform-origin:center center}.mdc-text-field.mdc-ripple-upgraded--unbounded::after{top:var(--mdc-ripple-top, 0);left:var(--mdc-ripple-left, 0)}.mdc-text-field.mdc-ripple-upgraded--foreground-activation::after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-text-field.mdc-ripple-upgraded--foreground-deactivation::after{animation:mdc-ripple-fg-opacity-out 150ms;transform:translate(var(--mdc-ripple-fg-translate-end, 0)) scale(var(--mdc-ripple-fg-scale, 1))}.mdc-text-field::before,.mdc-text-field::after{top:calc(50% - 100%);left:calc(50% - 100%);width:200%;height:200%}.mdc-text-field.mdc-ripple-upgraded::after{width:var(--mdc-ripple-fg-size, 100%);height:var(--mdc-ripple-fg-size, 100%)}.mdc-text-field{height:56px;border-radius:4px 4px 0 0;display:inline-flex;position:relative;box-sizing:border-box;overflow:hidden;will-change:opacity,transform,color}.mdc-text-field::before,.mdc-text-field::after{background-color:rgba(0,0,0,.87)}.mdc-text-field:hover::before{opacity:.04}.mdc-text-field.mdc-ripple-upgraded--background-focused::before,.mdc-text-field:not(.mdc-ripple-upgraded):focus::before{transition-duration:75ms;opacity:.12}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-floating-label{color:rgba(0,0,0,.6)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input{color:rgba(0,0,0,.87)}@media all{.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:rgba(0,0,0,.54)}}@media all{.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:rgba(0,0,0,.54)}}.mdc-text-field .mdc-text-field__input{caret-color:#6200ee;caret-color:var(--mdc-theme-primary, #6200ee)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input{border-bottom-color:rgba(0,0,0,.42)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input:hover{border-bottom-color:rgba(0,0,0,.87)}.mdc-text-field .mdc-line-ripple{background-color:#6200ee;background-color:var(--mdc-theme-primary, #6200ee)}.mdc-text-field:not(.mdc-text-field--disabled)+.mdc-text-field-helper-line .mdc-text-field-helper-text{color:rgba(0,0,0,.6)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field-character-counter,.mdc-text-field:not(.mdc-text-field--disabled)+.mdc-text-field-helper-line .mdc-text-field-character-counter{color:rgba(0,0,0,.6)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__icon--leading{color:rgba(0,0,0,.54)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__icon--trailing{color:rgba(0,0,0,.54)}.mdc-text-field:not(.mdc-text-field--disabled){background-color:#f5f5f5}.mdc-text-field .mdc-floating-label{left:16px;right:initial;top:50%;transform:translateY(-50%);pointer-events:none}[dir=rtl] .mdc-text-field .mdc-floating-label,.mdc-text-field .mdc-floating-label[dir=rtl]{left:initial;right:16px}.mdc-text-field .mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-text-field--textarea .mdc-floating-label{left:4px;right:initial}[dir=rtl] .mdc-text-field--textarea .mdc-floating-label,.mdc-text-field--textarea .mdc-floating-label[dir=rtl]{left:initial;right:4px}.mdc-text-field--outlined .mdc-floating-label{left:4px;right:initial}[dir=rtl] .mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:4px}.mdc-text-field--outlined--with-leading-icon .mdc-floating-label{left:36px;right:initial}[dir=rtl] .mdc-text-field--outlined--with-leading-icon .mdc-floating-label,.mdc-text-field--outlined--with-leading-icon .mdc-floating-label[dir=rtl]{left:initial;right:36px}.mdc-text-field--outlined--with-leading-icon .mdc-floating-label--float-above{left:40px;right:initial}[dir=rtl] .mdc-text-field--outlined--with-leading-icon .mdc-floating-label--float-above,.mdc-text-field--outlined--with-leading-icon .mdc-floating-label--float-above[dir=rtl]{left:initial;right:40px}.mdc-text-field__input{font-family:Roboto, sans-serif;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-size:1rem;font-weight:400;letter-spacing:.009375em;text-decoration:inherit;text-transform:inherit;align-self:flex-end;box-sizing:border-box;width:100%;height:100%;padding:20px 16px 6px;border:none;border-bottom:1px solid;border-radius:0;background:none;appearance:none;transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-text-field__input::placeholder{transition:opacity 67ms cubic-bezier(0.4, 0, 0.2, 1);opacity:0}.mdc-text-field--fullwidth .mdc-text-field__input::placeholder,.mdc-text-field--no-label .mdc-text-field__input::placeholder,.mdc-text-field--focused .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms;opacity:1}.mdc-text-field__input:focus{outline:none}.mdc-text-field__input:invalid{box-shadow:none}.mdc-text-field__input:-webkit-autofill{z-index:auto !important}.mdc-text-field--no-label:not(.mdc-text-field--outlined):not(.mdc-text-field--textarea) .mdc-text-field__input{padding-top:16px;padding-bottom:16px}.mdc-text-field__input:-webkit-autofill+.mdc-floating-label{transform:translateY(-50%) scale(0.75);cursor:auto}.mdc-text-field--outlined{border:none;overflow:visible}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.38)}.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.87)}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:#6200ee;border-color:var(--mdc-theme-primary, #6200ee)}.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined 250ms 1}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-radius:4px 0 0 4px}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl]{border-radius:0 4px 4px 0}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-radius:0 4px 4px 0}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl]{border-radius:4px 0 0 4px}.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) scale(1)}.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) scale(0.75)}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:1px}.mdc-text-field--outlined::before,.mdc-text-field--outlined::after{content:none}.mdc-text-field--outlined:not(.mdc-text-field--disabled){background-color:transparent}.mdc-text-field--outlined .mdc-text-field__input{display:flex;padding:12px 16px 14px;border:none !important;background-color:transparent;z-index:1}.mdc-text-field--outlined .mdc-text-field__icon{z-index:2}.mdc-text-field--outlined.mdc-text-field--focused .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:2px}.mdc-text-field--outlined.mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--focused .mdc-notched-outline__trailing{border-width:2px}.mdc-text-field--outlined.mdc-text-field--disabled{background-color:transparent}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.06)}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-text-field__input{border-bottom:none}.mdc-text-field--outlined.mdc-text-field--dense{height:48px}.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--float-above{transform:translateY(-134%) scale(1)}.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--float-above{font-size:.8rem}.mdc-text-field--outlined.mdc-text-field--dense.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined.mdc-text-field--dense .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-120%) scale(0.8)}.mdc-text-field--outlined.mdc-text-field--dense.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined.mdc-text-field--dense .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-dense 250ms 1}.mdc-text-field--outlined.mdc-text-field--dense .mdc-text-field__input{padding:12px 12px 7px}.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label{top:14px}.mdc-text-field--outlined.mdc-text-field--dense .mdc-text-field__icon{top:12px}.mdc-text-field--with-leading-icon .mdc-text-field__icon--leading{left:16px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon .mdc-text-field__icon--leading,.mdc-text-field--with-leading-icon .mdc-text-field__icon--leading[dir=rtl]{left:initial;right:16px}.mdc-text-field--with-leading-icon .mdc-text-field__input{padding-left:48px;padding-right:16px}[dir=rtl] .mdc-text-field--with-leading-icon .mdc-text-field__input,.mdc-text-field--with-leading-icon .mdc-text-field__input[dir=rtl]{padding-left:16px;padding-right:48px}.mdc-text-field--with-leading-icon .mdc-floating-label{left:48px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon .mdc-floating-label,.mdc-text-field--with-leading-icon .mdc-floating-label[dir=rtl]{left:initial;right:48px}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-text-field__icon--leading{left:16px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-text-field__icon--leading,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-text-field__icon--leading[dir=rtl]{left:initial;right:16px}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) translateX(-32px) scale(1)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-37.25px) translateX(32px) scale(1)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) translateX(-32px) scale(0.75)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-34.75px) translateX(32px) scale(0.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon 250ms 1}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake,.mdc-text-field--with-leading-icon.mdc-text-field--outlined[dir=rtl] .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-rtl 250ms 1}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label{left:36px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:36px}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--float-above{transform:translateY(-134%) translateX(-21px) scale(1)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-134%) translateX(21px) scale(1)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--float-above{font-size:.8rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-120%) translateX(-21px) scale(0.8)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense.mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-120%) translateX(21px) scale(0.8)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-dense 250ms 1}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label--shake,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense[dir=rtl] .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-dense-rtl 250ms 1}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label{left:32px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-text-field--dense .mdc-floating-label[dir=rtl]{left:initial;right:32px}.mdc-text-field--with-trailing-icon .mdc-text-field__icon--trailing{left:initial;right:12px}[dir=rtl] .mdc-text-field--with-trailing-icon .mdc-text-field__icon--trailing,.mdc-text-field--with-trailing-icon .mdc-text-field__icon--trailing[dir=rtl]{left:12px;right:initial}.mdc-text-field--with-trailing-icon .mdc-text-field__input{padding-left:16px;padding-right:48px}[dir=rtl] .mdc-text-field--with-trailing-icon .mdc-text-field__input,.mdc-text-field--with-trailing-icon .mdc-text-field__input[dir=rtl]{padding-left:48px;padding-right:16px}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon .mdc-text-field__icon--leading{left:16px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon .mdc-text-field__icon--leading,.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon .mdc-text-field__icon--leading[dir=rtl]{left:initial;right:16px}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon .mdc-text-field__icon--trailing{left:initial;right:12px}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon .mdc-text-field__icon--trailing,.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon .mdc-text-field__icon--trailing[dir=rtl]{left:12px;right:initial}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon .mdc-text-field__input{padding-right:48px;padding-left:48px}.mdc-text-field--dense .mdc-text-field__icon{bottom:16px;transform:scale(0.8)}.mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-text-field__icon--leading{left:12px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-text-field__icon--leading,.mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-text-field__icon--leading[dir=rtl]{left:initial;right:12px}.mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-text-field__input{padding-left:44px;padding-right:16px}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-text-field__input,.mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-text-field__input[dir=rtl]{padding-left:16px;padding-right:44px}.mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-floating-label{left:44px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--dense .mdc-floating-label[dir=rtl]{left:initial;right:44px}.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--trailing{left:initial;right:12px}[dir=rtl] .mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--trailing,.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--trailing[dir=rtl]{left:12px;right:initial}.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__input{padding-left:16px;padding-right:44px}[dir=rtl] .mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__input,.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__input[dir=rtl]{padding-left:44px;padding-right:16px}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--leading{left:12px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--leading,.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--leading[dir=rtl]{left:initial;right:12px}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--trailing{left:initial;right:12px}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--trailing,.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__icon--trailing[dir=rtl]{left:12px;right:initial}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--dense .mdc-text-field__input{padding-right:44px;padding-left:44px}.mdc-text-field--dense .mdc-floating-label--float-above{transform:translateY(-70%) scale(0.8)}.mdc-text-field--dense .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-dense 250ms 1}.mdc-text-field--dense .mdc-text-field__input{padding:12px 12px 0}.mdc-text-field--dense .mdc-floating-label{font-size:.813rem}.mdc-text-field--dense .mdc-floating-label--float-above{font-size:.813rem}.mdc-text-field__input:required~.mdc-floating-label::after,.mdc-text-field__input:required~.mdc-notched-outline .mdc-floating-label::after{margin-left:1px;content:"*"}.mdc-text-field--textarea{display:inline-flex;width:auto;height:auto;overflow:visible;transition:none}.mdc-text-field--textarea:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--textarea:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--textarea:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.38)}.mdc-text-field--textarea:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--textarea:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--textarea:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--textarea:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--textarea:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--textarea:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.87)}.mdc-text-field--textarea:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--textarea:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--textarea:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:#6200ee;border-color:var(--mdc-theme-primary, #6200ee)}.mdc-text-field--textarea .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea 250ms 1}.mdc-text-field--textarea .mdc-notched-outline .mdc-notched-outline__leading{border-radius:4px 0 0 4px}[dir=rtl] .mdc-text-field--textarea .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--textarea .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl]{border-radius:0 4px 4px 0}.mdc-text-field--textarea .mdc-notched-outline .mdc-notched-outline__trailing{border-radius:0 4px 4px 0}[dir=rtl] .mdc-text-field--textarea .mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--textarea .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl]{border-radius:4px 0 0 4px}.mdc-text-field--textarea::before,.mdc-text-field--textarea::after{content:none}.mdc-text-field--textarea:not(.mdc-text-field--disabled){background-color:transparent}.mdc-text-field--textarea .mdc-floating-label--float-above{transform:translateY(-144%) scale(1)}.mdc-text-field--textarea .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--textarea.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-130%) scale(0.75)}.mdc-text-field--textarea.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--textarea .mdc-text-field-character-counter{left:initial;right:16px;position:absolute;bottom:13px}[dir=rtl] .mdc-text-field--textarea .mdc-text-field-character-counter,.mdc-text-field--textarea .mdc-text-field-character-counter[dir=rtl]{left:16px;right:initial}.mdc-text-field--textarea .mdc-text-field__input{align-self:auto;box-sizing:border-box;height:auto;margin:8px 1px 1px 0;padding:0 16px 16px;border:none;line-height:1.75rem}.mdc-text-field--textarea .mdc-text-field-character-counter+.mdc-text-field__input{margin-bottom:28px;padding-bottom:0}.mdc-text-field--textarea .mdc-floating-label{top:17px;width:auto;pointer-events:none}.mdc-text-field--textarea .mdc-floating-label:not(.mdc-floating-label--float-above){transform:none}.mdc-text-field--textarea.mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--textarea.mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--textarea.mdc-text-field--focused .mdc-notched-outline__trailing{border-width:2px}.mdc-text-field--fullwidth{width:100%}.mdc-text-field--fullwidth:not(.mdc-text-field--disabled) .mdc-text-field__input{border-bottom-color:rgba(0,0,0,.42)}.mdc-text-field--fullwidth.mdc-text-field--disabled .mdc-text-field__input{border-bottom-color:rgba(0,0,0,.42)}.mdc-text-field--fullwidth:not(.mdc-text-field--textarea){display:block}.mdc-text-field--fullwidth:not(.mdc-text-field--textarea)::before,.mdc-text-field--fullwidth:not(.mdc-text-field--textarea)::after{content:none}.mdc-text-field--fullwidth:not(.mdc-text-field--textarea):not(.mdc-text-field--disabled){background-color:transparent}.mdc-text-field--fullwidth:not(.mdc-text-field--textarea) .mdc-text-field__input{padding:0}.mdc-text-field--fullwidth.mdc-text-field--textarea .mdc-text-field__input{resize:vertical}.mdc-text-field--fullwidth.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error, #b00020)}.mdc-text-field-helper-line{display:flex;justify-content:space-between;box-sizing:border-box}.mdc-text-field--dense+.mdc-text-field-helper-line{margin-bottom:4px}.mdc-text-field+.mdc-text-field-helper-line{padding-right:16px;padding-left:16px}.mdc-form-field>.mdc-text-field+label{align-self:flex-start}.mdc-text-field--focused:not(.mdc-text-field--disabled) .mdc-floating-label{color:rgba(98,0,238,.87)}.mdc-text-field--focused+.mdc-text-field-helper-line .mdc-text-field-helper-text:not(.mdc-text-field-helper-text--validation-msg){opacity:1}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input:hover{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple{background-color:#b00020;background-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label{color:#b00020;color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{color:#b00020;color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid .mdc-text-field__input{caret-color:#b00020;caret-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__icon--trailing{color:#b00020;color:var(--mdc-theme-error, #b00020)}.mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{opacity:1}.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--textarea.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__input:hover~.mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused) .mdc-text-field__icon:hover~.mdc-notched-outline .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error, #b00020)}.mdc-text-field--disabled{background-color:#fafafa;border-bottom:none;pointer-events:none}.mdc-text-field--disabled .mdc-text-field__input{border-bottom-color:rgba(0,0,0,.06)}.mdc-text-field--disabled .mdc-text-field__input{color:rgba(0,0,0,.38)}@media all{.mdc-text-field--disabled .mdc-text-field__input::placeholder{color:rgba(0,0,0,.38)}}@media all{.mdc-text-field--disabled .mdc-text-field__input:-ms-input-placeholder{color:rgba(0,0,0,.38)}}.mdc-text-field--disabled .mdc-floating-label{color:rgba(0,0,0,.38)}.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-helper-text{color:rgba(0,0,0,.38)}.mdc-text-field--disabled .mdc-text-field-character-counter,.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-character-counter{color:rgba(0,0,0,.38)}.mdc-text-field--disabled .mdc-text-field__icon--leading{color:rgba(0,0,0,.3)}.mdc-text-field--disabled .mdc-text-field__icon--trailing{color:rgba(0,0,0,.3)}.mdc-text-field--disabled .mdc-floating-label{cursor:default}.mdc-text-field--textarea.mdc-text-field--disabled{background-color:transparent;background-color:#f9f9f9}.mdc-text-field--textarea.mdc-text-field--disabled .mdc-notched-outline__leading,.mdc-text-field--textarea.mdc-text-field--disabled .mdc-notched-outline__notch,.mdc-text-field--textarea.mdc-text-field--disabled .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.06)}.mdc-text-field--textarea.mdc-text-field--disabled .mdc-text-field__input{border-bottom:none}.mdc-text-field--end-aligned .mdc-text-field__input{text-align:right}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__input,.mdc-text-field--end-aligned .mdc-text-field__input[dir=rtl]{text-align:left}@keyframes mdc-floating-label-shake-float-above-text-field-dense{0%{transform:translateX(calc(0 - 0%)) translateY(-70%) scale(0.8)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-70%) scale(0.8)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-70%) scale(0.8)}100%{transform:translateX(calc(0 - 0%)) translateY(-70%) scale(0.8)}}@keyframes mdc-floating-label-shake-float-above-text-field-outlined{0%{transform:translateX(calc(0 - 0%)) translateY(-34.75px) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-34.75px) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-34.75px) scale(0.75)}100%{transform:translateX(calc(0 - 0%)) translateY(-34.75px) scale(0.75)}}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-dense{0%{transform:translateX(calc(0 - 0%)) translateY(-120%) scale(0.8)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-120%) scale(0.8)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-120%) scale(0.8)}100%{transform:translateX(calc(0 - 0%)) translateY(-120%) scale(0.8)}}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon{0%{transform:translateX(calc(0 - 0)) translateY(-34.75px) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0)) translateY(-34.75px) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0)) translateY(-34.75px) scale(0.75)}100%{transform:translateX(calc(0 - 0)) translateY(-34.75px) scale(0.75)}}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-dense{0%{transform:translateX(calc(0 - 21px)) translateY(-120%) scale(0.8)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 21px)) translateY(-120%) scale(0.8)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 21px)) translateY(-120%) scale(0.8)}100%{transform:translateX(calc(0 - 21px)) translateY(-120%) scale(0.8)}}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-rtl{0%{transform:translateX(calc(0 - 0)) translateY(-34.75px) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0)) translateY(-34.75px) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0)) translateY(-34.75px) scale(0.75)}100%{transform:translateX(calc(0 - 0)) translateY(-34.75px) scale(0.75)}}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-dense-rtl{0%{transform:translateX(calc(0 - -21px)) translateY(-120%) scale(0.8)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - -21px)) translateY(-120%) scale(0.8)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - -21px)) translateY(-120%) scale(0.8)}100%{transform:translateX(calc(0 - -21px)) translateY(-120%) scale(0.8)}}@keyframes mdc-floating-label-shake-float-above-textarea{0%{transform:translateX(calc(0 - 0%)) translateY(-130%) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(-130%) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(-130%) scale(0.75)}100%{transform:translateX(calc(0 - 0%)) translateY(-130%) scale(0.75)}}.material-icons{font-family:var(--mdc-icon-font, "Material Icons");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:"liga"}.hidden,.hidden::before,.hidden::after{display:none}:host{display:inline-block;outline:none}:host([fullwidth]){display:block}.mdc-text-field{display:flex;width:100%;border-radius:4px 4px 0 0;border-radius:var(--mdc-text-field-filled-border-radius, 4px 4px 0 0)}mwc-notched-outline{--mdc-notched-outline-border-color: var(--mdc-text-field-outlined-idle-border-color, rgba(0, 0, 0, 0.38))}:host(:not([disabled]):hover) :not(.mdc-text-field--invalid):not(.mdc-text-field--focused) mwc-notched-outline{--mdc-notched-outline-border-color: var(--mdc-text-field-outlined-hover-border-color, rgba(0, 0, 0, 0.87))}:host(:not([disabled])) .mdc-text-field:not(.mdc-text-field--outlined){background-color:var(--mdc-text-field-fill-color, whitesmoke)}:host(:not([disabled])) .mdc-text-field:not(.mdc-text-field--outlined):not(.mdc-text-field--invalid) .mdc-text-field__input{border-bottom-color:var(--mdc-text-field-idle-line-color, black)}:host(:not([disabled])) .mdc-text-field:not(.mdc-text-field--outlined):not(.mdc-text-field--invalid) .mdc-text-field__input:hover{border-bottom-color:var(--mdc-text-field-hover-line-color, #000001)}:host(:not([disabled])) .mdc-text-field.mdc-text-field--invalid mwc-notched-outline{--mdc-notched-outline-border-color: var(--mdc-text-field-error-color, var(--mdc-theme-error, #b00020))}:host(:not([disabled])) .mdc-text-field.mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-character-counter,:host(:not([disabled])) .mdc-text-field.mdc-text-field--invalid .mdc-text-field__icon{color:var(--mdc-text-field-error-color, var(--mdc-theme-error, #b00020))}:host(:not([disabled])) .mdc-text-field:not(.mdc-text-field--invalid):not(.mdc-text-field--focused) .mdc-floating-label,:host(:not([disabled])) .mdc-text-field:not(.mdc-text-field--invalid):not(.mdc-text-field--focused) .mdc-floating-label::after{color:var(--mdc-text-field-label-ink-color, rgba(0, 0, 0, 0.6))}:host(:not([disabled])) .mdc-text-field.mdc-text-field--focused mwc-notched-outline{--mdc-notched-outline-stroke-width: 2px}:host(:not([disabled])) .mdc-text-field.mdc-text-field--focused:not(.mdc-text-field--invalid) mwc-notched-outline{--mdc-notched-outline-border-color: var(--mdc-text-field-focused-label-color, var(--mdc-theme-primary, rgba(98, 0, 238, 0.87)))}:host(:not([disabled])) .mdc-text-field.mdc-text-field--focused:not(.mdc-text-field--invalid) .mdc-floating-label{color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}:host(:not([disabled])) .mdc-text-field.mdc-text-field--focused:not(.mdc-text-field--invalid) .mdc-text-field__input:required~.mdc-floating-label::after,:host(:not([disabled])) .mdc-text-field.mdc-text-field--focused:not(.mdc-text-field--invalid) .mdc-text-field__input:required~.mdc-notched-outline .mdc-floating-label::after{color:#6200ee;color:var(--mdc-theme-primary, #6200ee)}:host(:not([disabled])) .mdc-text-field .mdc-text-field__input{color:var(--mdc-text-field-ink-color, rgba(0, 0, 0, 0.87))}:host(:not([disabled])) .mdc-text-field .mdc-text-field__input::placeholder{color:var(--mdc-text-field-label-ink-color, rgba(0, 0, 0, 0.6))}:host(:not([disabled])) .mdc-text-field-helper-line .mdc-text-field-helper-text:not(.mdc-text-field-helper-text--validation-msg),:host(:not([disabled])) .mdc-text-field-helper-line:not(.mdc-text-field--invalid) .mdc-text-field-character-counter{color:var(--mdc-text-field-label-ink-color, rgba(0, 0, 0, 0.6))}:host([disabled]) .mdc-text-field:not(.mdc-text-field--outlined){background-color:var(--mdc-text-field-disabled-fill-color, #fafafa)}:host([disabled]) .mdc-text-field.mdc-text-field--outlined mwc-notched-outline{--mdc-notched-outline-border-color: var(--mdc-text-field-outlined-disabled-border-color, rgba(0, 0, 0, 0.06))}:host([disabled]) .mdc-text-field:not(.mdc-text-field--invalid):not(.mdc-text-field--focused) .mdc-floating-label,:host([disabled]) .mdc-text-field:not(.mdc-text-field--invalid):not(.mdc-text-field--focused) .mdc-floating-label::after{color:var(--mdc-text-field-disabled-ink-color, rgba(0, 0, 0, 0.38))}:host([disabled]) .mdc-text-field .mdc-text-field__input,:host([disabled]) .mdc-text-field .mdc-text-field__input::placeholder{color:var(--mdc-text-field-disabled-ink-color, rgba(0, 0, 0, 0.38))}:host([disabled]) .mdc-text-field-helper-line .mdc-text-field-helper-text,:host([disabled]) .mdc-text-field-helper-line .mdc-text-field-character-counter{color:var(--mdc-text-field-disabled-ink-color, rgba(0, 0, 0, 0.38))}.mdc-text-field:not(.mdc-text-field--outlined){padding-bottom:1px}.mdc-text-field:not(.mdc-text-field--outlined):not(.mdc-text-field--disabled):not(.mdc-text-field--invalid){border-bottom-color:rgba(0,0,0,.42)}.mdc-text-field:not(.mdc-text-field--outlined):not(.mdc-text-field--disabled):not(.mdc-text-field--invalid):hover{border-bottom-color:rgba(0,0,0,.87)}.mdc-text-field:not(.mdc-text-field--outlined):not(.mdc-text-field--disabled).mdc-text-field--invalid{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error, #b00020)}.mdc-text-field:not(.mdc-text-field--outlined) .mdc-floating-label.mdc-floating-label--float-above{transform:translateY(-50%) scale(0.75);font-size:initial}.mdc-text-field:not(.mdc-text-field--outlined).mdc-text-field--disabled{border-bottom-color:rgba(0,0,0,.06)}.mdc-text-field:not(.mdc-text-field--outlined) .mdc-text-field__input,.mdc-text-field:not(.mdc-text-field--outlined) .mdc-text-field-character-counter.hidden+.mdc-text-field__input{padding:0 16px 0 16px;margin:20px 0 1px 0}.mdc-text-field:not(.mdc-text-field--outlined) .mdc-text-field-character-counter:not(.hidden)+.mdc-text-field__input{margin-bottom:28px}.mdc-text-field:not(.mdc-text-field--outlined) .mdc-text-field-character-counter{bottom:14px}.mdc-text-field:not(.mdc-text-field--outlined) .mdc-floating-label{top:18px;left:16px}.mdc-text-field{height:100%}.mdc-text-field.mdc-text-field--outlined.mdc-text-field--disabled{background-color:transparent}.mdc-text-field.mdc-text-field--outlined:not(.mdc-text-field--fullwidth) .mdc-text-field__input{margin-bottom:14px;padding-bottom:0px}.mdc-text-field.mdc-text-field--outlined:not(.mdc-text-field--fullwidth) .mdc-text-field-character-counter{bottom:14px}.mdc-text-field.mdc-text-field--outlined:not(.mdc-text-field--fullwidth) .mdc-text-field-character-counter:not(.hidden)+.mdc-text-field__input{margin-bottom:41px}.mdc-text-field__input{-ms-overflow-style:none;scrollbar-color:transparent transparent;resize:none}.mdc-text-field__input::-webkit-scrollbar{display:none}`;
// CONCATENATED MODULE: ./node_modules/@material/mwc-textarea/mwc-textarea.js
/**
@license
Copyright 2019 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




let mwc_textarea_TextArea = class TextArea extends mwc_textarea_base_TextAreaBase {};
mwc_textarea_TextArea.styles = mwc_textarea_css_style;
mwc_textarea_TextArea = Object(tslib_es6["c" /* __decorate */])([customElement('mwc-textarea')], mwc_textarea_TextArea);

// CONCATENATED MODULE: ./node_modules/@material/mwc-icon/mwc-icon-host-css.js
/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

const mwc_icon_host_css_style = css`:host{font-family:var(--mdc-icon-font, "Material Icons");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:"liga"}`;
// CONCATENATED MODULE: ./node_modules/@material/mwc-icon/mwc-icon.js

/**
@license
Copyright 2018 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/



let mwc_icon_Icon = class Icon extends lit_element_LitElement {
  render() {
    return lit_html_html`<slot></slot>`;
  }

};
mwc_icon_Icon.styles = mwc_icon_host_css_style;
mwc_icon_Icon = Object(tslib_es6["c" /* __decorate */])([customElement('mwc-icon')], mwc_icon_Icon);

// CONCATENATED MODULE: ./src/components/leap-module.js












class leap_module_LeapModule extends lit_element_LitElement {
  static get properties() {
    return {
      module: {
        type: Object
      },
      editable: {
        type: Boolean
      },
      editingTitle: {
        type: Boolean
      },
      editingContent: {
        type: Object
      }
    };
  }

  constructor() {
    super();
    this.editingContent = {};
  }

  static get styles() {
    return [sharedStyles, css`
        .dialog-field {
          padding-top: 16px;
          padding-bottom: 16px;
        }

        .content-title {
          font-size: 18px;
        }

        .action {
          --mdc-icon-button-size: 40px;
        }
      `];
  }

  async createOrUpdateContent() {
    const client = await getClient();

    if (this.editingContent.id) {
      client.mutate({
        mutation: UPDATE_CONTENT,
        variables: {
          contentId: this.editingContent.id,
          content: {
            name: this.editingContent.name,
            description: this.editingContent.description,
            url: this.editingContent.url
          }
        }
      });
    } else {
      client.mutate({
        mutation: CREATE_CONTENT,
        variables: {
          moduleId: this.module.id,
          content: {
            name: this.editingContent.name,
            description: this.editingContent.description,
            url: this.editingContent.url
          }
        }
      });
    }

    window.location.reload();
  }

  async updateModule() {
    this.editingTitle = false;
    const client = await getClient();
    client.mutate({
      mutation: UPDATE_MODULE,
      variables: {
        moduleId: this.module.id,
        title: this.renameModule
      }
    });
    window.location.reload();
  }

  async deleteModule() {
    const client = await getClient();
    client.mutate({
      mutation: DELETE_MODULE,
      variables: {
        moduleId: this.module.id
      }
    });
    window.location.reload();
  }

  async deleteContent(contentId) {
    const client = await getClient();
    client.mutate({
      mutation: DELETE_CONTENT,
      variables: {
        contentId: contentId
      }
    });
    window.location.reload();
  }

  showContentDialog(existingContent) {
    this.editingContent = existingContent || {};
    this.shadowRoot.getElementById('create-content-dialog').open = true;
  }

  renderCreateContentDialog() {
    return lit_html_html`
      <mwc-dialog
        id="create-content-dialog"
        .heading=${this.editingContent.id ? 'Edit content' : 'Add content'}
      >
        <div class="column" style="width: 500px; margin-top: 16px;">
          <mwc-textfield
            outlined
            class="dialog-field"
            label="Name"
            dialogInitialFocus
            .value=${this.editingContent.name || ''}
            @input=${e => this.editingContent.name = e.target.value}
          >
          </mwc-textfield>
          <mwc-textarea
            outlined
            class="dialog-field"
            label="Description"
            .value=${this.editingContent.description || ''}
            @input=${e => this.editingContent.description = e.target.value}
          >
          </mwc-textarea>
          <mwc-textfield
            outlined
            class="dialog-field"
            label="URL"
            .value=${this.editingContent.url || ''}
            @input=${e => this.editingContent.url = e.target.value}
          >
          </mwc-textfield>
        </div>
        <mwc-button
          slot="primaryAction"
          dialogAction="create"
          @click=${() => this.createOrUpdateContent()}
        >
          Create
        </mwc-button>
        ${this.editable ? lit_html_html`
              <mwc-button
                slot="secondaryAction"
                dialogAction="cancel"
                label="Delete"
                @click=${e => {
      e.stopPropagation();
      this.deleteContent(this.editingContent.id);
    }}
              ></mwc-button>
            ` : lit_html_html``}
        <mwc-button slot="secondaryAction" dialogAction="cancel">
          Cancel
        </mwc-button>
      </mwc-dialog>
    `;
  }

  renderHeader() {
    return lit_html_html`
      <div class="row" style="align-items: center;">
        <div style="flex: 1; align-items: center;" class="fill">
          ${this.renderTitle()}
        </div>
        ${this.renderToolbar()}
      </div>
    `;
  }

  renderTitle() {
    return lit_html_html`
      <div class="row" style="align-items: center;">
        ${this.editable && this.editingTitle ? lit_html_html`
              <mwc-textfield
                outlined
                @input=${e => this.renameModule = e.target.value}
                .value=${this.module.title}
              ></mwc-textfield>
            ` : lit_html_html`
              <span class="title"> ${this.module.title}</span>
            `}
      </div>
    `;
  }

  renderToolbar() {
    if (!this.editable) return lit_html_html``;
    if (this.editingTitle) return lit_html_html`
        <div class="row">
          <mwc-icon-button
            class="action"
            label="Save"
            icon="done"
            @click=${() => this.updateModule()}
          ></mwc-icon-button>
          <mwc-icon-button
            class="action"
            label="Cancel"
            icon="clear"
            @click=${() => this.editingTitle = false}
          ></mwc-icon-button>
        </div>
      `;
    return lit_html_html`
      <div class="row">
        <mwc-icon-button
          class="action"
          label="Edit"
          icon="edit"
          @click=${() => this.editingTitle = true}
        ></mwc-icon-button>
        <mwc-icon-button
          slot="action-buttons"
          class="action"
          icon="add"
          label="Add content"
          @click=${() => this.showContentDialog()}
        ></mwc-icon-button>
        <mwc-icon-button
          slot="action-buttons"
          class="action"
          icon="delete"
          label="Delete module"
          @click=${() => this.deleteModule()}
        ></mwc-icon-button>
      </div>
    `;
  }

  renderContent(content, index) {
    return lit_html_html`
      <mwc-list-item
        @click=${() => window.open(content.url)}
        class="content-item"
        hasMeta
        twoline
      >
        <span class="content-title">${content.name}</span>
        <span slot="secondary">${content.description}</span>

        ${this.editable ? lit_html_html`
              <mwc-icon
                slot="meta"
                label="Edit content"
                @click=${e => {
      e.stopPropagation();
      this.showContentDialog(content);
    }}
                >edit</mwc-icon
              >
            ` : lit_html_html``}
      </mwc-list-item>
      ${index !== this.module.contents.length - 1 ? lit_html_html`
            <li divider padded role="separator"></li>
          ` : lit_html_html``}
    `;
  }

  render() {
    return lit_html_html`
      ${this.renderCreateContentDialog()}

      <mwc-card class="fill">
        <div style="padding: 16px;" class="column">
          ${this.renderHeader()}
          ${this.module.contents.length === 0 ? lit_html_html`
                <leap-empty-placeholder
                  message="There are no contents in this module"
                ></leap-empty-placeholder>
              ` : lit_html_html`
                <mwc-list style="padding-top: 8px; padding-bottom: 8px;">
                  ${this.module.contents.map((content, index) => this.renderContent(content, index))}
                </mwc-list>
              `}
        </div>
      </mwc-card>
    `;
  }

}
// CONCATENATED MODULE: ./src/components/leap-emtpy-placeholder.js


class leap_emtpy_placeholder_LeapEmtpyPlacholder extends lit_element_LitElement {
  static get styles() {
    return [sharedStyles, css`
        .message {
          font-size: 18px;
          text-align: center;
        }

        .container {
          opacity: 0.6;
        }
        mwc-icon {
          --mdc-icon-size: 64px;
        }
        :host {
          display: flex;
          flex: 1;
        }
      `];
  }

  static get properties() {
    return {
      message: {
        type: String
      }
    };
  }

  render() {
    return lit_html_html`
      <div class="container column fill center-content">
        <mwc-icon>filter_drama</mwc-icon>
        <span class="message">${this.message || 'No items in this list'}</span>
      </div>
    `;
  }

}
// CONCATENATED MODULE: ./src/index.js






customElements.define('leap-course-detail', leap_course_detail_LeapCourseDetail);
customElements.define('leap-courses-list', leap_courses_list_LeapCoursesList);
customElements.define('leap-app', leap_app_LeapApp);
customElements.define('leap-dashboard', leap_dashboard_LeapDashboard);
customElements.define('leap-module', leap_module_LeapModule);
customElements.define('leap-empty-placeholder', leap_emtpy_placeholder_LeapEmtpyPlacholder);

/***/ })
/******/ ]);
//# sourceMappingURL=index.development.js.map